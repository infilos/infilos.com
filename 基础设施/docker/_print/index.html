<!doctype html><html lang=zh class=no-js><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=generator content="Hugo 0.100.2"><meta name=ROBOTS content="INDEX, FOLLOW"><link rel=canonical type=text/html href=/%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD/docker/><link rel="shortcut icon" href=/favicons/favicon.ico><link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180><link rel=icon type=image/png href=/favicons/favicon-16x16.png sizes=16x16><link rel=icon type=image/png href=/favicons/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/favicons/android-36x36.png sizes=36x36><link rel=icon type=image/png href=/favicons/android-48x48.png sizes=48x48><link rel=icon type=image/png href=/favicons/android-72x72.png sizes=72x72><link rel=icon type=image/png href=/favicons/android-96x96.png sizes=96x96><link rel=icon type=image/png href=/favicons/android-144x144.png sizes=144x144><link rel=icon type=image/png href=/favicons/android-192x192.png sizes=192x192><title>Docker | infilos.com</title><meta property="og:title" content="Docker"><meta property="og:description" content="Infilos Wiki Website"><meta property="og:type" content="website"><meta property="og:url" content="/%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD/docker/"><meta property="og:site_name" content="infilos.com"><meta itemprop=name content="Docker"><meta itemprop=description content="Infilos Wiki Website"><meta name=twitter:card content="summary"><meta name=twitter:title content="Docker"><meta name=twitter:description content="Infilos Wiki Website"><script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga('create','UA-123062585-1','auto'),ga('send','pageview'))</script><script async src=https://www.google-analytics.com/analytics.js></script>
<link rel=preload href=/scss/main.min.847464b684a6e89d7276700a5c500c17ab494dd1755b2654a7b27d8b59e3347e.css as=style><link href=/scss/main.min.847464b684a6e89d7276700a5c500c17ab494dd1755b2654a7b27d8b59e3347e.css rel=stylesheet integrity><script src=/js/jquery-3.5.1.min.js integrity="sha256-9/aliU8dGd2tb6OSsuzixeV4y/faTqgFtohetphbbj0=" crossorigin=anonymous></script></head><body class=td-section><header><nav class="js-navbar-scroll navbar navbar-expand-lg navbar-dark td-navbar"><a class=navbar-brand href=/><span class=navbar-logo><svg id="Capa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 512 512" style="enable-background:new 0 0 512 512"><path style="fill:#ffc107" d="M432.384 143.616c-4.165-4.164-10.917-4.164-15.083.0l-60.352 60.352c-4.164 4.165-4.164 10.917.0 15.083 21.187 20.463 54.951 19.876 75.413-1.311 19.962-20.668 19.962-53.435.0-74.102L432.384 143.616z"/><path style="fill:#607d8b" d="M42.667 277.334c-5.891.003-10.669-4.771-10.672-10.662-.002-4.338 2.623-8.245 6.64-9.882l234.667-96c5.455-2.233 11.687.38 13.92 5.835s-.38 11.687-5.835 13.92l-234.667 96C45.433 277.069 44.056 277.337 42.667 277.334z"/><path style="fill:#546e7a" d="M391.552 56.448l-32-32C343.938 8.745 322.689-.059 300.544.0h-3.755c-46.082.024-83.432 37.374-83.456 83.456v3.755c-.053 22.138 8.75 43.377 24.448 58.987l32 32c4.165 4.164 10.917 4.164 15.083.0L391.531 71.531C395.701 67.372 395.71 60.62 391.552 56.448z"/><path style="fill:#607d8b" d="M160 469.334c-3.279.006-6.379-1.497-8.405-4.075L34.261 315.926c-3.635-4.636-2.823-11.341 1.813-14.976s11.341-2.823 14.976 1.813l117.333 149.333c3.629 4.641 2.809 11.344-1.832 14.973C164.681 468.533 162.375 469.329 160 469.334z"/><path style="fill:#455a64" d="M487.467 86.848l-3.669-3.648c-37.687-36.557-97.71-36.197-134.955.811l-51.413 51.413c-36.996 37.25-37.357 97.263-.811 134.955l3.584 3.669c1.7 2.457 4.671 3.706 7.616 3.2 2.831.005 5.548-1.115 7.552-3.115l172.181-172.181c4.189-4.143 4.226-10.896.083-15.085-.028-.028-.055-.056-.083-.083L487.467 86.848z"/><g><path style="fill:#ffc107" d="M501.333 192H480c-5.891.0-10.667-4.776-10.667-10.667s4.776-10.667 10.667-10.667h21.333c5.891.0 10.667 4.776 10.667 10.667S507.225 192 501.333 192z"/><path style="fill:#ffc107" d="M394.667 298.667c-5.891.0-10.667-4.776-10.667-10.667v-21.333c0-5.891 4.776-10.667 10.667-10.667 5.891.0 10.667 4.776 10.667 10.667V288C405.333 293.891 400.558 298.667 394.667 298.667z"/><path style="fill:#ffc107" d="M480 277.334c-2.831.005-5.548-1.115-7.552-3.115l-21.333-21.333c-4.093-4.237-3.975-10.99.262-15.083 4.134-3.993 10.687-3.993 14.821.0l21.333 21.333c4.159 4.172 4.148 10.926-.024 15.085C485.514 276.209 482.815 277.327 480 277.334z"/></g><g><path style="fill:#455a64" d="M266.667 448H96c-29.455.0-53.333 23.878-53.333 53.333.0 5.891 4.776 10.667 10.667 10.667h256c5.891.0 10.667-4.776 10.667-10.667C320 471.878 296.122 448 266.667 448z"/><circle style="fill:#455a64" cx="32" cy="288" r="32"/></g><g/><g/><g/><g/><g/><g/><g/><g/><g/><g/><g/><g/><g/><g/><g/></svg></span><span class=font-weight-bold>infilos.com</span></a>
<button class=navbar-toggler type=button data-toggle=collapse data-target=#navbarSupportedContent aria-controls=navbarSupportedContent aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span></button><div class="collapse navbar-collapse" id=navbarSupportedContent><ul class="navbar-nav mr-auto"><li class=nav-item style=max-width:90px;min-width:10px><a class=nav-link href=/%e5%9f%ba%e7%a1%80%e7%9f%a5%e8%af%86><span>基础</span></a></li><li class=nav-item style=max-width:90px;min-width:10px><a class=nav-link href=/%e7%bc%96%e7%a8%8b%e8%af%ad%e8%a8%80><span>语言</span></a></li><li class=nav-item style=max-width:90px;min-width:10px><a class=nav-link href=/%e6%a1%86%e6%9e%b6%e4%b8%8e%e5%ba%93><span>框架库</span></a></li><li class="nav-item dropdown" style=max-width:90px;min-width:10px><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>分布式
<span>+</span></a><div class=dropdown-menu aria-labelledby=navbarDropdown><a class=dropdown-item href=/%e5%88%86%e5%b8%83%e5%bc%8f/base>基本构成</a></div></li><li class="nav-item dropdown" style=max-width:90px;min-width:10px><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>大数据
<span>+</span></a><div class=dropdown-menu aria-labelledby=navbarDropdown><a class=dropdown-item href=/%e5%ad%98%e5%82%a8%e7%b3%bb%e7%bb%9f>存储系统</a>
<a class=dropdown-item href=/%e6%9f%a5%e8%af%a2%e7%b3%bb%e7%bb%9f>查询系统</a>
<a class=dropdown-item href=/%e6%b6%88%e6%81%af%e7%b3%bb%e7%bb%9f>消息系统</a>
<a class=dropdown-item href=/%e5%a4%84%e7%90%86%e7%b3%bb%e7%bb%9f>处理系统</a>
<a class=dropdown-item href=/%e6%95%b0%e6%8d%ae%e6%b2%bb%e7%90%86>数据治理</a></div></li><li class="nav-item dropdown" style=max-width:90px;min-width:10px><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>中后台
<span>+</span></a><div class=dropdown-menu aria-labelledby=navbarDropdown><a class=dropdown-item href=/%e5%9f%ba%e7%a1%80%e8%ae%be%e6%96%bd>基础设施</a>
<a class=dropdown-item href=/%e7%94%a8%e6%88%b7%e7%b3%bb%e7%bb%9f>用户系统</a>
<a class=dropdown-item href=/%e4%ba%a4%e4%ba%92%e7%95%8c%e9%9d%a2>交互界面</a>
<a class=dropdown-item href=/%e4%b8%9a%e5%8a%a1%e7%b3%bb%e7%bb%9f>业务系统</a></div></li><li class=nav-item style=max-width:90px;min-width:10px><a class=nav-link href=/%e6%a8%a1%e5%bc%8f%e6%9e%b6%e6%9e%84><span>模式架构</span></a></li><li class=nav-item style=max-width:90px;min-width:10px><a class=nav-link href=/%e9%9d%a2%e8%af%95%e9%97%ae%e7%ad%94><span>面试</span></a></li><li class=nav-item style=max-width:90px;min-width:10px><a class=nav-link href=/%e7%ae%a1%e7%90%86%e8%b7%af%e5%be%84><span>管理</span></a></li><li class=nav-item style=max-width:90px;min-width:10px><a class=nav-link href=/%e5%bc%80%e6%ba%90%e9%a1%b9%e7%9b%ae><span>开源</span></a></li></ul><div class="form-inline my-2 my-lg-0"><div class="nav-item nav-search-item my-2 my-md-0"><input type=search class="form-control td-search-input" placeholder="&#xf002; 站内搜索…" aria-label=站内搜索… autocomplete=off></div></div></div></nav></header><div class="container-fluid td-outer"><div class=td-main><div class="row flex-xl-nowrap"><div class="col-12 col-md-3 col-xl-2 td-sidebar d-print-none"></div><div class="d-none d-xl-block col-xl-2 td-toc d-print-none"></div><main class="col-12 col-md-9 col-xl-8 pl-md-5" role=main><div class=td-content><div class="pageinfo pageinfo-primary d-print-none"><p>这是本节的多页打印视图。
<a href=# onclick="return print(),!1">点击此处打印</a>.</p><p><a href=/%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD/docker/>返回本页常规视图</a>.</p></div><h1 class=title>Docker</h1><ul><li>1: <a href=#pg-750965be63a0662f0d03e14ecad3cf1b>Dockerfile</a></li><li>2: <a href=#pg-43c061e08a55c8a5941e3bca93b7e18f>Cheat Sheet</a></li><li>3: <a href=#pg-b5b32ea2a8d7a0858812be1d0a7ffaa7>Docker 实战</a></li></ul><div class=content></div></div><div class=td-content><h1 id=pg-750965be63a0662f0d03e14ecad3cf1b>1 - Dockerfile</h1><h2 id=dockerfile>Dockerfile</h2><p>Docker可以通过<code>Dockerfile</code>自动构建镜像，<code>Dockerfile</code>是一个包含多个指令的文档。如下</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=display:flex><span><span style=color:#8f5902;font-style:italic># syntax=docker/dockerfile:1</span><span style=color:#a40000>
</span></span></span><span style=display:flex><span><span style=color:#a40000></span><span style=color:#204a87;font-weight:700>FROM</span><span style=color:#4e9a06> ubuntu:18.04</span><span style=color:#a40000>
</span></span></span><span style=display:flex><span><span style=color:#a40000></span><span style=color:#204a87;font-weight:700>COPY</span> . /app<span style=color:#a40000>
</span></span></span><span style=display:flex><span><span style=color:#a40000></span><span style=color:#204a87;font-weight:700>RUN</span> make /app<span style=color:#a40000>
</span></span></span><span style=display:flex><span><span style=color:#a40000></span><span style=color:#204a87;font-weight:700>CMD</span> python /app/app.py<span style=color:#a40000>
</span></span></span></code></pre></div><h2 id=from>FROM</h2><p><code>FROM</code>命令用于初始化一个新的构建阶段，并为后续指令设置基础镜像：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=display:flex><span><span style=color:#204a87;font-weight:700>FROM</span><span style=color:#4e9a06> [--platform=&lt;platform&gt;] &lt;image&gt; [AS &lt;name&gt;]</span><span style=color:#a40000>
</span></span></span><span style=display:flex><span><span style=color:#a40000></span><span style=color:#204a87;font-weight:700>FROM</span><span style=color:#4e9a06> [--platform=&lt;platform&gt;] &lt;image&gt;[:&lt;tag&gt;] [AS &lt;name&gt;]</span><span style=color:#a40000>
</span></span></span><span style=display:flex><span><span style=color:#a40000></span><span style=color:#204a87;font-weight:700>FROM</span><span style=color:#4e9a06> [--platform=&lt;platform&gt;] &lt;image&gt;[@&lt;digest&gt;] [AS &lt;name&gt;]</span><span style=color:#a40000>
</span></span></span></code></pre></div><ul><li><code>FROM</code>指令用于指定基础镜像，<code>ARG</code>是唯一可以位于<code>FROM</code>指令之前的指令，一般用于声明基础镜像的版本。</li><li>单个<code>Dockerfile</code>可以多次出现<code>FROM</code>，以使用之前的构建阶段作为另一个构建阶段的依赖项。</li><li><code>--platform</code>选项可用在<code>FROM</code>多平台镜像的情况下指定平台。例如，linux/amd64、lunux/arm64、windows/amd64。</li><li><code>AS name</code>表示为构建阶段命令，在后续<code>FROM</code>和<code>COPY --from=name</code>说明中可以使用这个名词，引用此阶段构建的映像。</li><li><code>tag</code>或<code>digest</code>值是可选的。如果您省略其中任何一个，构建器默认使用<code>latest</code>标签。如果找不到指定<code>tag</code>，构建起将返回错误。</li></ul><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=display:flex><span><span style=color:#204a87;font-weight:700>ARG</span> <span style=color:#000>CODE_VERSION</span><span style=color:#ce5c00;font-weight:700>=</span>latest
</span></span><span style=display:flex><span><span style=color:#204a87;font-weight:700>FROM</span><span style=color:#4e9a06> base:${CODE_VERSION}</span><span style=color:#a40000>
</span></span></span><span style=display:flex><span><span style=color:#a40000></span><span style=color:#204a87;font-weight:700>CMD</span> /code/run-app<span style=color:#a40000>
</span></span></span><span style=display:flex><span><span style=color:#a40000></span><span style=color:#204a87;font-weight:700>FROM</span><span style=color:#4e9a06> extras:${CODE_VERSION}</span><span style=color:#a40000>
</span></span></span><span style=display:flex><span><span style=color:#a40000></span><span style=color:#204a87;font-weight:700>CMD</span> /code/run-extras<span style=color:#a40000>
</span></span></span></code></pre></div><h2 id=run>RUN</h2><p><code>RUN</code>指令将在当前镜像之上的新层中执行命令，并且提交结果。在<code>docker build</code>时运行。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=display:flex><span><span style=color:#204a87;font-weight:700>RUN</span> /bin/bash -c <span style=color:#4e9a06>&#39;source $HOME/.bashrc; \
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>echo $HOME&#39;</span><span style=color:#a40000>
</span></span></span></code></pre></div><p>RUN有两种形式：</p><ul><li>RUN <command>：shell形式，命令在shell中运行，默认在Linux上使用<code>/bin/sh -c</code>，在Windows上使用<code>cmd /S /C</code>。</li><li>RUN [&ldquo;程序名&rdquo;,&ldquo;param1&rdquo;,&ldquo;param1&rdquo;]：exec形式，不会触发shell，所以$HOME这样的环境变量无法使用，但它可以在没有bash的镜像中执行。</li></ul><p>说明：</p><ul><li>可以使用反斜杠（\）将单个<code>RUN</code>命令延续到下一行。</li><li><code>RUN</code>在下一次构建期间，指令缓存不会自动失效。可以使用<code>--no-cache</code>选项使指令缓存失效。如RUN apt-get update之类的构建缓存将在下一次构建期间被重用，此时构建中可能安装过时版本的工具，但我们可以使用&ndash;no-cache标志来使RUN命令的缓存失效，如docker build &ndash;no-cache。</li><li>Dockerfile的指令每执行一次就会给镜像新建一层只读层。过多无意义的层会造成镜像膨胀过大，可以使用&&符号连接多个命令，这样执行RUN指令后之后创建一层镜像。</li></ul><p>有些命令会使用管道（|），如：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=display:flex><span><span style=color:#204a87;font-weight:700>RUN</span> wget -O - https://some.site <span style=color:#000;font-weight:700>|</span> wc -l &gt; /number<span style=color:#a40000>
</span></span></span></code></pre></div><p>Docker使用<code>/bin/sh -c</code>解释器，解释器只计算所有一个命令的退出状态码以确定命令是否执行成功，如上例，只要<code>wc -l</code>执行成功，即使<code>wget</code>命令失败，这个构建步骤也会生成一层新镜像。如果希望命令由于管道中任意阶段命令的错误而失败，需要预先设置<code>set-o pipefail&&</code>，如下：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span> RUN set -o pipefail &amp;&amp; wget -O - https://some.site | wc -l &gt; /number
</span></span></code></pre></div><blockquote><p>注意，基于debian的镜像要使用exec形式支持<code>-o pipefail</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=display:flex><span><span style=color:#204a87;font-weight:700>RUN</span> <span style=color:#ce5c00;font-weight:700>[</span><span style=color:#4e9a06>&#34;/bin/bash&#34;</span>, <span style=color:#4e9a06>&#34;-c&#34;</span>, <span style=color:#4e9a06>&#34;set -o pipefail &amp;&amp; wget -O - https://some.site | wc -l &gt; /number&#34;</span><span style=color:#ce5c00;font-weight:700>]</span><span style=color:#a40000>
</span></span></span></code></pre></div></blockquote><h2 id=cmd>CMD</h2><p>Dockerfile使用<code>RUN</code>指令完成<code>docker build</code>所有的环境安装与配置，通过<code>CMD</code>指令来指示<code>docker run</code>命令运行镜像时要执行的命令。Dockerfile只允许使用一次<code>CMD</code>命令。使用多个<code>CMD</code>会抵消之前所有的命令，只有最后一个命令生效。一般来说，这是整个Dockerfile脚本的最后一个命令。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=display:flex><span><span style=color:#204a87;font-weight:700>FROM</span><span style=color:#4e9a06> ubuntu</span><span style=color:#a40000>
</span></span></span><span style=display:flex><span><span style=color:#a40000></span><span style=color:#204a87;font-weight:700>CMD</span> <span style=color:#000;font-weight:700>[</span><span style=color:#4e9a06>&#34;/usr/bin/wc&#34;</span><span style=color:#000;font-weight:700>,</span><span style=color:#4e9a06>&#34;--help&#34;</span><span style=color:#000;font-weight:700>]</span><span style=color:#a40000>
</span></span></span></code></pre></div><p>CMD有三种形式：</p><ul><li>CMD [&ldquo;exec&rdquo;,&ldquo;param1&rdquo;,&ldquo;param2&rdquo;]：使用exec执行，推荐方式。</li><li>CMD command param1 param2：在/bin/sh中执行，可以提供交互操作。</li><li>CMD [&ldquo;param1&rdquo;,&ldquo;param2&rdquo;]：提供给ENTRYPOINT的默认参数（极少这样使用）。</li></ul><h2 id=expose>EXPOSE</h2><p><code>EXPOSE</code>指令通知容器在运行时监听某个端口，可以指定TCP或UDP，如果不指定协议，默认为TCP端口。但是为了安全，<code>docker run</code>命令如果没有带上相应的端口映射参数，Docker并不会将端口映射出去。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=display:flex><span><span style=color:#204a87;font-weight:700>EXPOSE</span><span style=color:#4e9a06> 80/tcp</span><span style=color:#a40000>
</span></span></span><span style=display:flex><span><span style=color:#a40000></span><span style=color:#204a87;font-weight:700>EXPOSE</span><span style=color:#4e9a06> 80/udp</span><span style=color:#a40000>
</span></span></span></code></pre></div><p>指定映射端口方式：</p><p>docker run -P：将所有端口发布到主机接口，每个公开端口绑定到主机上的随机端口，端口范围在<code>/proc/sys/net/ipv4/ip_local_port_range</code>定义的临时端口范围内。</p><p>docker run -p ：显式映射单个端口或端口范围。</p><h2 id=label>LABEL</h2><p><code>LABEL</code>指令为镜像添加标签，当前镜像会继承父镜像的标签，如果与父标签重复，会覆盖之前的标签。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=display:flex><span><span style=color:#204a87;font-weight:700>LABEL</span> multi.label1<span style=color:#ce5c00;font-weight:700>=</span><span style=color:#4e9a06>&#34;value1&#34;</span> <span style=color:#4e9a06>\
</span></span></span><span style=display:flex><span><span style=color:#4e9a06></span>  multi.label2<span style=color:#ce5c00;font-weight:700>=</span><span style=color:#4e9a06>&#34;value2&#34;</span> <span style=color:#4e9a06>\
</span></span></span><span style=display:flex><span><span style=color:#4e9a06></span>  <span style=color:#000>other</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#4e9a06>&#34;value3&#34;</span><span style=color:#a40000>
</span></span></span><span style=display:flex><span><span style=color:#a40000></span><span style=color:#8f5902;font-style:italic># 或</span><span style=color:#a40000>
</span></span></span><span style=display:flex><span><span style=color:#a40000></span><span style=color:#204a87;font-weight:700>LABEL</span> multi.label1<span style=color:#ce5c00;font-weight:700>=</span><span style=color:#4e9a06>&#34;value1&#34;</span> multi.label2<span style=color:#ce5c00;font-weight:700>=</span><span style=color:#4e9a06>&#34;value2&#34;</span> <span style=color:#000>other</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#4e9a06>&#34;value3&#34;</span><span style=color:#a40000>
</span></span></span></code></pre></div><p>可以使用如下方式查看镜像标签：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>docker image inspect --format<span style=color:#ce5c00;font-weight:700>=</span><span style=color:#4e9a06>&#39;&#39;</span> myimage
</span></span></code></pre></div><p>查看结果实例：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span><span style=color:#000;font-weight:700>{</span>
</span></span><span style=display:flex><span> <span style=color:#204a87;font-weight:700>&#34;com.example.vendor&#34;</span><span style=color:#000;font-weight:700>:</span> <span style=color:#4e9a06>&#34;ACME Incorporated&#34;</span><span style=color:#000;font-weight:700>,</span>
</span></span><span style=display:flex><span> <span style=color:#204a87;font-weight:700>&#34;com.example.label-with-value&#34;</span><span style=color:#000;font-weight:700>:</span> <span style=color:#4e9a06>&#34;foo&#34;</span><span style=color:#000;font-weight:700>,</span>
</span></span><span style=display:flex><span> <span style=color:#204a87;font-weight:700>&#34;version&#34;</span><span style=color:#000;font-weight:700>:</span> <span style=color:#4e9a06>&#34;1.0&#34;</span><span style=color:#000;font-weight:700>,</span>
</span></span><span style=display:flex><span> <span style=color:#204a87;font-weight:700>&#34;description&#34;</span><span style=color:#000;font-weight:700>:</span> <span style=color:#4e9a06>&#34;This text illustrates that label-values can span multiple lines.&#34;</span><span style=color:#000;font-weight:700>,</span>
</span></span><span style=display:flex><span> <span style=color:#204a87;font-weight:700>&#34;multi.label1&#34;</span><span style=color:#000;font-weight:700>:</span> <span style=color:#4e9a06>&#34;value1&#34;</span><span style=color:#000;font-weight:700>,</span>
</span></span><span style=display:flex><span> <span style=color:#204a87;font-weight:700>&#34;multi.label2&#34;</span><span style=color:#000;font-weight:700>:</span> <span style=color:#4e9a06>&#34;value2&#34;</span><span style=color:#000;font-weight:700>,</span>
</span></span><span style=display:flex><span> <span style=color:#204a87;font-weight:700>&#34;other&#34;</span><span style=color:#000;font-weight:700>:</span> <span style=color:#4e9a06>&#34;value3&#34;</span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>}</span>
</span></span></code></pre></div><h2 id=env>ENV</h2><p><code>ENV</code>命令用来在执行<code>docker run</code>命令运行镜像时指定自动设置的环境变量。这个环境变量可以在后续任何RUN命令中使用，并在容器运行时保持。一般用于软件更便捷的运行，如：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=display:flex><span><span style=color:#204a87;font-weight:700>ENV</span> <span style=color:#000>PATH</span><span style=color:#ce5c00;font-weight:700>=</span>/usr/local/nginx/bin:<span style=color:#000>$PATH</span><span style=color:#a40000>
</span></span></span><span style=display:flex><span><span style=color:#a40000></span><span style=color:#204a87;font-weight:700>CMD</span> <span style=color:#000;font-weight:700>[</span><span style=color:#4e9a06>&#34;nginx&#34;</span><span style=color:#000;font-weight:700>]</span><span style=color:#a40000>
</span></span></span></code></pre></div><p>设置的环境变量将持续存在，可以使用<code>docker inspect</code>来查看。这些环境变量可以通过<code>docker run --env &lt;key>=&lt;value></code>命令的参数来修改。</p><h2 id=arg>ARG</h2><p>ARG命令定义用户只在构建时使用的变量，效果和<code>docker build --build-arg &lt;varname>=&lt;value></code>一样，这个参数只会在构建时存在，不会保留在镜像中。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=display:flex><span><span style=color:#204a87;font-weight:700>ARG</span> &lt;name&gt;<span style=color:#ce5c00;font-weight:700>[=</span>&lt;default value&gt;<span style=color:#ce5c00;font-weight:700>]</span><span style=color:#a40000>
</span></span></span></code></pre></div><p>ARG与ENV类似，不同的是ENV会在镜像构建结束后一直保存在容器中，而ARG会在镜像构建结束狗消失。一般运用在希望整个构建过程是无交互的，那么可以使用ARG命令（仅限Debian发行版）。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=display:flex><span><span style=color:#204a87;font-weight:700>ARG</span> <span style=color:#000>DEBIAN_FRONTEND</span><span style=color:#ce5c00;font-weight:700>=</span>noninteractive
</span></span><span style=display:flex><span><span style=color:#204a87;font-weight:700>RUN</span> apt-get update <span style=color:#ce5c00;font-weight:700>&amp;&amp;</span> apt-get install -y ...<span style=color:#a40000>
</span></span></span></code></pre></div><p>Docker 有一组预定义的 ARG 变量，您可以在 Dockerfile 中没有相应指令的情况下使用这些变量。</p><ul><li>HTTP_PROXY</li><li>http_proxy</li><li>HTTPS_PROXY</li><li>https_proxy</li><li>FTP_PROXY</li><li>ftp_proxy</li><li>NO_PROXY</li><li>no_proxy</li></ul><p>要使用这些，请使用 &ndash;build-arg 标志在命令行上传递它们，例如：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>docker build --build-arg <span style=color:#000>HTTPS_PROXY</span><span style=color:#ce5c00;font-weight:700>=</span>https://my-proxy.example.com .
</span></span></code></pre></div><h2 id=add>ADD</h2><p><code>ADD</code>指令用于复制新文件、目录或远程文件 URL到容器<dest>路径中。可以指定多个资源，但如果它们是文件或目录，则它们的路径被解释为相对于构建上下文的源，也就是 WORKDIR。</p><p><code>ADD</code>指令有两种形式：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=display:flex><span><span style=color:#204a87;font-weight:700>ADD</span> <span style=color:#ce5c00;font-weight:700>[</span>--chown<span style=color:#ce5c00;font-weight:700>=</span>&lt;user&gt;:&lt;group&gt;<span style=color:#ce5c00;font-weight:700>]</span> &lt;src&gt;... &lt;dest&gt;<span style=color:#a40000>
</span></span></span><span style=display:flex><span><span style=color:#a40000></span><span style=color:#204a87;font-weight:700>ADD</span> <span style=color:#ce5c00;font-weight:700>[</span>--chown<span style=color:#ce5c00;font-weight:700>=</span>&lt;user&gt;:&lt;group&gt;<span style=color:#ce5c00;font-weight:700>]</span> <span style=color:#ce5c00;font-weight:700>[</span><span style=color:#4e9a06>&#34;&lt;src&gt;&#34;</span>,... <span style=color:#4e9a06>&#34;&lt;dest&gt;&#34;</span><span style=color:#ce5c00;font-weight:700>]</span><span style=color:#a40000>
</span></span></span></code></pre></div><p>每个都 <src>可能包含通配符，匹配将使用 Go 的 filepath.Match 规则。<dest> 是一个绝对路径，或相对 WORKDIR 的相对路径。例如：</p><p>添加所有以“hom”开头的文件：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=display:flex><span><span style=color:#204a87;font-weight:700>ADD</span> hom* /mydir/<span style=color:#a40000>
</span></span></span></code></pre></div><p>在下面的示例中，? 被替换为任何单个字符，例如“home.txt”。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=display:flex><span><span style=color:#204a87;font-weight:700>ADD</span> hom?.txt /mydir/<span style=color:#a40000>
</span></span></span></code></pre></div><p>所有新创建的文件和目录的UID和GID都为0，除非使用<code>--chown</code>指定UID/GID以及权限。<code>-chown</code>特性仅在用于构建Linux容器。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=display:flex><span><span style=color:#204a87;font-weight:700>ADD</span> --chown<span style=color:#ce5c00;font-weight:700>=</span>55:mygroup files* /somedir/<span style=color:#a40000>
</span></span></span><span style=display:flex><span><span style=color:#a40000></span><span style=color:#204a87;font-weight:700>ADD</span> --chown<span style=color:#ce5c00;font-weight:700>=</span>bin files* /somedir/<span style=color:#a40000>
</span></span></span><span style=display:flex><span><span style=color:#a40000></span><span style=color:#204a87;font-weight:700>ADD</span> --chown<span style=color:#ce5c00;font-weight:700>=</span><span style=color:#0000cf;font-weight:700>1</span> files* /somedir/<span style=color:#a40000>
</span></span></span><span style=display:flex><span><span style=color:#a40000></span><span style=color:#204a87;font-weight:700>ADD</span> --chown<span style=color:#ce5c00;font-weight:700>=</span>10:11 files* /somedir/<span style=color:#a40000>
</span></span></span></code></pre></div><p>如果<src>是一个可识别压缩格式（identity、gzip、bzip2或xz）的本地tar存档，那么它将被解包为一个目录。远程URL中的资源不会解压缩。当一个目录被复制或解包时，它的行为与<code>tar -x</code>相同。</p><h2 id=copy>COPY</h2><p>COPY 指令和 ADD 指令的唯一区别在于：是否支持从远程URL获取资源。COPY 指令只能从执行 docker build 所在的主机上读取资源并复制到镜像中。而 ADD 指令还支持通过 URL 从远程服务器读取资源并复制到镜像中。</p><p>相同复制命令下，使用ADD构建的镜像比COPY命令构建的体积大，所以如果只是复制文件使用COPY命令。ADD 指令更擅长读取本地tar文件并解压缩。</p><h2 id=entrypoint>ENTRYPOINT</h2><p><code>ENTRYPOINT</code>和<code>CMD</code>一样，都是在指定容器启动程序以及参数，不会它不会被<code>docker run</code>的命令行指令所覆盖。如果要覆盖的话需要通过<code>docker run --entrypoint</code>来指定。</p><p>ENTRYPOINT有两种形式：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=display:flex><span><span style=color:#204a87;font-weight:700>ENTRYPOINT</span> <span style=color:#000;font-weight:700>[</span><span style=color:#4e9a06>&#34;exec&#34;</span><span style=color:#000;font-weight:700>,</span><span style=color:#4e9a06>&#34;param1&#34;</span><span style=color:#000;font-weight:700>,</span><span style=color:#4e9a06>&#34;param1&#34;</span><span style=color:#000;font-weight:700>]</span><span style=color:#a40000>
</span></span></span><span style=display:flex><span><span style=color:#a40000></span><span style=color:#204a87;font-weight:700>ENTRYPOINT</span> <span style=color:#204a87>command</span> param1 param2<span style=color:#a40000>
</span></span></span></code></pre></div><p>指定了ENTRYPOINT后，CMD的内容作为参数传递给ENTRYPOINT指令，实际执行时将变为：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>&lt;ENTRYPOINT&gt;&lt;CMD&gt;
</span></span></code></pre></div><h2 id=volume>VOLUME</h2><p>创建一个具有指定名称的挂载数据卷。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=display:flex><span><span style=color:#204a87;font-weight:700>VOLUME</span> <span style=color:#000;font-weight:700>[</span><span style=color:#4e9a06>&#34;/var/log/&#34;</span><span style=color:#000;font-weight:700>]</span><span style=color:#a40000>
</span></span></span><span style=display:flex><span><span style=color:#a40000></span><span style=color:#204a87;font-weight:700>VOLUME</span><span style=color:#4e9a06> /var/log</span><span style=color:#a40000>
</span></span></span></code></pre></div><p>VOLUME的主要作用是：</p><ul><li>避免重要的数据因容器重启而丢失。</li><li>避免容器不断变大。</li><li>保留配置文件。</li></ul><h2 id=onbuild>ONBUILD</h2><p><code>ONBUILD</code>指令作为触发指令添加到镜像中，只有在该镜像作为基础镜像时执行。触发器将在下游构建的Dockerfile中的<code>FROM</code>指令之后执行。如果任何触发器失败，<code>FROM</code>指令将中止，从而导致生成失败。如果所有触发器都成功，<code>FROM</code>指令将完成，构建将照常继续。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=display:flex><span><span style=color:#204a87;font-weight:700>ONBUILD</span> <span style=color:#204a87;font-weight:700>ADD</span> . /app/src<span style=color:#a40000>
</span></span></span><span style=display:flex><span><span style=color:#a40000></span><span style=color:#204a87;font-weight:700>ONBUILD</span> <span style=color:#204a87;font-weight:700>RUN</span> /usr/local/bin/python-build --dir /app/src<span style=color:#a40000>
</span></span></span></code></pre></div><blockquote><p>注意，ONBUILD指令不能触发FORM和MAINTAINER指令。</p></blockquote><h2 id=stopsignal>STOPSIGNAL</h2><p>设置容器退出时唤起的系统调用信号。该信号可以是与内核系统调用表中的位置匹配的有效无符号数字，例如9，或格式为SIGNAME的信号名称，如SIGKILL。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=display:flex><span><span style=color:#204a87;font-weight:700>STOPSIGNAL</span><span style=color:#4e9a06> signal</span><span style=color:#a40000>
</span></span></span></code></pre></div><p>默认的stop-signal是SIGTERM，在<code>docker stop</code>的时候会给容器内PID为1的进程发送这个信号，通过<code>--stop-signal</code>可以设置需要的signal，主要用于让容器内的程序在接收到signal之后可以先处理些未完成的事务，实现优雅结束进程后退出容器。如果不做任何处理，容器将在一段时间后强制退出，可能会造成业务强制中断，默认时间是10s。</p><h2 id=healthcheck>HEALTHCHECK</h2><p><code>HEALTHCHECK</code>指令告诉容器如何检查它是否保持运行。当容器具有指定的<code>HEALTHCHECK</code>时，除了其正常状态外，还具有健康状态。容器的状态最初是<code>starting</code>，只要通过健康检查，容器的状态就变成<code>healthy</code>（无论之前处于什么状态）。如果经过一定数量的失败检查，容器的状态会变成<code>unhealthy</code>。</p><p>该<code>HEALTHCHECK</code>指令有两种形式：</p><ul><li><p>HEALTHCHECK [OPTIONS] CMD command：通过容器内运行命令来检查容器健康状况。后面命令的退出状态会影响容器的健康状态，如：</p></li><li><ul><li>0: success - 容器是健康的，并且准备使用</li><li>1: unhealthy - 容器没有正确工作</li><li>2: reserved - 没有使用退出状态</li></ul></li><li><p>HEALTHCHECK NONE：禁用从基础镜像继承的任何健康检查。</p></li></ul><p><code>HEALTHCHECK</code>选项（应处于<code>CMD</code>之前）：</p><ul><li><code>--interval=DURATION</code>：检查间隔，default: <code>30s</code>。</li><li><code>--timeout=DURATION</code>：检查超时时间，超出此范围认为检查失败，default: <code>30s</code>。</li><li><code>--start-period=DURATION</code>：容器初始化阶段的时间，此阶段健康检查失败不计入最大重试次数，如果检查成功则认为容器已启动，default: <code>0s</code>。</li><li><code>--retries=N</code>：健康检查连续失败次数，default: <code>3</code>。</li></ul><p>举例：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=display:flex><span><span style=color:#a40000>HEALTHCHECK --interval=5m --timeout=3s \
</span></span></span><span style=display:flex><span><span style=color:#a40000> </span><span style=color:#204a87;font-weight:700>CMD</span> curl -f http://localhost/ <span style=color:#ce5c00;font-weight:700>||</span> <span style=color:#204a87>exit</span> <span style=color:#0000cf;font-weight:700>1</span><span style=color:#a40000>
</span></span></span></code></pre></div><h2 id=shell>SHELL</h2><p><code>SHELL</code>指令用于设置默认shell。Linux上默认shell是<code>["/bin/sh","-c"]</code>，Windows上是<code>["cmd","/S","/C"]</code>。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=display:flex><span><span style=color:#204a87;font-weight:700>SHELL</span> <span style=color:#000;font-weight:700>[</span><span style=color:#4e9a06>&#34;exec&#34;</span><span style=color:#000;font-weight:700>,</span><span style=color:#4e9a06>&#34;param1&#34;</span><span style=color:#000;font-weight:700>]</span><span style=color:#a40000>
</span></span></span></code></pre></div><p><code>SHELL</code>指令在Windows上特别有用，因为Windows有两种截然不同的本机SHELL：CMD和powershell，以及备用的sh。该SHELL指令可以出现多次。每条SHELL指令都会覆盖所有先前的SHELL指令，并影响后续指令。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=display:flex><span><span style=color:#204a87;font-weight:700>FROM</span><span style=color:#a40000>
</span></span></span><span style=display:flex><span><span style=color:#a40000></span>Learn more about the <span style=color:#4e9a06>&#34;FROM&#34;</span> Dockerfile command.<span style=color:#a40000>
</span></span></span><span style=display:flex><span><span style=color:#a40000></span> microsoft/windowsservercore<span style=color:#a40000>
</span></span></span><span style=display:flex><span><span style=color:#a40000>
</span></span></span><span style=display:flex><span><span style=color:#a40000></span><span style=color:#8f5902;font-style:italic># Executed as cmd /S /C echo default</span><span style=color:#a40000>
</span></span></span><span style=display:flex><span><span style=color:#a40000></span><span style=color:#204a87;font-weight:700>RUN</span> <span style=color:#204a87>echo</span> default<span style=color:#a40000>
</span></span></span><span style=display:flex><span><span style=color:#a40000>
</span></span></span><span style=display:flex><span><span style=color:#a40000></span><span style=color:#8f5902;font-style:italic># Executed as cmd /S /C powershell -command Write-Host default</span><span style=color:#a40000>
</span></span></span><span style=display:flex><span><span style=color:#a40000></span><span style=color:#204a87;font-weight:700>RUN</span> powershell -command Write-Host default<span style=color:#a40000>
</span></span></span><span style=display:flex><span><span style=color:#a40000>
</span></span></span><span style=display:flex><span><span style=color:#a40000></span><span style=color:#8f5902;font-style:italic># Executed as powershell -command Write-Host hello</span><span style=color:#a40000>
</span></span></span><span style=display:flex><span><span style=color:#a40000></span><span style=color:#204a87;font-weight:700>SHELL</span> <span style=color:#000;font-weight:700>[</span><span style=color:#4e9a06>&#34;powershell&#34;</span><span style=color:#000;font-weight:700>,</span> <span style=color:#4e9a06>&#34;-command&#34;</span><span style=color:#000;font-weight:700>]</span><span style=color:#a40000>
</span></span></span><span style=display:flex><span><span style=color:#a40000></span><span style=color:#204a87;font-weight:700>RUN</span> Write-Host hello<span style=color:#a40000>
</span></span></span><span style=display:flex><span><span style=color:#a40000>
</span></span></span><span style=display:flex><span><span style=color:#a40000></span><span style=color:#8f5902;font-style:italic># Executed as cmd /S /C echo hello</span><span style=color:#a40000>
</span></span></span><span style=display:flex><span><span style=color:#a40000></span><span style=color:#204a87;font-weight:700>SHELL</span> <span style=color:#000;font-weight:700>[</span><span style=color:#4e9a06>&#34;cmd&#34;</span><span style=color:#000;font-weight:700>,</span> <span style=color:#4e9a06>&#34;/S&#34;</span><span style=color:#000;font-weight:700>,</span> <span style=color:#4e9a06>&#34;/C&#34;</span><span style=color:#000;font-weight:700>]</span><span style=color:#a40000>
</span></span></span><span style=display:flex><span><span style=color:#a40000></span><span style=color:#204a87;font-weight:700>RUN</span> <span style=color:#204a87>echo</span> hello<span style=color:#a40000>
</span></span></span></code></pre></div><h2 id=workdir>WORKDIR</h2><p><code>WORKDIR</code>指令为Dockerfile中接下来的<code>RUN</code>、<code>CMD</code>、<code>ENTRYPOINT</code>、<code>ADD</code>、<code>COPY</code>指令设置工作目录。如果<code>WORKDIR</code>不存在，及时它没有在后续Dockerfile指令中使用，它也会被创建。</p><p>Dockerfile中可以多次使用<code>WORKDIR</code>，如果提供了相对路径，它将相对于前一条<code>WORKDIR</code>指令的路径。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=display:flex><span><span style=color:#204a87;font-weight:700>WORKDIR</span><span style=color:#4e9a06> /a</span><span style=color:#a40000>
</span></span></span><span style=display:flex><span><span style=color:#a40000></span><span style=color:#204a87;font-weight:700>WORKDIR</span><span style=color:#4e9a06> b</span><span style=color:#a40000>
</span></span></span><span style=display:flex><span><span style=color:#a40000></span><span style=color:#204a87;font-weight:700>WORKDIR</span><span style=color:#4e9a06> c</span><span style=color:#a40000>
</span></span></span><span style=display:flex><span><span style=color:#a40000></span><span style=color:#204a87;font-weight:700>RUN</span> pwd<span style=color:#a40000>
</span></span></span></code></pre></div><p>最终 pwd 命令的输出是 /a/b/c。</p><p>该 WORKDIR 指令可以解析先前使用 ENV，例如：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=display:flex><span><span style=color:#204a87;font-weight:700>ENV</span> <span style=color:#000>DIRPATH</span><span style=color:#ce5c00;font-weight:700>=</span>/path<span style=color:#a40000>
</span></span></span><span style=display:flex><span><span style=color:#a40000></span><span style=color:#204a87;font-weight:700>WORKDIR</span><span style=color:#4e9a06> $DIRPATH/$DIRNAME</span><span style=color:#a40000>
</span></span></span><span style=display:flex><span><span style=color:#a40000></span><span style=color:#204a87;font-weight:700>RUN</span> pwd<span style=color:#a40000>
</span></span></span></code></pre></div><p>最终 pwd 命令的输出是 /path/$DIRNAME。</p><blockquote><p>官方推荐WORKDIR始终使用绝对路径。此外，尽量避免使用<code>RUN cd ..&& dosomething</code>，大量的类似指令会降低可读性，令Dockerfile难以维护。</p></blockquote><h2 id=user>USER</h2><p><code>RUN</code>指令设置用户名或（UID）和可选用户组（或GID），用于运行<code>Dockerfile</code>中接下来的<code>RUN</code>、<code>CMD</code>、<code>ENTRYPOINT</code>指令。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=display:flex><span><span style=color:#204a87;font-weight:700>USER</span><span style=color:#4e9a06> &lt;user&gt;[:&lt;group&gt;]</span><span style=color:#a40000>
</span></span></span><span style=display:flex><span><span style=color:#a40000></span><span style=color:#204a87;font-weight:700>USER</span><span style=color:#4e9a06> &lt;UID&gt;[:&lt;GID&gt;]</span><span style=color:#a40000>
</span></span></span></code></pre></div><blockquote><p>注意，在Linux上，当用户没有主组时，镜像（或指令）将与根组一起运行。在Windows上，如果用户不是内置帐户，则必须首先创建该用户。也可以先通通过<code>net user</code>创建用户，再指定用户。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=display:flex><span><span style=color:#204a87;font-weight:700>FROM</span><span style=color:#4e9a06> microsoft/windowsservercore</span><span style=color:#a40000>
</span></span></span><span style=display:flex><span><span style=color:#a40000></span><span style=color:#8f5902;font-style:italic># Create Windows user in the container</span><span style=color:#a40000>
</span></span></span><span style=display:flex><span><span style=color:#a40000></span><span style=color:#204a87;font-weight:700>RUN</span> net user /add patrick<span style=color:#a40000>
</span></span></span><span style=display:flex><span><span style=color:#a40000></span><span style=color:#8f5902;font-style:italic># Set it for subsequent commands</span><span style=color:#a40000>
</span></span></span><span style=display:flex><span><span style=color:#a40000></span><span style=color:#204a87;font-weight:700>USER</span><span style=color:#4e9a06> patrick</span><span style=color:#a40000>
</span></span></span></code></pre></div></blockquote><h2 id=maintainer>MAINTAINER</h2><p>MAINTAINER指令设置生成镜像的作者。如：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=display:flex><span><span style=color:#204a87;font-weight:700>MAINTAINER</span><span style=color:#4e9a06> &lt;name&gt;</span><span style=color:#a40000>
</span></span></span></code></pre></div></div><div class=td-content style=page-break-before:always><h1 id=pg-43c061e08a55c8a5941e3bca93b7e18f>2 - Cheat Sheet</h1><div class="pageinfo pageinfo-primary"><p><a href=https://github.com/wsargent/docker-cheat-sheet/tree/master/zh-cn>https://github.com/wsargent/docker-cheat-sheet/tree/master/zh-cn</a></p></div></div><div class=td-content style=page-break-before:always><h1 id=pg-b5b32ea2a8d7a0858812be1d0a7ffaa7>3 - Docker 实战</h1><div class="pageinfo pageinfo-primary"><p><a href=https://yeasy.gitbook.io/docker_practice/>https://yeasy.gitbook.io/docker_practice/</a></p></div></div></main></div></div><footer class="bg-dark py-5 row d-print-none"><div class="container-fluid mx-sm-5"><div class=row><div class="col-6 col-sm-4 text-xs-center order-sm-2"></div><div class="col-6 col-sm-4 text-right text-xs-center order-sm-3"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Weibo aria-label=Weibo><a class=text-white target=_blank rel="noopener noreferrer" href=https://weibo.com/u/3848950217><i class="fab fa-weibo"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Twitter aria-label=Twitter><a class=text-white target=_blank rel="noopener noreferrer" href=https://twitter.com/zhange_zzg><i class="fab fa-twitter"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="Stack Overflow" aria-label="Stack Overflow"><a class=text-white target=_blank rel="noopener noreferrer" href=https://stackoverflow.com><i class="fab fa-stack-overflow"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=GitHub aria-label=GitHub><a class=text-white target=_blank rel="noopener noreferrer" href=https://github.com/infilos/infilos.com><i class="fab fa-github"></i></a></li></ul></div><div class="col-12 col-sm-4 text-center py-2 order-sm-2"><small class=text-white>&copy; 2022 infilos.com All Rights Reserved</small></div></div></div></footer></div><script src=/js/popper.min.js integrity=sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49 crossorigin=anonymous></script>
<script src=/js/bootstrap.min.js integrity=sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy crossorigin=anonymous></script>
<script src=/js/main.min.234862a61a98834daa49494cfddb4df5f6d0196eaeb7db34a9ce068e7f17863e.js integrity="sha256-I0hiphqYg02qSUlM/dtN9fbQGW6ut9s0qc4Gjn8Xhj4=" crossorigin=anonymous></script></body></html>