<!doctype html><html lang=zh class=no-js>
<head>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=generator content="Hugo 0.88.1">
<meta name=ROBOTS content="INDEX, FOLLOW">
<link rel=canonical type=text/html href=/%E6%A1%86%E6%9E%B6%E4%B8%8E%E5%BA%93/parboiled/>
<link rel="shortcut icon" href=/favicons/favicon.ico>
<link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180>
<link rel=icon type=image/png href=/favicons/favicon-16x16.png sizes=16x16>
<link rel=icon type=image/png href=/favicons/favicon-32x32.png sizes=32x32>
<link rel=icon type=image/png href=/favicons/android-36x36.png sizes=36x36>
<link rel=icon type=image/png href=/favicons/android-48x48.png sizes=48x48>
<link rel=icon type=image/png href=/favicons/android-72x72.png sizes=72x72>
<link rel=icon type=image/png href=/favicons/android-96x96.png sizes=96x96>
<link rel=icon type=image/png href=/favicons/android-144x144.png sizes=144x144>
<link rel=icon type=image/png href=/favicons/android-192x192.png sizes=192x192>
<title>Parboiled | infilos.com</title><meta property="og:title" content="Parboiled">
<meta property="og:description" content="Infilos Wiki Website">
<meta property="og:type" content="website">
<meta property="og:url" content="/%E6%A1%86%E6%9E%B6%E4%B8%8E%E5%BA%93/parboiled/"><meta property="og:site_name" content="infilos.com">
<meta itemprop=name content="Parboiled">
<meta itemprop=description content="Infilos Wiki Website"><meta name=twitter:card content="summary">
<meta name=twitter:title content="Parboiled">
<meta name=twitter:description content="Infilos Wiki Website">
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga('create','UA-123062585-1','auto'),ga('send','pageview'))</script>
<script async src=https://www.google-analytics.com/analytics.js></script>
<link rel=preload href=/scss/main.min.847464b684a6e89d7276700a5c500c17ab494dd1755b2654a7b27d8b59e3347e.css as=style>
<link href=/scss/main.min.847464b684a6e89d7276700a5c500c17ab494dd1755b2654a7b27d8b59e3347e.css rel=stylesheet integrity>
<script src=/js/jquery-3.5.1.min.js integrity="sha256-9/aliU8dGd2tb6OSsuzixeV4y/faTqgFtohetphbbj0=" crossorigin=anonymous></script>
</head>
<body class=td-section>
<header>
<nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-column flex-md-row td-navbar">
<a class=navbar-brand href=/>
<span class=navbar-logo><svg id="Capa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 512 512" style="enable-background:new 0 0 512 512"><path style="fill:#ffc107" d="M432.384 143.616c-4.165-4.164-10.917-4.164-15.083.0l-60.352 60.352c-4.164 4.165-4.164 10.917.0 15.083 21.187 20.463 54.951 19.876 75.413-1.311 19.962-20.668 19.962-53.435.0-74.102L432.384 143.616z"/><path style="fill:#607d8b" d="M42.667 277.334c-5.891.003-10.669-4.771-10.672-10.662-.002-4.338 2.623-8.245 6.64-9.882l234.667-96c5.455-2.233 11.687.38 13.92 5.835s-.38 11.687-5.835 13.92l-234.667 96C45.433 277.069 44.056 277.337 42.667 277.334z"/><path style="fill:#546e7a" d="M391.552 56.448l-32-32C343.938 8.745 322.689-.059 300.544.0h-3.755c-46.082.024-83.432 37.374-83.456 83.456v3.755c-.053 22.138 8.75 43.377 24.448 58.987l32 32c4.165 4.164 10.917 4.164 15.083.0L391.531 71.531C395.701 67.372 395.71 60.62 391.552 56.448z"/><path style="fill:#607d8b" d="M160 469.334c-3.279.006-6.379-1.497-8.405-4.075L34.261 315.926c-3.635-4.636-2.823-11.341 1.813-14.976s11.341-2.823 14.976 1.813l117.333 149.333c3.629 4.641 2.809 11.344-1.832 14.973C164.681 468.533 162.375 469.329 160 469.334z"/><path style="fill:#455a64" d="M487.467 86.848l-3.669-3.648c-37.687-36.557-97.71-36.197-134.955.811l-51.413 51.413c-36.996 37.25-37.357 97.263-.811 134.955l3.584 3.669c1.7 2.457 4.671 3.706 7.616 3.2 2.831.005 5.548-1.115 7.552-3.115l172.181-172.181c4.189-4.143 4.226-10.896.083-15.085-.028-.028-.055-.056-.083-.083L487.467 86.848z"/><g><path style="fill:#ffc107" d="M501.333 192H480c-5.891.0-10.667-4.776-10.667-10.667s4.776-10.667 10.667-10.667h21.333c5.891.0 10.667 4.776 10.667 10.667S507.225 192 501.333 192z"/><path style="fill:#ffc107" d="M394.667 298.667c-5.891.0-10.667-4.776-10.667-10.667v-21.333c0-5.891 4.776-10.667 10.667-10.667 5.891.0 10.667 4.776 10.667 10.667V288C405.333 293.891 400.558 298.667 394.667 298.667z"/><path style="fill:#ffc107" d="M480 277.334c-2.831.005-5.548-1.115-7.552-3.115l-21.333-21.333c-4.093-4.237-3.975-10.99.262-15.083 4.134-3.993 10.687-3.993 14.821.0l21.333 21.333c4.159 4.172 4.148 10.926-.024 15.085C485.514 276.209 482.815 277.327 480 277.334z"/></g><g><path style="fill:#455a64" d="M266.667 448H96c-29.455.0-53.333 23.878-53.333 53.333.0 5.891 4.776 10.667 10.667 10.667h256c5.891.0 10.667-4.776 10.667-10.667C320 471.878 296.122 448 266.667 448z"/><circle style="fill:#455a64" cx="32" cy="288" r="32"/></g><g/><g/><g/><g/><g/><g/><g/><g/><g/><g/><g/><g/><g/><g/><g/></svg></span><span class=font-weight-bold>infilos.com</span>
</a>
<div class="collapse navbar-collapse" id=navbarSupportedContent>
<ul class="navbar-nav mr-auto">
<li class="nav-item dropdown" style=max-width:90px;min-width:10px>
<a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>
基础
<span>+</span>
</a>
<div class=dropdown-menu aria-labelledby=navbarDropdown>
<a class=dropdown-item href=/%e5%9f%ba%e7%a1%80%e7%9f%a5%e8%af%86/%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f>操作系统</a>
<a class=dropdown-item href=/%e5%9f%ba%e7%a1%80%e7%9f%a5%e8%af%86/%e6%80%a7%e8%83%bd%e4%b9%8b%e6%ae%87>性能之殇</a>
<a class=dropdown-item href=/%e5%9f%ba%e7%a1%80%e7%9f%a5%e8%af%86/io%e6%a8%a1%e5%9e%8b>IO 模型</a>
<a class=dropdown-item href=/%e5%9f%ba%e7%a1%80%e7%9f%a5%e8%af%86/%e7%bd%91%e7%bb%9c%e5%9f%ba%e7%a1%80>网络基础</a>
<a class=dropdown-item href=/%e5%9f%ba%e7%a1%80%e7%9f%a5%e8%af%86/tcp-ip>TCP-IP</a>
<a class=dropdown-item href=/%e5%9f%ba%e7%a1%80%e7%9f%a5%e8%af%86/http>HTTP</a>
</div>
</li>
<li class="nav-item dropdown" style=max-width:90px;min-width:10px>
<a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>
语言
<span>+</span>
</a>
<div class=dropdown-menu aria-labelledby=navbarDropdown>
<a class=dropdown-item href=/%e7%bc%96%e7%a8%8b%e8%af%ad%e8%a8%80/java>Java 编程</a>
<a class=dropdown-item href=/%e7%bc%96%e7%a8%8b%e8%af%ad%e8%a8%80/jvm-core>JVM 核心</a>
<a class=dropdown-item href=/%e7%bc%96%e7%a8%8b%e8%af%ad%e8%a8%80/jvm-concurrent>JVM 并发</a>
<a class=dropdown-item href=/%e7%bc%96%e7%a8%8b%e8%af%ad%e8%a8%80/scala>Scala 编程</a>
</div>
</li>
<li class="nav-item dropdown" style=max-width:90px;min-width:10px>
<a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>
框架库
<span>+</span>
</a>
<div class=dropdown-menu aria-labelledby=navbarDropdown>
<a class=dropdown-item href=/%e6%a1%86%e6%9e%b6%e4%b8%8e%e5%ba%93/spring>Spring</a>
<a class=dropdown-item href=/%e6%a1%86%e6%9e%b6%e4%b8%8e%e5%ba%93/hikari>Hikari</a>
<a class=dropdown-item href=/%e6%a1%86%e6%9e%b6%e4%b8%8e%e5%ba%93/parboiled>Parboiled</a>
</div>
</li>
<li class="nav-item dropdown" style=max-width:90px;min-width:10px>
<a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>
分布式
<span>+</span>
</a>
<div class=dropdown-menu aria-labelledby=navbarDropdown>
<a class=dropdown-item href=/%e5%88%86%e5%b8%83%e5%bc%8f/base>基本构成</a>
</div>
</li>
<li class="nav-item dropdown" style=max-width:90px;min-width:10px>
<a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>
大数据
<span>+</span>
</a>
<div class=dropdown-menu aria-labelledby=navbarDropdown>
<a class=dropdown-item href=/%e5%ad%98%e5%82%a8%e7%b3%bb%e7%bb%9f>存储系统</a>
<a class=dropdown-item href=/%e6%9f%a5%e8%af%a2%e7%b3%bb%e7%bb%9f>查询系统</a>
<a class=dropdown-item href=/%e6%b6%88%e6%81%af%e7%b3%bb%e7%bb%9f>消息系统</a>
<a class=dropdown-item href=/%e5%a4%84%e7%90%86%e7%b3%bb%e7%bb%9f>处理系统</a>
<a class=dropdown-item href=/%e7%ae%a1%e7%90%86%e7%b3%bb%e7%bb%9f>管理系统</a>
</div>
</li>
<li class="nav-item dropdown" style=max-width:90px;min-width:10px>
<a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>
中后台
<span>+</span>
</a>
<div class=dropdown-menu aria-labelledby=navbarDropdown>
<a class=dropdown-item href=/%e5%9f%ba%e7%a1%80%e8%ae%be%e6%96%bd>基础设施</a>
<a class=dropdown-item href=/%e4%ba%a4%e4%ba%92%e7%95%8c%e9%9d%a2>交互界面</a>
<a class=dropdown-item href=/%e4%b8%9a%e5%8a%a1%e7%b3%bb%e7%bb%9f>业务系统</a>
</div>
</li>
<li class="nav-item dropdown" style=max-width:90px;min-width:10px>
<a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>
模式架构
<span>+</span>
</a>
<div class=dropdown-menu aria-labelledby=navbarDropdown>
<a class=dropdown-item href=/%e6%a8%a1%e5%bc%8f%e6%9e%b6%e6%9e%84/design-pattern>设计模式</a>
<a class=dropdown-item href=/%e6%a8%a1%e5%bc%8f%e6%9e%b6%e6%9e%84/micro-service>微服务架构</a>
</div>
</li>
<li class=nav-item style=max-width:90px;min-width:10px>
<a class=nav-link href=/%e9%9d%a2%e8%af%95%e9%97%ae%e7%ad%94>
<span>面试</span>
</a>
</li>
<li class=nav-item style=max-width:90px;min-width:10px>
<a class=nav-link href=/%e7%ae%a1%e7%90%86%e8%b7%af%e5%be%84>
<span>管理</span>
</a>
</li>
<li class=nav-item style=max-width:90px;min-width:10px>
<a class=nav-link href=/%e5%bc%80%e6%ba%90%e9%a1%b9%e7%9b%ae>
<span>开源</span>
</a>
</li>
</ul>
<div class="form-inline my-2 my-lg-0">
<div class="nav-item nav-search-item my-2 my-md-0">
<input type=search class="form-control td-search-input" placeholder="&#xf002; 站内搜索…" aria-label=站内搜索… autocomplete=off>
</div>
</div>
</div>
</nav>
</header>
<div class="container-fluid td-outer">
<div class=td-main>
<div class="row flex-xl-nowrap">
<div class="col-12 col-md-3 col-xl-2 td-sidebar d-print-none">
</div>
<div class="d-none d-xl-block col-xl-2 td-toc d-print-none">
</div>
<main class="col-12 col-md-9 col-xl-8 pl-md-5" role=main>
<div class=td-content>
<div class="pageinfo pageinfo-primary d-print-none">
<p>
这是本节的多页打印视图。
<a href=# onclick="return print(),!1">点击此处打印</a>.
</p><p>
<a href=/%E6%A1%86%E6%9E%B6%E4%B8%8E%E5%BA%93/parboiled/>返回本页常规视图</a>.
</p>
</div>
<h1 class=title>Parboiled</h1>
<ul>
<li>1: <a href=#pg-9128c2dc49c622f7600933c8d1ea1035>CH01-Motivation</a></li>
<li>2: <a href=#pg-05a361d8cd94e1828f1031c78fe17a96>CH02-Features</a></li>
<li>3: <a href=#pg-c01e1d6286ccead6f7f8fe20b1de6a82>CH03-Java Example</a></li>
<li>4: <a href=#pg-58a76c5a3dcaf6862a60be2d58ff89be>CH04-Scala Example</a></li>
<li>5: <a href=#pg-aefd071109bac895cd9af8eb4428de7d>CH05-Comparison</a></li>
<li>6: <a href=#pg-0b8da0caaa67951e41a357509aa1eb83>CH06-Concepts</a></li>
<li>7: <a href=#pg-63d9481a39ef551c7e8a0cb56828ef77>CH07-Java APIs</a></li>
<li>8: <a href=#pg-e7fc3f9332a7db16b99b057d62a76d6f>CH08-Scala APIs</a></li>
<li>9: <a href=#pg-d172300b36f276e75efe2961e9416e8d>CH09-Advanced Topics</a></li>
</ul>
<div class=content>
<p><a href=https://github.com/sirthias/parboiled>Parboiled</a> 是一个轻量、易用、强大且优雅的解析库，用于解析任意任意输入文本，基于 “解析表达式文法(PEGs)”，同时支持 Java 和 Scala。PEGs 是一种针对形式特定语法的上下文无关文法，是对正则表达式的很好替代，通过 CFGs 来构建解析器通常也会比传统的方式要有很多优势。</p>
</div>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-9128c2dc49c622f7600933c8d1ea1035>1 - CH01-Motivation</h1>
<p>Parboiled 的诞生源自对 JVM 上现有解析器构建工具的挫败感。</p>
<p>近年来流行动态语言(如 Ruby、Groovy)的巨大增长，很大一部分原因是它们将自身作为 DSL 的模型。虽然这些语言(甚至是一些静态类型的语言，如 Scala)具有简洁灵活的语法，通常直接可以用作内部 DSL 的基础，但相当笨拙的 Java 语法使得内部 DSL 非常缺乏吸引力。</p>
<p>对于很多项目来说，一个很小的 DSL 久能够构建出一个优雅的“用户接口”，以在没有 GUI 的情况下提供丰富的表现力以及灵活性。在 Java 中，内部 DSL 并不在规划之内，你不得不为外部 DSL 构建一个解析器以获得便利。尽管外部 DSL 并非解析器的唯一用例，像 Java 中这样对语言的传统解析支持工具并不出众。很多时候支持 DSL 并非项目的核心目标(如下编译器实现中)，而是解决各种问题之一的优雅方案。因此，你可能并不希望将太多时间用于上下文无关的文法、词法理论以及错综复杂的外部解析器生成器。您只想以某种方式指定解析语法的外观并使其快速轻松地工作。这也就是 Parboiled 存在的原因。</p>
<p>下面是一些传统解析器生成器的缺点：</p>
<ul>
<li>专有性，以非 Java 语法的形式保存在单独的项目文件(如外部 DSL)。</li>
<li>对文法文件没有 IDE 内置支持(语法高亮、内联检查、重构、代码导航等)。</li>
<li>运行外部解析器生成器需要特殊的构建步骤。</li>
<li>“谜不可触”，在你项目中生成的 Java 源文件需要与文法规范保持同步。</li>
<li>通过词法分析(令牌生成)和令牌解析阶段中的分离解析过程进行更复杂的设计和维护。</li>
<li>综合占用(ANTLR 分发的生成器加上运行时占用多余 1.8 MB)。</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-05a361d8cd94e1828f1031c78fe17a96>2 - CH02-Features</h1>
<ol>
<li>以 Java、Scala 源码的形式定义文法。
<ul>
<li>没有外部的、非 Java/Scala 源码格式的文件。</li>
<li>无需学习额外的特有语法。</li>
<li>无需破坏 IDE 支持。</li>
</ul>
</li>
<li>真实世界可读。
<ul>
<li>来自<a href=https://en.wikipedia.org/wiki/Parsing_expression_grammar>PEG</a>的完整表现力。</li>
<li>支持强大且灵活的解析器动作。</li>
<li>游戏的解析错误包括与恢复。</li>
<li>高性能。</li>
</ul>
</li>
<li>非常易于集成。
<ul>
<li>无需管理外部的解析器生成器。</li>
<li>没有特殊的步骤使你的构建过程复杂化。</li>
<li>你的项目结构中不再有“谜不可触”的、生成的源文件。</li>
<li>开放、轻量的结构使得非常易于集成到现有项目结构。</li>
</ul>
</li>
<li>轻量、易用。</li>
</ol>
<ul>
<li>仅有一个解析阶段(词法分析代码不是必须的)。</li>
<li>少量且简单的 API。</li>
<li>整个库仅占用 300/450 KB，依赖较少。</li>
</ul>
<p>虽然 Parboiled 最初设计的速度低于易用性和可维护性，但其解析性能自早期版本以来已显着改善，现在对于大多数应用程序来说已经足够了。它可以以近似的速率解析其自身的 Java 5 源码。以每秒 55,000 行或每秒 200 万个字符的速度运行(2.4 GHz Intel Core i5 单核，OS/X Java 6)。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-c01e1d6286ccead6f7f8fe20b1de6a82>3 - CH03-Java Example</h1>
<p>首先是一个计算器的文法定义：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback>Expression &lt;- Term ((&#39;+&#39; / &#39;-&#39;) Term)*
Term &lt;- Factor ((&#39;*&#39; / &#39;/&#39;) Factor)*
Factor &lt;- Number / &#39;(&#39; Expression &#39;)&#39;
Number &lt;- [0-9]+
</code></pre></div><p>然后是基于 Java 代码的解析器定义：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#5c35cc;font-weight:700>@BuildParseTree</span>
<span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>CalculatorParser</span> <span style=color:#204a87;font-weight:700>extends</span> <span style=color:#000>BaseParser</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>Object</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#ce5c00;font-weight:700>{</span>
  
  <span style=color:#000>Rule</span> <span style=color:#000>Expression</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>Sequence</span><span style=color:#ce5c00;font-weight:700>(</span>
      <span style=color:#000>Term</span><span style=color:#ce5c00;font-weight:700>(),</span>
      <span style=color:#000>ZeroOrMore</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>AnyOf</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#4e9a06>&#34;+-&#34;</span><span style=color:#ce5c00;font-weight:700>),</span> <span style=color:#000>Term</span><span style=color:#ce5c00;font-weight:700>())</span>
    <span style=color:#ce5c00;font-weight:700>);</span>
  <span style=color:#ce5c00;font-weight:700>}</span>
  
  <span style=color:#000>Rule</span> <span style=color:#000>Term</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>Sequence</span><span style=color:#ce5c00;font-weight:700>(</span>
      <span style=color:#000>Factor</span><span style=color:#ce5c00;font-weight:700>(),</span>
      <span style=color:#000>ZeroOrMore</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>AnyOf</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#4e9a06>&#34;*/&#34;</span><span style=color:#ce5c00;font-weight:700>),</span> <span style=color:#000>Factor</span><span style=color:#ce5c00;font-weight:700>())</span>
    <span style=color:#ce5c00;font-weight:700>);</span>
  <span style=color:#ce5c00;font-weight:700>}</span>
  
  <span style=color:#000>Rule</span> <span style=color:#000>Factor</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>FirstOf</span><span style=color:#ce5c00;font-weight:700>(</span>
      <span style=color:#000>Number</span><span style=color:#ce5c00;font-weight:700>(),</span>
      <span style=color:#000>Sequence</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#4e9a06>&#39;(&#39;</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>Expression</span><span style=color:#ce5c00;font-weight:700>(),</span> <span style=color:#4e9a06>&#39;)&#39;</span><span style=color:#ce5c00;font-weight:700>)</span>
    <span style=color:#ce5c00;font-weight:700>);</span>
  <span style=color:#ce5c00;font-weight:700>}</span>
  
  <span style=color:#000>Rule</span> <span style=color:#000>Number</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>OneOrMore</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>CharRange</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#4e9a06>&#39;0&#39;</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#4e9a06>&#39;9&#39;</span><span style=color:#ce5c00;font-weight:700>));</span>
  <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>最后是对该解析器的应用：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#000>String</span> <span style=color:#000>input</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#4e9a06>&#34;1+2&#34;</span><span style=color:#ce5c00;font-weight:700>;</span>
<span style=color:#000>CalculatorParser</span> <span style=color:#000>parser</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>Parboiled</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>createParser</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>CalculatorParser</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>class</span><span style=color:#ce5c00;font-weight:700>);</span>
<span style=color:#000>ParsingResult</span><span style=color:#ce5c00;font-weight:700>&lt;?&gt;</span> <span style=color:#000>result</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>ReportingParseRunner</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>parser</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>Expression</span><span style=color:#ce5c00;font-weight:700>()).</span><span style=color:#c4a000>run</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>input</span><span style=color:#ce5c00;font-weight:700>);</span>
<span style=color:#000>String</span> <span style=color:#000>parseTreePrintOut</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>ParseTreeUtils</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>printNodeTree</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>result</span><span style=color:#ce5c00;font-weight:700>);</span>
<span style=color:#000>System</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>out</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>println</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>parseTreePrintOut</span><span style=color:#ce5c00;font-weight:700>);</span>
</code></pre></div><p>第 2 行创建了一个解释器实例，其方法可以被用于各种不同的 ParserRunner 来执行实际的解析过程并创建 ParsingResult。ParsingResult 对象除了包含输入是否匹配的信息之外，还包含表达式的解析树的根(如果启用了解析书构建)、结果值、解析错误列表。理解解析器是如何处理输入的方式是使用 ParseTreeUtils.printNodeTree，如上面示例中第 4~5 行那样。</p>
<p>通常来说，Parboiled 会在 Java 语法的约束下使你的规则规范尽可能的可读。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-58a76c5a3dcaf6862a60be2d58ff89be>4 - CH04-Scala Example</h1>
<p>首先是一个计算器的文法定义：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback>Expression &lt;- Term ((&#39;+&#39; / &#39;-&#39;) Term)*
Term &lt;- Factor ((&#39;*&#39; / &#39;/&#39;) Factor)*
Factor &lt;- Number / &#39;(&#39; Expression &#39;)&#39;
Number &lt;- [0-9]+
</code></pre></div><p>然后是基于 Scala 代码的解析器定义：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=color:#204a87;font-weight:700>import</span> <span style=color:#000>org.parboiled.scala._</span>

<span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>SimpleCalculator</span> <span style=color:#204a87;font-weight:700>extends</span> <span style=color:#000>Parser</span> <span style=color:#ce5c00;font-weight:700>{</span>
  
  <span style=color:#204a87;font-weight:700>def</span> <span style=color:#000>Expression</span><span style=color:#204a87;font-weight:700>:</span><span style=color:#204a87;font-weight:700>Rule0</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>rule</span> <span style=color:#ce5c00;font-weight:700>{</span> <span style=color:#000>Term</span> <span style=color:#ce5c00;font-weight:700>~</span> <span style=color:#000>zeroOrMore</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>anyOf</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#4e9a06>&#34;+-&#34;</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>~</span> <span style=color:#000>Term</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>}</span>
  
  <span style=color:#204a87;font-weight:700>def</span> <span style=color:#000>Term</span> <span style=color:#204a87;font-weight:700>=</span> <span style=color:#000>rule</span> <span style=color:#ce5c00;font-weight:700>{</span> <span style=color:#000>Factor</span> <span style=color:#ce5c00;font-weight:700>~</span> <span style=color:#000>zeroOrMore</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>anyOf</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#4e9a06>&#34;*/&#34;</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>~</span> <span style=color:#000>Factor</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>}</span>
  
  <span style=color:#204a87;font-weight:700>def</span> <span style=color:#000>Factor</span> <span style=color:#204a87;font-weight:700>=</span> <span style=color:#000>rule</span> <span style=color:#ce5c00;font-weight:700>{</span> <span style=color:#000>Number</span> <span style=color:#ce5c00;font-weight:700>|</span> <span style=color:#4e9a06>&#34;(&#34;</span> <span style=color:#ce5c00;font-weight:700>~</span> <span style=color:#000>Expression</span> <span style=color:#ce5c00;font-weight:700>~</span> <span style=color:#4e9a06>&#34;)&#34;</span> <span style=color:#ce5c00;font-weight:700>}</span>
  
  <span style=color:#204a87;font-weight:700>def</span> <span style=color:#000>Number</span> <span style=color:#204a87;font-weight:700>=</span> <span style=color:#000>rule</span> <span style=color:#ce5c00;font-weight:700>{</span> <span style=color:#000>oneOrMore</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#4e9a06>&#34;0&#34;</span> <span style=color:#ce5c00;font-weight:700>-</span> <span style=color:#4e9a06>&#34;9&#34;</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>最后是对该解析器的应用：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=color:#204a87;font-weight:700>val</span> <span style=color:#000>input</span> <span style=color:#204a87;font-weight:700>=</span> <span style=color:#4e9a06>&#34;1+2&#34;</span>
<span style=color:#204a87;font-weight:700>val</span> <span style=color:#000>parser</span> <span style=color:#204a87;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>SimpleCalculator</span> <span style=color:#ce5c00;font-weight:700>{</span> <span style=color:#204a87;font-weight:700>override</span> <span style=color:#204a87;font-weight:700>val</span> <span style=color:#000>buildParseTree</span> <span style=color:#204a87;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>true</span> <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#204a87;font-weight:700>val</span> <span style=color:#000>result</span> <span style=color:#204a87;font-weight:700>=</span> <span style=color:#000>ReportingParseRunner</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>parser</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#000>Expression</span><span style=color:#ce5c00;font-weight:700>).</span><span style=color:#000>run</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>input</span><span style=color:#ce5c00;font-weight:700>)</span>
<span style=color:#204a87;font-weight:700>val</span> <span style=color:#000>parseTreePrintOut</span> <span style=color:#204a87;font-weight:700>=</span> <span style=color:#000>org</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#000>parboiled</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#000>support</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#000>ParseTreeUtils</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#000>printNodeTree</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>result</span><span style=color:#ce5c00;font-weight:700>)</span>
<span style=color:#000>println</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>parseTreePrintOut</span><span style=color:#ce5c00;font-weight:700>)</span>
</code></pre></div>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-aefd071109bac895cd9af8eb4428de7d>5 - CH05-Comparison</h1>
<p>如果你将解析需求想象为一个光谱，一边是“脏且快”的正则表达式，一边是像 ANTLR 一样完整的解析器生成器，Parboiled 则旨在填补两端之间的巨大空间。对于非常简单的用例，正则表达式可能是一个具有最小开销的适当解决方案。然而，正则表达式可以很快变成丑陋的混乱、难以阅读理解并最终难以维护。在许多情况下，它们也缺乏表达能力来解析像嵌套构造这样需要递归规则定义的东西。它们也不会生成正确的错误消息或从输入的错误中恢复，而这可以在开发过程中节省大量时间。</p>
<p>在光谱的另一端，像 ANTLR 和 Rats! 这样强大的工具当然也有其适用场景。当必须解析那些用复杂语言编写的大量源码时，解析器生成器可能是合适的工具。比如，你可能想要使用现有的语法，或者需要一些发展多年的企业工具的完整特性集。</p>
<p>然而，当你需要定义自己的语法，并且对解析器生成器没有丰富的经验，Parboiled 则可以快速简便的帮你达到目的。Parboiled 可以用于小的任务，如解析日期与时间；也可以用于复杂的任务，如解析 Java 源码或像 Markdown 这样的标记语言。占用小、轻量的架构使其很容易与其他应用集成，同时又能为多种定制需求提供良好的基础。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-0b8da0caaa67951e41a357509aa1eb83>6 - CH06-Concepts</h1>
<h2 id=纵观全局>纵观全局</h2>
<p>Parboiled 提供了一个递归下降的 PEG 解析器实现来操作你指定的 PEG 规则。</p>
<p>你的语法规范可以包含解析器动作，这些动作可以在解析过程中的任意一点执行额外的逻辑，比如使用自定义条件来增强输入识别，或者构造抽象语法树(AST)。</p>
<h3 id=两个阶段>两个阶段</h3>
<p>你的代码会在两个阶段与 Parboiled 交互。在第一个阶段——“规则构造”阶段，Parboiled 会基于你定义的 Java/Scala 代码为解析器规则构建一个树(一个有向图)。该阶段与实际的输入阶段没有依赖，仅需要在整个 JVM 的生命周期中执行一次，即构建过的规则树是可复用的。第二个阶段是实际的解析阶段，使用第一阶段中的规则来处理特定的输入文本。最终的执行结构将包含以下信息：</p>
<ul>
<li>一个布尔值来表示输入是否与根规则匹配。</li>
<li>可能遇到的所有解析错误。</li>
<li>由你的解析器动作构造的一个或多个值对象。</li>
</ul>
<h3 id=规则构造>规则构造</h3>
<p>在执行由 Java/Scala 定义的规则代码时将触发规则构造。Parboiled 分别为 Java 和 Scala 提供了单独的 DSL 来使得规则的定义过程与语言本身结合的更加舒适。</p>
<p>在 Java 中你需要实现一个自定义类来继承 BaseParser 类，并定义一些方法来返回 Rule 实例。这些方法可以通过调用其他自定义方法、终止符、预定义原语、动作表达式来构造规则实例。由于 Java 语法的限制，Parboiled 则使用了一个名为“解析器扩展(Parser Extension)”的过程来支持比其他方式更加简洁的规则构造代码。</p>
<p>因为 Scala 本身就富有较强的表现力，因此 Parboiled 并不需要为 Scala 再提供一个单独的解析器扩展步骤。在 Scala 中，你可以直接通过 Scala 语言元素来构造解析器规则树。</p>
<h3 id=解析动作>解析动作</h3>
<p>为了避免你的解析器仅仅是一个“识别器”(一段仅能检测输入是否与定义的语法匹配的代码)，在你的解析器中需要包含一些动作。解析器动作是一段自定义的代码，在规则执行期间的一些特定点被执行。除了检查解析器状态(如查看匹配的输入文本片段)，解析器动作通常用于构造“值”(如 AST 节点)，并可以作为语义谓词主动影响解析过程。</p>
<h3 id=值栈>值栈</h3>
<p>在规则执行阶段，你的解析器动作可以利用“值栈”来组织自定义对象的构造，如 AST 节点。值栈是一个简单的栈结构，作为一个临时存储为自定义对象提供服务。使用值栈的方式取决于你使用的是 Parboiled Java 还是 Parboiled Scala。</p>
<h3 id=解析树>解析树</h3>
<p>在规则执行阶段 Parboiled 能够以可选的方式构造一个解析树，其节点对应于已识别的规则。每个解析树 Node 包含一个对应规则的 Matcher，同时，被匹配的输入文本(位置)也会作为当前值栈的栈顶元素。该解析树可以被看做是输入对已匹配规则的记录，在调试过程中尤其有用。</p>
<h3 id=解析执行器>解析执行器</h3>
<p>ParseRunner 的职责是“监管”解析的执行过程，并能以可选的方式提供额外的逻辑，尤其重要的是对非法输入字符的处理(基于语法)。当你使用 Parboiled 执行解析时可以选择一下 5 种预定义的 ParseRunner：</p>
<ol>
<li>BasicParseRunner，最快最基本的 ParseRunner，不执行错误处理。</li>
<li>ReportingParseRunner，为输入的第一个错误创建衣蛾 InvalidInputError。</li>
<li>RecoveringParseRunner，最复杂的 ParseRunner，报告输入中的所有错误，并尝试从错误中恢复。</li>
<li>TracingParseRunner，为每条匹配的或未匹配的规则有选择的打印追踪信息。</li>
<li>ProfilingParseRunner，在你的解析器处理一个或多个输入时生成详细的统计信息。</li>
</ol>
<h2 id=rule-tree>Rule Tree</h2>
<p>像大多数解析相关的程序一样，Parboiled 严重依赖于图和树结构。第一个这样的结构会在解析过程中创建，即规则“树”。该规则树这时尚未与实际的输入产生依赖。解析输入会在解析执行的过程中被解析器消费并被应用到规则树上，该过程可以以可选的方式生成一个解析树。</p>
<p>假设以下示例语法：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback>a ← b ‘a’ c
b ← ‘b’ d
c ← ‘c’ d
d ← ‘d’ c?
</code></pre></div><p>如果你将该语法转换为一个图，仅将规则作为图的节点，规则引用作为有向边，这时该语法可以用以下结构来表示：</p>
<div align=center>
<img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20190212174806.png style=display:block;width:20% alt=NAME align=center>
</div>
<p>你会发现该图存在一个环，同时节点 d 拥有两个父亲，这也就是为什么该图不是一个树而仅仅是一个有向图。很多真实世界的语法的大多部分都像是一个树，带有非常清晰的规则到子规则层级引用。虽然回环(递归)并不十分罕见，但与“常规”分层引用相比，它们的数量确实很少。</p>
<p>因此这样的原因(以及对许多人而言，“树”是一种更常见的心理图景)，你可能会选择将这样的规则图看做是带有两个特殊异常的规则树：多父亲、回环。</p>
<p>顺便提一下，PEG 语法的这种有向图特性几乎与方法调用在 JVM 中的工作方式一致：方法调用其他方法，可能包括调用堆栈祖先。这也是为什么 Parboiled 会或多或少的将规则声明映射到 Java/Scala 的方法调用。你的每个解析器规则方法都会构造一个规则对象，并在构造过程中潜在的调用其他规则构造方法。</p>
<p>然而这里还有两个问题：</p>
<ul>
<li>Java/Scala 方法递归到方法自身或其祖先时需要一种方式来终止递归。通常这是通过一些逻辑实现的，可以在逻辑中通过一些条件来退出递归。然而规则声明无法做到这一点，只有解析的输入文本(是有限的)将会终止任何规则递归。因此为了防止用于构造规则的 Java/Scala 方法出现无限递归，需要采取一些技巧。</li>
<li>当一个规则构造方法被调用多次时(可能被多起其他规则构造方法调用)，通常会为每次调用创建结构相同的全新的规则实例。虽然这不是什么问题，但在规模较大的语法中则会比较低效，这时一个大型的规则树中会包含很多重复的规则实例。</li>
</ul>
<p>Parboiled 在 Java 中通过重写解析类的规则方法来、并注入开发者不可见的代码来解决这两个问题。这些代码会确保每个方法仅会被调用一次，即背个规则仅被创建一次，后续的调用则会返回已创建的相同规则实例。如果规则的创建过程递归会自身，则插入代理规则以防止无限递归。所有这些事情都在幕后透明地发生，开发者无需关心。</p>
<p>Parboiled 在 Scala 中则不需要重写实际的字节码，而是将实际的规则创建代码封装到一个函数块，并作为主规则构建方法的参数。</p>
<p>最后，当你调用你的顶级规则方法并传给所选的 ParseRunner 时，则会得到一个规则树，没有重复节点，正确的链接关系，甚至还有递归。</p>
<h3 id=mathcers>Mathcers</h3>
<p>你可能已经在 Javadoc API 文档中看到 Rule 接口仅仅是一个外观接口，带有很少的方法以指定特殊的规则属性。所有实现该接口的类被定义在 <code>org.parboiled.matchers</code> 中。有一个用于所有规则原语的 Matcher 实现，它实现了实际规则类型的逻辑。因此规则树实际上是一个 Matcher 树。然而，大多时候你不必了解这些内部细节，仅需关注于解析器规则和值栈。</p>
<h2 id=value-stack>Value Stack</h2>
<p>在规则执行阶段，你的解析器动作可以利用“值栈”来组织自定义对象(如 AST 节点)的构造。值栈是一个简单的栈结构，作为临时存储服务于自定义对象。</p>
<p>通常，规则可以以任何方式修改值栈。可以创建新的值并推到栈上，或者消费已有的值，或者转换已有的值并重新推到栈上，等等。Parboiled 解析引擎并不关心你的规则和解析器动作与值栈之间的交互。</p>
<p>有两个特殊异常：</p>
<h3 id=规则未匹配>规则未匹配</h3>
<p>如果规则因任何原因未匹配成功，则将值栈重置为执行该失败规则之前的状态。这意味着失败的规则无法修改值栈(这包括失败的语义判定动作)。</p>
<p>此行为的原因是使您不仅可以将动作放在一系列规则的最后位置。考虑如下规则：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback>Rule ← ‘a’ ‘b’ action ‘c’
</code></pre></div><p>假设匹配规则 “b” 之后将一个新值推到栈上。如果因为最终的元素 “c” 不能匹配到规则而导致规则序列失败，该值栈仍然会包含刚才被动作推入的新值。即使您的规则逻辑可能能够处理这些情况，这也会使动作设计复杂化并使解析器逻辑更加脆弱。</p>
<p>事实上，当规则不匹配时 Parboiled 重置堆栈的行为使得你可以自由的放置解析器动作，并将值栈用于规则内临时存储，这在很多情况下都非常方便。</p>
<h3 id=语义判定>语义判定</h3>
<p>Test 和 TestNot 规则永远不会影响值栈。Parboiled 会使用一个以保存的快照将值栈重置回 Test/TestNot 规则匹配之前的状态。因此，您可以确定语法判定永远不会“混乱”您的值栈设置，即使它们包含解析器动作或引用其他规则。</p>
<h2 id=parse-tree>Parse Tree</h2>
<p>Parboiled 在规则执行阶段以可选的方式支持构建一个解析树。查看解析树可以更好的理解你的解析器对输入的消费过程，因此有助于解析器的开发和调试。</p>
<p>由 Parboiled 创建的解析树由一系列实现 Node 接口的不可变对象组成。除了基本的树节点功能(父亲、儿子)之外，该接口定义了节点名、所匹配输入文本的起始终止位置，以及一个自定义值对象。一些工具类为解析树提供了额外的处理方法，有 ParseTreeUtils、TreeUtils、GraphUtils。</p>
<p>需要注意的是解析树的节点是不可变的，即一旦被创建则不再能被修改。这实际上意味着它们的子节点结构和它们的值对象“引用”不能被修改。(尽管它们的值对象可以是可变的，或者仍然能够被修改。)整个解析树会从底向上被构建，先从叶子节点开始。通常来说，如果开启了解析树构建选项，匹配成功的每个规则都会创建一个解析树节点，该节点将匹配成功的子规则所创建的节点作为子节点。匹配失败的规则不会创建节点。解析树可以被认为是“已匹配规则的记录”。Parboiled 将解析树节点的 value 字段值设置为节点构造时值栈的栈顶元素。因此产看解析树值对象可以为你提供解析器如何使用值栈的线索。</p>
<p>或许对解析树最有用的使用方式是使用 ParseTreeUtils 的 printNodeTree 来将其打印出来。</p>
<h3 id=在-java-中开启解析树构建>在 Java 中开启解析树构建</h3>
<p>可以在解析器实现类上添加 <code>@BuildParseTree</code> 注解来开启解析树构建。还可以在解析器方法上使用 <code>@SuppressNode</code>/<code>@SuppresssSubnodes</code>/<code>@SkipNode</code> 来对解析树进行微调。</p>
<h3 id=在-scala-中开启解析树构建>在 Scala 中开启解析树构建</h3>
<p>在 Scala 中，Parser 特质拥有一个 <code>buildParseTree</code> 标记方法，将其设置为 true 则可以开启解析树构建。最简单的方式是在解析器类的构造方法上调用 <code>.withParseTreeBuilding()</code> 方法。类似 Java API，可以使用 <code>Parser$RuleOption</code> 中的选项来对解析树的构建过程进行微调。</p>
<h2 id=ast-construction>AST Construction</h2>
<p>和解析树与语法之间的紧密关联关系相反，你想要构造的抽象语法树(AST)则完全取决于你的项目需要。这就是为什么 Parboiled 采用非常开放和灵活的方法来支持它。</p>
<p>事实上对 AST 节点的类型没有任何约束。Parboiled 没有提供任何不变或可变的对象来使用，因此也不会强制你使用什么。可以查看 <code>org.parboiled.trees</code> 包来开始。</p>
<p>通常你可以使用解析器值栈来作为构造 AST 的“工作台”。对于 Java API 可以参考 Calculators 示例，Scala API 可以参考 JSON Parser 示例。</p>
<h2 id=error-handling>Error Handling</h2>
<p>对非法输入的适当处理是任何要被应用到真实项目的解析器的关键特性，这也是正则比倒是的最大缺陷之一。比如，如果用户在自定义 DSL 中提供了输入，你可以清楚的知道其中的语法或语义错误。语义错误可以被更高级的应用程序捕获并报告，但是语法错误必须在解析器中直接被捕获并报告。Parboiled 通过提供 4 种不同的 ParseRunner 实现来支持你选择处理解析错误的方式。</p>
<h3 id=basicparserunner>BasicParseRunner</h3>
<p>这是最简单的实现。它不会执行任何错误处理，如果输入与指定的语法规则无效，则会简单的导致解析过程不匹配。这时，它的行为就像正则表达式引擎一样。它只执行一次解析，是确定指定输入是否符合解析器语法定义的最快方式。</p>
<h3 id=recordingparserunner>RecordingParseRunner</h3>
<p>比 BasicParseRunner 多一点特性：跟踪输入字符流中成功匹配的最远输入位置。如果给定的语法根规则不匹配，则紧随其后的位置必须是错误位置。和 BasicParseRunner 一样，仅执行一次解析运行。</p>
<h3 id=reportingparserunner>ReportingParseRunner</h3>
<p>不提供任何错误恢复功能，但是会在发现输入中的第一个匹配错误时报告错误。它在无错误输入上执行一次解析运行，但如果输入包含解析错误，则内部触发另外两次运行。在第二次运行期间，它会记录第一个解析错误的位置，并且在第三次运行期间，它会“监视”解析器尝试匹配错误字符时的行为，以便为用户创建有意义的错误消息。然后实例化一个 InvalidInputError 并将其添加到 ParsingResult 中返回的错误解析列表中。</p>
<h3 id=recoveringparserunner>RecoveringParseRunner</h3>
<p>这是 4 种 ParseRunner 实现中最复杂的一个，它提供了自动的、只能的错误恢复，并且即便是存在解析错误也能完整的解析整个输入文本。Parboiled 提供的这种策略与 ANTLR 类似。如果可能的话，Parboiled 会在识别到非法输入时尝试进行单字符删除、插入或替换。如果仍然失败，Parboiled 会在当前规则堆栈中找到合适的重新同步规则，并是由所有非法字符，知道解析器可以重新同步以继续解析为止。</p>
<h4 id=解析错误恢复细节>解析错误恢复细节</h4>
<p>类似于 ReportingParseRunner，RecoveringParseRunner 首先会尝试一次快速的基本运行以发现输入是否存在错误。如果整个输入没有任何错误则直接结束执行。</p>
<p>如果首次运行出现错误，RecoveringParseRunner 则会执行以下算法来尝试克服错误：</p>
<ol>
<li>首先执行一次“记录运行”以检测当前错误的位置。</li>
<li>然后执行一次“报告运行”，并将有意义的 InvalidInputError 添加到解析错误列表。</li>
<li>然后当前错误位置的字符会被临时性的删除，随后再次执行“记录运行”来发现下个错误的位置，以此类推。如果没有发现更多错误，则表示所有错误已被解决，然后直接结束解析。</li>
<li>在“报告运行”期间，运行器会收集所有在预期字符发生错误的规则并失败。对于所有这些规则，运行期会尝试插入临时性的“虚拟”字符到输入字符流，然后执行一次“记录运行”来检测下个错误的位置。如果这些插入的字符能够使得完整运行整个输入文本，则直接结束解析。</li>
<li>运行器尝试使用一个配件“虚拟”字符来替换错误字符(像上一步一些样)。如果这样能够使得错误得到解决则直接结束解析。</li>
<li>在这一步中，运行器知道没有单个字符恢复能够完全修复错误输入。但是它现在知道是否有一个动作(单个字符删除、插入、替换)允许解析器能够继续解析直到超出错误的位置。如果是这种情况，则可以通过单个字符恢复来克服错误，并且运行器应用允许解析器继续解析最远输入流的修复。因此，如果有可用的话，运行器总是选择最好的单字符修复。</li>
<li>如果没有单字符修复能够使得将下一个错误位置推送到当前错误位置之外，则会强制运行程序重新同步并重新执行“记录运行”以确定下一个错误的位置。为了做到这一点，运行器首先识别重新同步规则，该规则是作为序列并且已经匹配至少一个字符的第一个父规则。运行器确定运行哪些字符在合法解析中遵循此重新同步规则，并跳过所有不符合条件的字符。</li>
<li>既然最佳单字符修复或重新同步已经克服了当前的解析错误，则运行器继续解析到下一个错误并从步骤 1 开始从该错误中恢复。</li>
</ol>
<h3 id=动作设计的后果>动作设计的后果</h3>
<p>由于上述概述的解析错误恢复策略允许解析即使已存在错误，如果你决定使用 RecoveringParseRunner，解析器动作应该能够处理一些意外情况。</p>
<p>单字符修复通常不会对你的动作产生任何影响，因为解析器动作所能看到的匹配输入文本已经包含错误更正，即排除掉了非法字符，并且在错误恢复期间插入的虚拟字符也包含在其结果中。但是，通过重新同步进行错误恢复会导致不匹配的规则序列“神奇的”匹配，即使并非是所有序列子规则都匹配或甚至运行。由于这会抛弃预期的值栈设置，因此在重新同步期间，Parboiled 会在重新同步序列中执行所有低限度要求的解析器动作。所有这些动作都会看到空匹配，因此可以提供有意义的默认值。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-63d9481a39ef551c7e8a0cb56828ef77>7 - CH07-Java APIs</h1>
<p>Parboiled Java 的应用步骤：</p>
<ol>
<li>安装依赖。</li>
<li>确定要解析器值栈中要参数化的类型，继承 BaseParser 实现自定义解析类。</li>
<li>在该解析类中添加返回类型为 Rule 的规则方法。</li>
<li>通过 <code>Parboiled.createParser</code> 创建解析器实例。</li>
<li>调用解析器的根规则方法来创建规则树。</li>
<li>选择 ParseRunner 的特定实现，调用其 run 方法并传入根规则和输入文本。</li>
<li>查看 ParsingResult 对象的属性。</li>
</ol>
<h2 id=rule-construction>Rule Construction</h2>
<p>一个 PEG 由任意数量的规则组成，规则又可以由其他规则、终止符、或下表中的原语规则组成：</p>
<table>
<thead>
<tr>
<th style=text-align:left>Name</th>
<th style=text-align:center>Common Notation</th>
<th style=text-align:left>Primitive</th>
</tr>
</thead>
<tbody>
<tr>
<td style=text-align:left>Sequence</td>
<td style=text-align:center>a b</td>
<td style=text-align:left>Sequence(a, b)</td>
</tr>
<tr>
<td style=text-align:left>Ordered Choice</td>
<td style=text-align:center>a | b</td>
<td style=text-align:left>FisrtOf(a, b)</td>
</tr>
<tr>
<td style=text-align:left>Zero-Or-More</td>
<td style=text-align:center>a *</td>
<td style=text-align:left>ZeroOrMore(a)</td>
</tr>
<tr>
<td style=text-align:left>One-Or-More</td>
<td style=text-align:center>a +</td>
<td style=text-align:left>OneOrMore(a)</td>
</tr>
<tr>
<td style=text-align:left>Optional</td>
<td style=text-align:center>a ?</td>
<td style=text-align:left>Optional(a)</td>
</tr>
<tr>
<td style=text-align:left>And-Predicate</td>
<td style=text-align:center>& a</td>
<td style=text-align:left>Test(a)</td>
</tr>
<tr>
<td style=text-align:left>Non-Predicate</td>
<td style=text-align:center>! a</td>
<td style=text-align:left>TestNot(a)</td>
</tr>
</tbody>
</table>
<p>这些原语实际是 BaseParser 类的实例方法，即所有自定义解析器的必要父类。这些原语规则创建方法可以接收一个或多个 Object 参数，这些参数的类型可以是：</p>
<ul>
<li>一个 Rule 实例</li>
<li>一个字符字面量</li>
<li>一个字符串字面量</li>
<li>一个字符数组</li>
<li>一个动作表达式</li>
<li>实现了 Action 接口的类的实例</li>
</ul>
<p>除了以上原语方法，还有以下原语可供使用：</p>
<table>
<thead>
<tr>
<th style=text-align:left>Method/Field</th>
<th style=text-align:left>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style=text-align:left>ANY</td>
<td style=text-align:left>匹配任何除了 EOI 的单个字符</td>
</tr>
<tr>
<td style=text-align:left>NOTHING</td>
<td style=text-align:left>不匹配任何，总是失败</td>
</tr>
<tr>
<td style=text-align:left>EMPTY</td>
<td style=text-align:left>不匹配任何，总是成功</td>
</tr>
<tr>
<td style=text-align:left>EOI</td>
<td style=text-align:left>匹配特殊的 EOI 字符</td>
</tr>
<tr>
<td style=text-align:left>Ch(char)</td>
<td style=text-align:left>创建一个匹配单个字符的规则</td>
</tr>
<tr>
<td style=text-align:left>CharRange(char, char)</td>
<td style=text-align:left>匹配给定的字符范围</td>
</tr>
<tr>
<td style=text-align:left>AnyOf(string)</td>
<td style=text-align:left>匹配给定字符串中的任意字符</td>
</tr>
<tr>
<td style=text-align:left>NoneOf(string)</td>
<td style=text-align:left>不匹配给定字符串中的任意字符和 EOI</td>
</tr>
<tr>
<td style=text-align:left>IgnoreCase(char)</td>
<td style=text-align:left>匹配单个字符且忽略大小写</td>
</tr>
<tr>
<td style=text-align:left>IgnoreCase(String)</td>
<td style=text-align:left>匹配整个字符串且胡烈大小写</td>
</tr>
<tr>
<td style=text-align:left>String(string)</td>
<td style=text-align:left>创建一个匹配整个字符串的</td>
</tr>
</tbody>
</table>
<h2 id=parser-action-expressions>Parser Action Expressions</h2>
<p>Parboiled Java 的解析器可以在规则定义的任意位置包含解析器动作。这些动作可以分为 4 类。</p>
<h3 id=regular-objects-implementing-the-action-interface>“Regular” objects implementing the Action interface</h3>
<p>如果你的动作代码较多，则可以将其封装到一个实现了 Action 接口的自定义类中，然后再在规则定义方法中使用该自定义类的实例。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>MyParser</span> <span style=color:#204a87;font-weight:700>extends</span> <span style=color:#000>BaseParser</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>Object</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#000>Action</span> <span style=color:#000>myAction</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>MyActionClass</span><span style=color:#ce5c00;font-weight:700>();</span>

    <span style=color:#000>Rule</span> <span style=color:#000>MyRule</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span>
        <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>Sequence</span><span style=color:#ce5c00;font-weight:700>(</span>
            <span style=color:#ce5c00;font-weight:700>...,</span>
            <span style=color:#000>myAction</span><span style=color:#ce5c00;font-weight:700>,</span>
            <span style=color:#ce5c00;font-weight:700>...</span>
        <span style=color:#ce5c00;font-weight:700>);</span>
    <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>如果使用这种方式，你的自定义动作类也可以实现 SkippableAction 接口以告诉解析器引擎在执行内部的语法判定时是否跳过这些动作。</p>
<h3 id=anonymous-inner-classes-implementing-the-action-interface>Anonymous inner classes implementing the Action interface</h3>
<p>更多时候动作仅会包含少量的代码，这时可以直接使用匿名类：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>MyParser</span> <span style=color:#204a87;font-weight:700>extends</span> <span style=color:#000>BaseParser</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>Object</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#ce5c00;font-weight:700>{</span>

    <span style=color:#000>Rule</span> <span style=color:#000>MyRule</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span>
        <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>Sequence</span><span style=color:#ce5c00;font-weight:700>(</span>
            <span style=color:#ce5c00;font-weight:700>...,</span>
            <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>Action</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span>
                <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>boolean</span> <span style=color:#000>run</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>Context</span> <span style=color:#000>context</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
                    <span style=color:#ce5c00;font-weight:700>...;</span> <span style=color:#8f5902;font-style:italic>// arbitrary action code
</span><span style=color:#8f5902;font-style:italic></span>                    <span style=color:#204a87;font-weight:700>return</span> <span style=color:#204a87;font-weight:700>true</span><span style=color:#ce5c00;font-weight:700>;</span> <span style=color:#8f5902;font-style:italic>// could also return false to stop matching the Sequence and continue looking for other matching alternatives
</span><span style=color:#8f5902;font-style:italic></span>                <span style=color:#ce5c00;font-weight:700>}</span>
            <span style=color:#ce5c00;font-weight:700>},</span>
            <span style=color:#ce5c00;font-weight:700>...</span>
        <span style=color:#ce5c00;font-weight:700>);</span>
    <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><h3 id=explicit-action-expressions>Explicit action expressions</h3>
<p>虽然匿名类要比独立的动作类定义简单一点，但仍然显得冗余。可以继续简化为一个布尔表达式：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>MyParser</span> <span style=color:#204a87;font-weight:700>extends</span> <span style=color:#000>BaseParser</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>Object</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#ce5c00;font-weight:700>{</span>

    <span style=color:#000>Rule</span> <span style=color:#000>MyRule</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span>
        <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>Sequence</span><span style=color:#ce5c00;font-weight:700>(</span>
            <span style=color:#ce5c00;font-weight:700>...,</span>
            <span style=color:#000>ACTION</span><span style=color:#ce5c00;font-weight:700>(...),</span> <span style=color:#8f5902;font-style:italic>// the argument being the boolean expression to wrap
</span><span style=color:#8f5902;font-style:italic></span>            <span style=color:#ce5c00;font-weight:700>...</span>
        <span style=color:#ce5c00;font-weight:700>);</span>
    <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p><code>BaseParser.ACTION</code> 是一个特殊的标记方法，其告诉 Parboiled 将参数表达式封装到一个单独的、自动创建的动作类中，类似上面匿名类的例子。这样的动作表达式中可以包含对本地变量的访问代码或方法参数、读写非私有的解析器字段、调用非私有的解析器方法。</p>
<p>此外，如果动作表达式中调用实现了 ContextAware 接口的类对象方法，将自动在调用方法之前插入 setContext 方法。比如你想将所有的动作代码移出到解析器类之外以简化实现：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>MyParser</span> <span style=color:#204a87;font-weight:700>extends</span> <span style=color:#000>BaseParser</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>Object</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#000>MyActions</span> <span style=color:#000>actions</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>MyActions</span><span style=color:#ce5c00;font-weight:700>();</span>

    <span style=color:#000>Rule</span> <span style=color:#000>MyRule</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span>
        <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>Sequence</span><span style=color:#ce5c00;font-weight:700>(</span>
            <span style=color:#ce5c00;font-weight:700>...,</span>
            <span style=color:#000>ACTION</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>actions</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>someAction</span><span style=color:#ce5c00;font-weight:700>()),</span>
            <span style=color:#ce5c00;font-weight:700>...</span>
        <span style=color:#ce5c00;font-weight:700>);</span>
    <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>如果 MyActions 实现了 ContextAware 接口，Parboiled 将会自动在内部转换为类似下列清单的代码：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>MyParser</span> <span style=color:#204a87;font-weight:700>extends</span> <span style=color:#000>BaseParser</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>Object</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#000>MyActions</span> <span style=color:#000>actions</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>MyActions</span><span style=color:#ce5c00;font-weight:700>();</span>

    <span style=color:#000>Rule</span> <span style=color:#000>MyRule</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span>
        <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>Sequence</span><span style=color:#ce5c00;font-weight:700>(</span>
            <span style=color:#ce5c00;font-weight:700>...,</span>
            <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>Action</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span>
                <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>boolean</span> <span style=color:#000>run</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>Context</span> <span style=color:#000>context</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
                    <span style=color:#000>actions</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>setContext</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>context</span><span style=color:#ce5c00;font-weight:700>);</span>
                    <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>actions</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>someAction</span><span style=color:#ce5c00;font-weight:700>();</span>
                <span style=color:#ce5c00;font-weight:700>}</span>
            <span style=color:#ce5c00;font-weight:700>},</span>
            <span style=color:#ce5c00;font-weight:700>...</span>
        <span style=color:#ce5c00;font-weight:700>);</span>
    <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>注意 BaseParser 已经继承了 BaseActions，其实现了 ContextAware 接口，所以解析器类中的所有动作方法可以通过 getContext 方法获得当前的上下文。</p>
<h3 id=implicit-action-expressions>Implicit action expressions</h3>
<p>大多数情况下，Parboiled 可以自动识别你的规则定义中哪些是动作表达式。比如下面的规则定义中包含了一个隐式的动作表达式：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#000>Rule</span> <span style=color:#000>Number</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>Sequence</span><span style=color:#ce5c00;font-weight:700>(</span>
        <span style=color:#000>OneOrMore</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>CharRange</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#4e9a06>&#39;0&#39;</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#4e9a06>&#39;9&#39;</span><span style=color:#ce5c00;font-weight:700>)),</span>
        <span style=color:#000>Math</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>random</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>&lt;</span> <span style=color:#000>0</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>5</span> <span style=color:#ce5c00;font-weight:700>?</span> <span style=color:#000>extractIntegerValue</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>match</span><span style=color:#ce5c00;font-weight:700>())</span> <span style=color:#ce5c00;font-weight:700>:</span> <span style=color:#000>someObj</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>doSomething</span><span style=color:#ce5c00;font-weight:700>()</span>
    <span style=color:#ce5c00;font-weight:700>);</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>Parboiled 的检测逻辑如下：</p>
<p>BaseParser 中所有的默认规则创建器方法都拥有通用的 Java Object 参数，Java 编译器会自动将原始布尔表达式的结果作为一个 Boolean 对象传递。这是通过在布尔动作表达式的代码之后隐式地插入对 Boolean.valueOf 的调用来实现的。Parboiled 会在你的规则方法字节码中查找这些调用然后将其当做隐式动作表达式来处理，如果其结果直接被用作规则创建方法的参数的话。也可以通过 <code>@ExplicitActionsOnly</code> 注解(定义在解析类或规则方法上)来关闭该功能。</p>
<h3 id=return-values>Return Values</h3>
<p>动作表达式均为布尔表达式。其返回值将影响对当前值的解析进度。如果动作表达式的结果为 false，解析将继续，就像替换动作表达式的假设解析规则失败一样。因此，你可以将动作表达式视作可以(匹配)成功或(匹配)失败的“规则”，具体则取决于其返回值。</p>
<h2 id=value-stack>Value Stack</h2>
<p>在任何特定的解析项目中，解析器动作都希望能够以某种方式来创建对应输入文本结构的自定义对象。Parboiled Java 提供了两种工具来在解析器规则中管理创建的自定义对象：</p>
<ul>
<li>值栈</li>
<li>动作变量</li>
</ul>
<p>值栈是一个简单的栈结构，作为一个临时存储为你的自定义对象提供服务。你的解析器动作可以将对象推到栈上、推出栈、推出再推入栈交换对象，等等。值栈的实现隐藏在 ValueStack 接口下面，其定义了操作值栈的一系列方法。</p>
<p>所有的解析器动作可以通过当前 context 的 getValueStack 来获得当前值栈。为了简化值栈操作的冗余，BaseActions 类(BaseParser)的父类提供了一些值栈操作的快捷方法，可以直接在解析器动作表达式中内联使用。</p>
<p>在解析器规则中使用值栈的方式通常有以下几种：</p>
<ul>
<li>匹配分隔符、空格或其他辅助结构的规则通常不会影响值栈。</li>
<li>较底层的规则会从匹配到的输入中创建基本对象并推到栈上。</li>
<li>调用一个或多个底层规则的高级别规则，会从栈上推出值对象，然后创建高级别的对象并重新推到栈上。</li>
<li>根规则作为最高级别的规则会创建自定义结构的根对象。</li>
</ul>
<p>大多时候，但一个规则被完整处理过后，最多会推一个对象到栈上(尽管在处理过程中会推多个对象到栈上)。那么你可以认为：如果规则匹配，一个规则会在栈上创建一个特定类型的对象，否则则不会影响栈。</p>
<h3 id=规则定义须知>规则定义须知</h3>
<p>一条重要的原则是一个规则总是应该确保其对值栈的操作是“稳定的行为”，而无论输入是什么。因此，如果一个规则将一个特定类型的值对象推到栈上，则其应该为所有可能的输入都推一个值到栈上。如果不然，那么引用该规则之外的规则时将无法在规则匹配之后会值栈的状态进行假设，这将使动作设计复杂化。以下讨论着眼于各种 PEG 原语以及在使用影响值栈的解析器操作时需要注意的事项。</p>
<h4 id=sequence-规则>Sequence 规则</h4>
<p>由于它们不提供任何可选组件，因此关于值栈操作，序列规则相当直接。它们的最终结果本质上是稳定的，仅包括所有子操作的串联。</p>
<h4 id=firstof-规则>FirstOf 规则</h4>
<p>FirstOf 规则提供了几种替代子规则匹配。为了向外部提供稳定的“输出”，重要的是所有替代方案都表现出兼容的值堆栈行为。考虑以下例子：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#000>Rule</span> <span style=color:#000>R</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>FirstOf</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>A</span><span style=color:#ce5c00;font-weight:700>(),</span> <span style=color:#000>B</span><span style=color:#ce5c00;font-weight:700>(),</span> <span style=color:#000>C</span><span style=color:#ce5c00;font-weight:700>());</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>如果子规则 A 将推一个对象到栈，则 B 和 C 也需要这样做。</p>
<h4 id=optional-规则>Optional 规则</h4>
<p>Optional 规则的子规则通常不应该在值栈中添加或删除对象。由于 Optional 规则始终会匹配成功，即使其子规则不匹配，对值栈上的对象数量的任何影响都将违反“稳定行为”的原则。但是，Optional 规则可以很好的转换值栈上的内容，而避免不稳定的行为。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#000>Rule</span> <span style=color:#000>R</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>Sequence</span><span style=color:#ce5c00;font-weight:700>(</span>
        <span style=color:#000>Number</span><span style=color:#ce5c00;font-weight:700>(),</span> <span style=color:#8f5902;font-style:italic>// number adds an Integer object to the stack
</span><span style=color:#8f5902;font-style:italic></span>        <span style=color:#000>Optional</span><span style=color:#ce5c00;font-weight:700>(</span>
            <span style=color:#4e9a06>&#39;+&#39;</span><span style=color:#ce5c00;font-weight:700>,</span>
            <span style=color:#000>Number</span><span style=color:#ce5c00;font-weight:700>(),</span> <span style=color:#8f5902;font-style:italic>// another Integer object on the stack
</span><span style=color:#8f5902;font-style:italic></span>            <span style=color:#000>push</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>pop</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>+</span> <span style=color:#000>pop</span><span style=color:#ce5c00;font-weight:700>())</span> <span style=color:#8f5902;font-style:italic>// pop two and repush one Integer
</span><span style=color:#8f5902;font-style:italic></span>        <span style=color:#ce5c00;font-weight:700>)</span>
    <span style=color:#ce5c00;font-weight:700>);</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>该规则的行为始终是稳定的，因为它总是会将一个值推送到栈上。</p>
<h4 id=zeroormoreoneormore-规则>ZeroOrMore/OneOrMore 规则</h4>
<p>与 Optional 规则类似，不能添加或删除值栈的元素，而可以修改值栈的元素内容。</p>
<h2 id=action-variables>Action Variables</h2>
<p>对值栈的操作需要一些设计素养，同时为了类型安全，值栈中仅能使用一个较为宽泛的通用类型，然后再在解析器动作使用使用强制类型转换，这会带来维护成本。为了提供更多的灵活性，提供了动作变量功能。</p>
<p>通常，一个规则方法会在规则的子结构中包含多个动作表达式，以协同的方式来构造出最终规则。在很多情况下如果能够通过一个通用的临时辅助变量来访问规则中所有的动作，则会大有帮助。考虑如下例子：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#000>Rule</span> <span style=color:#000>Verbatim</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#000>StringVar</span> <span style=color:#000>text</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>StringVar</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#4e9a06>&#34;&#34;</span><span style=color:#ce5c00;font-weight:700>);</span>
    <span style=color:#000>StringVar</span> <span style=color:#000>temp</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>StringVar</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#4e9a06>&#34;&#34;</span><span style=color:#ce5c00;font-weight:700>);</span>
        <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>Sequence</span><span style=color:#ce5c00;font-weight:700>(</span>
            <span style=color:#000>OneOrMore</span><span style=color:#ce5c00;font-weight:700>(</span>
                <span style=color:#000>ZeroOrMore</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>BlankLine</span><span style=color:#ce5c00;font-weight:700>(),</span> <span style=color:#000>temp</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>append</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#4e9a06>&#34;\n&#34;</span><span style=color:#ce5c00;font-weight:700>)),</span>
                <span style=color:#000>NonblankIndentedLine</span><span style=color:#ce5c00;font-weight:700>(),</span> <span style=color:#000>text</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>append</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>temp</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>getAndSet</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#4e9a06>&#34;&#34;</span><span style=color:#ce5c00;font-weight:700>),</span> <span style=color:#000>pop</span><span style=color:#ce5c00;font-weight:700>().</span><span style=color:#c4a000>getText</span><span style=color:#ce5c00;font-weight:700>())</span>
            <span style=color:#ce5c00;font-weight:700>),</span>
            <span style=color:#000>push</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>VerbatimNode</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>text</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>get</span><span style=color:#ce5c00;font-weight:700>()))</span>
        <span style=color:#ce5c00;font-weight:700>);</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>该规则用于解析 Markdown 的逐行结构，其中包含一行或多行的缩进文本。这些缩进行可以通过完全的空行来拆分，如果其跟随的有最少一个缩进行则也可以被匹配。该规则的工作是创建一个 AST 节点并初始化为匹配到的文本(不带有行缩进)。</p>
<p>为了能够构建该 AST 节点的文本参数，如果能够访问一个字符串变量——作为构建字符串的临时容器，则会非常有帮助。在通常的 Java 方法中可以使用一个本地变量，然而，因为规则方法仅包含规则的构造代码而非规则实际运行的代码，因此本地变量起不了作用。因为本地变量仅能在规则的构造期间而非运行期间可见。</p>
<p>这就是为什么 Parboiled Java 提供了一个名为 Var 的类，它可以用作规则执行阶段的本地变量。Var 对象包装一个任意类型的值，可以拥有初始值，支持对值的读写，可以在嵌套规则方法之间传递。每轮规则调用(如规则匹配重试)都会接受到自己的 Var 域，因此递归规则中的动作也会像预期一样运行。此外，Var 类还定义了一系列简便的辅助方法来简化其在动作表达式中的应用过程。</p>
<p>如下所示：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#000>Rule</span> <span style=color:#000>A</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#000>Var</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>Integer</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>i</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>Var</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>Integer</span><span style=color:#ce5c00;font-weight:700>&gt;();</span>
    <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>Sequence</span><span style=color:#ce5c00;font-weight:700>(</span>
        <span style=color:#ce5c00;font-weight:700>...,</span>
        <span style=color:#000>i</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>set</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>42</span><span style=color:#ce5c00;font-weight:700>),</span>
        <span style=color:#000>B</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>i</span><span style=color:#ce5c00;font-weight:700>),</span>
        <span style=color:#000>action</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>i</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>get</span><span style=color:#ce5c00;font-weight:700>())</span>
    <span style=color:#ce5c00;font-weight:700>);</span>
<span style=color:#ce5c00;font-weight:700>}</span>

<span style=color:#000>Rule</span> <span style=color:#000>B</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>Var</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>Integer</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>i</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>Sequence</span><span style=color:#ce5c00;font-weight:700>(</span>
        <span style=color:#ce5c00;font-weight:700>...,</span>
        <span style=color:#000>i</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>set</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>26</span><span style=color:#ce5c00;font-weight:700>)</span>
    <span style=color:#ce5c00;font-weight:700>);</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>规则方法 A 传递一个其域内定义的 Var 作为参数到规则方法 B，规则方法 B 内的动作向该 Var 写入一个新值，规则方法 A 中所有运行在 B 之后的动作都能看到该新写入的 Var 的值。上面的例子中，A 中的 action 读取 Var 值时会得到 26。</p>
<h2 id=parser-extension>Parser Extension</h2>
<p>当你首次调用 <code>Parboiled.createParser</code> 来构造你的解析器实例时，Parboiled Java 会在内部运行解析器扩展逻辑来为你的解析器类增加所有可能的特殊功能。因为你定义的解析器类一定不是 private 和 final 的，因此可以被子类化。新创建的类与你原有的解析器类处于同一个包下，使用原有的类名并加上 <code>$$parboiled</code> 后缀。</p>
<p>自动穿件的解析器子类会覆写所有返回 Rule 实例的方法。这些覆写会在某个点将调用为派给父方法(即原始解析器类中的方法)，或者甚至完全重写而不会父类方法做任何调用。</p>
<p>以下规则方法扩展需要完全重写而不会对父方法执行委派调用：</p>
<ul>
<li>解析器动作表达式</li>
<li>动作变量</li>
</ul>
<p>以下规则方法扩展可以无需方法重写而应用，如果方法中没有上面列出的转换时也可以调用父方法：</p>
<ul>
<li>@Label</li>
<li>@Cache</li>
<li>@SuppressNode</li>
<li>@SuppressSubnodes</li>
<li>@SkipNode</li>
<li>@MemoMismatches</li>
</ul>
<p>通常你不必担心是否需要进行方法覆写的问题。然而在调试环节，当你需要在规则方法中添加断点以追踪执行过程时，如果你的规则方法被重写，则端点就无法没命中。因此，比如你需要调试一个带有隐式或显式动作表达式的规则方法时，需要临时将动作表达式改写为显式匿名内部 Action 类，来避免对该规则方法的完全重写。</p>
<p>解析器扩展逻辑不会触碰那些不返回 Rule 实例的方法则，而是直接保留。</p>
<h2 id=examples>Examples</h2>
<ul>
<li><a href=https://github.com/sirthias/parboiled/tree/master/examples-java/src/main/java/org/parboiled/examples/abc>ABC Grammar</a></li>
<li><a href=https://github.com/sirthias/parboiled/wiki/Calculators>Calculators</a></li>
<li><a href=https://github.com/sirthias/parboiled/wiki/Java-Parser>Java Parser</a></li>
<li><a href=https://github.com/sirthias/parboiled/wiki/Time-Parser>Time Parser</a></li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-e7fc3f9332a7db16b99b057d62a76d6f>8 - CH08-Scala APIs</h1>
<p>与 Java 的区别在于规则的构造过程，在 Scala 中使用了特殊的 Scala DSL 构造。相比 Java API，Scala API 更具优势：</p>
<ul>
<li>更加简明的规则构建 DSL(Scala 语言的丰富表现力)。</li>
<li>通过对值栈的进一步抽象隐藏了值栈，增加了类型安全性(Scala Type Inference)。</li>
<li>高阶规则构造。</li>
<li>更快的初次规则构建(不再有昂贵的解析器扩展步骤)。</li>
</ul>
<h2 id=rule-construction>Rule Construction</h2>
<p>一个 PEG 由任意数量的规则组成，规则又可以由其他规则、终止符、或下表中的原语规则组成：</p>
<table>
<thead>
<tr>
<th style=text-align:left>Name</th>
<th style=text-align:center>Common Notation</th>
<th style=text-align:left>Primitive</th>
</tr>
</thead>
<tbody>
<tr>
<td style=text-align:left>Sequence</td>
<td style=text-align:center>a b</td>
<td style=text-align:left>a ~ b</td>
</tr>
<tr>
<td style=text-align:left>Ordered Choice</td>
<td style=text-align:center>a | b</td>
<td style=text-align:left>a | b</td>
</tr>
<tr>
<td style=text-align:left>Zero-Or-More</td>
<td style=text-align:center>a *</td>
<td style=text-align:left>zeroOrMore(a)</td>
</tr>
<tr>
<td style=text-align:left>One-Or-More</td>
<td style=text-align:center>a +</td>
<td style=text-align:left>oneOrMore(a)</td>
</tr>
<tr>
<td style=text-align:left>Optional</td>
<td style=text-align:center>a ?</td>
<td style=text-align:left>optional(a)</td>
</tr>
<tr>
<td style=text-align:left>And-Predicate</td>
<td style=text-align:center>& a</td>
<td style=text-align:left>&(a)</td>
</tr>
<tr>
<td style=text-align:left>Non-Predicate</td>
<td style=text-align:center>! a</td>
<td style=text-align:left>!a</td>
</tr>
</tbody>
</table>
<p>除了以上原语方法，还有以下原语可供使用：</p>
<table>
<thead>
<tr>
<th style=text-align:left>Method/Field</th>
<th style=text-align:left>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style=text-align:left>ANY</td>
<td style=text-align:left>匹配任何除了 EOI 的单个字符</td>
</tr>
<tr>
<td style=text-align:left>NOTHING</td>
<td style=text-align:left>不匹配任何，总是失败</td>
</tr>
<tr>
<td style=text-align:left>EMPTY</td>
<td style=text-align:left>不匹配任何，总是成功</td>
</tr>
<tr>
<td style=text-align:left>EOI</td>
<td style=text-align:left>匹配特殊的 EOI 字符</td>
</tr>
<tr>
<td style=text-align:left>ch(Char)</td>
<td style=text-align:left>创建一个匹配单个字符的规则</td>
</tr>
<tr>
<td style=text-align:left>{String} ~ {String}</td>
<td style=text-align:left>匹配给定的字符范围</td>
</tr>
<tr>
<td style=text-align:left>anyOf(String)</td>
<td style=text-align:left>匹配给定字符串中的任意字符</td>
</tr>
<tr>
<td style=text-align:left>ignoreCase(Char)</td>
<td style=text-align:left>匹配单个字符且忽略大小写</td>
</tr>
<tr>
<td style=text-align:left>ignoreCase(String)</td>
<td style=text-align:left>匹配整个字符串且胡烈大小写</td>
</tr>
<tr>
<td style=text-align:left>str(String)</td>
<td style=text-align:left>创建一个匹配整个字符串的</td>
</tr>
<tr>
<td style=text-align:left>nTimes(Int, Rule)</td>
<td style=text-align:left>创建一个匹配子规则 N 次的规则</td>
</tr>
</tbody>
</table>
<h2 id=parser-actions>Parser Actions</h2>
<p>在 Parboiled Java 中需要以布尔表达式的形式设置解析器动作，然后再被自动转换为解析器动作规则。没有进一步的动作类型来支持 Parboiled Java 对值栈操作元素数量进行区分。这意味着 Java 开发者不能依赖编译器来检测解析器动作对值栈操作的一致性(主要是元素数量)。因此在动作的设计期间需要更多对人的规范约束。</p>
<p>在 Parboiled Scala 中，Scala 的类型推断能力使得解析器动作支持比 Java 中更高级别的抽象。在 Scala 解析器动作中，无需对值栈进行操作，而是将其指定为函数。因此，它们不仅仅是简单的代码块，其本身就是类型。</p>
<p>根据规则中包含的解析器动作，规则的实际类型会发生变化。对值栈没有任何影响的规则类型为 Rule0。将类型为 A 的值对象推送到值栈的规则具有类型 <code>Rule1[A]</code>。导致类型分别为 A 和 B 的两个值对象被推送到值栈的规则类型为 <code>Rule2[A,B]</code>。导致类型为 Z 的一个值对象从堆栈中弹出的规则具有类型 <code>PopRule1[Z]</code>。目前共 15 种具体的规则类型。</p>
<p>这种稍微复杂的类结构允许 Scala 在规则类型中进行编码，以确定规则如何影响解析器值堆栈，并确保所有解析器操作正确地协同工作以生成解析器最终结果值。请注意，这不会对值对象的类型施加任何限制！</p>
<p>支持 3 种形式的解析器动作：</p>
<ol>
<li>动作操作符</li>
<li>push/test/run 方法</li>
<li>独立动作</li>
</ol>
<h3 id=action-operators>Action Operators</h3>
<p>共定义了 9 种动作操作符。每种都会链接一个动作函数到语法规则结构，但与它们的动作函数参数的类型和语义不同。下表是一个概览：</p>
<table>
<thead>
<tr>
<th style=text-align:left>Action Result</th>
<th style=text-align:left>Action Argument(String)</th>
<th>Action Argument(Value Object Pop)</th>
<th>Action Argument(Value Object Peek)</th>
<th>Action Argument(Char)</th>
<th>Action Argument(IndexRange)</th>
</tr>
</thead>
<tbody>
<tr>
<td style=text-align:left>Value Object</td>
<td style=text-align:left>~></td>
<td>~~></td>
<td>~~~></td>
<td>~:></td>
<td>~&#187;</td>
</tr>
<tr>
<td style=text-align:left>Boolean</td>
<td style=text-align:left>~?</td>
<td>~~?</td>
<td>~~~?</td>
<td></td>
<td></td>
</tr>
<tr>
<td style=text-align:left>Unit</td>
<td style=text-align:left>~%</td>
<td>~~%</td>
<td><code>~~~%</code></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>以单个 <code>~</code> 字符起始的操作符通常是解析器动作接收已匹配输入文本的方式。其参数是一个类型为 <code>String => ...</code> 的函数。该操作符内部会创建一个新的动作规则，在运行时，将与紧邻的规则匹配的输入文本作为参数传递给该函数。</p>
<p>以 <code>~~</code> 和 <code>~~~</code> 字符起始的操作符接收一个或多个值对象作为参数。</p>
<p>以 <code>></code> 字符结尾的操作符创建一个或多个新的值对象，在动作函数运行之后推送到值栈。这些动作结构值的类型会被编码到操作符的返回类型。</p>
<p>以 <code>?</code> 字符结尾的操作符接收一个返回布尔值的函数作为语义判定。如果动作函数返回 false 则停止当前规则序列的求值，即为匹配，然后强制解析器回退并查找其他匹配可能。</p>
<p>以 <code>%</code> 字符结尾的操作符支持你运行任意逻辑而不会对处理过程产生影响。其动作函数返回 Unit，一旦解析器经过，它们就会被运行。</p>
<h3 id=pushtestrun-方法>push/test/run 方法</h3>
<p>上述讨论的动作操作符均为将你的动作链接到当前的解析处理过程，要么是接收已匹配的输入文本作为参数，要么是生成新的栈值元素。但有时你的动作并不需要任何输入，因为其在规则结构中的位置就是其需要的所有上下文。这时你可以使用 push/test/run 方法来实现与上述讨论的操作符相同的功能，这些方法由 Parser 特质提供。</p>
<p>由这些方法构造的动作规则可以通过被链接在一起。如下所示：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=color:#204a87;font-weight:700>def</span> <span style=color:#000>JsonTrue</span> <span style=color:#204a87;font-weight:700>=</span> <span style=color:#000>rule</span> <span style=color:#ce5c00;font-weight:700>{</span> <span style=color:#4e9a06>&#34;true&#34;</span> <span style=color:#ce5c00;font-weight:700>~</span> <span style=color:#000>push</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>True</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><h3 id=独立动作>独立动作</h3>
<p>独立动作是以 Context 对象作为参数的独立函数。它们可以像普通规则一样被使用，因为 Parser 特质提供了以下两种隐式转换：</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Semantics</th>
</tr>
</thead>
<tbody>
<tr>
<td>toRunAction(f:(Context[Any]) => Unit):Rule0</td>
<td>通用非判断动作</td>
</tr>
<tr>
<td>toTestAction(f:(Context[Any]) => Boolean):Rule0</td>
<td>通用语义判定动作</td>
</tr>
</tbody>
</table>
<p>当前解析的 Context 为通用动作提供了对解析器的所有状态访问能力。它们可以通过 getValueStack 方法来修改解析器的值栈。但并不推荐这种用法，因为这将导致 Scala 编译器无法有效的验证值栈操作的一致性。</p>
<h3 id=withcontext-动作>“withContext” 动作</h3>
<p>Parser 特质提供的另一个便利的工具是 withContext 方法，通过该方法，你可以包装一个动作函数然后再将其传递给动作操作符。该方法支持你的动作函数除了其常规的参数之外还能接收当前解析器的 Context。</p>
<p>withContext 的签名类似如下定义：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=color:#204a87;font-weight:700>def</span> <span style=color:#000>withContext</span><span style=color:#ce5c00;font-weight:700>[</span><span style=color:#204a87;font-weight:700>A</span>, <span style=color:#204a87;font-weight:700>B</span>, <span style=color:#204a87;font-weight:700>R</span><span style=color:#ce5c00;font-weight:700>](</span><span style=color:#000>f</span><span style=color:#204a87;font-weight:700>:</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>A</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#204a87;font-weight:700>B</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>Context</span><span style=color:#ce5c00;font-weight:700>[</span><span style=color:#204a87;font-weight:700>_</span><span style=color:#ce5c00;font-weight:700>])</span> <span style=color:#204a87;font-weight:700>=&gt;</span> <span style=color:#000>R</span><span style=color:#ce5c00;font-weight:700>)</span><span style=color:#204a87;font-weight:700>:</span> <span style=color:#ce5c00;font-weight:700>((</span><span style=color:#204a87;font-weight:700>A</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#204a87;font-weight:700>B</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>=&gt;</span> <span style=color:#000>R</span><span style=color:#ce5c00;font-weight:700>)</span>
</code></pre></div><p>因此，被该方法包装的动作函数在外部会显示为一个函数，比如，弹出值栈的两个对象并生成一个新的值。但是，在内部你的动作同样也可以接受到当前上下文的实例，比如可以查看当前输入位置以及行号。</p>
<h2 id=parser-tesing>Parser Tesing</h2>
<p>从 0.9.9.0 开始提供了一个 ParboiledTest 特质来简化测试的开发工作。Parboiled 使用它来完成内部测试，你可以参考 <a href=https://github.com/sirthias/parboiled/blob/master/parboiled-scala/src/test/scala/org/parboiled/scala/WithContextTest.scala>WithContextTest</a> 来查看应用方式。</p>
<h2 id=examples>Examples</h2>
<ul>
<li><a href=https://github.com/sirthias/parboiled/wiki/Simple-Calculator>Simple Calculator</a></li>
<li><a href=https://github.com/sirthias/parboiled/wiki/JSON-Parser>JSON Parser</a></li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-d172300b36f276e75efe2961e9416e8d>9 - CH09-Advanced Topics</h1>
<ul>
<li><a href=https://github.com/sirthias/parboiled/wiki/Handling-Whitespace>Handling Whitespace</a></li>
<li><a href=https://github.com/sirthias/parboiled/wiki/Parsing-Performance-Tuning>Performance Tuning</a></li>
<li><a href=https://github.com/sirthias/parboiled/wiki/Indentation-Based-Grammars>Indentation Based Grammars</a></li>
<li><a href=https://github.com/sirthias/parboiled/wiki/The-ProfilingParseRunner>ProfilingParseRunner</a></li>
<li><a href=https://github.com/sirthias/parboiled/wiki/Grammar-and-Parser-Debugging>Debugging</a></li>
<li><a href=https://github.com/sirthias/parboiled/wiki/Thread-Safety>Thread Safety</a></li>
</ul>
</div>
</main>
</div>
</div>
<footer class="bg-dark py-5 row d-print-none">
<div class="container-fluid mx-sm-5">
<div class=row>
<div class="col-6 col-sm-4 text-xs-center order-sm-2">
</div>
<div class="col-6 col-sm-4 text-right text-xs-center order-sm-3">
<ul class="list-inline mb-0">
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Weibo aria-label=Weibo>
<a class=text-white target=_blank rel="noopener noreferrer" href=https://weibo.com/u/3848950217>
<i class="fab fa-weibo"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Twitter aria-label=Twitter>
<a class=text-white target=_blank rel="noopener noreferrer" href=https://twitter.com/zhange_zzg>
<i class="fab fa-twitter"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="Stack Overflow" aria-label="Stack Overflow">
<a class=text-white target=_blank rel="noopener noreferrer" href=https://stackoverflow.com>
<i class="fab fa-stack-overflow"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=GitHub aria-label=GitHub>
<a class=text-white target=_blank rel="noopener noreferrer" href=https://github.com/infilos/infilos.com>
<i class="fab fa-github"></i>
</a>
</li>
</ul>
</div>
<div class="col-12 col-sm-4 text-center py-2 order-sm-2">
<small class=text-white>&copy; 2021 infilos.com All Rights Reserved</small>
</div>
</div>
</div>
</footer>
</div>
<script src=/js/popper.min.js integrity=sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49 crossorigin=anonymous></script>
<script src=/js/bootstrap.min.js integrity=sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy crossorigin=anonymous></script>
<script src=/js/main.min.5c74b870c6953931a705f390a49c7e4c0a842ec5c83b24354758dd674343ed0d.js integrity="sha256-XHS4cMaVOTGnBfOQpJx+TAqELsXIOyQ1R1jdZ0ND7Q0=" crossorigin=anonymous></script>
</body>
</html>