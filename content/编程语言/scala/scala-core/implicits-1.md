---
type: docs
title: "Implicits-基础"
linkTitle: "Implicits-基础"
weight: 8
---

> 《Programming in Scala 3rd》- Implicit Conversions And Parameters

主要解决的问题是扩展已有的对象。

## 隐式转换

每个库对实质上相同的概念有其各自不同的编码方式，隐式转换用于减少两种类型之间的显式转换操作。

## 隐式-规则

这些隐式定义是编译器允许的、被用于插入到程序中以用来解决类型错误问题。

- 标记规则：只有那些被关键字`implicit`标记的定义
- 作用域规则：被插入的隐式转换在作用域中必须是一个**单独的**标示符，或者是在被转换对象的**伴生对象**中。必须直接引入该隐式定义，而不是拥有该定义的对象。比如需要`convert`，它属于一个对象`object`，只有直接通过`import object.convert`才有效。需要的隐式定义在伴生对象中时则不需要显式引入。
- 一次一个规则：只有一个隐式被插入。编译器永远不会将`x + y`重写为`convert1(convert2(x)) + y`。
- 显式优先规则：无论何时以代码编写的方式类型检查，都不会尝试隐式。编译器不会再去改变已经运行的代码。因此你可以随时使用显式定义替换隐式定义。

## 隐式转换到一个指定的类型

如果编译器看到一个 X，但是需要的是一个 Y，这时他会寻找隐式转换函数来将 X 转换为 Y。

## 隐式转换方法调用者

如果编译器看到如下代码`obj.toInt`，但是对象`obj`并不拥有`toInt`方法，这是会尝试查找拥有该方法的类型并尝试进行隐式转换。

## 与新类型互操作

