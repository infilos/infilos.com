---
type: docs
title: "CH04-线程基础-2"
linkTitle: "CH04-线程基础-2"
weight: 4
---

## Create Thread

- What happens when creating a Thread instance

```java
Thread thread = new Thread(){
    @Override
    public void run() {
        // code
    }
}; 
// at this point the thread is in NEW state, all you have a simple java object, 
// no actual thread is created

thread.start();
// when start() is invoked, at some unspecified point in the near future 
// the thread will go into RUNNABLE state, this means an actual thread will be created.  
// That can happen before start() returns.
```

- 通过 `new ` 创建线程时，你只是创建了一个 Thread 类的实例，该 Thread 实例的状态为 NEW。
- 通过 `thread.start()` 调用线程时，该 Thread 实例的状态将会在未来某个时刻变为 RUNNABLE，这表示 OS 级别的线程将被创建，这部分工作由 JVM 完成。

## 用户空间 & 内核空间

在操作系统中，内存通常会被分成用户空间（User space）与内核空间（Kernel space）这两个部分。当进程/线程运行在用户空间时就处于用户态，运行在内核空间时就处于内核态：

- 运行在内核态的程序可以访问用户空间和内核空间，或者说它可以访问计算机的任何资源，不受限制，为所欲为，例如协调 CPU 资源，分配内存资源，提供稳定的环境供应用程序运行等
- 而应用程序基本都是运行在用户态的，或者说用户态就是提供应用程序运行的空间。运行在用户态的程序只能访问用户空间

### **那为什么要区分用户态和内核态呢**？

早期操作系统是不区分用户态和内核态的，也就是说应用程序可以访问任意内存空间，如果程序不稳定常常会让系统崩溃，比如清除了操作系统的内存数据。为此大佬们设计出了一套规则：对于那些比较危险的操作需要切到内核态才能运行，比如 CPU、内存、设备等资源管理器程序就应该在内核态运行，否则安全性没有保证。

**用户态的程序不能随意操作内核地址空间，这样有效地防止了操作系统程序受到应用程序的侵害**。

那如果处于用户态的程序想要访问内核空间的话怎么办呢？就需要进行系统调用从用户态切换到内核态。

## 操作系统线程

### 在用户空间实现线程

在**早期**的操作系统中，所有的线程都是在用户空间下实现的，操作系统只能看到线程所属的进程，而不能看到线程。

<div align="center"> <img src="https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210429212415.png" style="display:block;width:50%;" alt="NAME" align=center /> </div>

从我们开发者的角度来理解用户级线程就是说：在这种模型下，我们需要自己定义线程的数据结构、创建、销毁、调度和维护等，这些线程运行在操作系统的某个进程内，然后操作系统直接对进程进行调度。

这种方式的好处一目了然，首先第一点，就是即使操作系统原生不支持线程，我们也可以通过库函数来支持线程；第二点，线程的调度只发生在用户态，避免了操作系统从内核态到用户态的转换开销。

当然缺点也很明显：由于操作系统看不见线程，不知道线程的存在，而 CPU 的时间片切换是以进程为维度的，所以如果进程中某个线程进行了耗时比较长的操作，那么由于用户空间中没有时钟中断机制，就会导致此进程中的其它线程因为得不到 CPU 资源而长时间的持续等待；另外，如果某个线程进行系统调用时比如缺页中断而导致了线程阻塞，此时操作系统也会阻塞住整个进程，即使这个进程中其它线程还在工作。

### 在内核空间中实现线程

所谓内核级线程就是运行在内核空间的线程， 直接由内核负责，只能由内核来完成线程的调度。

每个内核线程可以视为内核的一个分身，这样操作系统就有能力同时处理多件事情，**支持多线程的内核就叫做多线程内核**（Multi-Threads Kernel）。

从我们开发者的角度来理解内核级线程就是说：我们可以直接使用操作系统中已经内置好的线程，线程的创建、销毁、调度和维护等，都是直接由操作系统的内核来实现，我们只需要使用系统调用就好了，不需要像用户级线程那样自己设计线程调度等。

<div align="center"> <img src="https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210429212532.png" style="display:block;width:50%;" alt="NAME" align=center /> </div>

上图画的是 1：1 的线程模型，所谓线程模型，也就是用户线程和内核线程之间的关联方式，线程模型当然不止 1：1 这一种，下面我们来详细解释以下这三种多线程模型：

#### **1. 多对一线程模型**：

<div align="center"> <img src="https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210429212627.png" style="display:block;width:50%;" alt="NAME" align=center /> </div>

- 在多对一模型中，多个用户级线程映射到某一个内核线程上
- 线程管理由用户空间中的线程库处理，这非常有效
- 但是，如果进行了阻塞系统调用，那么即使其他用户线程能够继续，整个进程也会阻塞
- 由于单个内核线程只能在单个 CPU 上运行，因此多对一模型不允许在多个 CPU 之间拆分单个进程

从并发性角度来总结下，虽然多对一模型允许开发人员创建任意多的用户线程，但是由于内核只能一次调度一个线程，所以并未增加并发性。现在已经几乎没有操作系统来使用这个模型了，因为它无法利用多个处理核。

#### **2. 一对一线程模型**：

<div align="center"> <img src="https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/88c73a25-6223-4b64-98cc-9284552ed1e1.png" style="display:block;width:50%;" alt="NAME" align=center /> </div>

- 一对一模型克服了多对一模型的问题
- 一对一模型创建一个单独的内核线程来处理每个用户线程
- 但是，管理一对一模型的开销更大，涉及更多开销和减慢系统速度
- 此模型的大多数实现都限制了可以创建的线程数

从并发性角度来总结下，虽然一对一模型提供了更大的并发性，但是开发人员应注意不要在应用程序内创建太多线程（有时系统可能会限制创建线程的数量），因为管理一对一模型的开销更大。

#### **3. 多对多线程模型**：

<div align="center"> <img src="https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210429212753.png" style="display:block;width:50%;" alt="NAME" align=center /> </div>

- 多对多模型将任意数量的用户线程复用到相同或更少数量的内核线程上，结合了一对一和多对一模型的最佳特性
- 用户对创建的线程数没有限制
- 阻止内核系统调用不会阻止整个进程
- 进程可以分布在多个处理器上
- 可以为各个进程分配可变数量的内核线程，具体取决于存在的 CPU 数量和其他因素

## Java Thread

在上面的模型介绍中，我们提到了通过线程库来创建、管理线程，那么什么是线程库呢？

**线程库就是为开发人员提供创建和管理线程的一套 API**。

当然，线程库不仅可以在用户空间中实现，还可以在内核空间中实现。前者涉及仅在用户空间内实现的 API 函数，没有内核支持。后者涉及系统调用，也就是说调用库中的一个 API 函数将会导致对内核的系统调用，并且需要具有线程库支持的内核。

下面简单介绍下三个主要的线程库：

1. POSIX Pthreads：可以作为用户或内核库提供，作为 POSIX 标准的扩展

2. Win32 线程：用于 Window 操作系统的内核级线程库

3. Java 线程：**Java 线程 API 通常采用宿主系统的线程库来实现**，也就是说在 Win 系统上，Java 线程 API 通常采用 Win API 来实现，在 UNIX 类系统上，采用 Pthread 来实现。

事实上，**在 JDK 1.2 之前**，Java 线程是基于称为 "绿色线程"（Green Threads）的用户级线程实现的，也就是说程序员大佬们为 JVM 开发了自己的一套线程库或者说线程管理机制。

而**在 JDK 1.2 及以后**，JVM 选择了更加稳定且方便使用的操作系统原生的内核级线程，通过系统调用，将线程的调度交给了操作系统内核。而对于不同的操作系统来说，它们本身的设计思路基本上是完全不一样的，因此它们各自对于线程的设计也存在种种差异，所以 JVM 中明确声明了：**虚拟机中的线程状态，不反应任何操作系统中的线程状态**。

也就是说，在 JDK 1.2 及之后的版本中，Java 的线程很大程度上依赖于操作系统采用什么样的线程模型，这点在不同的平台上没有办法达成一致，JVM 规范中也并未限定 Java 线程需要使用哪种线程模型来实现，可能是一对一，也可能是多对多或多对一。

总结来说，**现今 Java 中线程的本质，其实就是操作系统中的线程，其线程库和线程模型很大程度上依赖于操作系统（宿主系统）的具体实现，比如在 Windows 中 Java 就是基于 Wind32 线程库来管理线程，且 Windows 采用的是一对一的线程模型**。

## Java线程调度

线程调度是指系统为线程分配处理使用权的过程，调度主要方式有两种，分别是**协同式（Cooperative Threads-Scheduling）线程调度**和**抢占式（Preemptive Threads-Scheduling）线程调度**。

- **协同式线程调度**：线程的执行时间由线程本身来控制，线程把自己的工作执行完了之后，要主动通知系统切换到另外一个线程上去。
  **优点**：实现简单，切换操作对线程自己是可知的，所以一般没有什么线程同步问题。
  **缺点**：线程执行时间不可控制，甚至如果一个线程的代码编写有问题，一直不告知系统进行线程切换，那么程序就会一直阻塞在那里。
- **抢占式线程调度**：每个线程将由系统来分配执行时间，线程的切换不由线程本身来决定。
  **优点**：可以主动让出执行时间（例如Java的`Thread::yield()`方法），并且线程的执行时间是系统可控的，也不会有一个线程导致整个系统阻塞的问题。
  **缺点**：无法主动获取执行时间。

Java使用的就是抢占式线程调度，虽然这种方式的线程调度是系统自己的完成的，但是我们可以给操作系统一些建议，就是通过设置线程优先级来实现。Java语言一共设置了10个级别的线程优先级。在两个线程同时处于Ready状态时，优先级越高的线程越容易被系统选择执行。

> **不过由于各个系统的提供的优先级数量不一致，所以导致Java提供的10个级别的线程优先级并不见得能与各系统的优先级都一一对应**。

### Java 线程状态转换

Java语言定义了6种线程状态，在任意一个时间点钟，一个线程只能有且只有其中的一种状态，并且可以通过特定的方法在不同状态之间切换。

- **新建（New）**：创建后尚未启动的线程处于这种状态。
- **运行（Runnable）**：包括操作系统线程状态中的Running和Ready，也就是处理此状态的线程有可能正在执行，也有可能正在等待着操作系统为它分配执行时间。
- **无限期等待（Waiting）**：处于这种状态的线程不会被分配处理器执行时间，它们要等待被其他线程显示唤醒。
  以下方法会让线程陷入无限期等待状态：
  **1**、没有设置Timeout参数的`Object::wait()`方法；
  **2**、没有设置Timeout参数的`Thread::join()`方法；
  **3**、`LockSupport::park()`方法。
- **限期等待（Timed Waiting）**：处于这种状态的线程也不会被分配处理器执行时间，不过无须等待被其他线程显式唤醒，在一定时间之后它们会由系统自动唤醒。
  以下方法会让线程进入限期等待状态：
  **1**、`Thread::sleep()`方法；
  **2**、设置了Timeout参数的`Object::wait()`方法；
  **3**、设置了Timeout参数的`Thread::join()`方法；
  **4**、`LockSupport::parkNanos()`方法；
  **5**、`LockSupport::parkUntil()`方法；
- **阻塞（Blocked）**：线程被阻塞了，“阻塞状态”与“等待状态”的区别是“阻塞状态”在等待着获取到一个排他锁，这个事件将在另外一个线程放弃这个锁的时候发生；而“等待状态”则是在等待一段时间 ，或者唤醒动作发生。在程序进入同步区域的时候，线程将进入这种状态。
- **结束（Terminated）**：已终止线程的线程状态，线程已经结束执行。

### Thread.sleep

如果执行了 Thread.sleep, 底层的执行流程:

1. JVM 调用底层 OS 的线程 API
2. 因为 JVM 采用关于内核线性一对一的线程模型, JVM 会要求操作系统在执行的时间内将线程的使用权归还给 CPU
3. 一旦休眠时间到期, OS 调度器将会通过中断来唤醒线程, 并为线性分配 CPU 时间片以恢复该线程的执行

这里的关键点是， JVM 层面的这个线程在休眠期间是完全无法被复用的。

- 但是一个 JVM 内部能够创建的线程数量是有限的的，创建过多则会引起 OOM。
  - java.lang.OutOfMemoryError : unable to create new native Thread
- JVM 中的每个线程都会带来昂贵的内存开销，它会附带一个线程栈。
- 太多的 JVM 线程将产生开销，因为上下文切换非常昂贵，而且它们共享有限的硬件资源。

- [How to Thread.sleep without blocking on the JVM | by Daniel Sebban | Medium](https://medium.com/@daniel.sebban/how-to-thread-sleep-without-blocking-on-the-jvm-3bc3fac08011)

