<!doctype html><html lang=zh class=no-js>
<head>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=generator content="Hugo 0.93.0">
<meta name=ROBOTS content="INDEX, FOLLOW">
<link rel=canonical type=text/html href=/%E4%BA%A4%E4%BA%92%E7%95%8C%E9%9D%A2/javafx/>
<link rel="shortcut icon" href=/favicons/favicon.ico>
<link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180>
<link rel=icon type=image/png href=/favicons/favicon-16x16.png sizes=16x16>
<link rel=icon type=image/png href=/favicons/favicon-32x32.png sizes=32x32>
<link rel=icon type=image/png href=/favicons/android-36x36.png sizes=36x36>
<link rel=icon type=image/png href=/favicons/android-48x48.png sizes=48x48>
<link rel=icon type=image/png href=/favicons/android-72x72.png sizes=72x72>
<link rel=icon type=image/png href=/favicons/android-96x96.png sizes=96x96>
<link rel=icon type=image/png href=/favicons/android-144x144.png sizes=144x144>
<link rel=icon type=image/png href=/favicons/android-192x192.png sizes=192x192>
<title>JavaFX | infilos.com</title><meta property="og:title" content="JavaFX">
<meta property="og:description" content="Infilos Wiki Website">
<meta property="og:type" content="website">
<meta property="og:url" content="/%E4%BA%A4%E4%BA%92%E7%95%8C%E9%9D%A2/javafx/"><meta property="og:site_name" content="infilos.com">
<meta itemprop=name content="JavaFX">
<meta itemprop=description content="Infilos Wiki Website"><meta name=twitter:card content="summary">
<meta name=twitter:title content="JavaFX">
<meta name=twitter:description content="Infilos Wiki Website">
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-123062585-1","auto"),ga("send","pageview"))</script>
<script async src=https://www.google-analytics.com/analytics.js></script>
<link rel=preload href=/scss/main.min.847464b684a6e89d7276700a5c500c17ab494dd1755b2654a7b27d8b59e3347e.css as=style>
<link href=/scss/main.min.847464b684a6e89d7276700a5c500c17ab494dd1755b2654a7b27d8b59e3347e.css rel=stylesheet integrity>
<script src=/js/jquery-3.5.1.min.js integrity="sha256-9/aliU8dGd2tb6OSsuzixeV4y/faTqgFtohetphbbj0=" crossorigin=anonymous></script>
</head><body class=td-section>
<header>
<nav class="js-navbar-scroll navbar navbar-expand-lg navbar-dark td-navbar">
<a class=navbar-brand href=/>
<span class=navbar-logo><svg id="Capa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 512 512" style="enable-background:new 0 0 512 512"><path style="fill:#ffc107" d="M432.384 143.616c-4.165-4.164-10.917-4.164-15.083.0l-60.352 60.352c-4.164 4.165-4.164 10.917.0 15.083 21.187 20.463 54.951 19.876 75.413-1.311 19.962-20.668 19.962-53.435.0-74.102L432.384 143.616z"/><path style="fill:#607d8b" d="M42.667 277.334c-5.891.003-10.669-4.771-10.672-10.662-.002-4.338 2.623-8.245 6.64-9.882l234.667-96c5.455-2.233 11.687.38 13.92 5.835s-.38 11.687-5.835 13.92l-234.667 96C45.433 277.069 44.056 277.337 42.667 277.334z"/><path style="fill:#546e7a" d="M391.552 56.448l-32-32C343.938 8.745 322.689-.059 300.544.0h-3.755c-46.082.024-83.432 37.374-83.456 83.456v3.755c-.053 22.138 8.75 43.377 24.448 58.987l32 32c4.165 4.164 10.917 4.164 15.083.0L391.531 71.531C395.701 67.372 395.71 60.62 391.552 56.448z"/><path style="fill:#607d8b" d="M160 469.334c-3.279.006-6.379-1.497-8.405-4.075L34.261 315.926c-3.635-4.636-2.823-11.341 1.813-14.976s11.341-2.823 14.976 1.813l117.333 149.333c3.629 4.641 2.809 11.344-1.832 14.973C164.681 468.533 162.375 469.329 160 469.334z"/><path style="fill:#455a64" d="M487.467 86.848l-3.669-3.648c-37.687-36.557-97.71-36.197-134.955.811l-51.413 51.413c-36.996 37.25-37.357 97.263-.811 134.955l3.584 3.669c1.7 2.457 4.671 3.706 7.616 3.2 2.831.005 5.548-1.115 7.552-3.115l172.181-172.181c4.189-4.143 4.226-10.896.083-15.085-.028-.028-.055-.056-.083-.083L487.467 86.848z"/><g><path style="fill:#ffc107" d="M501.333 192H480c-5.891.0-10.667-4.776-10.667-10.667s4.776-10.667 10.667-10.667h21.333c5.891.0 10.667 4.776 10.667 10.667S507.225 192 501.333 192z"/><path style="fill:#ffc107" d="M394.667 298.667c-5.891.0-10.667-4.776-10.667-10.667v-21.333c0-5.891 4.776-10.667 10.667-10.667 5.891.0 10.667 4.776 10.667 10.667V288C405.333 293.891 400.558 298.667 394.667 298.667z"/><path style="fill:#ffc107" d="M480 277.334c-2.831.005-5.548-1.115-7.552-3.115l-21.333-21.333c-4.093-4.237-3.975-10.99.262-15.083 4.134-3.993 10.687-3.993 14.821.0l21.333 21.333c4.159 4.172 4.148 10.926-.024 15.085C485.514 276.209 482.815 277.327 480 277.334z"/></g><g><path style="fill:#455a64" d="M266.667 448H96c-29.455.0-53.333 23.878-53.333 53.333.0 5.891 4.776 10.667 10.667 10.667h256c5.891.0 10.667-4.776 10.667-10.667C320 471.878 296.122 448 266.667 448z"/><circle style="fill:#455a64" cx="32" cy="288" r="32"/></g><g/><g/><g/><g/><g/><g/><g/><g/><g/><g/><g/><g/><g/><g/><g/></svg></span>
<span class=font-weight-bold>infilos.com</span>
</a>
<button class=navbar-toggler type=button data-toggle=collapse data-target=#navbarSupportedContent aria-controls=navbarSupportedContent aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span>
</button>
<div class="collapse navbar-collapse" id=navbarSupportedContent>
<ul class="navbar-nav mr-auto">
<li class=nav-item style=max-width:90px;min-width:10px>
<a class=nav-link href=/%e5%9f%ba%e7%a1%80%e7%9f%a5%e8%af%86>
<span>基础</span>
</a>
</li><li class=nav-item style=max-width:90px;min-width:10px>
<a class=nav-link href=/%e7%bc%96%e7%a8%8b%e8%af%ad%e8%a8%80>
<span>语言</span>
</a>
</li><li class=nav-item style=max-width:90px;min-width:10px>
<a class=nav-link href=/%e6%a1%86%e6%9e%b6%e4%b8%8e%e5%ba%93>
<span>框架库</span>
</a>
</li><li class="nav-item dropdown" style=max-width:90px;min-width:10px>
<a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>
分布式
<span>+</span>
</a>
<div class=dropdown-menu aria-labelledby=navbarDropdown>
<a class=dropdown-item href=/%e5%88%86%e5%b8%83%e5%bc%8f/base>基本构成</a>
</div></li><li class="nav-item dropdown" style=max-width:90px;min-width:10px>
<a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>
大数据
<span>+</span>
</a>
<div class=dropdown-menu aria-labelledby=navbarDropdown>
<a class=dropdown-item href=/%e5%ad%98%e5%82%a8%e7%b3%bb%e7%bb%9f>存储系统</a>
<a class=dropdown-item href=/%e6%9f%a5%e8%af%a2%e7%b3%bb%e7%bb%9f>查询系统</a>
<a class=dropdown-item href=/%e6%b6%88%e6%81%af%e7%b3%bb%e7%bb%9f>消息系统</a>
<a class=dropdown-item href=/%e5%a4%84%e7%90%86%e7%b3%bb%e7%bb%9f>处理系统</a>
<a class=dropdown-item href=/%e6%95%b0%e6%8d%ae%e6%b2%bb%e7%90%86>数据治理</a>
</div></li><li class="nav-item dropdown" style=max-width:90px;min-width:10px>
<a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>
中后台
<span>+</span>
</a>
<div class=dropdown-menu aria-labelledby=navbarDropdown>
<a class=dropdown-item href=/%e5%9f%ba%e7%a1%80%e8%ae%be%e6%96%bd>基础设施</a>
<a class=dropdown-item href=/%e7%94%a8%e6%88%b7%e7%b3%bb%e7%bb%9f>用户系统</a>
<a class=dropdown-item href=/%e4%ba%a4%e4%ba%92%e7%95%8c%e9%9d%a2>交互界面</a>
<a class=dropdown-item href=/%e4%b8%9a%e5%8a%a1%e7%b3%bb%e7%bb%9f>业务系统</a>
</div></li><li class=nav-item style=max-width:90px;min-width:10px>
<a class=nav-link href=/%e6%a8%a1%e5%bc%8f%e6%9e%b6%e6%9e%84>
<span>模式架构</span>
</a>
</li><li class=nav-item style=max-width:90px;min-width:10px>
<a class=nav-link href=/%e9%9d%a2%e8%af%95%e9%97%ae%e7%ad%94>
<span>面试</span>
</a>
</li><li class=nav-item style=max-width:90px;min-width:10px>
<a class=nav-link href=/%e7%ae%a1%e7%90%86%e8%b7%af%e5%be%84>
<span>管理</span>
</a>
</li><li class=nav-item style=max-width:90px;min-width:10px>
<a class=nav-link href=/%e5%bc%80%e6%ba%90%e9%a1%b9%e7%9b%ae>
<span>开源</span>
</a>
</li></ul><div class="form-inline my-2 my-lg-0">
<div class="nav-item nav-search-item my-2 my-md-0">
<input type=search class="form-control td-search-input" placeholder="&#xf002; 站内搜索…" aria-label=站内搜索… autocomplete=off>
</div></div></div></nav></header><div class="container-fluid td-outer">
<div class=td-main>
<div class="row flex-xl-nowrap">
<div class="col-12 col-md-3 col-xl-2 td-sidebar d-print-none">
</div><div class="d-none d-xl-block col-xl-2 td-toc d-print-none">
</div><main class="col-12 col-md-9 col-xl-8 pl-md-5" role=main>
<div class=td-content>
<div class="pageinfo pageinfo-primary d-print-none">
<p>
这是本节的多页打印视图。
<a href=# onclick="return print(),!1">点击此处打印</a>.
</p><p>
<a href=/%E4%BA%A4%E4%BA%92%E7%95%8C%E9%9D%A2/javafx/>返回本页常规视图</a>.
</p></div><h1 class=title>JavaFX</h1><ul>
<li>1: <a href=#pg-b2022453167049de2580cb00839ceaed>JavaFX Layouts</a></li><li>2: <a href=#pg-22d0f29a97996f46e50502f41d01ad55>JavaFX Property</a></li><li>3: <a href=#pg-a0e53fb9906b7763988ff54dd605d01c>JavaFX Style</a></li><li>4: <a href=#pg-fce106ddb364c8ae9b64694691856820>JavaFX Controls</a></li><li>5: <a href=#pg-45c994056032155f1ebd23912c264fad>JavaFX Responsive</a></li><li>6: <a href=#pg-797aff4628595fd753e4ed089cd367ee>JavaFX TextEditor</a></li><li>7: <a href=#pg-c263bc76c47fbb2735368cb2edc4fa39>JavaFX Background Task</a></li><li>8: <a href=#pg-26f1809d0d5390ebf89ec905900adc91>JavaFX Animation</a></li><li>9: <a href=#pg-4cd4932cb513a79c2df43f9277cae639>JavaFX Events</a></li><li>10: <a href=#pg-864673981e258e7289b86932d5faef7a>JavaFX Refresh Scene</a></li><li>11: <a href=#pg-ee893caf1b181c2909a7c40d7ab77034>JavaFX TableView</a></li><li>12: <a href=#pg-203d5f4dd417e90a6499e21e20a9d4a7>JavaFX REST</a></li><li>13: <a href=#pg-1fea95547b38c395f5d9e92ec678383f>JavaFX New Window</a></li><li>14: <a href=#pg-e64814d30f4670330429afd9eba6dfa1>JavaFX Button Events</a></li><li>15: <a href=#pg-f6c3a53134930f7864e254234f51fe7c>JavaFX Canvas Vs Pane</a></li><li>16: <a href=#pg-39db9bdf39735c82f0d6b4d47a7fbd74>JavaFX GridPane Nodes</a></li><li>17: <a href=#pg-4af80e84aed274d41b7c5e0539fec8dc>JavaFX Triangles</a></li><li>18: <a href=#pg-17d441f58268bc383a6a3c296869f31c>JavaFX Canvas</a></li><li>19: <a href=#pg-660583bfd25d6d5bd13d23ebb178db6c>JavaFX Charts</a></li><li>20: <a href=#pg-b4a90c934c24c035a7c7b4536e3f2349>JavaFX Drag Shapes</a></li><li>21: <a href=#pg-db615bb8772bfa6841d04dadd992834c>JavaFX TableView Filter</a></li><li>22: <a href=#pg-bee837053f49f2fe262b61d70aa02ff8>JavaFX TableView Style</a></li><li>23: <a href=#pg-93e6b2f1c871911602629a05f6905f09>JavaFX TableView SVG</a></li><li>24: <a href=#pg-53c4686a2deb1ed93e30dba57b5e06ea>JavaFX All Buttons</a></li></ul><div class=content>
</div></div><div class=td-content>
<h1 id=pg-b2022453167049de2580cb00839ceaed>1 - JavaFX Layouts</h1><div class="pageinfo pageinfo-primary">
<p><a href=https://edencoding.com/javafx-layouts/>How to use JavaFX Layouts</a></p></div><p>JavaFX 中的布局容器提供了各种内置功能，用于设置组件节点的位置、大小、对齐。</p><p><strong>一共提供了 9 种默认的布局容器，包括基类 <code>Pane</code>，该类仅用于设置位置。</strong></p><ul>
<li>Pane</li><li>AnchorPane</li><li>BorderPane</li><li>GridPane</li><li>StackPane</li><li>TilePane</li><li>HBox</li><li>VBox</li></ul><p><strong>另外一些布局容器用于支持用户控制查看节点的视窗，而非布局：</strong></p><ul>
<li>ScrollPane：支持滚动或平移窗格。</li><li>TabPane：通过选择 Tab 来查看不同的窗格。</li><li>SplitPane：通过移动分隔符来改变两个可见窗格的比例。</li></ul><p><strong>布局的选择取决于两个关键因素：</strong></p><ul>
<li>你想要你的节点所处的位置(布局类型)</li><li>布局的方式将控制其子元素的位置、大小和对齐方式</li></ul><p><strong>选择布局之后，基于布局功能设置节点的位置、大小、对齐。</strong></p><h2 id=布局类型>布局类型</h2><p>可以将布局分为 3 个大类：块(block)、网格(grid)、行列(row/column)。</p><div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20220110165957.png style=display:block;width:80% alt=20220110165957 align=center> </div><h3 id=block-布局>Block 布局</h3><p>块布局是最简单的，只有一组规则来定义其子元素的布局。我称它们为“块”布局，因为它们不会将节点划分为网格(网格布局)或行列(行/列布局)。</p><p>也就是说，从布局逻辑的角度来看，窗格是单个块。</p><div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20220110170129.png style=display:block;width:80% alt=20220110170129 align=center> </div><ul>
<li>StackPane：节点位置的设置由 <strong>对齐</strong> 设置来控制。</li><li>AnchorPane：阶段位置的设置由 ”绝对位置“ 设置来控制。
<ul>
<li>绝对位置表示可以同时控制位置和大小，StackPane 则仅能控制位置。</li></ul></li></ul><h3 id=grid-布局>Grid 布局</h3><p>网格布局是最复杂的，可以非常详细地控制节点的位置。</p><div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20220110170401.png style=display:block;width:60% alt=20220110170401 align=center> </div><ul>
<li>TilePane：最简单，但也提供了最少的控制能力。</li><li>BorderPane：支持对定位的粗略控制，但在默认情况下也保证了确定行为。这对于默认窗口行为用例来说是一个很好的平衡。</li><li>GridPane：支持非常精细的控制节点位置，但使用起来可能很困难和复杂。</li></ul><h3 id=rowcolumn-布局>Row/Column 布局</h3><p>以顺序方式排列节点，横向或纵向。</p><div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20220110170721.png style=display:block;width:60% alt=20220110170721 align=center> </div><p>其中每种布局都可以控制序列中节点之间的间距。对于 FlowPane，用户还可以在多行和多列设置中控制行或列之间的空间。</p><h2 id=选择布局>选择布局</h2><p><strong>基于控制子元素的方式来选择需要的布局。</strong></p><p>窗格用于以各种方式控制子元素的位置、大小和对齐。这将影响面板调整大小时它如何移动和调整节点的大小。</p><p>值得记住的是，窗口经常被用户调整大小，比你默认设定的的要小或大。</p><p>以下是各种布局如何控制子节点：</p><table>
<thead>
<tr>
<th style=text-align:left>Pane</th><th style=text-align:left>Layout Positions Children</th><th style=text-align:center>Resizes Children</th><th style=text-align:center>Aligns Children</th><th style=text-align:left><strong>Has sub-regions</strong></th><th style=text-align:left>Children can overlap</th></tr></thead><tbody>
<tr>
<td style=text-align:left>AnchorPane</td><td style=text-align:left>✔</td><td style=text-align:center>✔</td><td style=text-align:center></td><td style=text-align:left></td><td style=text-align:left>✔</td></tr><tr>
<td style=text-align:left>StackPane</td><td style=text-align:left></td><td style=text-align:center></td><td style=text-align:center>✔</td><td style=text-align:left></td><td style=text-align:left>✔</td></tr><tr>
<td style=text-align:left>BorderPane</td><td style=text-align:left>✔</td><td style=text-align:center>✔</td><td style=text-align:center>✔</td><td style=text-align:left>✔</td><td style=text-align:left></td></tr><tr>
<td style=text-align:left>GridPane</td><td style=text-align:left>✔</td><td style=text-align:center></td><td style=text-align:center>✔</td><td style=text-align:left>(virtual)</td><td style=text-align:left></td></tr><tr>
<td style=text-align:left>TilePane</td><td style=text-align:left>✔</td><td style=text-align:center></td><td style=text-align:center>✔</td><td style=text-align:left>(virtual)</td><td style=text-align:left></td></tr><tr>
<td style=text-align:left>FlowPane</td><td style=text-align:left>✔</td><td style=text-align:center></td><td style=text-align:center>✔</td><td style=text-align:left></td><td style=text-align:left></td></tr><tr>
<td style=text-align:left>HBox</td><td style=text-align:left>✔</td><td style=text-align:center>✔</td><td style=text-align:center>✔</td><td style=text-align:left></td><td style=text-align:left></td></tr><tr>
<td style=text-align:left>VBox</td><td style=text-align:left>✔</td><td style=text-align:center>✔</td><td style=text-align:center>✔</td><td style=text-align:left></td><td style=text-align:left></td></tr></tbody></table><p>使用布局的一个常见问题是试图调整控件的大小。如果你在调整控件的布局时遇到了麻烦，比如按钮，可以查看下拉菜单来修复它。</p><h2 id=深入布局>深入布局</h2><p><code>Pane</code> 类是所有布局的基类，不会对其子布局应用任何布局行为。因此，当您需要绝对定位一个节点，但又不希望有任何额外的调整大小行为或对齐时，Pane 就够用了。</p><p>每个布局窗格扩展了 Pane 类，并在窗格中定义的核心行为之上提供了附加的功能层。布局窗格没有任何魔法：<strong>它们通过根据一组特定于它们试图创建的布局的规则手动计算每个子节点的 layoutX 和 layoutty 属性来实现它们想要的布局行为。</strong></p><h2 id=anchorpane>AnchorPane</h2><ul>
<li>区域是一个单独的块，任何节点都可以在上面定位</li><li>在节点上设置的锚点将被应用，覆盖任何现有的最大或最小属性值</li><li>重叠节点从 observableelist 子节点的开始呈现到结束，这意味着在默认情况下，后添加的项最后呈现</li></ul><div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/AnchorPane-Animation.gif style=display:block;width:80% alt=AnchorPane-Animation align=center> </div><h3 id=应用方法>应用方法</h3><p>除了使用 layoutX 和 layoutY 进行绝对定位之外，AnchorPane 还有四个方法来定义它的子组件的布局。</p><ul>
<li><code>setTopAnchor(Double double)</code></li><li><code>setBottomAnchor(Double value)</code></li><li><code>setRightAnchor(Double value)</code></li><li><code>setLeftAnchor(Double value)</code></li></ul><p>这些方法定义了子元素的边缘相对于 AnchorPane 的指定边缘的绝对位置。</p><div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20220110172832.png style=display:block;width:80% alt=20220110172832 align=center> </div><p>这些方法可以同时用于设置位置和大小。</p><p>要更改重叠节点的呈现顺序，请使用 <code>getChildren()</code> 获取子节点列表，并更改顺序。</p><h3 id=设置位置>设置位置</h3><p>在一个节点上设置一个或两个锚点将会影响到根据 AnchorPane 的布局边界来定位该节点。</p><div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20220110173059.png style=display:block;width:80% alt=20220110173059 align=center> </div><p>将锚点设置为 0 将把节点的指定一侧粘到 AnchorPane 的同一侧。</p><p><strong>注意：锚设置方法接受双精度值，可能为负值，但可能没有您想象的效果。</strong></p><p>如果我尝试设置一个负的左锚，我可能期望节点看起来像是从 AnchorPane 的左边缘滑出。相反，AnchorPane 尝试调整自己的大小以适应节点。</p><p>如果是为上部的节点设置一个负锚点，看起来仍然像粘在面板的左边。而其他的节点看起来只是向右移动了。</p><div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20220110173405.png style=display:block;width:80% alt=20220110173405 align=center> </div><p>如果想要成功实现从一个 AnchorPane 的左边滑出的预期效果，你需要将滑动和剪切结合起来(sliding with clipping)。</p><h3 id=设置大小>设置大小</h3><p>在一个节点上设置三个锚，将会有拉伸两个相反的锚之间的节点的效果。</p><div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20220110173932.png style=display:block;width:80% alt=20220110173932 align=center> </div><p>这可能非常有用，因为它会覆盖节点上的任何最大或最小宽度或高度。通过使用所有四个锚点，可以在两个方向上拉伸节点。</p><h2 id=stackpane>StackPane</h2><p>StackPane 是一个简单的布局窗格，类似于 AnchorPane。这两个窗格都是相对简单的布局，支持呈现相互重叠的节点。但是，<strong>AnchorPane 专注于绝对定位，而 StackPane 专注于基于对齐的节点定位</strong>。</p><h3 id=应用方法-1>应用方法</h3><p>为了充分利用 StackPane，我通常先对对齐进行排序，然后再进行定位，所以在本例中，我将先进行对齐，然后再进行定位。</p><p>StackPane 也不会调整节点的大小。与锚窗格不同的是，锚窗格可以通过在子节点边界上强制绝对定位来拉伸节点，而 StackPane 专注于对齐，这意味着它不会调整任何节点的大小。</p><h3 id=设置对齐>设置对齐</h3><p>默认情况下，所有节点都在 StackPane 的中心对齐。</p><div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20220110174334.png style=display:block;width:80% alt=20220110174334 align=center> </div><p>要更改节点的默认对齐方式，需要在相关的 StackPane 上使用 <code>setAlignment(Pos value)</code>。</p><div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20220110174448.png style=display:block;width:80% alt=20220110174448 align=center> </div><p>为了使节点准确地位于您想要的位置，您可能需要使用 translateX 和 translateY 属性来修改对象的位置。事实上，当我开始使用 StackPanes 时，我经常将侦听器挂接到可以调整节点翻译属性的 StackPane 宽度上。</p><p><strong>停! 用边距(margin)代替。</strong></p><p>要调整节点位置，可以使用静态方法 <code>StackPane.setMargin(Node child, Insets insets)</code>，引用要对齐的节点和需要的对齐方式。</p><h3 id=设置位置-1>设置位置</h3><p>StackPane 不支持节点的绝对定位，任何 layoutX 和 layoutY 的值都会被 StackPane 忽略。通过逐个节点设置边距，或更改节点的 translateX 和 translateY 值，可以对节点的位置进行微调。</p><h4 id=margins边距>Margins：边距</h4><p>我认为使用 StackPane 最安全的方法是使用边距，而不是手动修改对象的 translate 属性。在本例中，您可以通过调用静态方法 <code>StackPane.setMargin(Node node, Insets margin)</code>，在每个节点周围手动创建一个透明的边距。</p><h4 id=手动修改>手动修改</h4><p>您可以使用 translateX 和 translateY 属性来调整子节点的位置。这对于添加或删除节点的动画或过渡特别有用。</p><p>这些可能非常有用，但请记住，它们是在计算完 StackPane 的布局边界之后应用的，所以带有修改的 translate 属性的节点可能会在 StackPane 的边界之外呈现。</p><p>注意：当一个 translate 属性被修改时，它将在所有对齐和插入之后被应用，所以在计算修改这些属性的数量时，请记住要考虑这些因素。</p><h2 id=borderpane>BorderPane</h2><p>BorderPane 被设计为具有固定高度的顶部和底部区域，以及固定宽度的左右区域。其效果是，随着 BorderPane 改变尺寸，中心的大小也会变化。</p><div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/BorderPaneExample.gif style=display:block;width:80% alt=BorderPaneExample align=center> </div><h3 id=应用方式>应用方式</h3><p>其应用方式包含三个部分：位置、大小、对齐。</p><h3 id=设置位置-2>设置位置</h3><p>与我们迄今为止看到的窗格不同，这些窗格使用 <code>getChildren()</code> 方法访问节点的子节点，这与 BorderPane 不兼容。</p><p>由于设计意图以特定的方式托管子节点，我们需要告诉 BorderPane 要将节点添加到哪个区域。在 BorderPane 中设置节点的五种方法是:</p><ul>
<li>Centre: <code>setCenter(Node node)</code></li><li>Left: <code>setLeft(Node node)</code></li><li>Right: <code>setRight(Node node)</code></li><li>Top: <code>setTop(Node node)</code></li><li>Bottom: <code>setBottom(Node node)</code></li></ul><p>在 BorderPane 的每个区域中只能存储一个节点，因此多次调用这些方法将删除原始节点，并用最近的赋值替换它。</p><h3 id=设置大小-1>设置大小</h3><p>BorderPane 的大小调整行为是它特别适合于标准窗口布局的原因之一。它的设计是为了适应固定高度但可变宽度的菜单栏和固定宽度但可变高度的导航窗口。</p><p>由于这种确切的设计意图，BorderPane 对节点大小的影响取决于节点在 BorderPane 中的位置。以下是关于 BorderPane 如何调整其子节点大小的细节:</p><h4 id=topbottom>Top、Bottom</h4><ul>
<li>Height：顶部和底部窗格中的节点固定在它们的首选高度。</li><li>Width：顶部和底部区域节点的宽度根据 BorderPane 的宽度在其可调整大小的范围内进行调整。
<ul>
<li>如果要求 BorderPane 缩小到顶部/底部节点的最小宽度以下，它们仍然忠实地以最小大小呈现。</li></ul></li></ul><h4 id=leftright>Left、Right</h4><ul>
<li>Height：左右区域节点的高度根据 BorderPane 的高度在其可调整大小的范围内进行调整。计算结果为 BorderPane 的高度减去顶部和底部区域的高度。
<ul>
<li>如果要求 BorderPane 缩小到左/右节点的最小高度以下，它们仍然忠实地以最小大小呈现。</li></ul></li><li>Width：左右窗格中的节点固定在它们的首选宽度上。</li></ul><h4 id=center>Center</h4><ul>
<li>Height：中心区域的宽度计算为 BorderPane 的宽度减去左右节点的首选宽度之和。</li><li>Width：中心区域的高度计算为边框窗格的高度减去顶部和底部节点的首选高度之和。</li></ul><p>如果要求 BorderPane 收缩到中心节点的最小高度或宽度以下，它仍将忠实地呈现在其最小大小。</p><h3 id=设置对齐-1>设置对齐</h3><p>在以下情况下，BorderPane 将在其区域的节点周围创建空间:</p><ul>
<li>BoderPane 的宽度大于顶部或底部节点的最大宽度。</li><li>BorderPane 的高度大于左右节点的最大高度。</li><li>中间剩余空间大于中心节点的最大尺寸。</li></ul><p>如果任何 BorderPane 区域的大小大于其包含节点的最大大小，默认情况下它将按照以下规则进行定位:</p><ul>
<li><strong>Top/Bottom/Left/Right</strong>：Top-Left 对齐。(记住，对于 Top 和 Bottom，区域的大小为 preheight，所以垂直对齐不会被注意到，左/右和水平对齐也是如此。</li><li><strong>Center</strong>：中心对齐。</li></ul><p>可以使用静态方法 <code>BorderPane.setAlignment(Node node, Pos alignment)</code> 设置 BorderPane 区域内任何节点的对齐方式。或者 FXML 文件中使用 <code>BorderPane.alignment="&lt;alignment>"</code>。</p><h2 id=gridpane>GridPane</h2><p>GridPane 布局为网格布局中的节点提供了最好的控制级别。这包括为对齐和调整大小设置特定于列和行属性的功能，以及特定于节点的跨行和跨列行为。</p><h3 id=应用方式-1>应用方式</h3><p>GridPane 是 JavaFX 最复杂的默认布局，有多层的位置和大小控制。</p><p>几乎所有这些都涉及到创建 RowConstraints 或 ColumnConstraints 对象。涉及的方法为：<code>getColumnConstraints().add(ColumnConstraints constraint)</code> 或 <code>getRowConstraints().add(RowConstraints constraint)</code>。</p><p>约束按添加到 GridPane 的顺序设置到列和行。向 GridPane 中添加空约束(如 <code>new ColumnConstraints()</code>)将产生不设置任何约束的效果。如果您想要跳过行或列，这是有用的。</p><h3 id=设置位置-3>设置位置</h3><p>在 GridPane 中定位内容可以通过四种方式实现：</p><ol>
<li>
<p>设置放置节点的单元格</p></li><li>
<p>更改列或行的大小</p></li><li>
<p>将节点设置为跨多个列或行</p></li><li>
<p>更改列和行之间的填充</p></li></ol><h4 id=1-设置放置节点的单元格>1. 设置放置节点的单元格</h4><p>在最粗糙的层次上，通过在网格中设置节点的位置来实现节点的定位。这可以通过同时设置行位置、列位置或两者来实现。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8f5902;font-style:italic>//set both positions simultaneously
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span><span style=color:#000>GridPane</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>setConstraints</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>myNode</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>0</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>1</span><span style=color:#ce5c00;font-weight:700>);</span>
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>//set column position
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span><span style=color:#000>GridPane</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>setColumnIndex</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>myNode</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>0</span><span style=color:#ce5c00;font-weight:700>);</span>
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>//set row position
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span><span style=color:#000>GridPane</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>setRowIndex</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>myNode</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>1</span><span style=color:#ce5c00;font-weight:700>);</span>
</span></span></code></pre></div><h4 id=2-更改列或行的大小>2. 更改列或行的大小</h4><p>默认情况下，列和行大小将根据内容的首选宽度和高度计算。可以通过创建 ColumnConstraints 和 RowConstraints 对象重写此行为，并将它们应用到 GridPane。</p><p>使用 RowConstraints 对象，可以使用 <code>setPrefHeight(Double value)</code> 指定行的高度为像素尺寸，或者使用<code>setPercentHeight(Double value)</code>指定的网格窗格总高度的百分比。</p><p>ColumnConstraints 对象也有类似的方法。</p><h4 id=3-将节点设置为跨多个列或行>3. 将节点设置为跨多个列或行</h4><p>可以通过指示 GridPane 将节点设置为跨多列或多行来更改节点在网格中的位置。</p><p>通过静态方法来设置：<code>GridPane.setRowSpan(Node child, Integer value)</code>、<code>GridPane.setColumnSpan(Node child, Integer value)</code>。</p><h4 id=4-更改列和行之间的填充>4. 更改列和行之间的填充</h4><p>最后，可以通过更改 GridPane 的行和列之间的填充来调整节点的位置。</p><p>GridPane 边缘的普通填充可以使用 <code>setHgap(double value)</code> 和 <code>setVgap(double value)</code>，其他地方则可以使用 <code>setPadding(Insets value)</code> 来设置。</p><h3 id=设置大小-2>设置大小</h3><p>可以通过多种方式成功地调整节点和列的大小。这两种方法都需要创建 RowConstraints 和 ColumnConstraints 对象。</p><ol>
<li>
<p>扩展行和列以填充未占用的空间</p></li><li>
<p>垂直和水平地将节点扩展到行或列中的可用空间</p></li></ol><p>默认情况下，GridPane 将以节点的首选大小容纳节点，并且不会将节点拉伸以填充列。它还将把所有列和行相等地展开到可用空间中，因此这对于调优位置行为很有用。</p><h4 id=1-扩展行和列以填充未占用的空间>1. 扩展行和列以填充未占用的空间</h4><p>可以通过创建一个 RowConstraints 对象并调用 <code>setVgrow(true)</code> 来指示一行填充任何未被占用的空间。</p><p>同样，可以通过创建 ColumnConstraints 对象并调用 <code>setHgrow(true)</code> 来指示列填充任何未占用的空间。</p><p>空间通过以下逻辑分布在行和列之间：</p><ul>
<li>总是在所有具有 <code>Priority.ALWAYS</code> 优先级的行或列之间均匀地分配空间。</li><li>如果没有列/行具有 <code>Priority.ALWAYS</code> 优先级。如果仍然存在剩余空间，则将剩余空间分配到带有 <code>Priority.SOMETIMES</code> 优先级的行或列之间。</li></ul><h4 id=2-垂直和水平地将节点扩展到行或列中的可用空间>2. 垂直和水平地将节点扩展到行或列中的可用空间</h4><p>通过创建一个 RowConstraints 对象(或修改一个现有的对象)，并调用 <code>setFillHeight (true)</code>，可以指示一行将所有节点垂直增长到未占用的空间。</p><p>同样以类似的方式，可以通过创建 ColumnConstraints 对象(或修改现有的对象)并调用 <code>setFillWidth (true)</code> 来指示列填充任何未被占用的水平空间。</p><h3 id=设置对齐-2>设置对齐</h3><p>最后，可以指示行内的节点垂直对齐(以及列内的节点水平对齐)。这些是使用 HPos 和 VPos 枚举设置的。</p><p>最后，可以通过创建 RowConstraints 对象(或修改现有对象)并调用 <code>setValignment (VPos value)</code> 来指示一行垂直对齐节点。</p><p>通过创建 ColumnConstraints 对象(或修改现有对象)并调用 <code>setHalignment (HPos value)</code>，可以指示列水平对齐节点。</p><h2 id=tilepane>TilePane</h2><p>TilePane 通过在一维中添加 tiles(节点在其中呈现的虚拟区域)，然后将 tiles 包装到其他行或列来计算其布局。tiles 在整个窗格中大小一致。</p><h3 id=应用方式-2>应用方式</h3><p>可以通过调整 tile 之间的填充或设置特定于节点的边距来改变 tile 中节点的位置、大小和对齐方式。</p><h3 id=设置位置-4>设置位置</h3><p>节点之间的距离可以通过设置包含节点的 TilePane 实例的 hgap 和 vgap 属性来调整。</p><div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20220110194524.png style=display:block;width:60% alt=20220110194524 align=center> </div><p>Tile 的大小也可以作为一种改变节点位置的方法，尽管用户应该知道这也会改变节点的大小(在其可调整大小的范围内)。</p><div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20220110194553.png style=display:block;width:60% alt=20220110194553 align=center> </div><p>Tile 的大小可以通过调用 <code>setPrefTileWidth(double value)</code> 和 <code>setPrefTileHeight(double value)</code> 来改变。这些大小不能保证，如果 TilePane 的大小减小到不能容纳这些瓷砖的程度，那么它们的大小就会减小。</p><h3 id=设置大小-3>设置大小</h3><p>与许多其他布局不同，TilePane 在默认情况下会尝试在其可调整大小范围内拉伸小于 tile 大小的 tile 实例。</p><p>如果 <code>tileprefWidth</code> 和 <code>tilePrefHeight</code> 属性小于节点的首选尺寸，它也会尝试在可调整大小的范围内缩小较大的节点。</p><h3 id=设置对齐-3>设置对齐</h3><p>如果默认的 tile 大小大于任何节点的最大大小，节点将根据它设置的对齐方式在 tile 中分布。</p><div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20220110194759.png style=display:block;width:60% alt=20220110194759 align=center> </div><p>使用静态方法 <code>TilePane.setAlignment(Pos value)</code> 在每个节点的基础上设置对齐。默认的对齐方式是 <code>Pos.CENTER</code>，但如果您使用静态方法 <code>TilePane.getAlignment(Node node)</code> 在没有显式设置的节点上，它将返回 null(对于其他窗格也是如此)。</p><h2 id=flowpane>FlowPane</h2><p>FlowPane 的设计是为了给你的布局一个响应式的感觉，改变行或列的长度，以适应流窗格本身的大小。对于外观相似但需要重新洗牌的物品来说，这是非常棒的。</p><h3 id=应用方式-3>应用方式</h3><p>默认情况下，FlowPane 会将节点填充到行中，然后在必要时生成额外的行。对于生成内容列而不是行的流窗格，创建一个流窗格并调用 <code>setOrientation(Orientation.VERTICAL)</code>。</p><p>流窗格不会尝试调整节点的大小，所以这里没有调整大小的部分。</p><h3 id=设置位置-5>设置位置</h3><p>因为 FlowPane 可以用来将项目打包成行或列，所以它在内部将它们称为“runs”。如果方向是水平的，则运行是水平的。如果它是垂直的，runs 就是垂直的。</p><p>FlowPanes 的基本规则是：在下一个节点超过最大允许长度之前尽可能长地运行一次，然后将该节点作为下一次运行的第一项。</p><p>你可以通过调用 <code>setMargin(Insets Insets)</code> 来设置 FlowPane 的边距，在内容周围创建一个空间，它不会试图填充节点。它使用 Insets 对象，该对象可以分别或同时指定顶部、底部、左侧和右侧的边距。</p><div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20220110195217.png style=display:block;width:80% alt=20220110195217 align=center> </div><p>您可以使用 <code>setAlignment(Pos value)</code> 来确定 FlowPane 将分配的剩余空间的位置。上面的图像显示了一个垂直的流窗格，对齐方式为 <code>Pos.TOP_LEFT</code>，这意味着空间分布在底部和右侧。</p><h4 id=run-的长度><strong>Run 的长度</strong></h4><p>您可以通过调用 <code>setPrefWrapLength(Double value)</code> 来控制 run 的长度，无论您设置的方向如何，它都可以工作。</p><div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20220110195347.png style=display:block;width:70% alt=20220110195347 align=center> </div><h4 id=垂直与水平间隙>垂直与水平间隙</h4><p>当设置间隙时，FlowPane 不区分方向，所以它们是绝对的。这意味着需要使用 <code>setVgap(Double value)</code> 设置垂直元素之间的间隙，使用 <code>setHgap(Double value)</code> 设置水平元素之间的间隙。</p><div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20220110195539.png style=display:block;width:70% alt=20220110195539 align=center> </div><p>如果您希望功能区分运行和运行中的项目，那么开始切换方向时可能会感到困惑。</p><h4 id=run-中元素的间隙>run 中元素的间隙</h4><p>对于水平 FlowPane(默认值)，使用 <code>setVgap()</code>，对于垂直流窗格，使用 <code>setHgap()</code>。</p><h4 id=run-之间的间隙>run 之间的间隙</h4><p>对于水平 FlowPane(默认值)，使用 <code>setHgap()</code>，对于垂直流窗格，使用 <code>setVgap()</code>。</p><h3 id=设置对齐-4>设置对齐</h3><p>如果 FlowPane 中包含不同大小的节点，则流窗格将运行以容纳该运行中的最大成员。这意味着如果它是一个垂直的流窗格，它将使运行足够宽的最宽成员。如果它是一个水平的 FlowPane，它将使运行足够高的最高成员。</p><p>令人沮丧的是，FlowPane 要求您分别设置列(垂直方向)和行(水平方向)的对齐方式。</p><ul>
<li><strong>水平 <code>FlowPane</code> 带有行:</strong> <code>setRowValignment(VPos value).</code> VPos 枚举值为 <code>TOP</code>, <code>BOTTOM</code>, <code>BASELINE</code> and <code>CENTER</code>。</li><li><strong>垂直 <code>FlowPane</code> 带有列:</strong> <code>setColumnHalignment(HPos value).</code> HPos 枚举值为 <code>LEFT</code>, <code>CENTER</code> and <code>RIGHT</code>。</li></ul><p>这是一个垂直方向的 FlowPane，使用 <code>HPos.LEFT</code> 设置列对齐。</p><div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20220110195952.png style=display:block;width:60% alt=20220110195952 align=center> </div><h2 id=hbox>HBox</h2><p>HBox 从左到右水平定位节点。可以设置节点大小和对齐首选项，而元素的顺序可以通过改变 ObservableList 子元素的顺序来改变。</p><h3 id=应用方式-4>应用方式</h3><p>与FlowPane不同，HBox 只有一组水平节点。然而，她们对孩子的体型有更多的控制权。</p><h3 id=设置位置-6>设置位置</h3><p>子节点的水平顺序是从左到右的，与 ObservableList 中项目的顺序相同。默认情况下，节点的顺序是添加子节点的顺序。</p><h3 id=设置大小-4>设置大小</h3><p>可以在水平方向和垂直方向上对 HBox 进行调整。</p><h4 id=垂直方向>垂直方向</h4><p>默认情况下，HBox 将垂直调整其子节点的最大允许高度(由 HBox 本身的高度及其最大高度属性限制)。这个功能可以通过调用 <code>setFillHeight(false)</code> 来关闭。</p><p>这是为 HBox 实例设置的，并将应用于该 HBox 中的所有节点。</p><h4 id=水平方向>水平方向</h4><p>节点可以请求按节点逐个调整大小，以填充任何额外的水平空间。</p><p>节点可以通过调用静态方法 <code>Hbox.setHgrow(Node node, Priority value)</code> 来请求填充 HBox 内部任何剩余的水平空间。</p><p>Priority 枚举值为 SOMETIMES、ALWAYS 和 NEVER 。空间的分布方式如下:</p><ul>
<li>总是在所有具有优先级的节点之间均匀分配空间。</li><li>如果没有节点具有优先级。如果总是有剩余空间，则在节点之间优先分配剩余空间。</li><li>根据 HBox 的对齐方式分配剩余空间。</li></ul><h3 id=设置对齐-5>设置对齐</h3><p>你可以通过调用 <code>setAlignment(Pos value)</code> 来设置 HBox 的对齐方式。</p><h2 id=vbox>VBox</h2><p>VBox 从上到下垂直地定位节点。我将简单介绍一下，但如果您想了解更详细的功能指南，可以参考 HBox 的部分，内部逻辑是相同的，但是是水平的而不是垂直的。</p><h3 id=应用方式-5>应用方式</h3><p>VBox 有一组垂直节点。就像 HBox 一样，比垂直的 FlowPane 对其子节点的大小有更多的控制。</p><h3 id=设置大小-5>设置大小</h3><p>可以水平和垂直地对VBox进行调整。</p><h4 id=水平设置>水平设置</h4><p>要停止 VBox 水平拉伸其子元素，使用 <code>setFillWidth(false)</code>。这是为 VBox 实例设置的，并将应用于该 VBox 中的所有节点。</p><h4 id=垂直设置>垂直设置</h4><p>通过通过方法 <code>Vbox.setHgrow(Node node, Priority value)</code> 请求节点伸展以适应 VBox 中任何剩余的垂直空间。空间的分布规则与 HBox 相同(但垂直分布……)</p><h3 id=设置对齐-6>设置对齐</h3><p>可以通过方法 <code>setAlignment(Pos value)</code> 设置对齐方式。</p><h2 id=总结>总结</h2><p>JavaFX 有 9 个预定义的容器，提供了定义图表、图像和控件等节点的位置、大小和对齐方式的功能。JavaFX 的布局可以实现各种各样的功能和位置控制。</p><p>有三种基本的布局类型：网格、行列和块。它们定义了布局“思考”节点定位的方式。先画出容器的草图，然后用它来决定你需要的布局类型，这通常是一个很好的开始。</p><p>一旦你选择了你想让你的面板看起来的基本方式(网格，行列或块)，我建议你选择你的布局基于他们如何响应被调整大小。除非你明确地将它们设置为固定大小，否则用户总是会发现一些漏洞，使窗口变得非常大(或非常小)。</p></div><div class=td-content style=page-break-before:always>
<h1 id=pg-22d0f29a97996f46e50502f41d01ad55>2 - JavaFX Property</h1><div class="pageinfo pageinfo-primary">
<p><a href=https://edencoding.com/javafx-properties-and-binding-a-complete-guide/#advanced>JavaFX Properties and Binding – A Complete Guide</a></p></div><p>使用 JavaFX 的好处之一是它对 Property 和 Binding 的强大而全面的支持。除此之外，Property 还允许你连接场景，这样当你修改它后面的数据时，视图就会自动更新。</p><p>属性是可写或只读的可观察对象。在 JavaFX 中有 30 种类型的 Property 对象，包括 StringProperty、SimpleListProperty 和 ReadOnlyObjectProperty。每个属性都包装了一个现有的 Java 对象，添加了监听和绑定的功能。</p><div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20220110230824.png style=display:block;width:80% alt=20220110230824 align=center> </div><p>以 <code>SimpleDoubleProperty</code> 为例，它集成了 JavaFX 中 binding、property 和 value 的各种重要的 package，每个 package 都增加了JavaFX 属性所展示的最终功能的一个方面。</p><p>除了属性功能之外，JavaFX 还通过 Binding 和 Expression 对象提供绑定值的功能。</p><p>Binding 是一种强制对象之间关系的机制，其中一个或多个可观察对象被用来更新另一个对象的值。Binding 可以是一个方向，也可以是两个方向，可以直接从属性(Fluent API)或使用 Bindings 实用程序类(Bindings API)创建。</p><p>如果需要额外的自定义或性能，也可以手动创建自定义绑定对象。这被称为低级 API。</p><h2 id=主要内容>主要内容</h2><p>Property 和 Binding 是一组接口和类，旨在大大简化开发人员的工作。也就是说，在 Bindings 类中有 61个 属性和 249 个方法，因此很难管理。</p><p>本文将介绍：</p><ul>
<li>什么是属性，哪些属性是可用的</li><li>如何观察一个属性值</li><li>什么是约束?</li><li>如何绑定属性</li><li>中间绑定技术(Fluent API 和 Bindings API)</li><li>高阶绑定技术(低级 API)</li></ul><p>JavaFX 早期的许多问题，比如当你改变某些东西时，场景不能自动更新，这是因为场景与属性的错误连接。JavaFX 场景旨在基于属性和事件进行更新。</p><p>如果您想加深对 JavaFX 如何工作的理解，也可以查看关于<a href=https://edencoding.com/javafx-events/>事件的全面指南</a>。这两篇文章结合起来将为 JavaFX 的后台工作提供一个真正坚实的基础。</p><h2 id=什么是-property>什么是 Property</h2><p>如果你像我一样，并且没有计算机科学背景，那么属性一开始似乎很吓人。不过，引擎盖下面并没有什么魔法。大多数 JavaFX Property 对象扩展了两个关键接口：<code>ReadOnlyProperty&lt;T></code> 和 <code>WriteableValue&lt;T></code>。</p><div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20220110231507.png style=display:block;width:80% alt=20220110231507 align=center> </div><p>Some of them don’t, though. JavaFX has 10 read-only properties, which extend <code>ReadOnlyProperty&lt;T></code>, but don’t extend <code>WriteableValue&lt;T></code>.</p><p>JavaFX 有 10 个只读属性，扩展了 <code>ReadOnlyProperty&lt;T></code>，但没有扩展 <code>WriteableValue&lt;T></code>。</p><h3 id=创建-property>创建 Property</h3><p>JavaFX 提供了十个内置类，使创建属性变得非常容易。它们实现了所有必需的功能，从监听到绑定。</p><ul>
<li>SimpleBooleanProperty</li><li>SimpleDoubleProperty</li><li>SimpleFloatProperty</li><li>SimpleIntegerProperty</li><li>SimpleListProperty</li><li>SimpleLongProperty</li><li>SimpleMapProperty</li><li>SimpleObjectProperty</li><li>SimpleSetProperty</li><li>SimpleStringProperty</li></ul><p>您可以定义任何简单的属性对象，可以带有或不带初始值。如果没有定义默认值，它们将默认为属性包装对象的默认值——0、false、 空字符串("")或一个空集合。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#000>SimpleIntegerProperty</span><span style=color:#ce5c00;font-weight:700>()</span>
</span></span><span style=display:flex><span><span style=color:#000>SimpleIntegerProperty</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>initialValue</span><span style=color:#ce5c00;font-weight:700>)</span>
</span></span></code></pre></div><p>它们也可以用一个名称和一个 JavaFX 称为属性“bean”的对象来创建。这并没有以任何方式封装属性，而是创建了一个符号链接到表示属性“所有者”的对象。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#000>SimpleIntegerProperty</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>Object</span> <span style=color:#000>bean</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>String</span> <span style=color:#000>name</span><span style=color:#ce5c00;font-weight:700>)</span>
</span></span><span style=display:flex><span><span style=color:#000>SimpleIntegerProperty</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>Object</span> <span style=color:#000>bean</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>String</span> <span style=color:#000>name</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>initialValue</span><span style=color:#ce5c00;font-weight:700>)</span>
</span></span></code></pre></div><p>参数 name 和 bean 都不会改变属性的行为，但它可以作为有用的查找方式。如果您将相同的侦听器附加到多个属性(特别是通过编程生成的属性)，那么这很有用。然后，一旦发生更改，您可以使用 bean 和 name 参数来检查刚刚更改的属性。</p><p>所有的 JavaFX 属性都有方法来实现以下功能：</p><ul>
<li>侦听对属性值的更改</li><li>将属性捆绑在一起(绑定)，以便它们自动更新</li><li>获取和设置(如果可写)属性值</li></ul><h3 id=如何观察属性>如何观察属性</h3><p>正如我们刚才从上面看到的，JavaFX Property 对象是不同实现接口的大杂烩。这在这里很重要，因为这意味着它们提供了两种侦听更改的方式：失效和更改。</p><div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20220110233407.png style=display:block;width:80% alt=20220110233407 align=center> </div><p><strong>失效侦听器</strong>：JavaFX 中的每个属性都扩展了 Observable 接口，这意味着它们都提供了注册侦听器的功能，当属性失效时，这些侦听器就会被触发。如果你不熟悉“invalidates”，它是一种将属性标记为潜在更改而不强制其重新计算属性值的方法。</p><p>对于具有复杂或昂贵计算的属性，这可能是一个有用的工具，但我发现它们使用得不如更改侦听器多。</p><p><strong>更改监听器</strong>：在此之上，JavaFX 属性扩展了 <code>ObservableValue&lt;T></code>，这意味着您可以注册监听器，该监听器只在对象实际更改时触发。与无效侦听器相比，我更经常使用这些侦听器。</p><p>更改侦听器允许我们听到更改，并提前提供可执行代码，这些代码将基于 Property 的新旧值执行。</p><h3 id=监听更改>监听更改</h3><p>您可以通过调用 <code>addListener()</code> 方法在属性上注册一个监听器，提供一个 <code>InvalidationListener</code>(不太常见)或 <code>ChangeListener</code>(更常见)。</p><p>要添加更改侦听器，我们可以通过实现 ChangeListener 接口来完整地定义它——这是一个具有一个方法：<code>changed()</code> 的函数接口。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#000>DoubleProperty</span> <span style=color:#000>altitude</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>SimpleDoubleProperty</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>35000</span><span style=color:#ce5c00;font-weight:700>);</span>
</span></span><span style=display:flex><span><span style=color:#000>ChangeListener</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>Number</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>changeListener</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>ChangeListener</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>Number</span><span style=color:#ce5c00;font-weight:700>&gt;()</span> <span style=color:#ce5c00;font-weight:700>{</span>
</span></span><span style=display:flex><span>        <span style=color:#5c35cc;font-weight:700>@Override</span>
</span></span><span style=display:flex><span>        <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>changed</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>ObservableValue</span><span style=color:#ce5c00;font-weight:700>&lt;?</span> <span style=color:#204a87;font-weight:700>extends</span> <span style=color:#000>Number</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>observable</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>Number</span> <span style=color:#000>oldValue</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>Number</span> <span style=color:#000>newValue</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
</span></span><span style=display:flex><span>            <span style=color:#204a87;font-weight:700>if</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>newValue</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>doubleValue</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>&lt;</span> <span style=color:#000>15000</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
</span></span><span style=display:flex><span>                <span style=color:#000>deployParachute</span><span style=color:#ce5c00;font-weight:700>();</span>
</span></span><span style=display:flex><span>            <span style=color:#ce5c00;font-weight:700>}</span>
</span></span><span style=display:flex><span>        <span style=color:#ce5c00;font-weight:700>}</span>
</span></span><span style=display:flex><span>    <span style=color:#ce5c00;font-weight:700>};</span>
</span></span><span style=display:flex><span><span style=color:#000>altitude</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>addListener</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>changeListener</span><span style=color:#ce5c00;font-weight:700>);</span>
</span></span></code></pre></div><p>所有的数值属性(double、float、int 和 long)都需要使用 Number 类型参数化的更改侦听器。当然，因为它们是一个功能性接口，我们也可以使用自 Java 8 以来的 lambdas 内联创建它们。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#000>altitude</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>addListener</span><span style=color:#ce5c00;font-weight:700>((</span><span style=color:#000>observable</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>oldValue</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>newValue</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>-&gt;</span> <span style=color:#ce5c00;font-weight:700>{</span>
</span></span><span style=display:flex><span>        <span style=color:#204a87;font-weight:700>if</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>newValue</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>doubleValue</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>&lt;</span> <span style=color:#000>15000</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
</span></span><span style=display:flex><span>            <span style=color:#000>deployParachute</span><span style=color:#ce5c00;font-weight:700>();</span>
</span></span><span style=display:flex><span>        <span style=color:#ce5c00;font-weight:700>}</span>
</span></span><span style=display:flex><span><span style=color:#ce5c00;font-weight:700>});</span>
</span></span></code></pre></div><p>每当属性的值更改时，更改侦听器将触发一次。</p><h2 id=什么是-binding>什么是 Binding</h2><p>Binding 是一种将对象连接在一起的方法，强制执行一个对象至少依赖另一个对象的关系。属性本身可以本机绑定，也可以通过创建 Expression 和 Binding 对象来绑定。</p><p>Expression 和 Binding 都是可观察对象，它们也依赖于至少一个其他可观察对象的值(但可能更多)。这使您能够创建具有多个计算的表达式链：一种将字符串或数字转换组合在一起的超简单方法。</p><p>Expression 和 Binding 在本文的中级和高级部分中。现在，我们只将两个属性绑定在一起，而不需要任何额外的类。</p><h3 id=如何绑定属性>如何绑定属性</h3><p>在幕后，绑定是侦听更改的特定用例。所有 JavaFX 的绑定 api 都有样板代码，用来监听(至少)一个属性的更改，并使用任何更改来更新该绑定的值。</p><p>更改侦听器让我们提前提供可执行代码，而绑定让我们方便地将两个属性串在一起，而不必担心实现更新特定值的问题。</p><p>最简单和最常用的方法是附加到 Property 对象本身的方法：<code>bind()</code> 和 <code>bindBidirectional()</code>。它们代表了单向和双向绑定的最简单的选项。</p><h3 id=单向绑定>单向绑定</h3><p>当您在目标属性上调用 <code>bind()</code> 方法时，您将第二个属性作为参数传递给它——绑定源。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#000>StringProperty</span> <span style=color:#000>sourceProperty</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>SimpleStringProperty</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#4e9a06>&#34;First Value&#34;</span><span style=color:#ce5c00;font-weight:700>);</span>
</span></span><span style=display:flex><span><span style=color:#000>StringProperty</span> <span style=color:#000>targetProperty</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>SimpleStringProperty</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#4e9a06>&#34;Second Value&#34;</span><span style=color:#ce5c00;font-weight:700>);</span>
</span></span><span style=display:flex><span><span style=color:#000>targetProperty</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>bind</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>sourceProperty</span><span style=color:#ce5c00;font-weight:700>);</span>
</span></span></code></pre></div><p>目标存储对新源属性的引用，并侦听更改。当源值更改时，当检测到更改时，它会自动更新目标(本身)。</p><div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20220111000825.png style=display:block;width:80% alt=20220111000825 align=center> </div><p>在本例中，targetProperty 将跟踪 sourceProperty 的值。关于此方法的额外位的几点注意事项:</p><ul>
<li>
<p>如果属性当前已经被绑定，则当前绑定将被删除，新绑定将替换它。</p></li><li>
<p>如果提供了 null 参数，则该方法抛出一个 NullPointerExeption。</p></li><li>
<p>该方法立即复制它正在侦听的属性的值，因此目标属性的当前值将丢失。</p></li></ul><h3 id=双向绑定>双向绑定</h3><p>当然，可以将两个方向的属性连接在一起，将它们的值连接在一起，这样它们的值总是相同的。为此，我们调用<code>bindBidirectional()</code>，再次将源属性作为参数传递。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#000>StringProperty</span> <span style=color:#000>sourceProperty</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>SimpleStringProperty</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#4e9a06>&#34;First Value&#34;</span><span style=color:#ce5c00;font-weight:700>);</span>
</span></span><span style=display:flex><span><span style=color:#000>StringProperty</span> <span style=color:#000>targetProperty</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>SimpleStringProperty</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#4e9a06>&#34;Second Value&#34;</span><span style=color:#ce5c00;font-weight:700>);</span>
</span></span><span style=display:flex><span><span style=color:#000>targetProperty</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>bindBidirectional</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>sourceProperty</span><span style=color:#ce5c00;font-weight:700>);</span>
</span></span></code></pre></div><p>如果属性的值不同，那么方法调用的顺序对于确定绑定的起始值很重要。</p><p>应用于 targetProperty 的方法在对 sourceProperty 进行交互绑定之前立即更新 targetProperty 的值。这意味着在双向绑定之后，两个属性都将把属性的值作为参数传递(源属性)。</p><div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20220111001044.png style=display:block;width:80% alt=20220111001044 align=center> </div><p>除了被限制为碳复制方法的基本绑定之外，JavaFX 还支持更复杂的绑定：创建一个属性的多个或复杂操作来更新另一个属性。</p><p>如果将一个属性绑定到另一个属性不能涵盖您的用例，请不要担心——我将在下面几节中介绍更复杂的绑定。</p><h2 id=中间绑定技术>中间绑定技术</h2><p>有三种方法可以操作任何属性，并将操作后的值用于绑定：</p><ul>
<li>Fluent API – 类似 <code>myProperty.bind(otherProperty).multiply(2)</code> 的方法</li><li>Bindings API – 类似 <code>Bindings.add(myProperty, otherProperty)</code> 的方法</li><li>Low-Level API – 创建 <code>DoubleBinding</code> 这样的自定义 Binding 对象</li></ul><p>其中两个提供了 cookie-cutter 方法，用于在预定义的实现中绑定属性。我总是发现这些包含了属性绑定的大部分用例，因为它们给了您巨大的灵活性。</p><p>低级 API(创建 Binding 对象)可以有更高的性能，但可能会变得复杂得多。在此基础上，我将它分成单独的部分，我将在本文的末尾详细介绍。</p><h3 id=fluent-api>Fluent API</h3><p>Fluent API 依赖于“表达式”对象的创建，该对象类似于属性(它们是可观察值)，具有额外的方便方法来支持额外的操作。</p><p>属性也可以绑定到表达式，这意味着任何操作的输出都可以用于更新属性，如上所述。这种功能——被观察到并依赖于对象的值——创造了链接的可能性。</p><div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20220111001321.png style=display:block;width:80% alt=20220111001321 align=center> </div><p><strong>在字符串的情况下</strong>，我们可以使用它来创建字符串链，它们连接在一起。一旦 sourceProperty 更新，targetProperty 将通过表达式自动更新。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#000>StringProperty</span> <span style=color:#000>sourceProperty</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>SimpleStringProperty</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#4e9a06>&#34;It doesn&#39;t matter how slowly you go&#34;</span><span style=color:#ce5c00;font-weight:700>);</span>
</span></span><span style=display:flex><span><span style=color:#000>StringExpression</span> <span style=color:#000>expression</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>sourceProperty</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>concat</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#4e9a06>&#34; as long as you don&#39;t stop&#34;</span><span style=color:#ce5c00;font-weight:700>);</span>
</span></span><span style=display:flex><span><span style=color:#000>StringProperty</span> <span style=color:#000>targetProperty</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>SimpleStringProperty</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#4e9a06>&#34;&#34;</span><span style=color:#ce5c00;font-weight:700>);</span>
</span></span><span style=display:flex><span><span style=color:#000>targetProperty</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>bind</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>expression</span><span style=color:#ce5c00;font-weight:700>);</span>
</span></span><span style=display:flex><span><span style=color:#000>System</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>out</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>println</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>targetProperty</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>get</span><span style=color:#ce5c00;font-weight:700>());</span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>//Output: It doesn&#39;t matter how slowly you go as long as you don&#39;t stop
</span></span></span></code></pre></div><p>您可以内联完成所有这些工作，使复杂的代码相对简洁。在本例中，我们将在调用 bind 方法的同时创建 StringExpression。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#000>targetProperty</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>bind</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>sourceProperty</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>concat</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#4e9a06>&#34; as long as you don&#39;t stop&#34;</span><span style=color:#ce5c00;font-weight:700>));</span>
</span></span><span style=display:flex><span><span style=color:#000>System</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>out</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>println</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>targetProperty</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>get</span><span style=color:#ce5c00;font-weight:700>());</span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>//Output: It doesn&#39;t matter how slowly you go as long as you don&#39;t stop
</span></span></span></code></pre></div><p>这可能有点令人困惑，但不要忘记 targetProperty 实际上是绑定到由 <code>concat()</code> 方法创建的 StringExpression 的。绑定到 sourceProperty 的是匿名表达式。</p><p>这带来了惊人的好处。API 很丰富，这种风格生成的可读代码涵盖了您需要的大多数操作。</p><p>我们也可以使用 Fluent API 来处理数字。</p><p><strong>在处理数字时</strong>，我们可以链式操作来创建简单、可读的代码，表示我们试图复制的公式。要把角度转换成弧度，你要乘以 π 再除以 180。代码具有很高的可读性。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#000>DoubleProperty</span> <span style=color:#000>degrees</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>SimpleDoubleProperty</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>180</span><span style=color:#ce5c00;font-weight:700>);</span>
</span></span><span style=display:flex><span><span style=color:#000>DoubleProperty</span> <span style=color:#000>radians</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>SimpleDoubleProperty</span><span style=color:#ce5c00;font-weight:700>();</span>
</span></span><span style=display:flex><span><span style=color:#000>radians</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>bind</span><span style=color:#ce5c00;font-weight:700>(</span>
</span></span><span style=display:flex><span>  <span style=color:#000>degrees</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>multiply</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>Math</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>PI</span><span style=color:#ce5c00;font-weight:700>).</span><span style=color:#c4a000>divide</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>180</span><span style=color:#ce5c00;font-weight:700>)</span>
</span></span><span style=display:flex><span><span style=color:#ce5c00;font-weight:700>);</span>
</span></span></code></pre></div><p>但是，就性能而言，每个表达式都是链中的一个链接，在初始属性的每次更改时都需要更新。在这个例子中，我们将角度转换为弧度，我们创建了两个可观察值来更新弧度属性。</p><p>对于复杂的转换，或者在需要进行大量绑定的情况下，可以考虑使用 Bindings API(如果它提供了所需的灵活性)，或者低级 API。</p><h3 id=bindings-api>Bindings API</h3><p>JavaFX 中的 Bindings 类是一个实用程序类，包含 249 个用于属性绑定的方法。它允许你在各种类型的可观察对象之间创建绑定。根据绑定的不同，可以将属性与值结合使用，比如字符串和数字。</p><div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20220111001625.png style=display:block;width:80% alt=20220111001625 align=center> </div><p>有 10 种通用的绑定策略，我将其分为两个主要领域，我将其称为“<strong>值操作</strong>”和“<strong>集合操作</strong>”。有些桶装不下，所以我们有了一个不雅的桶，叫做“<strong>other</strong>”。</p><h3 id=values>Values</h3><ul>
<li>Mathematics (+, – ÷, ×)</li><li>Selecting the maximum or minimum</li><li>Value comparison (=, !=, &lt;, >, &lt;=, >=)</li><li>String formatting</li></ul><h3 id=collections>Collections</h3><ul>
<li>Binding two collections (lists, maps, sets)</li><li>Binding values to objects at a certain position in a collection</li><li>Binding to collection size</li><li>Whether a collection is empty</li></ul><h3 id=other-bindings>Other bindings</h3><ul>
<li>Multiple-object bindings</li><li>Boolean operators (and, not or) – (and when!)</li><li>Selecting values</li></ul><p>由于方法的数量庞大，我将深入探讨如何使用我认为(1)经常使用的方法或(2)难以理解的方法。本质上，我会试着用有用的解释增加价值，同时尽量不让你看到 RSI 滚动。</p><h3 id=操作值>操作值</h3><p>Bindings API 支持四种简单的数学操作:加法、减法、乘法和除法。它提供了单独的方法来使用浮点型、双精度型、整型和长值，以及两个 ObservableNumberValue 对象(例如 DoubleProperty)之间的方法。</p><h4 id=mathematics>Mathematics</h4><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#000>DoubleBinding</span>    <span style=color:#000>add</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>double</span> <span style=color:#000>op1</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>ObservableNumberValue</span> <span style=color:#000>op2</span><span style=color:#ce5c00;font-weight:700>)</span>
</span></span><span style=display:flex><span><span style=color:#000>NumberBinding</span>    <span style=color:#000>add</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>float</span> <span style=color:#000>op1</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>ObservableNumberValue</span> <span style=color:#000>op2</span><span style=color:#ce5c00;font-weight:700>)</span>
</span></span><span style=display:flex><span><span style=color:#000>NumberBinding</span>    <span style=color:#000>add</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>op1</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>ObservableNumberValue</span> <span style=color:#000>op2</span><span style=color:#ce5c00;font-weight:700>)</span>
</span></span><span style=display:flex><span><span style=color:#000>NumberBinding</span>    <span style=color:#000>add</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>long</span> <span style=color:#000>op1</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>ObservableNumberValue</span> <span style=color:#000>op2</span><span style=color:#ce5c00;font-weight:700>)</span>
</span></span><span style=display:flex><span><span style=color:#000>DoubleBinding</span>    <span style=color:#000>add</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>ObservableNumberValue</span> <span style=color:#000>op1</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#204a87;font-weight:700>double</span> <span style=color:#000>op2</span><span style=color:#ce5c00;font-weight:700>)</span>
</span></span><span style=display:flex><span><span style=color:#000>NumberBinding</span>    <span style=color:#000>add</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>ObservableNumberValue</span> <span style=color:#000>op1</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#204a87;font-weight:700>float</span> <span style=color:#000>op2</span><span style=color:#ce5c00;font-weight:700>)</span>
</span></span><span style=display:flex><span><span style=color:#000>NumberBinding</span>    <span style=color:#000>add</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>ObservableNumberValue</span> <span style=color:#000>op1</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>op2</span><span style=color:#ce5c00;font-weight:700>)</span>
</span></span><span style=display:flex><span><span style=color:#000>NumberBinding</span>    <span style=color:#000>add</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>ObservableNumberValue</span> <span style=color:#000>op1</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#204a87;font-weight:700>long</span> <span style=color:#000>op2</span><span style=color:#ce5c00;font-weight:700>)</span>
</span></span><span style=display:flex><span><span style=color:#000>NumberBinding</span>    <span style=color:#000>add</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>ObservableNumberValue</span> <span style=color:#000>op1</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>ObservableNumberValue</span> <span style=color:#000>op2</span><span style=color:#ce5c00;font-weight:700>)</span>
</span></span></code></pre></div><p>对于每个数值选项都有相同的方法。为了方便，API 交换了第一个和第二个参数。对于加法和乘法来说，顺序无关紧要，但是对于减法来说，顺序决定了哪个参数要从另一个参数中减去。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#000>DoubleBinding</span>    <span style=color:#000>subtract</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>double</span> <span style=color:#000>op1</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>ObservableNumberValue</span> <span style=color:#000>op2</span><span style=color:#ce5c00;font-weight:700>)</span>
</span></span><span style=display:flex><span><span style=color:#000>DoubleBinding</span>    <span style=color:#000>subtract</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>ObservableNumberValue</span> <span style=color:#000>op1</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#204a87;font-weight:700>double</span> <span style=color:#000>op2</span><span style=color:#ce5c00;font-weight:700>)</span>
</span></span><span style=display:flex><span><span style=color:#000>NumberBinding</span>    <span style=color:#000>subtract</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>ObservableNumberValue</span> <span style=color:#000>op1</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>ObservableNumberValue</span> <span style=color:#000>op2</span><span style=color:#ce5c00;font-weight:700>)</span>
</span></span></code></pre></div><p>在每种情况下，从第一个参数中减去第二个参数。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#000>DoubleBinding</span>    <span style=color:#000>multiply</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>double</span> <span style=color:#000>op1</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>ObservableNumberValue</span> <span style=color:#000>op2</span><span style=color:#ce5c00;font-weight:700>)</span>
</span></span><span style=display:flex><span><span style=color:#000>DoubleBinding</span>    <span style=color:#000>multiply</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>ObservableNumberValue</span> <span style=color:#000>op1</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#204a87;font-weight:700>double</span> <span style=color:#000>op2</span><span style=color:#ce5c00;font-weight:700>)</span>
</span></span><span style=display:flex><span><span style=color:#000>NumberBinding</span>    <span style=color:#000>multiply</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>ObservableNumberValue</span> <span style=color:#000>op1</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>ObservableNumberValue</span> <span style=color:#000>op2</span><span style=color:#ce5c00;font-weight:700>)</span>
</span></span></code></pre></div><p>最后，有了划分，秩序又变得重要起来。绑定的值计算为第一个参数除以第二个参数。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#000>DoubleBinding</span>    <span style=color:#000>divide</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>double</span> <span style=color:#000>op1</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>ObservableNumberValue</span> <span style=color:#000>op2</span><span style=color:#ce5c00;font-weight:700>)</span>
</span></span><span style=display:flex><span><span style=color:#000>DoubleBinding</span>    <span style=color:#000>divide</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>ObservableNumberValue</span> <span style=color:#000>op1</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#204a87;font-weight:700>double</span> <span style=color:#000>op2</span><span style=color:#ce5c00;font-weight:700>)</span>
</span></span><span style=display:flex><span><span style=color:#000>NumberBinding</span>    <span style=color:#000>divide</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>ObservableNumberValue</span> <span style=color:#000>op1</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>ObservableNumberValue</span> <span style=color:#000>op2</span><span style=color:#ce5c00;font-weight:700>)</span>
</span></span></code></pre></div><p>总的来说，这为相对简单的操作生成了大量的方法——36 个实用方法用于 4 个基本操作。</p><p>这可能看起来有点过火，但它确实做到了它应该做的。JavaFX 的创建者为每个基本的数学运算提供了实现，这样您就不必做这些跑腿工作了。</p><h4 id=选择最大或最小>选择最大或最小</h4><p>和往常一样，JavaFX 在定义方便的方法方面做了大量的跑腿工作。下面是 <code>max()</code> 方法，它们在可观察值和非可观察值之间进行交换和更改。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#000>max</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>double</span> <span style=color:#000>op1</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>ObservableNumberValue</span> <span style=color:#000>op2</span><span style=color:#ce5c00;font-weight:700>)</span>
</span></span><span style=display:flex><span><span style=color:#000>max</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>ObservableNumberValue</span> <span style=color:#000>op1</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#204a87;font-weight:700>double</span> <span style=color:#000>op2</span><span style=color:#ce5c00;font-weight:700>)</span>
</span></span><span style=display:flex><span><span style=color:#000>max</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>ObservableNumberValue</span> <span style=color:#000>op1</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>ObservableNumberValue</span> <span style=color:#000>op2</span><span style=color:#ce5c00;font-weight:700>)</span>
</span></span></code></pre></div><p>事实上，当你需要求两个数的最小值时，这是完全一样的。绑定总是等于两个的最小值——至少其中一个是可观察的。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#000>min</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>double</span> <span style=color:#000>op1</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>ObservableNumberValue</span> <span style=color:#000>op2</span><span style=color:#ce5c00;font-weight:700>)</span>
</span></span><span style=display:flex><span><span style=color:#000>min</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>ObservableNumberValue</span> <span style=color:#000>op1</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#204a87;font-weight:700>double</span> <span style=color:#000>op2</span><span style=color:#ce5c00;font-weight:700>)</span>
</span></span><span style=display:flex><span><span style=color:#000>min</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>ObservableNumberValue</span> <span style=color:#000>op1</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>ObservableNumberValue</span> <span style=color:#000>op2</span><span style=color:#ce5c00;font-weight:700>)</span>
</span></span></code></pre></div><h4 id=比较值----->比较值(=, !=, &lt;, >, &lt;=, >=)</h4><p>当列表已满，选择了足够多的道具，或者当他们在游戏中获胜或失败时，价值比较可以自动提醒用户。</p><h4 id=取负和取反>取负和取反</h4><p>在最简单的情况下，JavaFX 提供了计算负数(减去 1 乘以数字)和的方法：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#000>negate</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>ObservableNumberValue</span> <span style=color:#000>value</span><span style=color:#ce5c00;font-weight:700>)</span>
</span></span><span style=display:flex><span><span style=color:#000>not</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>ObservableBooleanValue</span> <span style=color:#000>op</span><span style=color:#ce5c00;font-weight:700>)</span>
</span></span></code></pre></div><h4 id=不等于>不等于</h4><p>在复杂性方面，JavaFX 还提供了两种不同类型对象之间的比较。绑定的值将始终报告这两个对象是否相等。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#000>notEqual</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>double</span> <span style=color:#000>op1</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>ObservableNumberValue</span> <span style=color:#000>op2</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#204a87;font-weight:700>double</span> <span style=color:#000>epsilon</span><span style=color:#ce5c00;font-weight:700>)</span>
</span></span><span style=display:flex><span><span style=color:#000>notEqual</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>Object</span> <span style=color:#000>op1</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>ObservableObjectValue</span><span style=color:#ce5c00;font-weight:700>&lt;?&gt;</span> <span style=color:#000>op2</span><span style=color:#ce5c00;font-weight:700>)</span>
</span></span><span style=display:flex><span><span style=color:#000>notEqual</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>ObservableNumberValue</span> <span style=color:#000>op1</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#204a87;font-weight:700>double</span> <span style=color:#000>op2</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#204a87;font-weight:700>double</span> <span style=color:#000>epsilon</span><span style=color:#ce5c00;font-weight:700>)</span>
</span></span><span style=display:flex><span><span style=color:#000>notEqual</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>ObservableNumberValue</span> <span style=color:#000>op1</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>ObservableNumberValue</span> <span style=color:#000>op2</span><span style=color:#ce5c00;font-weight:700>)</span>
</span></span><span style=display:flex><span><span style=color:#000>notEqual</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>ObservableNumberValue</span> <span style=color:#000>op1</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>ObservableNumberValue</span> <span style=color:#000>op2</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#204a87;font-weight:700>double</span> <span style=color:#000>epsilon</span><span style=color:#ce5c00;font-weight:700>)</span>
</span></span><span style=display:flex><span><span style=color:#000>notEqual</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>ObservableObjectValue</span><span style=color:#ce5c00;font-weight:700>&lt;?&gt;</span> <span style=color:#000>op1</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>Object</span> <span style=color:#000>op2</span><span style=color:#ce5c00;font-weight:700>)</span>
</span></span><span style=display:flex><span><span style=color:#000>notEqual</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>ObservableObjectValue</span><span style=color:#ce5c00;font-weight:700>&lt;?&gt;</span> <span style=color:#000>op1</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>ObservableObjectValue</span><span style=color:#ce5c00;font-weight:700>&lt;?&gt;</span> <span style=color:#000>op2</span><span style=color:#ce5c00;font-weight:700>)</span>
</span></span></code></pre></div><p>它还为比较字符串提供了很多支持。特别值得注意的是 <code>notEqualIgnoreCase()</code> 方法。在比较之前，我花了很长时间将所有的字符串转换成小写。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#000>notEqual</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>ObservableStringValue</span> <span style=color:#000>op1</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>ObservableStringValue</span> <span style=color:#000>op2</span><span style=color:#ce5c00;font-weight:700>)</span>
</span></span><span style=display:flex><span><span style=color:#000>notEqual</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>ObservableStringValue</span> <span style=color:#000>op1</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>String</span> <span style=color:#000>op2</span><span style=color:#ce5c00;font-weight:700>)</span>
</span></span><span style=display:flex><span><span style=color:#000>notEqual</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>String</span> <span style=color:#000>op1</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>ObservableStringValue</span> <span style=color:#000>op2</span><span style=color:#ce5c00;font-weight:700>)</span>
</span></span><span style=display:flex><span><span style=color:#000>notEqualIgnoreCase</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>ObservableStringValue</span> <span style=color:#000>op1</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>ObservableStringValue</span> <span style=color:#000>op2</span><span style=color:#ce5c00;font-weight:700>)</span>
</span></span><span style=display:flex><span><span style=color:#000>notEqualIgnoreCase</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>ObservableStringValue</span> <span style=color:#000>op1</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>String</span> <span style=color:#000>op2</span><span style=color:#ce5c00;font-weight:700>)</span>
</span></span><span style=display:flex><span><span style=color:#000>notEqualIgnoreCase</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>String</span> <span style=color:#000>op1</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>ObservableStringValue</span> <span style=color:#000>op2</span><span style=color:#ce5c00;font-weight:700>)</span>
</span></span></code></pre></div><p>正如标题所建议的，我们的值比较 bucket 还包含比较小于和大于的数值的方法。查看<a href=https://docs.oracle.com/javase/8/javafx/api/javafx/beans/binding/Bindings.html>文档</a>了解所有的细节——我暂时让您休息一下，然后继续讨论集合。</p><h3 id=操作集合>操作集合</h3><p>Bindings API 提供了四种不同的绑定到集合的方式:复制、索引绑定、大小绑定和空绑定。只有第一个集合将集合的内容复制到目标集合中。其他三个提取值—单个变量—基于集合状态的一个方面。</p><h4 id=绑定两个集合>绑定两个集合</h4><p>要将两个集合绑定在一起，您可以调用 <code>Bindings.bindContent()</code>或 <code>Bindings.bindContentBidirectional()</code>。</p><p>在第一种情况下，你将跟踪一个可观察集合——一个 ObservableList, ObservableSet 或 ObservableMap——并在同一类型的非可观察集合中创建一个 carbon-copy。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#000>bindContent</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>List</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>E</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>list1</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>ObservableList</span><span style=color:#ce5c00;font-weight:700>&lt;?</span> <span style=color:#204a87;font-weight:700>extends</span> <span style=color:#000>E</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>list2</span><span style=color:#ce5c00;font-weight:700>)</span>
</span></span><span style=display:flex><span><span style=color:#000>bindContent</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>Map</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>K</span><span style=color:#ce5c00;font-weight:700>,</span><span style=color:#000>V</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>map1</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>ObservableMap</span><span style=color:#ce5c00;font-weight:700>&lt;?</span> <span style=color:#204a87;font-weight:700>extends</span> <span style=color:#000>K</span><span style=color:#ce5c00;font-weight:700>,?</span> <span style=color:#204a87;font-weight:700>extends</span> <span style=color:#000>V</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>map2</span><span style=color:#ce5c00;font-weight:700>)</span>
</span></span><span style=display:flex><span><span style=color:#000>bindContent</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>Set</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>E</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>set1</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>ObservableSet</span><span style=color:#ce5c00;font-weight:700>&lt;?</span> <span style=color:#204a87;font-weight:700>extends</span> <span style=color:#000>E</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>set2</span><span style=color:#ce5c00;font-weight:700>)</span>
</span></span></code></pre></div><p>在这种情况下，非可观察对象集合的内容会立即被可观察对象的内容覆盖。</p><p>如果你想把两个可观察集合绑定在一起，使用 <code>Bindings.bindContentBidirectional()</code> 方法，它接受两个相同类型的集合作为参数。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#000>bindContentBidirectional</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>ObservableList</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>E</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>list1</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>ObservableList</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>E</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>list2</span><span style=color:#ce5c00;font-weight:700>)</span>
</span></span><span style=display:flex><span><span style=color:#000>bindContentBidirectional</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>ObservableMap</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>K</span><span style=color:#ce5c00;font-weight:700>,</span><span style=color:#000>V</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>map1</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>ObservableMap</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>K</span><span style=color:#ce5c00;font-weight:700>,</span><span style=color:#000>V</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>map2</span><span style=color:#ce5c00;font-weight:700>)</span>
</span></span><span style=display:flex><span><span style=color:#000>bindContentBidirectional</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>ObservableSet</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>E</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>set1</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>ObservableSet</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>E</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>set2</span><span style=color:#ce5c00;font-weight:700>)</span>
</span></span></code></pre></div><p><strong>在这些情况下，第一个集合将被擦除，并作为绑定过程的一部分使用第二个列表的内容。</strong></p><p>Bindings API 不支持任何更复杂的集合绑定——比如相互映射、范围受限的列表复制。如果需要这些，则需要创建自己的绑定。为此，请查看下面的低级API部分。</p><h4 id=绑定集合相关的值>绑定集合——相关的值</h4><p>除此之外，绑定的选项仅限于绑定与集合相关的值——特定索引处的值、集合的大小或集合是否为空。</p><h5 id=将值绑定到集合中特定位置的对象>将值绑定到集合中特定位置的对象</h5><p>根据集合中指定索引处的单个值绑定变量是非常容易的。在每种情况下，你都需要提供一个可观察对象集合，以及该对象的索引。</p><p>索引的值也可以作为可观察值传入，这意味着随着它的变化，绑定的值也会发生变化。</p><p>每种对象类型都有一个方法专门化，它为请求的值生成正确类型的绑定对象。布尔值、浮点值、双精度值、整型值、长值和字符串值都通过单独的方法支持。</p><p><strong>记住</strong>：绝对值得记住的是，这些方法不会像我们上面看到的那样把你的参数绑定在一起。每个 valueAt 方法都返回一个 Binding 对象，其中包含您的值。</p><h5 id=绑定到大小或空置的>绑定到大小或空置的</h5><p>基于大小或集合是否为空的绑定要容易得多。绑定 API 提供了对 ObservableList, ObservableArray, ObservableSet 和 ObservableMap对象的支持，以及 ObservableStringValue。</p><p>查看 <code>isEmpty()</code> 和各种 <code>size()</code> 方法的文档，查看所有选项。</p><h3 id=创建绑定对象>创建绑定对象</h3><p>我将在这里介绍的 Bindings API 的最后一部分是绑定多个自定义对象，并提供一个函数来计算该值。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#000>createBooleanBinding</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>Callable</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>Boolean</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>func</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>Observable</span><span style=color:#ce5c00;font-weight:700>...</span> <span style=color:#000>dependencies</span><span style=color:#ce5c00;font-weight:700>)</span>
</span></span><span style=display:flex><span><span style=color:#000>createDoubleBinding</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>Callable</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>Double</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>func</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>Observable</span><span style=color:#ce5c00;font-weight:700>...</span> <span style=color:#000>dependencies</span><span style=color:#ce5c00;font-weight:700>)</span>
</span></span><span style=display:flex><span><span style=color:#000>createFloatBinding</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>Callable</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>Float</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>func</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>Observable</span><span style=color:#ce5c00;font-weight:700>...</span> <span style=color:#000>dependencies</span><span style=color:#ce5c00;font-weight:700>)</span>
</span></span><span style=display:flex><span><span style=color:#000>createIntegerBinding</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>Callable</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>Integer</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>func</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>Observable</span><span style=color:#ce5c00;font-weight:700>...</span> <span style=color:#000>dependencies</span><span style=color:#ce5c00;font-weight:700>)</span>
</span></span><span style=display:flex><span><span style=color:#000>createLongBinding</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>Callable</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>Long</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>func</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>Observable</span><span style=color:#ce5c00;font-weight:700>...</span> <span style=color:#000>dependencies</span><span style=color:#ce5c00;font-weight:700>)</span>
</span></span><span style=display:flex><span><span style=color:#000>createObjectBinding</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>Callable</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>T</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>func</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>Observable</span><span style=color:#ce5c00;font-weight:700>...</span> <span style=color:#000>dependencies</span><span style=color:#ce5c00;font-weight:700>)</span>
</span></span><span style=display:flex><span><span style=color:#000>createStringBinding</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>Callable</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>String</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>func</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>Observable</span><span style=color:#ce5c00;font-weight:700>...</span> <span style=color:#000>dependencies</span><span style=color:#ce5c00;font-weight:700>)</span>
</span></span></code></pre></div><p>这几乎和低级 API 一样好，但它有一些限制：</p><blockquote>
<p>请注意，它依赖于虚方法调用(您正在传递一个函数对象，而不是创建一个类方法)。这意味着如果你经常使用它，它可能会比低层 API 慢。</p></blockquote><p>不过，这是一个相对简单的API——只需传入每个依赖项，然后使用提供的函数对它们进行转换。为了清晰起见，我将函数定义为 lambda，但您也可以手动创建 <code>Callable&lt;Double></code> 并覆盖 <code>call()</code> 方法。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000>IntegerProperty</span> <span style=color:#000>cost</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>SimpleIntegerProperty</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>15</span><span style=color:#ce5c00;font-weight:700>);</span>
</span></span><span style=display:flex><span><span style=color:#000>DoubleProperty</span> <span style=color:#000>multiplier</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>SimpleDoubleProperty</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>25</span><span style=color:#ce5c00;font-weight:700>);</span>
</span></span><span style=display:flex><span><span style=color:#204a87;font-weight:700>double</span> <span style=color:#000>flatRate</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>4</span><span style=color:#ce5c00;font-weight:700>;</span>
</span></span><span style=display:flex><span><span style=color:#000>DoubleBinding</span> <span style=color:#000>totalCost</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>Bindings</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>createDoubleBinding</span><span style=color:#ce5c00;font-weight:700>(</span>
</span></span><span style=display:flex><span>        <span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>-&gt;</span> <span style=color:#000>cost</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>get</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>*</span> <span style=color:#000>multiplier</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>get</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>+</span> <span style=color:#000>flatRate</span><span style=color:#ce5c00;font-weight:700>,</span>
</span></span><span style=display:flex><span>        <span style=color:#000>cost</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>multiplier</span>
</span></span><span style=display:flex><span><span style=color:#ce5c00;font-weight:700>);</span>
</span></span></code></pre></div><p>如果这不能满足您的需求，您可以通过扩展 JavaFX 的 Bindings 类中可用的对象来创建完全定制的绑定。这样可以更快。所以如果你需要，这里是如何做的。</p><h2 id=高阶绑定低级-api-binding>高阶绑定——低级 API Binding</h2><p>在 JavaFX 中创建绑定的最可定制的方法是自己手动创建一个 binding 对象。这样做的好处是，您可以精确地定义所需的计算，而不必创建 Expression 对象链，这可能会降低性能。</p><p>当然，您也可以进行复杂的计算并使用 Bindings API 绑定多个对象，但正如我们前面看到的那样，这样做的效率并不高。低级 API 的好处是，在计算值时需要执行的任何计算都是在自定义 Binding 类中定义的。</p><p>如果你想知道为什么这可能会有更好的性能，那就是类函数更有可能被编译器“内联”。这意味着，如果您需要一个绑定的值重复且快速地为计算机，那么您的代码可能会执行得更快。</p><h3 id=什么是低级-api>什么是低级 API</h3><p>低级 API, 10 个抽象绑定类的集合，旨在实现所有棘手的绑定(例如，添加和删除侦听器)。这使您可以集中精力指定应该如何计算绑定的值。</p><p>每个类都接受可观察值(比如属性)并将它们转换为输出。就像 Fluent 和 Bindings API 一样，低级 API 支持布尔值、字符串、数字、集合和对象。</p><h3 id=创建低级-binding>创建低级 Binding</h3><p>创建低级绑定可以像定义抽象内部类(与其他代码一起定义的类)一样简单。因为抽象绑定类只有一个抽象方法，所以您只需要在定义方法时重写 <code>computeValue()</code>。</p><p>在定义绑定时，官方建议在绑定创建期间使用初始化块绑定源属性。老实说，与创建构造函数相比，我不喜欢这样做，但这可能只是因为初始化块看起来有点陌生。</p><p>总体效果是完全相同的——编译器将代码从初始化块复制到每个构造函数中。如果您要创建一个将要使用多次的具体类，则构造函数方法更合适。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>		<span style=color:#8f5902;font-style:italic>//Inside your binding object at the top
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span>    <span style=color:#ce5c00;font-weight:700>{</span>
</span></span><span style=display:flex><span>        <span style=color:#204a87;font-weight:700>super</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>bind</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>cost</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>itemCount</span><span style=color:#ce5c00;font-weight:700>);</span>
</span></span><span style=display:flex><span>    <span style=color:#ce5c00;font-weight:700>}</span>
</span></span></code></pre></div><p>然后，剩下的工作就是定义 <code>computeValue()</code> 方法。在本例中，它非常简单，但是您可以将计算变得任意复杂。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#000>DoubleProperty</span> <span style=color:#000>cost</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>SimpleDoubleProperty</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>25</span><span style=color:#ce5c00;font-weight:700>);</span>
</span></span><span style=display:flex><span><span style=color:#000>IntegerProperty</span> <span style=color:#000>itemCount</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>SimpleIntegerProperty</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>15</span><span style=color:#ce5c00;font-weight:700>);</span>
</span></span><span style=display:flex><span><span style=color:#000>DoubleBinding</span> <span style=color:#000>totalCost</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>DoubleBinding</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#ce5c00;font-weight:700>{</span>
</span></span><span style=display:flex><span>        <span style=color:#204a87;font-weight:700>super</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>bind</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>cost</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>itemCount</span><span style=color:#ce5c00;font-weight:700>);</span>
</span></span><span style=display:flex><span>    <span style=color:#ce5c00;font-weight:700>}</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#5c35cc;font-weight:700>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#204a87;font-weight:700>protected</span> <span style=color:#204a87;font-weight:700>double</span> <span style=color:#000>computeValue</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span>
</span></span><span style=display:flex><span>        <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>itemCount</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>get</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>*</span> <span style=color:#000>cost</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>get</span><span style=color:#ce5c00;font-weight:700>();</span>
</span></span><span style=display:flex><span>    <span style=color:#ce5c00;font-weight:700>}</span>
</span></span><span style=display:flex><span><span style=color:#ce5c00;font-weight:700>};</span>
</span></span></code></pre></div><p>由此可见，totalCost 绑定的值将始终反映 cost 和 itemCount 属性的乘积。</p><p>如果您希望能够传递 totalCost 对象并在稍后检索依赖项，您可以添加额外的功能来覆盖默认的 <code>getDependencies()</code> 方法。</p><h3 id=给低级-api-添加功能>给低级 API 添加功能</h3><p>在可定制的 value 方法之上，可以通过覆盖 <code>getDependencies()</code> 和 <code>dispose()</code> 方法来扩展低级 API 中的每个类。</p><ul>
<li><strong>getDependencies()</strong>：如果您需要存储它们并在以后取回它们，可以返回所有的依赖项(见下面的警告!)</li><li><strong>dispose()</strong>：可以注销绑定所有依赖项的侦听器。您通常不需要这样做，除非您特别在没有弱监听器(默认)的情况下实现绑定。</li></ul><h4 id=重写-getdependencies>重写 <code>getDependencies()</code></h4><p>如果您希望能够将绑定对象传递给另一个类，或者存储它并在以后检索依赖项，那么重写 <code>getDependencies()</code> 是很有用的。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#000>DoubleBinding</span> <span style=color:#000>totalCost</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>DoubleBinding</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span>
</span></span><span style=display:flex><span>    <span style=color:#ce5c00;font-weight:700>{</span>
</span></span><span style=display:flex><span>        <span style=color:#204a87;font-weight:700>super</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>bind</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>cost</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>itemCount</span><span style=color:#ce5c00;font-weight:700>);</span>
</span></span><span style=display:flex><span>    <span style=color:#ce5c00;font-weight:700>}</span>
</span></span><span style=display:flex><span>    <span style=color:#5c35cc;font-weight:700>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#204a87;font-weight:700>protected</span> <span style=color:#204a87;font-weight:700>double</span> <span style=color:#000>computeValue</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span>
</span></span><span style=display:flex><span>        <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>itemCount</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>get</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>*</span> <span style=color:#000>cost</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>get</span><span style=color:#ce5c00;font-weight:700>();</span>
</span></span><span style=display:flex><span>    <span style=color:#ce5c00;font-weight:700>}</span>
</span></span><span style=display:flex><span>    <span style=color:#5c35cc;font-weight:700>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#204a87;font-weight:700>public</span> <span style=color:#000>ObservableList</span><span style=color:#ce5c00;font-weight:700>&lt;?&gt;</span> <span style=color:#000>getDependencies</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span>
</span></span><span style=display:flex><span>        <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>FXCollections</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>observableList</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>Arrays</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>asList</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>cost</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>itemCount</span><span style=color:#ce5c00;font-weight:700>));</span>
</span></span><span style=display:flex><span>    <span style=color:#ce5c00;font-weight:700>}</span>
</span></span><span style=display:flex><span><span style=color:#ce5c00;font-weight:700>};</span>
</span></span></code></pre></div><p>在匆忙重写此方法之前，值得记住的是，低级API的所有默认实现都使用弱侦听器。这意味着:</p><p><strong>如果你使用默认实现的低级 API，你需要保持对你的可观察对象的强引用，否则它们将被垃圾收集，引用将丢失。</strong></p><p>也就是说，如果您已经用强侦听器实现了绑定，那么您还需要重写 <code>dispose()</code> 方法。这将防止内存泄漏的发生，如果绑定被使用并被遗忘(至少被您……)后没有从被观察的对象中注销。</p><h3 id=重写-dispose>重写 <code>dispose()</code></h3><p>重写 <code>dispose()</code>方法就像系统地注销我们开始时绑定的每个可观察对象一样简单。要在一次调用中完成此操作，可以调用 <code>unbind()</code>，传入每个值。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#5c35cc;font-weight:700>@Override</span>
</span></span><span style=display:flex><span><span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>dispose</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span>
</span></span><span style=display:flex><span>    <span style=color:#000>unbind</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>cost</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>itemCount</span><span style=color:#ce5c00;font-weight:700>);</span>
</span></span><span style=display:flex><span><span style=color:#ce5c00;font-weight:700>}</span>
</span></span></code></pre></div><p>如果您有一个更复杂的自定义实现，您可能需要一次查找和取消注册一个可观察对象。</p><h2 id=总结>总结</h2><p>JavaFX 中的属性可以是只读的，也可以是可写的，但是始终是可观察的。每个属性都实现了 javafx.bean 的功能。绑定，javafx.beans.value 和 javafx.beans.property 包。</p><p>每个属性都可以使用 InvalidationListener 或 ChangeListener 对象来观察。这两个都可以通过调用 <code>addListener()</code> 方法来访问，因为每个属性都有一个 <code>addListener()</code> 方法来进行无效和更改。</p><p>属性监听的一个扩展是属性绑定，该功能允许用户将属性连接在一起，以便根据一个或多个更改自动更新属性。</p><p>在此基础上，JavaFX 支持通过 Expression 对象和 bindings 对象扩展绑定。通过 Fluent 和 Bindings api 访问这些内容是最简单的。但是，如果您绝对需要性能或定制，那么低级 API 允许您自己创建完全定制的绑定。</p></div><div class=td-content style=page-break-before:always>
<h1 id=pg-a0e53fb9906b7763988ff54dd605d01c>3 - JavaFX Style</h1></div><div class=td-content style=page-break-before:always>
<h1 id=pg-fce106ddb364c8ae9b64694691856820>4 - JavaFX Controls</h1></div><div class=td-content style=page-break-before:always>
<h1 id=pg-45c994056032155f1ebd23912c264fad>5 - JavaFX Responsive</h1><div class="pageinfo pageinfo-primary">
<p><a href=https://edencoding.com/responsive-layouts/>How to make a responsive UI in JavaFX</a></p></div></div><div class=td-content style=page-break-before:always>
<h1 id=pg-797aff4628595fd753e4ed089cd367ee>6 - JavaFX TextEditor</h1><div class="pageinfo pageinfo-primary">
<p><a href=https://edencoding.com/how-to-open-edit-sync-and-save-a-text-file-in-javafx/>JavaFX Text Editor: Open, edit, sync and save a text file</a></p></div></div><div class=td-content style=page-break-before:always>
<h1 id=pg-c263bc76c47fbb2735368cb2edc4fa39>7 - JavaFX Background Task</h1><div class="pageinfo pageinfo-primary">
<p><a href=https://edencoding.com/periodic-background-tasks/>5 best ways to run periodic background tasks in JavaFX</a></p></div></div><div class=td-content style=page-break-before:always>
<h1 id=pg-26f1809d0d5390ebf89ec905900adc91>8 - JavaFX Animation</h1><div class="pageinfo pageinfo-primary">
<p><a href=https://edencoding.com/javafxanimation-transitions-timelines-and-animation-timers/>JavaFX Animation: Transitions, Timelines and Animation Timers</a></p></div></div><div class=td-content style=page-break-before:always>
<h1 id=pg-4cd4932cb513a79c2df43f9277cae639>9 - JavaFX Events</h1><div class="pageinfo pageinfo-primary">
<p><a href=https://edencoding.com/javafx-events/>A Definitive Guide To JavaFX Events</a></p></div></div><div class=td-content style=page-break-before:always>
<h1 id=pg-864673981e258e7289b86932d5faef7a>10 - JavaFX Refresh Scene</h1><div class="pageinfo pageinfo-primary">
<p><a href=https://edencoding.com/force-refresh-scene/>How to force refresh the Scene in JavaFX</a></p></div></div><div class=td-content style=page-break-before:always>
<h1 id=pg-ee893caf1b181c2909a7c40d7ab77034>11 - JavaFX TableView</h1><div class="pageinfo pageinfo-primary">
<p><a href=https://edencoding.com/tableview-customization-cellfactory/>CellFactory: Complete Customization of JavaFX TableView</a></p></div></div><div class=td-content style=page-break-before:always>
<h1 id=pg-203d5f4dd417e90a6499e21e20a9d4a7>12 - JavaFX REST</h1><div class="pageinfo pageinfo-primary">
<p><a href=https://edencoding.com/connect-javafx-to-a-rest-api/>Connecting JavaFX to a REST API</a></p></div></div><div class=td-content style=page-break-before:always>
<h1 id=pg-1fea95547b38c395f5d9e92ec678383f>13 - JavaFX New Window</h1><div class="pageinfo pageinfo-primary">
<p><a href=https://edencoding.com/new-windows-stage/>Creating new Windows in JavaFX</a></p></div></div><div class=td-content style=page-break-before:always>
<h1 id=pg-e64814d30f4670330429afd9eba6dfa1>14 - JavaFX Button Events</h1><div class="pageinfo pageinfo-primary">
<p><a href=https://edencoding.com/javafx-button-events-and-how-to-use-them/>JavaFX Button Events and How to Use Them</a></p></div></div><div class=td-content style=page-break-before:always>
<h1 id=pg-f6c3a53134930f7864e254234f51fe7c>15 - JavaFX Canvas Vs Pane</h1><div class="pageinfo pageinfo-primary">
<p><a href=https://edencoding.com/javafx-canvas-vs-pane/>JavaFX Canvas Vs Pane – Performance and Convenience</a></p></div></div><div class=td-content style=page-break-before:always>
<h1 id=pg-39db9bdf39735c82f0d6b4d47a7fbd74>16 - JavaFX GridPane Nodes</h1><div class="pageinfo pageinfo-primary">
<p><a href=https://edencoding.com/javafx-searching-grids/>Interacting with nodes in a GridPane layout – JavaFX</a></p></div></div><div class=td-content style=page-break-before:always>
<h1 id=pg-4af80e84aed274d41b7c5e0539fec8dc>17 - JavaFX Triangles</h1><div class="pageinfo pageinfo-primary">
<p><a href=https://edencoding.com/3-ways-to-draw-triangles-in-javafx-all-with-free-code/>3 ways to draw triangles in JavaFX</a></p></div></div><div class=td-content style=page-break-before:always>
<h1 id=pg-17d441f58268bc383a6a3c296869f31c>18 - JavaFX Canvas</h1><div class="pageinfo pageinfo-primary">
<p><a href=https://edencoding.com/javafx-canvas/>The JavaFX Canvas – A Helpful, Illustrated Guide</a></p></div></div><div class=td-content style=page-break-before:always>
<h1 id=pg-660583bfd25d6d5bd13d23ebb178db6c>19 - JavaFX Charts</h1><div class="pageinfo pageinfo-primary">
<p><a href=https://edencoding.com/javafx-charts/>Everything you need to know about JavaFX Charts</a></p></div></div><div class=td-content style=page-break-before:always>
<h1 id=pg-b4a90c934c24c035a7c7b4536e3f2349>20 - JavaFX Drag Shapes</h1><div class="pageinfo pageinfo-primary">
<p><a href=https://edencoding.com/drag-shapes-javafx/>The Best Way to Drag Shapes in JavaFX</a></p></div></div><div class=td-content style=page-break-before:always>
<h1 id=pg-db615bb8772bfa6841d04dadd992834c>21 - JavaFX TableView Filter</h1><div class="pageinfo pageinfo-primary">
<p><a href=https://edencoding.com/search-bar-dynamic-filtering/>Search bars: Dynamically Filter a TableView in JavaFX</a></p></div></div><div class=td-content style=page-break-before:always>
<h1 id=pg-bee837053f49f2fe262b61d70aa02ff8>22 - JavaFX TableView Style</h1><div class="pageinfo pageinfo-primary">
<p><a href=https://edencoding.com/style-tableview-javafx/>How to style a TableView in JavaFX</a></p></div></div><div class=td-content style=page-break-before:always>
<h1 id=pg-93e6b2f1c871911602629a05f6905f09>23 - JavaFX TableView SVG</h1><div class="pageinfo pageinfo-primary">
<p><a href=https://edencoding.com/svg-javafx/>How to use an SVG image in JavaFX</a></p></div></div><div class=td-content style=page-break-before:always>
<h1 id=pg-53c4686a2deb1ed93e30dba57b5e06ea>24 - JavaFX All Buttons</h1><div class="pageinfo pageinfo-primary">
<p><a href=https://pragmaticcoding.ca/javafx/elements/buttons>All about Buttons</a></p></div></div></main></div></div><footer class="bg-dark py-5 row d-print-none">
<div class="container-fluid mx-sm-5">
<div class=row>
<div class="col-6 col-sm-4 text-xs-center order-sm-2">
</div><div class="col-6 col-sm-4 text-right text-xs-center order-sm-3">
<ul class="list-inline mb-0">
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Weibo aria-label=Weibo>
<a class=text-white target=_blank rel="noopener noreferrer" href=https://weibo.com/u/3848950217>
<i class="fab fa-weibo"></i>
</a>
</li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Twitter aria-label=Twitter>
<a class=text-white target=_blank rel="noopener noreferrer" href=https://twitter.com/zhange_zzg>
<i class="fab fa-twitter"></i>
</a>
</li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="Stack Overflow" aria-label="Stack Overflow">
<a class=text-white target=_blank rel="noopener noreferrer" href=https://stackoverflow.com>
<i class="fab fa-stack-overflow"></i>
</a>
</li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=GitHub aria-label=GitHub>
<a class=text-white target=_blank rel="noopener noreferrer" href=https://github.com/infilos/infilos.com>
<i class="fab fa-github"></i>
</a>
</li></ul></div><div class="col-12 col-sm-4 text-center py-2 order-sm-2">
<small class=text-white>&copy; 2022 infilos.com All Rights Reserved</small>
</div></div></div></footer></div><script src=/js/popper.min.js integrity=sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49 crossorigin=anonymous></script>
<script src=/js/bootstrap.min.js integrity=sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy crossorigin=anonymous></script>
<script src=/js/main.min.3f3f4f1e22307ccbb13271a98be2e4dbb8386b7e67c3d606db44d3d0649f485e.js integrity="sha256-Pz9PHiIwfMuxMnGpi+Lk27g4a35nw9YG20TT0GSfSF4=" crossorigin=anonymous></script>
</body></html>