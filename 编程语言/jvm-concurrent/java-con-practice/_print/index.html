<!doctype html><html lang=zh class=no-js>
<head>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=generator content="Hugo 0.88.1">
<meta name=ROBOTS content="INDEX, FOLLOW">
<link rel=canonical type=text/html href=/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/jvm-concurrent/java-con-practice/>
<link rel="shortcut icon" href=/favicons/favicon.ico>
<link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180>
<link rel=icon type=image/png href=/favicons/favicon-16x16.png sizes=16x16>
<link rel=icon type=image/png href=/favicons/favicon-32x32.png sizes=32x32>
<link rel=icon type=image/png href=/favicons/android-36x36.png sizes=36x36>
<link rel=icon type=image/png href=/favicons/android-48x48.png sizes=48x48>
<link rel=icon type=image/png href=/favicons/android-72x72.png sizes=72x72>
<link rel=icon type=image/png href=/favicons/android-96x96.png sizes=96x96>
<link rel=icon type=image/png href=/favicons/android-144x144.png sizes=144x144>
<link rel=icon type=image/png href=/favicons/android-192x192.png sizes=192x192>
<title>Java 并发实战 | infilos.com</title><meta property="og:title" content="Java 并发实战">
<meta property="og:description" content="Infilos Wiki Website">
<meta property="og:type" content="website">
<meta property="og:url" content="/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/jvm-concurrent/java-con-practice/"><meta property="og:site_name" content="infilos.com">
<meta itemprop=name content="Java 并发实战">
<meta itemprop=description content="Infilos Wiki Website"><meta name=twitter:card content="summary">
<meta name=twitter:title content="Java 并发实战">
<meta name=twitter:description content="Infilos Wiki Website">
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga('create','UA-123062585-1','auto'),ga('send','pageview'))</script>
<script async src=https://www.google-analytics.com/analytics.js></script>
<link rel=preload href=/scss/main.min.847464b684a6e89d7276700a5c500c17ab494dd1755b2654a7b27d8b59e3347e.css as=style>
<link href=/scss/main.min.847464b684a6e89d7276700a5c500c17ab494dd1755b2654a7b27d8b59e3347e.css rel=stylesheet integrity>
<script src=/js/jquery-3.5.1.min.js integrity="sha256-9/aliU8dGd2tb6OSsuzixeV4y/faTqgFtohetphbbj0=" crossorigin=anonymous></script>
<link rel=stylesheet href=https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.css>
</head>
<body class=td-section>
<header>
<nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-column flex-md-row td-navbar">
<a class=navbar-brand href=/>
<span class=navbar-logo><svg id="Capa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 512 512" style="enable-background:new 0 0 512 512"><path style="fill:#ffc107" d="M432.384 143.616c-4.165-4.164-10.917-4.164-15.083.0l-60.352 60.352c-4.164 4.165-4.164 10.917.0 15.083 21.187 20.463 54.951 19.876 75.413-1.311 19.962-20.668 19.962-53.435.0-74.102L432.384 143.616z"/><path style="fill:#607d8b" d="M42.667 277.334c-5.891.003-10.669-4.771-10.672-10.662-.002-4.338 2.623-8.245 6.64-9.882l234.667-96c5.455-2.233 11.687.38 13.92 5.835s-.38 11.687-5.835 13.92l-234.667 96C45.433 277.069 44.056 277.337 42.667 277.334z"/><path style="fill:#546e7a" d="M391.552 56.448l-32-32C343.938 8.745 322.689-.059 300.544.0h-3.755c-46.082.024-83.432 37.374-83.456 83.456v3.755c-.053 22.138 8.75 43.377 24.448 58.987l32 32c4.165 4.164 10.917 4.164 15.083.0L391.531 71.531C395.701 67.372 395.71 60.62 391.552 56.448z"/><path style="fill:#607d8b" d="M160 469.334c-3.279.006-6.379-1.497-8.405-4.075L34.261 315.926c-3.635-4.636-2.823-11.341 1.813-14.976s11.341-2.823 14.976 1.813l117.333 149.333c3.629 4.641 2.809 11.344-1.832 14.973C164.681 468.533 162.375 469.329 160 469.334z"/><path style="fill:#455a64" d="M487.467 86.848l-3.669-3.648c-37.687-36.557-97.71-36.197-134.955.811l-51.413 51.413c-36.996 37.25-37.357 97.263-.811 134.955l3.584 3.669c1.7 2.457 4.671 3.706 7.616 3.2 2.831.005 5.548-1.115 7.552-3.115l172.181-172.181c4.189-4.143 4.226-10.896.083-15.085-.028-.028-.055-.056-.083-.083L487.467 86.848z"/><g><path style="fill:#ffc107" d="M501.333 192H480c-5.891.0-10.667-4.776-10.667-10.667s4.776-10.667 10.667-10.667h21.333c5.891.0 10.667 4.776 10.667 10.667S507.225 192 501.333 192z"/><path style="fill:#ffc107" d="M394.667 298.667c-5.891.0-10.667-4.776-10.667-10.667v-21.333c0-5.891 4.776-10.667 10.667-10.667 5.891.0 10.667 4.776 10.667 10.667V288C405.333 293.891 400.558 298.667 394.667 298.667z"/><path style="fill:#ffc107" d="M480 277.334c-2.831.005-5.548-1.115-7.552-3.115l-21.333-21.333c-4.093-4.237-3.975-10.99.262-15.083 4.134-3.993 10.687-3.993 14.821.0l21.333 21.333c4.159 4.172 4.148 10.926-.024 15.085C485.514 276.209 482.815 277.327 480 277.334z"/></g><g><path style="fill:#455a64" d="M266.667 448H96c-29.455.0-53.333 23.878-53.333 53.333.0 5.891 4.776 10.667 10.667 10.667h256c5.891.0 10.667-4.776 10.667-10.667C320 471.878 296.122 448 266.667 448z"/><circle style="fill:#455a64" cx="32" cy="288" r="32"/></g><g/><g/><g/><g/><g/><g/><g/><g/><g/><g/><g/><g/><g/><g/><g/></svg></span><span class=font-weight-bold>infilos.com</span>
</a>
<div class="collapse navbar-collapse" id=navbarSupportedContent>
<ul class="navbar-nav mr-auto">
<li class="nav-item dropdown" style=max-width:90px;min-width:10px>
<a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>
基础
<span>+</span>
</a>
<div class=dropdown-menu aria-labelledby=navbarDropdown>
<a class=dropdown-item href=/%e5%9f%ba%e7%a1%80%e7%9f%a5%e8%af%86/%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f>操作系统</a>
<a class=dropdown-item href=/%e5%9f%ba%e7%a1%80%e7%9f%a5%e8%af%86/%e6%80%a7%e8%83%bd%e4%b9%8b%e6%ae%87>性能之殇</a>
<a class=dropdown-item href=/%e5%9f%ba%e7%a1%80%e7%9f%a5%e8%af%86/io%e6%a8%a1%e5%9e%8b>IO 模型</a>
<a class=dropdown-item href=/%e5%9f%ba%e7%a1%80%e7%9f%a5%e8%af%86/%e7%bd%91%e7%bb%9c%e5%9f%ba%e7%a1%80>网络基础</a>
<a class=dropdown-item href=/%e5%9f%ba%e7%a1%80%e7%9f%a5%e8%af%86/tcp-ip>TCP-IP</a>
<a class=dropdown-item href=/%e5%9f%ba%e7%a1%80%e7%9f%a5%e8%af%86/http>HTTP</a>
</div>
</li>
<li class="nav-item dropdown" style=max-width:90px;min-width:10px>
<a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>
语言
<span>+</span>
</a>
<div class=dropdown-menu aria-labelledby=navbarDropdown>
<a class=dropdown-item href=/%e7%bc%96%e7%a8%8b%e8%af%ad%e8%a8%80/java>Java 编程</a>
<a class=dropdown-item href=/%e7%bc%96%e7%a8%8b%e8%af%ad%e8%a8%80/jvm-core>JVM 核心</a>
<a class=dropdown-item href=/%e7%bc%96%e7%a8%8b%e8%af%ad%e8%a8%80/jvm-concurrent>JVM 并发</a>
<a class=dropdown-item href=/%e7%bc%96%e7%a8%8b%e8%af%ad%e8%a8%80/scala>Scala 编程</a>
</div>
</li>
<li class="nav-item dropdown" style=max-width:90px;min-width:10px>
<a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>
框架库
<span>+</span>
</a>
<div class=dropdown-menu aria-labelledby=navbarDropdown>
<a class=dropdown-item href=/%e6%a1%86%e6%9e%b6%e4%b8%8e%e5%ba%93/spring>Spring</a>
<a class=dropdown-item href=/%e6%a1%86%e6%9e%b6%e4%b8%8e%e5%ba%93/hikari>Hikari</a>
<a class=dropdown-item href=/%e6%a1%86%e6%9e%b6%e4%b8%8e%e5%ba%93/parboiled>Parboiled</a>
</div>
</li>
<li class="nav-item dropdown" style=max-width:90px;min-width:10px>
<a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>
分布式
<span>+</span>
</a>
<div class=dropdown-menu aria-labelledby=navbarDropdown>
<a class=dropdown-item href=/%e5%88%86%e5%b8%83%e5%bc%8f/base>基本构成</a>
</div>
</li>
<li class="nav-item dropdown" style=max-width:90px;min-width:10px>
<a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>
大数据
<span>+</span>
</a>
<div class=dropdown-menu aria-labelledby=navbarDropdown>
<a class=dropdown-item href=/%e5%ad%98%e5%82%a8%e7%b3%bb%e7%bb%9f>存储系统</a>
<a class=dropdown-item href=/%e6%9f%a5%e8%af%a2%e7%b3%bb%e7%bb%9f>查询系统</a>
<a class=dropdown-item href=/%e6%b6%88%e6%81%af%e7%b3%bb%e7%bb%9f>消息系统</a>
<a class=dropdown-item href=/%e5%a4%84%e7%90%86%e7%b3%bb%e7%bb%9f>处理系统</a>
<a class=dropdown-item href=/%e7%ae%a1%e7%90%86%e7%b3%bb%e7%bb%9f>管理系统</a>
</div>
</li>
<li class="nav-item dropdown" style=max-width:90px;min-width:10px>
<a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>
中后台
<span>+</span>
</a>
<div class=dropdown-menu aria-labelledby=navbarDropdown>
<a class=dropdown-item href=/%e5%9f%ba%e7%a1%80%e8%ae%be%e6%96%bd>基础设施</a>
<a class=dropdown-item href=/%e4%ba%a4%e4%ba%92%e7%95%8c%e9%9d%a2>交互界面</a>
<a class=dropdown-item href=/%e4%b8%9a%e5%8a%a1%e7%b3%bb%e7%bb%9f>业务系统</a>
</div>
</li>
<li class="nav-item dropdown" style=max-width:90px;min-width:10px>
<a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>
模式架构
<span>+</span>
</a>
<div class=dropdown-menu aria-labelledby=navbarDropdown>
<a class=dropdown-item href=/%e6%a8%a1%e5%bc%8f%e6%9e%b6%e6%9e%84/design-pattern>设计模式</a>
<a class=dropdown-item href=/%e6%a8%a1%e5%bc%8f%e6%9e%b6%e6%9e%84/micro-service>微服务架构</a>
</div>
</li>
<li class=nav-item style=max-width:90px;min-width:10px>
<a class=nav-link href=/%e9%9d%a2%e8%af%95%e9%97%ae%e7%ad%94>
<span>面试</span>
</a>
</li>
<li class=nav-item style=max-width:90px;min-width:10px>
<a class=nav-link href=/%e7%ae%a1%e7%90%86%e8%b7%af%e5%be%84>
<span>管理</span>
</a>
</li>
<li class=nav-item style=max-width:90px;min-width:10px>
<a class=nav-link href=/%e5%bc%80%e6%ba%90%e9%a1%b9%e7%9b%ae>
<span>开源</span>
</a>
</li>
</ul>
<div class="form-inline my-2 my-lg-0">
<div class="nav-item nav-search-item my-2 my-md-0">
<input type=search class="form-control td-search-input" placeholder="&#xf002; 站内搜索…" aria-label=站内搜索… autocomplete=off>
</div>
</div>
</div>
</nav>
</header>
<div class="container-fluid td-outer">
<div class=td-main>
<div class="row flex-xl-nowrap">
<div class="col-12 col-md-3 col-xl-2 td-sidebar d-print-none">
</div>
<div class="d-none d-xl-block col-xl-2 td-toc d-print-none">
</div>
<main class="col-12 col-md-9 col-xl-8 pl-md-5" role=main>
<div class=td-content>
<div class="pageinfo pageinfo-primary d-print-none">
<p>
这是本节的多页打印视图。
<a href=# onclick="return print(),!1">点击此处打印</a>.
</p><p>
<a href=/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/jvm-concurrent/java-con-practice/>返回本页常规视图</a>.
</p>
</div>
<h1 class=title>Java 并发实战</h1>
<ul>
<li>1: <a href=#pg-c1531e0f2fb35d41879bf67e731c68e6>CH01-简介</a></li>
<li>2: <a href=#pg-c6afc2fb93740f63a78a4219f372c149>CH02-线程安全性</a></li>
<li>3: <a href=#pg-865029e0f0337f3b143056ed6e079db4>CH03-对象共享</a></li>
<li>4: <a href=#pg-9f6825bf562acd8b247cf517233cbbfc>CH04-对象组合</a></li>
<li>5: <a href=#pg-8b4a307e1ad6bded17f168b1dc6154b3>CH05-基础构建块</a></li>
<li>6: <a href=#pg-229d8c951e541a78268751629a09c23c>CH06-任务执行</a></li>
<li>7: <a href=#pg-17b3a37a702dffa06994fadaf5e04650>CH07-取消关闭</a></li>
<li>8: <a href=#pg-6323673bcab4aaf5bae0fd2fb26ec7df>CH08-线程池</a></li>
<li>9: <a href=#pg-ee31a489e60b7eb53487aea1f8b19250>CH09-GUI应用</a></li>
<li>10: <a href=#pg-c7824454c2c5b68a1a276860c2a3d769>CH10-活跃性危险</a></li>
<li>11: <a href=#pg-af9981d14338576c7a49dd8987440644>CH11-性能与伸缩</a></li>
<li>12: <a href=#pg-6feac954c9d43e334e5b483468c245c4>CH12-测试</a></li>
<li>13: <a href=#pg-5362a9725228190e36f82efd5628981c>CH13-显式锁</a></li>
<li>14: <a href=#pg-3eb4fd5dd1e91653a446b51ef13a16f9>CH14-自定义扩展</a></li>
<li>15: <a href=#pg-0f6189a0f6b1890e973a603e114094a4>CH15-原子与非阻塞同步</a></li>
<li>16: <a href=#pg-1e8879bd4c4535a8d4a95fb00a603a9c>CH16-内存模型</a></li>
</ul>
<div class=content>
</div>
</div>
<div class=td-content>
<h1 id=pg-c1531e0f2fb35d41879bf67e731c68e6>1 - CH01-简介</h1>
<p>线程是 Java 语言中不可或缺的重要功能，它们能使复杂的异步代码更加简单，从而极大简化复杂系统的开发。此外，要想充分发挥多处理器的强大计算能力，最简单的方式就是使用线程。</p>
<h2 id=11-并发简史>1.1 并发简史</h2>
<p>操作系统的出现使得计算机每次能运行多个程序，并且不同的程序都在单独的进程中运行：“操作系统为各个独立执行的进程分配各种资源，包括内存、文件句柄及安全证书等。”如果需要的话，在不同的进程之间可以通过一些粗粒度的通信机制来交换数据，包括：套接字、信号处理器、共享内存、信号量及文件等。</p>
<p><strong>在计算机中加入操作系统来实现多个程序的同时执行</strong>，主要是为了：</p>
<ul>
<li><strong>资源利用率</strong>。如果在等待某些外部输入的同时能够运行另一个程序，可以提高资源的利用率。</li>
<li><strong>公平性</strong>。高效的运行方式是通过粗粒度的时间片使多个用户能够共享计算机资源，而不是由一个程序运行到尾、然后再启动另一个程序。</li>
<li><strong>便利性</strong>。通常在计算多个任务时应该编写多个程序，每个程序执行一个任务并在必要时进行互相通信，这比仅编写一个程序来计算所有任务来说要更容易实现。</li>
</ul>
<p>在早期的“分时系统”中，每个进程相当于一台“虚拟的”冯诺依曼计算机，它拥有存储指令和数据的内存空间，根据机器语言的语义以串行方式执行指令，并通过一组 IO 指令与外部设备通信。对于每条被执行的指令，都有相应的“下一条指令”，程序中的“控制流”是按照指令集的规则来确定的。当前，几乎所有的主流编程语言都遵循这种“串行编程模型”，并且在这些语言的规范中也都清晰定义了在某个动作之后需要执行的“下一个动作”。</p>
<p>“串行编程模型”的优势在于其直观性和简单性，因为它模仿了人类的工作方式：每次只做一件事情，做完之后再做下一件。在编程语言中，这些现实世界的动作可以被进一步抽象为一组更细粒度的动作。例如，喝早茶的动作可以被进一步细化：打开橱柜，挑选喜欢的茶叶，将一些茶叶倒入杯中，看看茶壶中是否有足够的水，如果没有的话则添加足够的水，将茶壶放到火炉上，点燃火炉，然后等水烧开等等。在最后一步等水烧开的过程中包含了一定程度的“异步性”。当正在烧水时，你可以干等着，也可以做些其他事情，例如开始烤面包(这是一个异步任务)或者看报纸，同时留意茶壶中的水是否已经烧开。茶壶和面包机的生产商都很清楚：用户通常会采用异步方式来使用他们的产品，因此当这些机器完成任务时都会发出声音提示。“但凡做事高效的人，总能在串行性和异步性之间找到合理的平衡，对于程序来说同样如此。”</p>
<p>“这些促使进程出现的因素(资源利用率、公平性、便利性)同样也促使着线程的出现”。“线程允许在同一个进程内同时存在多个程序控制流”。线程会共享进程范围内的资源，但每个线程都有各自的程序计数器、栈、局部变量。线程还提供了一种直观的“分解模式”来充分利用多处理器系统中的“硬件并行性”，而在同一个程序中的多个线程也可以同时被“调度”到多个 CPU 上运行。</p>
<p>“线程被称为轻量级进程”。在大多数现代操作系统中，都是以线程为基本的“调度单位”，而不是进程。如果没有明确的“(线程间的)协同机制”，那么线程将彼此独立的运行。由于同一个进程中的所有线程都将共享进程的内存地址，因此这些线程都能访问相同的变量，并在同一个堆上分配对象，这就需要一种比在进程间共享数据粒度更细的“数据共享机制”。如果没有明确的“同步机制”来协同对共享数据的访问，那么当一个线程正在使用变量时，另一个线程可能同时访问这个变量，这将造成不可预测的结果。</p>
<h2 id=12-线程的优势>1.2 线程的优势</h2>
<p>如果使用得当，线程可以有效降低程序的开发和维护成本，同时提升应用程序的性能。“线程能够将大部分的异步工作流转换为串行工作流”，因此能够更好的模拟人类的工作和交互方式。此外，线程还可以降低代码的复杂度，使代码更容易编写、阅读、维护。</p>
<p>在 GUI 程序中，线程可以提供用户界面的响应灵敏度。而在服务器应用程序中，可以提升资源利用率及系统吞吐量。线程还可以简化 JVM 的实现，垃圾收集器通常在一个或多个专门的线程中运行。在许多重要的 Java 程序中，都在一定程度上使用了线程。</p>
<h3 id=121-发挥多处理器的强大能力>1.2.1 发挥多处理器的强大能力</h3>
<p>过去，多处理器系统是非常昂贵和稀少的，通常只有在大型数据中心和科学计算设备中才会使用多处理器系统。但现在，多处理器系统整日益普及，并且价格也在不断的降低，即使在底端服务器和中端桌面系统中，通常也会采用多个处理器。这种趋势还将进一步加快，因为通过提高时钟频率来提升性能已变得越来越困难，处理器生产厂商都开始转而在单个芯片上放置多个处理器核心。所有的主流芯片厂商都开始了这种转变，而我们已经看到了在一些机器上出现了更多的处理器。</p>
<p>由于基本的调度单位是线程，因此如果在程序中只有一个线程，那么最多同时只能在一个处理器上运行。在双处理器系统上，单线程的程序只能使用一半的 CPU 资源，而在拥有 100 个处理器的系统上，将有 99% 的资源无法使用。另一方面，多线程程序可以同时在多个处理器上执行。如果设计正确，多线程程序可以通过提高处理器资源利用率来提升系统吞吐率。</p>
<p>使用多个线程还有助于在单处理器系统上获得更高的吞吐率。如果程序是单线程的，那么当程序等待某个同步 IO 操作完成时，处理器将处于空闲状态。而在多线程程序中，如果一个线程在等待 IO 操作完成，另一个线程可以继续运行，使得程序能够在 IO 阻塞期间继续运行。(这就好比在等待烧水的同时看报纸，而不是等到水烧开之后再开始看报纸)</p>
<h3 id=122-建模的简单性>1.2.2 建模的简单性</h3>
<p>通常，当只需要执行一种类型的任务时，在时间管理方面比执行多种类型的任务要简单。当只有一种类型的任务需要完成时，只需要埋头工作，直到完成所有的任务，你不需要花任何精力来琢磨下一步该干什么。而另一方面，如果需要完成多种类型的任务，那么需要管理不同任务之间的优先级和执行时间，并在任务之间进行切换，这将带来额外的开销。</p>
<p>对于软件来说同样如此：如果在程序中仅包含一种类型的任务，那么比包含多种不同类型的任务的程序要更易于编写，错误更少，也更容易测试。如果为模型中每种类型的任务都分配一个专门的线程，那么可以形成一种串行执行的假象，并将程序的执行逻辑与调度机制的细节、交替执行的操作、异步 IO、资源等待等问题分类出来。通过使用线程，可以将复杂并且异步的工作流进一步分解为一组简单且同步的工作流，每个工作流在一个单独的线程中运行，并在特定的同步位置进行交互。</p>
<p>我们可以通过一些现有的框架来实现上述目标，例如 Servlet 和 RMI。框架负责解决一些细节问题，例如请求管理、线程创建、负载均衡，并且在正确的时刻将请求分发给正确的应用线程组件。编写 Servlet 的开发任务不需要了解有多少请求在同一时刻要被处理，也不需要了解套接字的输入输出流是否被阻塞。当调用 Servlet 的 service 方法来响应 Web 请求时，可以以同步的方式来处理这个请求，就好像它是一个单线程程序。这种方式可以简化组件的开发，并缩短掌握这种框架的学习时间。</p>
<h3 id=123-异步事件的简化处理>1.2.3 异步事件的简化处理</h3>
<p>服务器应用程序在接收来自多个远程客户端的套接字连接请求时，如果为每个连接都分配其各自的线程且使用同步 IO，那么会降低这类程序的开发难度。</p>
<p>如果某个应用程序对套接字执行读操作，而此时还没有数据到来，那么这个读操作将一直阻塞到有数据抵达。在单线程程序中，这不仅意味着在处理请求的过程中停顿，而且还意味着在该线程被阻塞期间，对所有请求的处理都将停顿。为了避免这个问题，单线程服务器应用程序必须使用非阻塞 IO，这种 IO 的复杂性要远远高于同步 IO，并且很容易出错。然而，如果每个请求都拥有自己的处理线程，那么在处理某个请求时发生的阻塞将不会影响其他请求的处理。</p>
<p>早期的操作系统通常会将进程中可创建的线程数量限制在一个较低的阈值内，大约在数百个甚至更少。因此，操作系统提供了一些高效的方法来实现多路 IO，例如 Unix 的的 select 和 poll 等系统调用，要调用这些方法，Java 类库需要获得一组实现非阻塞 IO 的包(java.nio)。然而，在现代操作系统中，线程数量已经得到极大的提升，这使得在某些平台上，即使有更多的客户端，为每个客户分配一个线程也是可行的。</p>
<h3 id=124-响应灵敏的用户界面>1.2.4 响应灵敏的用户界面</h3>
<p>传统的 GUI 程序都是单线程的，从而在代码的各个位置都需要调用 poll 方法来获得输入事件(这种方式将给代码带来极大的混乱)，或者通过一个“主事件循环”来间接的执行应用程序的所有代码。如果在主事件循环中调用的代码需要很长时间才能执行完成，那么用户界面就会“冻结”，直到代码执行完成。这是因为只有当执行控制权返回到主事件循环后，才能处理后续的用户界面事件。</p>
<p>在现代的 GUI 框架中，例如 AWT 和 Swing 等工具，都采用一个事件分发线程来替代主事件循环。当某个用户界面事件发生时(如按下一个按钮)，在事件线程中将调用应用程序的事件处理器。由于大多数 GUI 框架都单线程子系统，因此到目前为止仍然存在主事件循环，但其它线程处于 GUI 工具的控制下并在其自己的线程中运行，而不是在应用程序的控制下。</p>
<p>如果在事件线程中执行的任务都是短暂的，那么界面的响应灵敏度就较高，因为事件线程很够很快的处理用户的动作。然而，如果事件线程中的任务需要很长的执行时间，例如对一个大型文档进行拼写检查，或者从网络上获得一个资源，那么界面的响应灵敏度就会降低。如果用户在执行这类任务时触发了某个动作，那么必须等待很长时间才能获得响应，因为事件线程要先执行完该任务。更糟糕的是，不仅界面失去响应，而且即使在界面上包含了“取消”按钮，也无法取消这个长事件执行的任务，因为事件线程只有在执行完该任务后才能响应“取消”按钮的点击事件。然而，如果将这个长时间运行的任务放在一个单独的线程中运行，那么事件线程就能及时的处理其他界面事件，从而使得用户界面具有更高的灵敏度。</p>
<h2 id=13-线程带来的风险>1.3 线程带来的风险</h2>
<p>Java 对线程的支持其实是一把双刃剑。虽然 Java 提供了相应的语言和库，以及一种明确的“跨平台内存模型”，这些工具简化了并发应用程序的开发，但同时也提高了对开发人员的技术要求，因为在更多的程序中会使用线程。当线程还是一项鲜为人知的技术时，并发性是一个“高深的”话题，但现在，主流开发任务都必须了解线程方面的内容。</p>
<h3 id=131-安全性问题>1.3.1 安全性问题</h3>
<p>线程安全性是非常复杂的，在没有充分同步的情况下，多个线程中的操作执行顺序是不可预测的，甚至会产生奇怪的执行结果。如程序清单 1-1 的 UnsafeSequence 类中将产生一个整数值序列，该序列中的每个值都是唯一的。在这个类中简要说明了多个线程间的交替操作将如何导致出乎预料的结果。在单线程环境中，这个类能够正常工作，但在多线程环境中则不行。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#5c35cc;font-weight:700>@NotThreadSafe</span>
<span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>UnsafeSequnce</span> <span style=color:#ce5c00;font-weight:700>{</span>
  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>value</span><span style=color:#ce5c00;font-weight:700>;</span>
  
  <span style=color:#8f5902;font-style:italic>/* 返回一个唯一的数值 */</span>
  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>getNext</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>value</span><span style=color:#ce5c00;font-weight:700>++;</span>
  <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>UnsafeSequnce 的问题在于，如果执行时机不对，那么两个线程在调用 getNext 时会得到相同的值。在图 1-1 中给出了这种错误情况。虽然递增运算 <code>someVariable++</code> 看上去是单个操作，但事实上包含 3 个独立的操作：读取 value、将 value 加一、将结果写入 value。由于运行时可能将多个线程之间的操作交替执行，因此这两个线程可能同时执行读操作，从而使他们得到相同的值，并都将该值加 1。结果就是，在不同线程中的调用返回了相同的数值。</p>
<div align=center>
<img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20181117225555.png style=display:block;width:70% alt=1-1 align=center>
</div>
<p>在 UnsafeSequnce 中使用了一个非标准的注解：<code>@NotThreadSafe</code>。这是在本书中使用的几个自定义注解之一，用于说明类和成员的并发属性。线程安全性注解在许多方面都是有用的。如果使用 @ThreadSafe 类标注某个类，那么开发人员可以放心的在多线程环境中使用该类，维护人员也会发现它能保证线程安全性，而软件分析工具还可以识别出潜在的编码错误。</p>
<p>在 UnsafeSequnce 类中说明的是一种常见的并发安全问题，称为竟态条件(Race Condition)。在多线程环境下，getValue 是否返回唯一的值，要取决于运行时对线程中操作的交替执行方式，这并不是我们希望看到的情况。</p>
<p><strong>由于多线程有共享相同的内存地址空间，并且是并发运行，因此它们可能会访问或修改其他线程正在使用的变量。当然，这是一种极大的便利，因为这种方式比其他线程间通信机制更容易实现数据共享。但它同样也带来的巨大的风险：线程会由于无法预料的数据变化而发生错误。当多个线程同时访问和修改相同的变量时，将会在串行模型编程中引入非串行因素，而这种非串行性是很难分析的。要使多线程程序的行为可以被预测，必须对共享变量的访问操作进行协同，这样才不会在线程之间发生彼此干扰。幸运的是，Java 提供了各种同步机制来协同这种访问。</strong></p>
<p>通过将 getNext 修改为一个同步方法，可以修复 UnsafeSequnce 中的错误，如程序清单 1-2 中的 Sequnce，该类可以防止图 1-1 中错误的交替执行情况。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#5c35cc;font-weight:700>@ThreadSafe</span>
<span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>Sequence</span> <span style=color:#ce5c00;font-weight:700>{</span>
  <span style=color:#5c35cc;font-weight:700>@GuardedBy</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#4e9a06>&#34;this&#34;</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>value</span><span style=color:#ce5c00;font-weight:700>;</span>
  
  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>synchronized</span> <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>getNext</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>value</span><span style=color:#ce5c00;font-weight:700>++;</span>
  <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>如果没有同步，那么无论是“编译器、硬件、运行时”，都可以随意安排操作的执行时间和顺序，例如对寄存器或处理器中的变量进行缓存，而这些被缓存的变量对于其他线程来说是暂时的(甚至永久)不可见的。虽然这些技术有助于实现更优的性能，并且通常也是值得采用的方法，但这也给开发人员带来了负担，因为开发人员必须找出这些数据在那些位置被多个线程共享，只有这样才能使这些优化措施不破坏线程安全性。</p>
<h3 id=132-活跃性问题>1.3.2 活跃性问题</h3>
<p>在编写并发代码时，一定要注意线程安全性是不可破坏的。安全性不仅对于多线程程序很重要，对于单线程程序也是如此。此外，线程还会导致一些在单线程程序中不会出现的问题，比如活跃性问题。</p>
<p>安全性的含义是“永远不发生糟糕的事情”，而活跃性则关注于另一个目标，即“某件正确的事情最终会发生”。当某个操作无法继续执行下去时，就会发生活跃性问题。在串行程序中，活跃性问题的形式之一就是无意中造成的无限循环，从而使循环之后的代码无法得到执行。线程将到来其他一些活跃性问题。如，如果线程 A 在等待线程 B 释放其持有的资源，而线程 B 永远都不释放该资源，那么 A 就会永久的等待下去。与大多数并发性错误一样，导致活跃性问题的错误同样是难以分析的，因为它们依赖于不同线程的事件发生时序，因此在开发或测试中并不总是能够重现。</p>
<h3 id=133-性能问题>1.3.3 性能问题</h3>
<p>与活跃性密切相关的是性能问题。活跃性意味着某件正确的事情最终会发生。但这还不够好，我们通常希望正确的事情尽快发生。性能问题包括多个方面，如服务时间过长、响应不够灵敏、吞吐率过低、资源消耗过高、可伸缩性较低等。与安全性和活跃性一样，在多线程程序中不仅存在与单线程程序相同的性能问题，而且还存在由于使用线程而引入的其他性能问题。</p>
<p>在设计良好的并发程序中，线程能够提升程序的性能，但无论如何，线程总会带来某种程度的运行时开销。在多线程程序中，当线程调度器临时挂起活跃线程转而运行另一个线程时，就会频繁的出现上下文切换，这种操作将带来极大的开销：保存和恢复执行上下文、丢失现场，并且 CPU 时间将更多的花在线程调度而不是线程运行上。当线程共享数据时，必须使用同步机制，而这些机制往往会抑制某些编译器优化，使内存缓存区中的数据无效，以及增加共享内存总线的同步流量。所有这些因素都将带来额外的性能开销。</p>
<h2 id=14-线程无处不在>1.4 线程无处不在</h2>
<p>即使在程序中没有显式的创建线程，但在框架中人可能会创建线程，因此在这些线程中调用的代码同样必须是线程安全的。这将给开发人员在设计和实现上带来沉重负担，因为开发线程安全的类比开发非线程安全的类需要更加谨慎和细致。</p>
<p>每个 Java 程序都会使用线程。当 JVM 启动时，它将为 JVM 的内部任务(如垃圾回收、终结操作)创建后台线程，并创建一个主线程来运行 main 方法。AWT 和 Swing 的用户界面框架将创建线程来管理用户界面事件。Timer 将创建线程来执行延时任务。一些组件框架，如 Servlet 和 RMI，都会创建线程池并调用这些线程中的方法。</p>
<p>如果要使用这行功能，那么就必须熟悉并发性和线程安全性，因为这些框架将创建线程并且在这些线程中调用程序中的代码。虽然将并发性认为是一种“可选的”或“高级的”语言功能固然很理想，但现实情况是，几乎所有的 Java 程序都是多线程的，因此在使用这些框架时仍然需要对应用程序状态的访问进行协同。</p>
<p>当某个框架在应用程序中引入并发性时，通常不可能将并发性仅仅局限于框架代码，因为框架本身会回调应用程序代码，而这些代码将访问应用程序的状态。同样，对线程安全性的需求也不能局限于被调用的代码，而是要延伸到需要访问这些代码所访问的程序状态的所有代码路径。因此，对线程安全性的需求将在程序中蔓延开来。</p>
<p>下面给出的模块都将在应用程序之外的线程中调用应用程序的代码。尽管线程安全性需求可能源自这些模块，但却不会止步于它们，而是会延伸到整个应用程序。</p>
<p>Timer。Timer 类的作用是使任务在稍后的时刻运行，运行一次或周期性的运行。引入 Timer 可能会使串行程序变得复杂，因为 TimerTask 访问了应用程序中其他线程访问的数据，那么不仅 TimerTask 需要以线程安全的方式来访问数据，其他类也必须采用线程安全的方式来访问该数据。通常，要实现这个目标，最简单的方式是确保 TimerTask 访问的对象本身是线程安全的，从而就能把线程安全性封装在共享对象内部。</p>
<p>Servlet 和 JSP。Servlet 框架用于部署网页应用程序以及分来来自 HTTP 客户端的请求。到达服务器的请求可能会通过一个过滤器链被分发到正确的 Servlet 或 JSP。每个 Servlet 都表示一个程序逻辑组件，在高吞吐率的网站中，多个客户端可能同时请求一个 Servlet 的服务。在 Servlet 规范中，Servlet 同样需要满足被多个线程同时调用，换句话说，Servlet 需要是线程安全的。</p>
<p>即使你可以确保每次只有一个线程调用某个 Servlet，但在构建网页应用程序时仍然必须注意线程安全性。Servlet 通常会访问与其他 Servlet 共享的信息，例如应用程序中的对象或者会话中的对象。当一个 Servlet 访问在多个 Servlet 或者请求中共享的对象时，必须正确的协同对这些对象的访问，因为多个请求可能在不同的线程中同时访问这些对象。Servlet 和 JSP，以及在 ServletContext 和 HttpSession 等容器中保存的 Servlet 过滤器和对象等，都必须是线程安全的。</p>
<p>远程方法调用，RMI。RMI 使代码能够调用位于其他 JVM 中运行的对象。当通过 RMI 调用某个远程方法时，传递给方法的参数必须被打包到一个字节流中，通过网络传输给远程 JVM，然后由远程 JVM 拆包并传递给远程方法。</p>
<p>当 RMI 代码调用远程对象时，这个调用将在哪个线程中执行？你并不知道，但肯定不会在你创建的线程中，而是将在一个由 RMI 管理的线程中调用对象。RMI 会创建多给少个线程？同一个对象上的同一个远程方法会不会在多个 RMI 线程中被同时调用？</p>
<p>远程对象必须注意两个线程安全性问题：正确的协同在多个对象中共享的状态，以及对远程对象本身状态的访问。与 Servlet 相同，RMI 对象应用做好被多个线程同时调用的准备，并且必须确保它们自身的线程安全性。</p>
<p>Swing 和 AWT。GUI 程序的一个固有属性就是异步性。用户可以在任何时刻选择执行一个菜单项或按下一个按钮，应用程序会及时响应，即使应用程序当时正在执行其他的任务。Swing 和 AWT 很好的解决了这个问题，他们创建了一个单独的线程来处理用户触发的事件，并对呈现给用户的图形界面进行了更新。</p>
<p>Swing 的一些组件并不是线程安全的，例如 JTable。相反，Swing 程序通过将所有对 GUI 组件的访问局限在事件线程以实现线程安全性。如果某个程序希望在事件线程之外控制 GUI，那么必须将控制 GUI 的代码放在事件线程中运行。</p>
<p>当用户触发某个 UI 动作时，在事件线程中就会有一个事件处理器被调用以执行用户请求的操作。如果事件处理器需要访问由其他线程同时访问的应用程序状态，那么这个事件处理器，以及访问这个状态的所有其他代码，都必须采用一种线程安全的方式来访问该状态。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-c6afc2fb93740f63a78a4219f372c149>2 - CH02-线程安全性</h1>
<p>你或许会感到奇怪，线程或锁在并发编程中的作用，类似于铆钉和工字梁在土木工程中的作用。要建造一座坚固的桥梁，必须正确的使用大量的铆钉和工字梁。同理，在构件稳健的并发程序时，必须正确的使用线程和锁。但这些终归是一些机制。要编写线程安全的代码，“其核心在于对状态访问操作进行管理，特别是对共享的可变状态的访问”。</p>
<p>从非正式的意义上来说，对象的状态是存储在状态变量中的数据。对象的状态可能包括其他依赖对象的域。例如，HashMap 的状态不仅存储在 HashMap 对象本身，还存储在 Map.Entry 对象中。对象的状态中包含了任何可能影响其外部可见行为的数据。</p>
<p>“共享”意味着变量可以被多个线程同时访问，而“可变”则意味着变量的值在其声明周期内可以发生变化。我们将像讨论代码一样来讨论线程安全性，但更侧重于如何防止在数据上发生不受控的并发访问。</p>
<p>一个对象是否需求提供线程安全性，取决于它是否会被多个线程访问。这指的是在程序中访问对象的方式，而不是对象要实现的功能。要使得对象是线程安全的，需要采用同步机制来协同对对象可变状态的访问。如果无法实现协同，那么可能会导致数据破坏以及其他不该出现的结果。</p>
<p>当多个线程访问某个状态变量并且其中有一个线程执行写入操作时，必须采用同步机制来协同这些线程对变量的访问。Java 中的主要同步机制是关键字 synchronized，它提供了一种独占的加锁方式，但“同步”这个术语还包括 volatile 类型的变量、显式锁、原子变量。</p>
<p>在上述规则中并不存在一些“想象中的例外情况”。即使在某个程序中省略了必要的同步机制并且看上去似乎能正确执行，而且通过了测试并在随后几年时间里都能正确运行，但程序仍可能在某个时刻发生错误。</p>
<blockquote>
<p>如果当多个线程访问同一个可变状态变量时没有使用合适的同步，那么程序会出现错误。有三种方式可以修复这个问题：</p>
<ol>
<li>不在线程之间共享该状态变量。</li>
<li>将状态变量修改为不可变变量。</li>
<li>在访问状态变量时使用同步。</li>
</ol>
</blockquote>
<p>如果在设计类的时候没有考虑并发访问的情况，那么在采用上述方法时可能需要对设计进行重大修改，因此要修复这个问题可谓是知易行难。如果从一开始就设计一个线程安全的类，那么比在以后再将这个类修改为线程安全的类要容易的多。</p>
<p>在一些大型程序中，要找出多个线程在哪些位置上将访问同一个变量是非常复杂的。幸运的是，面向对象这种技术不仅有助于编写出结构优雅、可维护性高的类，还有助于编写出线程安全的类。访问某个变量的代码越少，就越容易确保对变量的所有访问都正确的实现了同步，同时也更容易找出变量在哪些条件下被访问。Java 语言并没有强制要求将状态都封装在类中，开发人员完全可以将状态保存在某个公开的域(甚至是公开的静态域)中，或者提供一个对内部对象的公开引用。然而，程序状态的封装性越好，就越容易实现程序的线程安全性，并且代码的维护人员也越容易保持这种方式。</p>
<blockquote>
<p>当设计线程安全的类时，良好的面向对象技术、不可修改性，以及明晰的不变性规范都能起到一定的帮助作用。</p>
</blockquote>
<p>在某些情况下，良好的面向对象设计技术与实际的需求并不一致。在某些情况下，可能需要牺牲一些良好的设计原则，以换取性能或者对遗留代码的向后兼容性。有时候，面向对象中的抽象和封装会降低程序的性能，但是在编写并发应用程序时，一种正确的编程方法就是：“首先使代码正确运行，然后再提高代码的运行速度”。即便如此，最好也只是当性能测试结果和应用需求告诉你必须提高性能，以及测量结果表明这种优化在实际环境中确实能够带来提升时，才进行优化。</p>
<p>如果你必须打破封装，那么也并非不可，你仍然可以实现程序的线程安全性，只是更困难。而且，程序的线程安全性将更加脆弱，不仅增加了成本和风险，而且也增加了维护的成本和风险。</p>
<p>到目前为止，我们使用了“线程安全类”和“线程安全程序”两个术语，二者的含义基本相同。线程安全的程序是否完全由线程安全的类构成？答案是否定的，完全由线程安全的类构成的程序并不一定是一个线程安全的程序，而在线程安全的程序中也可以包含非线程安全的类。在任何情况下，“只有当类中仅包含自己的状态时，线程安全类才是有意义的”。线程安全性是一个在代码上使用的术语，但它只是与状态相关的，因此只能应用于封装其状态的整个代码，这可能是一个对象，也可能是整个程序。</p>
<h2 id=21-什么是线程安全性>2.1 什么是线程安全性</h2>
<p>要对线程安全性给出一个确切的定义是非常复杂的。定义越正式，就越复杂，不仅很难提供有实际意义的指导建议，而且也很难从直观上去理解。因此，下面给出了一些非正式的描述，看上去令人困惑。比如：</p>
<ul>
<li>……可以在多个线程中调用，并且在线程之间不会出现错误的交互。</li>
<li>……可以同时被多个线程调用，而调用者无需执行额外的同步动作。</li>
</ul>
<p>看看这些定义，难怪我们会对线程安全性感到困惑。他们听起来非常像“如果这个类可以在线程中安全的使用，那么他就是一个线程安全的类”。对于这种说法，虽然没有太多的争议，但同样也不会带来太多的帮助。我们如何区分线程安全的类以及非线程安全的类？进一步说，“安全”的含义是什么？</p>
<p>在线程安全性的定义中，最核心的概念是正确性。如果对线程安全的定义是模糊的，那么就是因为缺乏对正确性的清晰定义。</p>
<p>“正确性的定义是，某个类的行为与其规范完全一致”。在良好的规范中通常会定义各种不变性条件来约束对象的状态，以及定义各种后验条件来描述对象操作的结果。由于我们通常不会对类编写详细的规范，那么如何知道这些类是正确的呢？我们无法知道，但这并不妨碍我们在确信“类的代码能够工作”后使用它们。这种“代码可信性”非常接近于我们对正确性的理解，因此我们可以将单线程的正确性近似定义为“所见即所得”。在对“正确性”给出一个较为清晰的定义后，就可以定义线程安全性：“当多个线程访问某个类时，这个类始终都能表现出正确的行为，那么就称这个类是线程安全的。”</p>
<blockquote>
<p>当多个线程访问某个类时，不管运行时环境采用何种调度方式或者这些线程将如何交替执行，并且在主调代码中不需要任何额外的同步或协同，这个类都能表现出正确的行为，那么就称这个类是线程安全的。</p>
</blockquote>
<p>由于单线程程序也可以被看成是一个多线程程序，如果某个类在单线程环境中都不是正确的，那么它肯定也不是线程安全的。如果正确的实现了某个对象，那么在任何操作中(包括调用对象的公有方法或者对其公有域进行读写操作)都不会违背不变性条件或后验条件。在线程安全类的对象实例上执行的任何串行或并行操作都不会使对象处于无效状态。</p>
<blockquote>
<p>在线程安全类中封装了必要的同步机制，因此客户端无需进一步采取同步措施。</p>
</blockquote>
<h3 id=示例一个线程安全的-servlet>示例：一个线程安全的 Servlet</h3>
<p>我们在第一章中列出了一组框架，其中每个框架都能创建多个线程并在这些线程中调用你编写的代码，因此你需要保证编写的代码是线程安全的。通常，线程安全性的需求并非来源于线程的直接调用，而是使用像 Servlet 这样的框架。我们来看一个简单的示例——一个基于 Servlet 的因数分解服务，并逐渐扩展它的功能，同时确保它的线程安全性。</p>
<p>程序清单 2-1 给出了一个简单的因素分解 Servlet。这个 Servlet 从请求中提取出数值，执行因数分解，然后将结果封装到该 Servlet 的响应中。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#5c35cc;font-weight:700>@ThreadSafe</span>
<span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>StatelessFactorizer</span> <span style=color:#204a87;font-weight:700>implements</span> <span style=color:#000>Servlet</span> <span style=color:#ce5c00;font-weight:700>{</span>
  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>service</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>ServletRequest</span> <span style=color:#000>req</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>ServletResponse</span> <span style=color:#000>resp</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#000>BigInteger</span> <span style=color:#000>i</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>extractFromRequest</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>req</span><span style=color:#ce5c00;font-weight:700>);</span>
    <span style=color:#000>BigInteger</span><span style=color:#ce5c00;font-weight:700>[]</span> <span style=color:#000>factors</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>factor</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>i</span><span style=color:#ce5c00;font-weight:700>);</span>
    <span style=color:#000>encodeIntoResponse</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>resp</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>factors</span><span style=color:#ce5c00;font-weight:700>);</span>
  <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>与大多数 Servlet 相同，StatelessFactorizer 是无状态的：它既不包含任何域，也不包含任何对其他类的域的引用。计算过程中的临时状态仅存在于线程栈上的局部变量中，并且只能由正在执行的线程访问。访问 StatelessFactorizer 的线程不会影响另一个访问同一个 StatelessFactorizer 的线程的计算结果，因为这两个线程并没有共享状态，就好像它们都在访问不同的实例。由于线程访问无状态对象的行为不会影响其他线程中操作的正确性，因此无状态对象是线程安全的。</p>
<blockquote>
<p>无状态对象一定是线程安全的。</p>
</blockquote>
<p>大多数 Servlet 都是无状态的，从而极大降低了在实现 Servlet 线程安全性时的复杂性。只有当 Servlet 在处理请求时需要保存一些信息，线程安全性才会成为一个问题。</p>
<h2 id=22-原子性>2.2 原子性</h2>
<p>当我们在无状态对象中增加一个状态时，会出现什么状况？假设我们希望增加一个“命中计数器”来统计所处理的请求数量。一种直观的方法是在 Servlet 中增加一个 long 类型的域，并且每处理一个请求就将该值加 1，如程序清单 2-2 所示：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#5c35cc;font-weight:700>@NotThreadSafe</span>
<span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>UnsafeCountingFactorizer</span> <span style=color:#204a87;font-weight:700>implements</span> <span style=color:#000>Servlet</span> <span style=color:#ce5c00;font-weight:700>{</span>
  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>long</span> <span style=color:#000>count</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>0</span><span style=color:#ce5c00;font-weight:700>;</span>
  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>long</span> <span style=color:#000>getCount</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span> <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>count</span><span style=color:#ce5c00;font-weight:700>;</span> <span style=color:#ce5c00;font-weight:700>}</span>
  
  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>service</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>ServletRequest</span> <span style=color:#000>req</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>ServletResponse</span> <span style=color:#000>resp</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#000>BigInteger</span> <span style=color:#000>i</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>extractFromRequest</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>req</span><span style=color:#ce5c00;font-weight:700>);</span>
    <span style=color:#000>BigInteger</span><span style=color:#ce5c00;font-weight:700>[]</span> <span style=color:#000>factors</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>factor</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>i</span><span style=color:#ce5c00;font-weight:700>);</span>
    <span style=color:#ce5c00;font-weight:700>++</span><span style=color:#000>count</span><span style=color:#ce5c00;font-weight:700>;</span>
    <span style=color:#000>encodeIntoResponse</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>factors</span><span style=color:#ce5c00;font-weight:700>);</span>
  <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>不幸的是，UnsafeCountingFactorizer 并非是线程安全的，尽管它在单线程环境中能正确运行。与前面的 UnsafeSequence 一样，这个类很可能会丢失一些更新操作。虽然递增操作 <code>++count</code> 是一种紧凑的语法，使其看上去只是一个操作，但是该操作并非是原子的，因而它并不会作为一个不可分割的操作来执行。实际上，它包含了三个独立的操作：读取 count 值、将值加 1、然后将计算结果写入 count。这是一个“读取——修改——写入”的操作序列，并且其结果状态依赖于之前的状态。</p>
<p>图 1-1 给出了两个线程在没有同步的情况下同时对一个计数器执行递增操作时发生的情况。如果计数器的初始值为 9，那么在某些情况下，每个线程读到的值都为 9，接着执行递增操作，并且都将计数器的值设为 10。显然，这并不是我们希望看到的结果，如果有一次递增操作丢失了，命中计数器的值就将偏差 1。</p>
<p>你可能会认为，在基于 Web 的服务中，命中计数器的少量偏差或许是可以接受的，在某些情况下也确实如此。但如果计数器被用来生成数值序列或唯一的对象标识符，那么在多次调用中返回相同的值将导致严重的数据完整性问题。在并发编程中，这种由于不恰当的执行时序而出现不正确结果是一种非常重要的情况，他有一个正式的名字：竟态条件。</p>
<h3 id=221-竟态条件>2.2.1 竟态条件</h3>
<p>在 UnsafeCountingFactorizer 中存在多个竟态条件，从而使结果变得不可靠。当某个计算的正确性取决于多个线程的交替执行时序时，那么就会出现竟态条件。换句话说，就是正确的结果要取决于运气。最常见的竟态条件类型是“先检查后执行(Check-Then-Act)”操作，即通过一个可能失效的观测结果来决定下一步的动作。</p>
<p>在实际情况中经常会遇到竟态条件。例如，假定你计划中午在 University Avenue 的星巴克与一位朋友烩面。但当你达到那里时，发现在 University Avenue 上有两家星巴克，并且你不知道约定的是哪一家。在 12:10 时，你没有在星巴克 A 看到朋友，那么就会去星巴克 B 看看他是否在那里，但他也不在那里。这有几种可能：你的朋友迟到了，还没有抵达任何一家星巴克；你的朋友在你离开后到了星巴克 A；你的朋友在星巴克 B，但是当它去星巴克 A 找你时，你此时正在赶往星巴克 B 的途中。我们假设的最后一种情况最为糟糕。现在是 12:15，你们两个都去过了两家星巴克，并且都开始怀疑对方失约了。现在你会怎么做？回到另一家星巴克？来来回回要走多少次？除非你们之间约定了某种协议，否则你们整天都在 University Avenue 上走来走去，倍感沮丧。</p>
<p>在“我去看看他是否在另一家星巴克”这种方法中，问题在于：当你在街上走时，你的朋友可能已经离开了你要去的星巴克。你首先看了看星巴克 A，发现“他不在”，并且开始去找他。你可以在星巴克 B 中做同样的选择，但不是同时发生。两家星巴克之间有几分钟的路程，而就在这几分钟时间里，系统的状态可能会发生变化。</p>
<p>在星巴克这个示例中说明了一种竟态条件，因为要获得正确的结果(与朋友会面)，必须取决于事件的发生时序(当你们到达星巴克时，在离开去另一家星巴克之前会等待剁成事件……)。当你迈出前门时，你在星巴克 A 的观察结果将变得无效，你的朋友可能从后门进来了，而你却不知道。这种观察结果的失效就是大多数竟态条件的本质——“基于一种可能失效的观察结果来做出判断或者执行某个计算”。这种类型的竟态条件被称为“先检查后执行”：首先观察到某个条件为真，然后根据观察结果采用相应的动作，但事实上，在你观察到这个结果以后以及开始执行动作之前，观察结构可能变得无效，从而导致各种问题。</p>
<blockquote>
<p>竟态条件这个术语经常与另一个相关术语“数据竞争(Data Race)”相混淆。数据竞争是指，如果在访问共享的非 final 类型的域时没有采用同步来进行协同，那么就会出现数据竞争。当一个线程写入一个变量而另一个线程接下来读取这个变量，或者读取一个之前由另一个线程写入的变量时，并且在这两个线程之间没有使用同步，那么就可能出现数据竞争。在 Java 内存模型中，如果代码中存在数据竞争，那么这段代码就没有确定的语义。并非所有竟态条件都是数据竞争，同样并非所有的数据竞争都是竟态条件，但二者都可能使并发程序失败。</p>
</blockquote>
<h3 id=222-示例延迟初始化中的竟态条件>2.2.2 示例：延迟初始化中的竟态条件</h3>
<p>使用“先检查后执行”的一种常见情况就是“延迟初始化”。延迟初始化的目的是将对象的初始化操作推迟到第一次实际被使用时才进行，同时要确保只被初始化一次。在程序清单 2-3 中的 LazyInitRace 说明了这种延迟初始化情况。getInstance 方法首先判断 ExpensiveObject 是否已经被初始化，如果已经初始化则返回现有的实例，否则他将创建一个新的实例并返回一个引用，从而在后来的调用中值无需执行这段高开销的代码路径。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#5c35cc;font-weight:700>@NotThreadSafe</span>
<span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>LazyInitRace</span> <span style=color:#ce5c00;font-weight:700>{</span>
  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#000>ExpensiveObject</span> <span style=color:#000>instance</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>null</span><span style=color:#ce5c00;font-weight:700>;</span>
  
  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#000>ExpensiveObject</span> <span style=color:#000>getInstance</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#204a87;font-weight:700>if</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>instance</span> <span style=color:#ce5c00;font-weight:700>==</span> <span style=color:#204a87;font-weight:700>null</span><span style=color:#ce5c00;font-weight:700>)</span> 
      <span style=color:#000>intstance</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>ExpensiveObject</span><span style=color:#ce5c00;font-weight:700>();</span>
    <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>instance</span><span style=color:#ce5c00;font-weight:700>;</span>
  <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>LazyInitRace 中包含一个竟态条件，他可能会打破这个类的正确性。假定线程 A 和 B 同时执行 getInstance。A 看到 instance 为空，因而创建一个新的 ExpensiveObject 实例。B 同样需要判断 instance 是否为空。此时的 instance 是否为空，要取决于不可预测的时序，包括线程的调度方式，以及 A 需要花多长时间来初始化 ExpensiveObject 并设置 instance。如果当 B 检查时 instance 为空，那么在两次调用 getInstance 时可能会得到不同的结果，即使 getInstance 通常被认为是返回相同的实例。</p>
<p>在 UnsafeCountingFactorizer 的统计命中计数操作中存在另一种竟态条件。在“读取——修改——写入”这种操作中，基于对象之前的状态来定义对象状态的转换。要递增一个计数器，你必须知道它之前的值，并确保在执行更新过程中没有其他线程会修改或使用这个值。</p>
<p>与大多数并发错误一样，竟态条件并不总是会产生错误，还需要某种不恰当的执行时序。然而，竟态条件也可能导致严重的问题。假定 LazyInitRace 被用于初始化应用程序范围内的注册表，如果在多次调用中返回不同的实例，那么要么会丢失部分注册信息，要么多个执行行为对同一个组注册对象表现出不一致的视图。如果将 UnsafeSequence 用于在某个持久化框架中生成对象的标识，那么两个不同的对象最终将获得相同的标识，这就违反了标识的完整性约束条件。</p>
<h3 id=223-复合操作>2.2.3 复合操作</h3>
<p>LazyInitRace 和 UnsafeCountingFactorizer 都包含一组需要以原子方式执行(不可分割)的操作。要避免竟态条件问题，就必须在某个线程修改变量时，通过某种方式防止其他线程使用这个变量，从而确保其他线程只能在修改操作完成之前或之后读取和修改状态，从而避免在修改状态的过程中观察到失效状态。</p>
<blockquote>
<p>假定两个操作 A 和 B，如果从执行 A 的线程来看，当另一个线程执行 B 时，要么将 B 全部执行完，要么完全不执行 B，那么 A 和 B 对彼此来说是原子的。原子操作是指，对于访问同一个状态的所有操作(包括该操作本身)来说，这个操作是一个以原子方式执行的操作。</p>
</blockquote>
<p>如果 UnsafeSequence 中的递增操作是原子操作，那么图 1-1 中的竟态条件就不会发生，并且递增操作在每次执行时都会把计数器加 1。为了确保线程安全性，“先检查后执行”和“读取—修改-写入”等操作都必须是原子的。我们将“先检查后执行”以及“读取—修改-写入”等操作统称为“复合操作”：“包含了一组必须以原子方式执行的操作以确保线程安全性”。在 2.3 节中，我们将介绍锁机制，这是 Java 中用于确保原子性的内置机制。就目前而言，我们先采用另一种凡事来修复这个问题，即使用一个现有的线程安全类，如程序清单 2-4 中的 CountingFactorizer 所示：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#5c35cc;font-weight:700>@ThreadSafe</span>
<span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>CountingFactorizer</span> <span style=color:#204a87;font-weight:700>implements</span> <span style=color:#000>Servlet</span> <span style=color:#ce5c00;font-weight:700>{</span>
  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>AtomicLong</span> <span style=color:#000>count</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>AtomicLong</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>0</span><span style=color:#ce5c00;font-weight:700>);</span>
  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>long</span> <span style=color:#000>getCount</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span> <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>count</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>get</span><span style=color:#ce5c00;font-weight:700>();</span> <span style=color:#ce5c00;font-weight:700>}</span>
  
  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>service</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>ServletRequest</span> <span style=color:#000>req</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>ServletResponse</span> <span style=color:#000>resp</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#000>BigInteger</span> <span style=color:#000>i</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>extractFromRequest</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>req</span><span style=color:#ce5c00;font-weight:700>);</span>
    <span style=color:#000>BigInteger</span><span style=color:#ce5c00;font-weight:700>[]</span> <span style=color:#000>factors</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>factor</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>i</span><span style=color:#ce5c00;font-weight:700>);</span>
    <span style=color:#000>count</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>incrementAndGet</span><span style=color:#ce5c00;font-weight:700>();</span>
    <span style=color:#000>encodeIntoResponse</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>factors</span><span style=color:#ce5c00;font-weight:700>);</span>
  <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>在 java.util.concurrent.atomic 包中包含了一些原子变量类，用于实现在数值的对象引用上的原子状态转换。通过用 AtomicLong 来代替 long 类型的计数器，能够确保所有对计数器状态的访问操作都是原子的。由于 Servlet 的状态就是计数器的状态，并且计数器是线程安全的，因此这里的 Servlet 也是线程安全的。</p>
<p>我们在因数分解的 Servlet 中增加了一个计数器，并且通过使用线程安全类 AtomicLong 来管理计数器的状态，从而确保了代码的线程安全性。挡在无状态的类中添加一个状态时，如果该状态完全由线程安全的对象来管理，那么这个类仍然是线程安全的。然而，在 2.3 节你将看到，当状态变量的数量不再是一个时，并不会像仅有一个状态变量时那么简单。</p>
<blockquote>
<p>在实际情况中，应尽可能的使用现有的线程安全对象来管理状态。与非线程安全对象相比，判断线程安全对象的状态空间及其状态迁移情况要更为容易，从而也更容易维护和验证线程安全性。</p>
</blockquote>
<h2 id=23-加锁机制>2.3 加锁机制</h2>
<p>当在 Servlet 中添加一个状态变量时，可以通过线程安全的对象来管理 Servlet 的状态以维护 Servlet 的线程安全性。但如果想在 Servlet 中添加更多的状态，那么是否只需要添加更多的线程安全状态变量就足够了？</p>
<p>假设我们希望提升 Servlet 的性能：将最近的计算结果缓存起来，当两个连续的请求对相同的数值进行因数分解时，可以直接使用上一次的计算结果，而无需重新计算。要实现该策略，需要保存两个状态：最近执行因数分解的数值，和分解结果。</p>
<p>我们曾通过 AtomicLong 以线程安全的方式来管理计数器的状态，那么，在这里是否可以使用类似 AtomicReference 来管理最近执行因数分解的数值及其分解结果吗？在程序清单 2-5 中的 UnsafeCachingFactorizer 实现了这种思想。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#5c35cc;font-weight:700>@NotThreadSafe</span>
<span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>UnsafeCachingFactorizer</span> <span style=color:#204a87;font-weight:700>implements</span> <span style=color:#000>Servlet</span> <span style=color:#ce5c00;font-weight:700>{</span>
  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>AtomicReference</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>BigInteger</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>lastNumber</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>AtomicReference</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>BigInteger</span><span style=color:#ce5c00;font-weight:700>&gt;();</span>
  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#000>fianl</span> <span style=color:#000>AtomicReference</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>BigInteger</span><span style=color:#ce5c00;font-weight:700>[]&gt;</span> <span style=color:#000>lastFactors</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>AtomicReference</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>BigInteger</span><span style=color:#ce5c00;font-weight:700>[]&gt;();</span>
  
  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>service</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>ServletRequest</span> <span style=color:#000>req</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>ServletResponse</span> <span style=color:#000>resp</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#000>BigInteger</span> <span style=color:#000>i</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>extactFromRequest</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>req</span><span style=color:#ce5c00;font-weight:700>);</span>
    <span style=color:#204a87;font-weight:700>if</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>i</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>equals</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>lastNumber</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>get</span><span style=color:#ce5c00;font-weight:700>()))</span> <span style=color:#ce5c00;font-weight:700>{</span>
      <span style=color:#000>encodeIntoResponse</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>resp</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>lastFactors</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>get</span><span style=color:#ce5c00;font-weight:700>());</span>
    <span style=color:#ce5c00;font-weight:700>}</span>
    <span style=color:#204a87;font-weight:700>else</span> <span style=color:#ce5c00;font-weight:700>{</span>
      <span style=color:#000>BigInteger</span><span style=color:#ce5c00;font-weight:700>[]</span> <span style=color:#000>factors</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>factor</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>i</span><span style=color:#ce5c00;font-weight:700>);</span>
      <span style=color:#000>lastNumber</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>set</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>i</span><span style=color:#ce5c00;font-weight:700>);</span>
      <span style=color:#000>lastFactors</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>set</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>factors</span><span style=color:#ce5c00;font-weight:700>);</span>
      <span style=color:#000>encodeIntoResponse</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>factors</span><span style=color:#ce5c00;font-weight:700>);</span>
    <span style=color:#ce5c00;font-weight:700>}</span>
  <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>然而，这种方法并不正确。尽管这些原子引用本身都是线程安全的，但在 UnsafeCachingFactorizer 中存在着竟态条件，这可能产生错误的结果。</p>
<p>在线程安全性的定义中要求，多个线程之间的操作无论采用何种执行时序或交替方式，都要保证不变性条件不被破坏。UnsafeCachingFactorizer 的不变性条件之一是：在 lastFactors 中缓存的因数之积应该等于在 lastNumber 中缓存的数值。只有确保了这个不变性条件不被破坏，上面的 Servlet 才是正确的。当在不变性条件中涉及到多个变量时，各个变量之间并不是彼此独立的，而是某个变量的值会对其他变量的值产生约束。因此，当更新某个变量时，需要在同一个原子操作中对其他变量同时进行更新。</p>
<p>在某些执行时序中，UnsafeCachingFactorizer 可能会破坏这个不变性条件。在使用原子引用的情况下，尽管对 set 方法的每次调用都是原子的，但仍然无法同时更新 lastNumber 和 lastFactors。如果只修改了其中一个变量，那么在两次修改操作之间，其他线程发现不变性条件被破坏了。同样，我们也不能保证会同时获取两个值：在线程 A 获取两个值的过程中，线程 B 可能修改了它们，这样线程 A 就发现不变性条件被破坏了。</p>
<blockquote>
<p>要保持状态的一致性，就需要在单个原子操作中更新所有相关的状态变量。</p>
</blockquote>
<h3 id=231-内置锁>2.3.1 内置锁</h3>
<p>Java 提供了一种内置的锁机制来支持原子性：同步代码块(Synchronized Block)。同步代码块包含两个部分：一个作为锁的对象引用，一个作为由这个锁保护的代码块。以关键字 synchronized 来修饰的方法就是一种横跨整个方法体的同步代码块，其中该同步代码块的锁就是方法调用所在的对象。静态的 synchronized 方法以 Class 对象作为锁。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#204a87;font-weight:700>synchronized</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>lock</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
  <span style=color:#8f5902;font-style:italic>// 访问或修改由锁保护的共享状态
</span><span style=color:#8f5902;font-style:italic></span><span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>每个 Java 对象都可以用作一个实现同步的锁，这些所被称为内置锁或监视器锁。线程在进入同步代码块之前会自动获得锁，并且在退出同步代码块时自动释放锁，而无论是通过正常的控制路径退出，还是通过从代码中抛出异常退出。获得内置锁的唯一途径就是进入由这个锁保护的同步代码块或方法。</p>
<p>Java 的内置锁相当于一种互斥体(或互斥锁)，这意味着最多只有一个线程能持有这种锁。当线程 A 尝试获取一个右线程 B 持有的锁时，线程 A 必须等待或阻塞，直到线程 B 释放这个锁。如果 B 永远不释放锁，那么 A 也将永远的等下去。</p>
<p>由于每次只能有一个线程执行内置锁保护的代码块，因此，由这个锁保护的同步代码块会以原子方式执行，多个线程在执行该代码块时也不会互相干扰。并发环境中的原子性与事务应用程序中的原子性有着相同的含义——“一组语句作为一个不可分割的单元被执行”。任何一个执行同步代码块的线程，都不可能看到其他线程正在执行由同一个锁保护的同步代码块。</p>
<p>这种同步机制使得要确保因数分解 Servlet 的线程安全性变得更加简单。在程序清单 2-6 中使用了关键字 synchronized 来修饰 service 方法，因此在同一时刻只有一个线程可以执行 service 方法。现在的 SynchronizedFactorizer 是线程安全的。然而，这种方法却过于极端，因为多个客户端无法同时使用因素分解 Servlet，服务的响应性非常低，令人无法接受。这是一个性能问题，而非线程安全问题，我们将在 2.5 中解决该问题。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#5c35cc;font-weight:700>@ThreadSafe</span>
<span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>SynchronizedFactorizer</span> <span style=color:#204a87;font-weight:700>implements</span> <span style=color:#000>Servlet</span> <span style=color:#ce5c00;font-weight:700>{</span>
  <span style=color:#5c35cc;font-weight:700>@GuardBy</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#4e9a06>&#34;this&#34;</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#204a87;font-weight:700>private</span> <span style=color:#000>BigInteger</span> <span style=color:#000>lastNumber</span><span style=color:#ce5c00;font-weight:700>;</span>
  <span style=color:#5c35cc;font-weight:700>@GuardBy</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#4e9a06>&#34;this&#34;</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#204a87;font-weight:700>private</span> <span style=color:#000>BigInteger</span><span style=color:#ce5c00;font-weight:700>[]</span> <span style=color:#000>lastFactors</span><span style=color:#ce5c00;font-weight:700>;</span>
  
  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>synchronized</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>service</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>ServletRequest</span> <span style=color:#000>req</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>ServletResponse</span> <span style=color:#000>resp</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#000>BigInteger</span> <span style=color:#000>i</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>extactFromRequest</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>req</span><span style=color:#ce5c00;font-weight:700>);</span>
    <span style=color:#204a87;font-weight:700>if</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>i</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>equals</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>lastNumber</span><span style=color:#ce5c00;font-weight:700>))</span> <span style=color:#ce5c00;font-weight:700>{</span>
      <span style=color:#000>encodeIntoResponse</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>resp</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>lastFactors</span><span style=color:#ce5c00;font-weight:700>);</span>
    <span style=color:#ce5c00;font-weight:700>}</span>
    <span style=color:#204a87;font-weight:700>else</span> <span style=color:#ce5c00;font-weight:700>{</span>
      <span style=color:#000>BigInteger</span><span style=color:#ce5c00;font-weight:700>[]</span> <span style=color:#000>factors</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>factor</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>i</span><span style=color:#ce5c00;font-weight:700>);</span>
      <span style=color:#000>lastNumber</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>i</span><span style=color:#ce5c00;font-weight:700>;</span>
      <span style=color:#000>lastFactors</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>factors</span><span style=color:#ce5c00;font-weight:700>;</span>
      <span style=color:#000>encodeIntoResponse</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>factors</span><span style=color:#ce5c00;font-weight:700>);</span>
    <span style=color:#ce5c00;font-weight:700>}</span>
  <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><h3 id=232-重入>2.3.2 重入</h3>
<p>当某个线程请求一个由其他线程持有的锁时，发出请求的线程就会阻塞。然而，“由于内置锁是可重入的”，因此如果某个线程试图获得一个已经由它自己持有的锁，那么这个请求就会成功。“重入”意味着获取锁的操作的粒度是“线程”，而不是“调用”(同一个线程可以发起多次调用)。重入的一种实现方式是，为每个锁关联一个获取计数值和一个拥有者线程。当计数器为 0 时，这个锁就被认为是没有被任何线程持有。当线程请求一个未被持有的锁时，JVM 将记录锁的持有者，并且将获取计数值设为 1。如果同一个线程再次获取这个锁，计数值将递增，而当线程退出同步代码块时，计数器会相应的递减。当计数值为 0 时，这个锁将被释放。</p>
<p>“重入”进一步提升了加锁行为的封装性，因此简化了面向对象并发代码的开发。在程序清单 2-7 的代码中，子类改写了父类的 synchronized 方法，然后调用父类中的方法，此时如果没有可重入锁，那么这段代码将产生死锁。由于 Widget 和 LoggingWidget 中 doSomething 方法都是 synchronized 方法，因此每个 doSomething 方法在执行前都会获取 Widget 上的锁。然而，如果内置锁不是可重入的，那么在调用 super.doSomething 时将无法获得 Widget 上的锁，因为这个锁已经被持有，从而线程将永远停顿下去，等待一个永远也无法获得的锁。重入则避免了这种死锁的发生。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>Widget</span> <span style=color:#ce5c00;font-weight:700>{</span>
  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>synchronized</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>doSomething</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{...}</span>
<span style=color:#ce5c00;font-weight:700>}</span>

<span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>LoggingWidget</span> <span style=color:#204a87;font-weight:700>extends</span> <span style=color:#000>Widget</span> <span style=color:#ce5c00;font-weight:700>{</span>
  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>synchronized</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>doSomething</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#000>System</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>out</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>println</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>toString</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>+</span> <span style=color:#4e9a06>&#34;: calling doSomething&#34;</span><span style=color:#ce5c00;font-weight:700>);</span>
    <span style=color:#204a87;font-weight:700>super</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>doSomething</span><span style=color:#ce5c00;font-weight:700>();</span>
  <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><h2 id=24-用锁来保护状态>2.4 用锁来保护状态</h2>
<p>由于锁能使其保护的代码路径以“串行形式”被访问，因此可以通过锁来构造一些协议以实现对共享状态的独占访问。只要始终遵循这些协议，就能确保状态的一致性。</p>
<p>访问共享状态的复合操作，例如命中计数器的递增操作(读取-修改-写入)或者延迟初始化(先检查后执行)，都必须是原子操作以避免产生竟态条件。如果在复合操作的执行过程中持有一个锁，那么会使复合操作成为原子操作。然而，仅仅将复合操作封装到一个同步代码块中是不够的。如果用同步来协调对某个变量的访问，那么在访问这个变量的所有位置上都需要使用同步块。而且，当使用锁来协调对某个变量的访问时，在访问变量的所有位置上都要使用同一个锁。</p>
<p>一种常见的错误是认为，只有在写入共享变量时才需要同步，然而事实并非如此。</p>
<blockquote>
<p>对于可能被多个线程同时访问的可变状态变量，在访问它时都需要持有同一个锁，在这种情况下，我们称状态变量由这个锁保护。</p>
</blockquote>
<p>在程序清单 2-6 的 SynchronizedFactorizer 中，lastNumber 和 lastFactors 这两个变量都是由 Servlet 对象的内置锁来保护的，在注解 @GuardBy 中也已经说明了这一点。</p>
<p>对象的内置锁与其状态之间没有内置的关联。虽然大多数类都将内置锁用作一种有效的加锁机制，但对象的域并不一定要通过内置锁类保护。当获取与对象关联的锁时，并不能阻止其他线程访问该对象，某个线程在获得对象的锁之后，只能阻止其他线程获得同一个锁。之所以每个对象都有一个内置锁，只是为了免去显式的创建锁对象。你需要自行构造加锁协议或者同步策略来实现对共享状态的安全访问，并且在程序中至始至终的使用它们。</p>
<blockquote>
<p>每个共享的可变的变量都应该由一个锁来保护，从而使维护人员知道是哪一个锁。</p>
</blockquote>
<p>一种常见的加锁约定是，将所有的可变状态都封装在对象内部，并通过对象的内置锁对所有的访问可变状态的代码路径进行同步，使得在该对象上不会发生并发访问。在许多多线程安全类中都使用了这种模式，例如 Vector 和其他的同步集合类。在这种情况下，对象状态中的所有变量都由对象的内置锁保护起来。然而，这种模式并没有任何特殊之处，编译器或运行时都不会强制实施这种(或其他)模式。如果在添加新的方法或代码路径时忘记了使用同步，那么这种加锁协议会很容易被破坏。</p>
<p>并非所有数据都需要锁的保护，只有被多个线程同时访问的可变数据才需要通过锁来保护。第一章曾介绍过，当添加一个简单的异步事件时，例如 TimerTask，整个程序都需要满足线程安全性要求，尤其是当程序状态的封装性比较糟糕时。考虑一个处理大规模数据的单线程程序，由于任何数据都不会在多个线程之间共享，因此在单线程程序中不需要同步。现在，假设希望添加一个功能，即定期对数据处理进度生成快照，这样当程序崩溃或必须停止时无需再次从头开始。你可能会选择使用 TimerTask，每十分钟触发一次，并将程序状态保存到一个文件中。</p>
<p>由于 TimerTask 在另一个(由 Timer 管理的)线程中调用，因此现在就有两个线程同时访问快照中的数据：程序的主线程与 Timer 线程。这意味着，当访问程序的状态时，不仅 TimerTask 代码必须使用同步，而且程序中所有访问相同数据的代码路径也必须使用同步。原本在程序中不需要使用同步，现在变成了在程序的各个位置都需要使用同步。</p>
<p>当某个变量由锁来保护时，意味着在每次访问这个变量时都需要首先获得锁，这样就确保在同一时刻只有一个线程可以访问这个变量。当类的不变性条件涉及多个状态变量时，那么还有另一个需求：在不变性条件中的每个变量都需要由同一把锁来保护。因此可以在单个原子操作中访问或更新所有这些变量，从而确保不变性条件不被破坏。在 SynchronizedFactorizer 类中说明了这条规则：缓存的数值和因数分解结果都由 Servlet 对象的内置锁来保护。</p>
<blockquote>
<p>对于每个包含多个变量的不变性条件，其中涉及的所有变量都需要由同一个锁来保护。</p>
</blockquote>
<p>如果同步可以避免竟态条件问题，那么为什么不在每个方法声明时都使用关键字 synchronized ？事实上，如果不加区别的滥用 synchronized，可能导致程序中出现过多的同步。此外，如果只是将每个方法都作为同步方法，例如 Vector，那么并不足以确保 Vector 上复合操作都是原子的：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#204a87;font-weight:700>if</span><span style=color:#ce5c00;font-weight:700>(!</span><span style=color:#000>vector</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>contains</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>element</span><span style=color:#ce5c00;font-weight:700>))</span>
  <span style=color:#000>vector</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>add</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>element</span><span style=color:#ce5c00;font-weight:700>);</span>
</code></pre></div><p>虽然 contains 和 add 等方法都是原子的，但在上面这个“如果不存在则添加(put-if-absent)”的操作中仍然存在竟态条件。虽然 synchronized 方法可以确保单个操作的原子性，但如果要把多个操作合并成一个复合操作，还是需要额外的加锁机制。此外，将每个方法都作为同步方法还可能导致活跃性问题或性能问题，我们在 SynchronizedFactorizer 中已经看到了这些问题。</p>
<h2 id=活跃性与性能>活跃性与性能</h2>
<p>在 UnsafeCachingFactorizer 中，我们通过在因数分解 Servlet 中引入了缓存机制来提升性能。在缓存中需要使用共享状态，因此需要通过同步来维护状态的完整性。然而，如果使用 SynchronizedFactorizer 中的同步方式，那么代码的执行性能将非常糟糕。SynchronizedFactorizer 中采用的同步策略是，通过 Servlet 对象的内置锁来保护每一个状态变量，该策略的实现方式也就是对整个 service 方法进行同步。虽然这种简单且粗粒度的方法能确保线程安全性，但付出的代价却很高。</p>
<p>由于 service 是一个 synchronized 方法，因此每次只有一个线程可以执行。这就背离了 Servlet 的初衷，即 Servlet 需要能够同时处理多个请求，这在负载过高的情况下将给用户带来糟糕的体验。如果 Servlet 在对某个大数值进行因数分解时需要很长的执行时间，那么其他的客户端必须一致等待，知道 Servlet 处理完当前的请求，才能开始另一个新的因数分解运算。如果在系统中有多个 CPU，那么当负载很高时，仍然会有处理器处于空闲状态。即使一些执行时间很短的请求，比如访问缓存的值，仍然需要很长的时间，因为这些请求都必须等待前一个请求执行完成。</p>
<p>图 2-1 给出了当多个请求同时到达因数分解 Servlet 时发生的情况：这些请求将排队等待处理。我们将这种 Web 应用程序称之为不良并发应用程序：可同时调用的数量，不仅受到可用处理资源的限制，还受到应用程序本身架构的限制。幸运的是，通过缩小同步代码块的作用范围，我们很容易做到既确保 Servlet 的并发性，同时又维护线程安全性。要确保同步代码块不要过小，并且不要将本应是原子的操作拆分到多个同步代码块中。应该尽量将不影响共享状态且执行时间较长的操作从同步代码块中分离出去，从而在这些操作的执行过程中，其他线程可以访问共享状态。</p>
<div align=center>
<img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20181117234510.png style=display:block;width:70% alt=2-1 align=center>
</div>
<p>程序清单 2-8 中的 CachedFactorizer 将 Servlet 的代码修改为使用两个独立的同步代码块，每个同步代码块都只包含一小段代码。其中一个同步代码块负责保护判断是否只需返回缓存结果的“先检查后执行”操作序列，另一个同步代码块则负责确保对缓存的数值和因数分解结果进行同步更新。此外，我们还重新引入了“命中计数器”，添加了一个“缓存命中”计数器，并在第一个同步代码块中更新这两个变量。由于这两个计数器也是共享可变状态的一部分，因此必须在所有访问它们的位置上使用同步。位于同步代码块之外的代码将以独占的方式来访问局部(位于栈上)的变量，这些变量不会在多个线程间共享，因此不需要同步。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#5c35cc;font-weight:700>@ThreadSafe</span>
<span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>CachedFactorizer</span> <span style=color:#204a87;font-weight:700>implements</span> <span style=color:#000>Servlet</span> <span style=color:#ce5c00;font-weight:700>{</span>
  <span style=color:#5c35cc;font-weight:700>@GuardedBy</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#4e9a06>&#34;this&#34;</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#204a87;font-weight:700>private</span> <span style=color:#000>BigInteger</span> <span style=color:#000>lastNumber</span><span style=color:#ce5c00;font-weight:700>;</span>
  <span style=color:#5c35cc;font-weight:700>@GuardedBy</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#4e9a06>&#34;this&#34;</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#204a87;font-weight:700>private</span> <span style=color:#000>BigInteger</span><span style=color:#ce5c00;font-weight:700>[]</span> <span style=color:#000>lastFactors</span><span style=color:#ce5c00;font-weight:700>;</span>
  <span style=color:#5c35cc;font-weight:700>@GuardedBy</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#4e9a06>&#34;this&#34;</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>long</span> <span style=color:#000>hits</span><span style=color:#ce5c00;font-weight:700>;</span>
  <span style=color:#5c35cc;font-weight:700>@GuardedBy</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#4e9a06>&#34;this&#34;</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>long</span> <span style=color:#000>cacheHits</span><span style=color:#ce5c00;font-weight:700>;</span>
  
  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>synchronized</span> <span style=color:#204a87;font-weight:700>long</span> <span style=color:#000>getHits</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span> <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>hits</span><span style=color:#ce5c00;font-weight:700>;</span> <span style=color:#ce5c00;font-weight:700>}</span>
  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>synchronized</span> <span style=color:#204a87;font-weight:700>double</span> <span style=color:#000>getCacheHitRatio</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#204a87;font-weight:700>return</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>double</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#000>cacheHits</span> <span style=color:#ce5c00;font-weight:700>/</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>double</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#000>hits</span><span style=color:#ce5c00;font-weight:700>;</span>
  <span style=color:#ce5c00;font-weight:700>}</span>
  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>service</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>ServletRequest</span> <span style=color:#000>req</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>ServletResponse</span> <span style=color:#000>resp</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#000>BigInteger</span> <span style=color:#000>i</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>extractFromRequest</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>req</span><span style=color:#ce5c00;font-weight:700>);</span>
    <span style=color:#000>BigInteger</span><span style=color:#ce5c00;font-weight:700>[]</span> <span style=color:#000>factors</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>null</span><span style=color:#ce5c00;font-weight:700>;</span>
    <span style=color:#000>synchronzied</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>this</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
      <span style=color:#ce5c00;font-weight:700>++</span><span style=color:#000>hits</span><span style=color:#ce5c00;font-weight:700>;</span>
      <span style=color:#204a87;font-weight:700>if</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>i</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>equals</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>lastNumber</span><span style=color:#ce5c00;font-weight:700>))</span> <span style=color:#ce5c00;font-weight:700>{</span>
        <span style=color:#ce5c00;font-weight:700>++</span><span style=color:#000>cacheHits</span><span style=color:#ce5c00;font-weight:700>;</span>
        <span style=color:#000>factors</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>lastFactors</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>clone</span><span style=color:#ce5c00;font-weight:700>();</span>
      <span style=color:#ce5c00;font-weight:700>}</span>
    <span style=color:#ce5c00;font-weight:700>}</span>
    <span style=color:#204a87;font-weight:700>if</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>factors</span> <span style=color:#ce5c00;font-weight:700>==</span> <span style=color:#204a87;font-weight:700>null</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
      <span style=color:#000>factors</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>factor</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>i</span><span style=color:#ce5c00;font-weight:700>);</span>
      <span style=color:#204a87;font-weight:700>synchronized</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>this</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
        <span style=color:#000>lastNumber</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>i</span><span style=color:#ce5c00;font-weight:700>;</span>
        <span style=color:#000>lastFactors</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>factors</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>clone</span><span style=color:#ce5c00;font-weight:700>();</span>
      <span style=color:#ce5c00;font-weight:700>}</span>
    <span style=color:#ce5c00;font-weight:700>}</span>
    <span style=color:#000>encodeIntoResponse</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>resp</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>factors</span><span style=color:#ce5c00;font-weight:700>);</span>
  <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>在 CachedFactorizer 中不再使用 AtomicLong 类型的命中计数器，而是使用了一个 long 类型的变量。当然也可以使用 AtomicLong 类型，但使用 CountingFactorizer 带来的好处更多。对于在单个变量上实现原子操作来说，原子变量是很有用的，但由于我们已经使用了同步代码块来构造原子操作，而使用两种不同的同步机制不仅会带来混乱，而不在性能和安全性上带来任何好处，因此这里不再使用原子变量。</p>
<p>重新构造后的 CachedFactorizer 实现了在简单性(对整个方法进行同步)与并发性(对仅可能短的代码路径进行同步)之间的平衡。在获取与释放锁等操作上需要一定的开销，因此如果将同步代码块分解的过细(例如将 <code>++hits</code> 分解到它自己的同步代码块中)，那么通常并不好，尽管这样做不会破坏原子性。当访问状态变量或者在复合操作的执行期间，CachedFactorizer 需要持有锁，但在执行时间较长的因素分解运算之前要释放锁。这样既能确保线程安全性，也不会过多的影响并发性，而且在每个同步代码块中的代码路径都“足够短”。</p>
<p>要判断同步代码块的合理大小，需要在各种设计需求之间进行权衡，包括安全性(这是必要需求)、简单性、性能。有时候，在简单性与性能之间会发生冲突，但在 CachedFactorizer 中已经说明了，在二者之间通常能够找到某种合理的平衡。</p>
<blockquote>
<p>通常，在简单性和性能之间存在相互制约因素。当实现某个同步策略时，一定不要盲目的为了性能而牺牲简单性(这可能会破坏安全性)。</p>
</blockquote>
<p>当使用锁时，你应该清楚代码块中实现的功能，以及在执行该代码块时是否需要很长的时间。无论是执行计算密集的操作，还是在执行某个可能阻塞的操作，如果持有锁的时间过长，那么都会带来活跃性或性能问题。</p>
<blockquote>
<p>当执行时间较长的计算或者可能无法快速完成的操作时，如 IO、控制台 IO，一定不要持有锁。</p>
</blockquote>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-865029e0f0337f3b143056ed6e079db4>3 - CH03-对象共享</h1>
<p>第二章的开头曾指出，要编写正确的并发程序，关键问题在于：“在访问共享的可变状态时需要正确的管理”。第二章介绍了如何通过同步来避免多个线程在同一时刻访问相同的数据，而本章将介绍“如何共享和发布对象”，从而使它们能够安全的同时被多个线程访问。这两章合在一起，就形成了构建线程安全类以及通过 JUC 类库来构建并发应用程序的重要基础。</p>
<p>我们已经知道了同步代码块和同步方法可以确保以原子的方式执行操作，但一种常见的误解是，认为关键字 synchronized 只能用于实现原子性或者确定“临界区”。同步还有一个重要的方面：“内存可见性”。“我们不仅希望防止某个线程正在使用对象状态而另一个线程在同时修改状态，而且希望确保当一个线程修改了对象状态之后，其他线程能够看到发生的状态变化”。如果没有同步，那么这种情况就无法实现。你可以通过显式的同步或者类库中内置的同步来保证对象被安全的发布。</p>
<h2 id=31-可见性>3.1 可见性</h2>
<p>可见性是一种复杂的属性，因为可见性中的错误总是违背我们的直觉。在单线程环境中，如果想某个变量先写入值，然后在没有其他写入操作的情况下读取这个变量，那么总能得到相同的值。这看起来很自然。然而，当读操作和写操作在不同的线程中执行时，情况却并非如此，这听起来或许有些难以接受。通常，我们无法确保执行读操作的线程能实时的看到其他线程写入的值，有时甚至是不可能的事情。为了确保多个线程之间对内存写入操作的可见性，必须使用同步机制。</p>
<p>在程序清单 3-1 中的 NoVisibility 说明了当多个线程在没有同步的情况下共享数据时出现的错误。在代码中，主线程和读线程都将访问变量 ready 和 number。主线程启动读线程，然后将 number 设为 42，并将 ready 设为 true。读线程一直循环直到发现 ready 的值变为 true，然后输出 number 的值。虽然 NoVisibility 看起来会输出 42，但事实上可能输出 0，或者根本无法终止。这是因为在代码中没有使用足够的同步机制，因此无法保证主线程写入的 ready 值和 number 值对于读线程来说是可见的。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>NoVisibility</span> <span style=color:#ce5c00;font-weight:700>{</span>
  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>static</span> <span style=color:#204a87;font-weight:700>boolean</span> <span style=color:#000>ready</span><span style=color:#ce5c00;font-weight:700>;</span>
  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>static</span> <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>number</span><span style=color:#ce5c00;font-weight:700>;</span>
  
  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>static</span> <span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>ReaderThread</span> <span style=color:#204a87;font-weight:700>extends</span> <span style=color:#000>Thread</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>run</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span>
      <span style=color:#204a87;font-weight:700>while</span><span style=color:#ce5c00;font-weight:700>(!</span><span style=color:#000>ready</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
        <span style=color:#000>Thread</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>yield</span><span style=color:#ce5c00;font-weight:700>();</span>
      <span style=color:#ce5c00;font-weight:700>}</span>
      <span style=color:#000>System</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>out</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>println</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>number</span><span style=color:#ce5c00;font-weight:700>);</span>
    <span style=color:#ce5c00;font-weight:700>}</span>
  <span style=color:#ce5c00;font-weight:700>}</span>
  
  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>static</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>mian</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>String</span><span style=color:#ce5c00;font-weight:700>...</span><span style=color:#c4a000>args</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>ReaderThread</span><span style=color:#ce5c00;font-weight:700>().</span><span style=color:#c4a000>start</span><span style=color:#ce5c00;font-weight:700>();</span>
    <span style=color:#000>number</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>42</span><span style=color:#ce5c00;font-weight:700>;</span>
    <span style=color:#000>ready</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>true</span><span style=color:#ce5c00;font-weight:700>;</span>
  <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>NoVisibility 可能会一致循环下去，因为读线程可能永远也看不到 ready 的值。一种更奇怪的现象是，NoVisibility 可能会输出 0，因为读线程可能看到了写入 ready 的值，但却没有看到只有写入 number 的值，这种现象被称为“重排序”。只要在某个线程中无法检测到重排序的情况(即使在其他线程中可以很明显的看到该线程中的重排序)，那么就无法确保线程中的操作将按照程序中指定的顺序来执行。当主线程首先写入 number，然后在没有同步的情况下写入 ready，那么读线程看到的顺序可能与写入的顺序完全相反。</p>
<blockquote>
<p>在没有同步的情况下，编译器、处理器以及运行时都有可能对操作的顺序进行一些意想不到的调整。在缺乏同步的多线程程序中，要想对内存操作的执行顺序进行判断，几乎无法得出正确的结论。</p>
</blockquote>
<p>NoVisibility 是一个简单的并发程序，只包含两个线程和两个共享变量，但即便如此，在判断程序的执行结果以及是否会结束时仍然很容易得出错误结论。要对那些缺乏足够同步的并发程序的执行情况进行推断是十分困难的。</p>
<p>这听起来有点恐怖，但实际情况也确实如此。幸运的是，有一种简单的方法能够避免这些复杂的问题：“只要有数据在多个线程间共享，就使用正确的同步”。</p>
<h3 id=311-失效数据>3.1.1 失效数据</h3>
<p>NoVisibility 展示了在缺乏同步的程序中可能产生错误结果的一种情况：失效数据。当读线程查看 ready 变量时，可能会得到一个已经失效的值。除非在每次访问变量时都使用同步，否则很可能获得该变量的一个失效值。更糟糕的是，失效值可能不会同时出现：“一个线程可能获得某个变量的最新值，而获得另一个变量的失效值”。</p>
<p>通常，当食物过期(失效)时，还是可以食用的，只不过味道差了些。但失效的数据可能会导致更危险的情况。虽然在 Web 应用程序中失效的命中计数器可能不会导致太糟糕的情况，但在其他情况中，失效值可能会导致一些严重的安全问题或者活跃性问题。在 NoVisibility 中，失效数据可能会导致输出错误的值，或者使程序无法结束。如果对象的引用(如链表中的指针)失效，那么情况会更加复杂。失效数据还可能导致一些令人困惑的故障，如意料之外的异常、被破坏的数据结构、不精确的计算以及无线循环等。</p>
<p>程序清单 3-2 中的 MutableInteger 不是线程安全的，因为 get 和 set 都是在没有同步的情况下访问 value 的。与其他问题相比，失效值问题更容易出现：如果某个线程调用了 set，那么另一个正在调用 get 的线程可能会看到更新后的 value 的值，也可能看不到。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#5c35cc;font-weight:700>@NotThreadSafe</span>
<span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>MutableInteger</span> <span style=color:#ce5c00;font-weight:700>{</span>
  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>value</span><span style=color:#ce5c00;font-weight:700>;</span>
  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>get</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span> <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>value</span><span style=color:#ce5c00;font-weight:700>;</span> <span style=color:#ce5c00;font-weight:700>}</span>
  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>set</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>value</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span> <span style=color:#204a87;font-weight:700>this</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>value</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>value</span><span style=color:#ce5c00;font-weight:700>;</span> <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>在程序清单 3-3 的 SynchronizedInteger 中，通过对 get 和 set 等方法进行同步，可以使 MutableInteger 称为一个线程安全的类。“仅对 set 方法进行同步是不够的，调用 get 的线程仍然会看见失效的值”。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#5c35cc;font-weight:700>@ThreadSafe</span>
<span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>SynchronizedInteger</span> <span style=color:#ce5c00;font-weight:700>{</span>
  <span style=color:#5c35cc;font-weight:700>@GuardBy</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#4e9a06>&#34;this&#34;</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>value</span><span style=color:#ce5c00;font-weight:700>;</span>
  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>synchronized</span> <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>get</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span> <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>value</span><span style=color:#ce5c00;font-weight:700>;</span> <span style=color:#ce5c00;font-weight:700>}</span>
  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>synchronized</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>set</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>value</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span> 
    <span style=color:#204a87;font-weight:700>this</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>value</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>value</span><span style=color:#ce5c00;font-weight:700>;</span> 
  <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><h3 id=312-非原子的-64-位操作>3.1.2 非原子的 64 位操作</h3>
<p>当线程在没有同步的情况下读取变量时，可能会得到一个失效值，但至少这个值是由之前某个线程设置的值，而不是一个随机值。这种安全性保证也被称为“最低安全性”。</p>
<p>最低安全性适用于绝大多数变量，但是存在一个例外：非 volatile 类型的 64 位数值变量(long/double)。Java 内存模型要求，变量的读取和写入操作都必须是原子的，但对于非 volatile 类型的 long 和 double 变量，JVM 允许将 64 位的读写操作分解为两个对 32 位数值的操作。当读取一个非 volatile 类型的 long 变量时，如果对该变量的读写操作在不同的线程中执行，那么很可能会读取到某个值的高 32 位或另一个值的低 32 位。因此，即使不考虑失效数据问题，在多线程程序中使用共享且可变的 long 和 double 等类型的变量也是不安全的，除非用关键字 volatile 来声明它们，或者用锁保护起来。</p>
<h3 id=313-加锁与可见性>3.1.3 加锁与可见性</h3>
<p>“内置锁可以用于确保某个线程以一种可预测的方式来查看另一个线程的执行结果”，如图 3-1 所示。当线程 A 执行某个同步代码块时，线程 B 随后进入由同一个锁保护的同步代码块，在这种情况下可以保证，在锁被释放之前，A 看到的变量值在 B 获得锁后同样可以由 B 看到。换句话说，当线程 B 执行由锁保护的同步代码块时，可以看到线程 A 之前在同一个同步代码块中的所有操作结果。如果没有同步，那么就无法实现上述保证。</p>
<div align=center>
<img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20181117235602.png style=display:block;width:70% alt=3-1 align=center>
</div>
<p>现在，我们可以进一步理解为什么在访问某个共享且可变的变量时要求所有线程在同一个锁上同步，就是为了确保某个线程写入该变量的值对于其他线程来说都是可见的。否则，如果一个线程在未持有正确的锁的情况下，那么读到的可能是一个失效值。</p>
<blockquote>
<p>加锁的含义不仅仅局限于互斥访问，还包括内存可见性。为了确保所有线程都能看到共享变量的最新值，所有执行读操作或写操作的线程都必须在同一个锁上同步。</p>
</blockquote>
<h3 id=314-volatile-变量>3.1.4 Volatile 变量</h3>
<p>Java 语言提供了一种稍弱的同步机制，即 volatile 变量，“用来确保将变量的更新操作通知到其他线程”。当把变量声明为 volatile 类型后，编译器与运行时都会注意到这个变量是共享的，因此不会将该变量上的操作与其他内存操作一起重排序。volatile 变量不会被缓存在寄存器或者对其他处理器不可见的地方，因此在读取 volatile 类型的变量时总会返回最新写入的值。</p>
<p>理解 volatile 变量的一种有效方法是，将它们的行为想象成程序清单 3-3 中 SynchronizedInteger 的类似行为，并将 volatile 变量的读写操作分别替换为 get 和 set 方法。然而，在访问 volatile 变量时不会执行加锁操作，因此也就不会使执行线程阻塞，因此 volatile 变量一种比 synchronized 关键字更加轻量的同步机制。</p>
<p>volatile 变量对可见性的影响比 volatile 变量本身更为重要。当线程 A 首先写入一个 volatile 变量并且线程 B 随后读取该变量时，在写入 volatile 变量之前对 A 可见的所有变量的值，在 B 读取了 volatile 变量后，对 B 也是可见的。因此，从内存可见性的角度来看，写入 volatile 变量相当于退出同步代码块，而读取 volatile 变量相当于进入同步代码块。然而，我们并不建议过度依赖 volatile 变量提供的可见性。如果在代码中依赖 volatile 变量来控制状态的可见性，通常比使用锁的代码更脆弱，也更难以理解。</p>
<blockquote>
<p>仅当 volatile 变量能简化代码的实现以及对同步策略的验证时，才应该使用它们。如果在验证正确性时需要对可见性进行复杂的判断，那么就不需要使用 volatile 变量。volatile 变量的正确用法包括：确保它们自身状态的可见性，确保它们所引用对象的状态的可见性，以及标识一些重要的程序生命周期事件的发生，如初始化和关闭。</p>
</blockquote>
<p>程序清单 3-4 给出了 volatile 变量的一种典型用法：检查某个状态标记以判断是否退出循环。在这个示例中，线程试图通过一种数绵羊的传统方法进入休眠状态。为了使这个示例能够正确执行，asleep 必须为 volatile 变量。否则，当 volatile 被另一个线程修改时，执行判断的线程却发现不了。我们也可以用锁定来确保 volatile 更新操作的可见性，但这将使代码变得更加复杂。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#204a87;font-weight:700>volatile</span> <span style=color:#204a87;font-weight:700>boolean</span> <span style=color:#000>asleep</span><span style=color:#ce5c00;font-weight:700>;</span>
<span style=color:#ce5c00;font-weight:700>...</span>
  <span style=color:#204a87;font-weight:700>while</span><span style=color:#ce5c00;font-weight:700>(!</span><span style=color:#000>asleep</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#000>countSomeSheep</span><span style=color:#ce5c00;font-weight:700>();</span>
  <span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>虽然 volatile 变量很方便，但也存在一些局限性。volatile 变量通常用作某个操作完成、发生中断或状态的标记，例如程序清单 3-4 中的 asleep 标记。尽管 volatile 也可以用于表示其他的状态信息，但在使用时要非常小心。例如，volatile 的语义不足以确保递增操作(count++)的原子性，除非你能确保只有一个线程对变量执行写操作。(原子变量提供了“读-改-写”的原子操作，并且常常用作“更好的 volatile 变量”)</p>
<blockquote>
<p>加锁机制既可以确保可见性又可以确保原子性，而 volatile 变量只能确保可见性。</p>
</blockquote>
<p>当且仅当满足以下条件时，才应该使用 volatile 变量：</p>
<ul>
<li>对变量的写入不依赖变量的当前值，或者你能确保只有单个线程更新变量的值。</li>
<li>该变量不会与其他状态变量一起被纳入不变性条件。</li>
<li>在访问变量时不需要加锁。</li>
</ul>
<h2 id=32-发布与逸出>3.2 发布与逸出</h2>
<p>“发布(Publish)” 一个对象的意思是指，是对象能够在当前作用域之外的代码中使用。例如，将一个指向对象的引用保存到其他代码可以访问的地方，或者在某一个非私有的方法中返回该引用，或者将引用传递到其他类的方法中。在许多情中，我们要确保对象及其内部状态不会被发布。而在某些情况下，我们又需要发布某个对象，但如果在发布时需要确保线程安全性，则可能需要同步。发布内部状态可能会破坏封装性，并使得程序难以维持不变性条件。例如，如果在对象的构造过程完成之前就发布该对象，就会破坏线程安全性。“当某个不应该发布的对象被发布时，这种情况就被称为逸出。” 3.5 节将介绍安全发布对象的一些方法。现在我们首先来看看一个对象是如何逸出的。</p>
<p>发布对象的最简单方法是将对象的引用保存到一个共有的静态变量中，以便任何类和线程都能看见该对象，如程序清单 2-5 所示。在 initialize 方法中实例化一个新的 HashSet 对象，并将对象的引用保存到 knownSecrets 中以发布该对象。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>static</span> <span style=color:#000>Set</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>Secret</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>knownSecrets</span><span style=color:#ce5c00;font-weight:700>;</span>

<span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>initialize</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span>
  <span style=color:#000>knownSecrets</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>HashSet</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>Secret</span><span style=color:#ce5c00;font-weight:700>&gt;():</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>当发布某个对象时，可能会间接的发布其他对象。如果将一个 Secret 对象添加到集合 knownSecrets 中，那么同样会发布这个对象，因为任何代码都可以遍历这个集合，并获得对这个新 Secret 对象的引用。同样，如果从非私有方法中返回一个引用，那么同样会发布返回的对象。程序清单 3-6 中的 UnsafeStates 发布了本应为私有的状态数组。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>UnsafeStates</span> <span style=color:#ce5c00;font-weight:700>{</span>
  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#000>String</span><span style=color:#ce5c00;font-weight:700>[]</span> <span style=color:#000>states</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>String</span><span style=color:#ce5c00;font-weight:700>[]{</span><span style=color:#4e9a06>&#34;AK&#34;</span><span style=color:#ce5c00;font-weight:700>,</span><span style=color:#4e9a06>&#34;AL&#34;</span><span style=color:#ce5c00;font-weight:700>,...}</span>
  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#000>String</span><span style=color:#ce5c00;font-weight:700>[]</span> <span style=color:#000>getStates</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span> <span style=color:#204a87;font-weight:700>return</span>  <span style=color:#000>states</span><span style=color:#ce5c00;font-weight:700>;</span> <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>如果按照上述方法来发布 states，就会出现问题，因为任何调用者都可以修改这个数组的内容。在这个示例中，数组 states 已经逸出了它所在的作用域，因为这个本应该是私有的变量已经被发布了。</p>
<p>当发布一个对象时，在该对象的非私有域中引用的所有对象同样会被发布。一般来说，如果一个已经发布的对象能够通过非私有的变量引用和方法调用到达其他的对象，那么这些对象也都会被发布。</p>
<p>假定有一个类 C，对于 C 来说，“外部方法”是指行为并不完全由 C 来规定的方法，包括其他类中定义的方法以及类 C 中可以被改写的方法(既不是 private 方法也不是 final 方法)。当把一个对象传递给外部方法时，就相当于发布了该对象。你无法知道哪些方法会被执行，也不知道在外部方法中究竟会发布这个对象，还是会保留对象的引用并在随后由另一个线程使用。</p>
<p>无论其他的线程会对已经发布的引用执行任何操作，其实都不重要，因为误用该引用的风险始终存在。当某个对象逸出后，你必须假设有某个类或线程最终可能会误用该对象。这正是需要使用封装的最主要原因：封装能够使得对程序的正确性进行分析变得可能，并使得无意中破坏设计约束条件变得更难。</p>
<p>最后一种发布对象或其内部状态的机制就是发布一个内部的类实例，如程序清单 3-7 的 ThisEscape 所示。当 ThisEscape 发布 EventListener 时，也隐含的发布了 ThisEscape 实例本身，因为在这个内部类的实例中包含了对 ThisEscape 实例的隐含引用。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>ThisEscape</span> <span style=color:#ce5c00;font-weight:700>{</span>
  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#000>ThisScape</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>EventSource</span> <span style=color:#000>source</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#000>source</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>registerListener</span><span style=color:#ce5c00;font-weight:700>(</span>
      <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>EventListener</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span>
        <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>onEvent</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>Event</span> <span style=color:#000>e</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
          <span style=color:#000>doSomething</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>e</span><span style=color:#ce5c00;font-weight:700>);</span>
        <span style=color:#ce5c00;font-weight:700>}</span>
      <span style=color:#ce5c00;font-weight:700>}</span>
    <span style=color:#ce5c00;font-weight:700>);</span>
  <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><h3 id=安全的对象构造过程>安全的对象构造过程</h3>
<p>在 ThisEscape 中给出了逸出的一个特殊示例，即 this 引用在构造函数中逸出。当内部的 EventListener 实例发布时，在外部封装的 ThisEscape 实例也逸出了。当且仅当对象的构造函数返回时，对象才处于可预测的和一致的状态。因此，当从对象的构造函数中发布对象时，只是发布了一个尚未构造完成的对象。即使发布对象的语句位于构造函数的最后一行也是如此。如果 this 引用在构造过程中逸出，那么这种对象就被认为是不正确的构造。</p>
<blockquote>
<p>不要在构造过程中使 this 引用逸出。</p>
</blockquote>
<p>在构造过程中使 this 引用逸出的一个常见错误是，在构造函数中启动一个线程。当对象在其构造函数中创建一个线程时，无论是显式创建(通过将它传递给构造函数)还是隐式创建(由于 Thread 或 Runnable 是该对象的一个内部类)，this 引用都会被新创建的线程共享。在对象尚未完全构造之前，新的线程就可以看到它。在构造函数中创建线程并没有错误，但是最好不要立即启动它，而是通过一个 start 或 initialize 方法来启动它。在构造函数中调用一个可改写的实例方法时(既不是私有方法、也不是终结方法)，同样会导致 this 引用在构成过程中溢出。</p>
<p>如果想在构造函数中注册一个事件监听器或启动线程，那么可以使用一个私有的构造函数和一个公共的工厂方法，从而避免不正确的构造过程，如程序清单 3-8 中 SafeListener 所示。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>SafeListener</span> <span style=color:#ce5c00;font-weight:700>{</span>
  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>EventListener</span> <span style=color:#000>listener</span><span style=color:#ce5c00;font-weight:700>;</span>
  
  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#000>SafeListener</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#000>listener</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>EventListener</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span>
      <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>onEvent</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>Event</span> <span style=color:#000>e</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
        <span style=color:#000>doSomething</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>e</span><span style=color:#ce5c00;font-weight:700>);</span>
      <span style=color:#ce5c00;font-weight:700>}</span>
    <span style=color:#ce5c00;font-weight:700>};</span>
  <span style=color:#ce5c00;font-weight:700>}</span>
  
  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>static</span> <span style=color:#000>SafeListener</span> <span style=color:#000>newInstance</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>EventSource</span> <span style=color:#000>source</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#000>SafeListener</span> <span style=color:#000>safe</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>SafeListener</span><span style=color:#ce5c00;font-weight:700>();</span>
    <span style=color:#000>source</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>registerListener</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>safe</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>listener</span><span style=color:#ce5c00;font-weight:700>);</span>
    <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>safe</span><span style=color:#ce5c00;font-weight:700>;</span>
  <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><blockquote>
<p>具体来说，只有当构造函数返回时，this 引用才应该从线程中逸出。构造函数可以将 this 引用保存在某个地方，只要其他线程不会在构造函数完成之前使用它，上面的 SafeListener 就使用了这种技术。</p>
</blockquote>
<h2 id=33-线程封闭>3.3 线程封闭</h2>
<p>当访问共享的可变数据时，通常需要使用同步。一种避免使用同步的方式就是不共享数据。如果仅在单线程内访问数据，就不需要同步。这种技术被称为线程封闭，它是实现线程安全性的最简单方式之一。当某个对象封闭在一个线程中时，这种用法将自动实现线程安全性，即使被封闭的对象本身不是线程安全的。</p>
<p>Swing 中大量使用了线程封闭技术。Swing 的可视化组件和数据模型都不是线程安全的，Swing 将它们封闭到 Swing 的事件分发线程中来实现线程安全性。要想正确的使用 Swing，在除了事件线程之外的其他线程中就不能访问这些对象(为了进一步简化 Swing 的使用，Swing 还提供了 inbokeLater 机制，用于将一个 Runnable 实例调度到事件线程中执行)。Swing 程序的许多并发错误都是由于错误的在另一个线程中使用了这些被封闭的对象。</p>
<p>线程封闭技术的另一个常见应用是 JDBC 的 Connection 对象。JDBC 规范并不要求 Connection 对象必须是线程安全的。在典型的服务器应用中，线程从连接池中获得一个 Connection 对象，并且用该对象来处理请求，使用完成后将对象返还给连接池。由于大多数请求都是由单个线程采用同步的方式来处理，并且在 Connection 对象返回之前，连接池也不会再将它分配给其他线程，因此，这种连接管理模式在处理请求时隐含的将 Connection 对象封闭在线程内。</p>
<p>在 Java 语言中并没有强制规定某个变量必须由锁来保护，同样在 Java 语言中也无法强制将对象封闭在某个线程中。线程封闭是在程序设计中的一个考虑因素，必须在程序中实现。Java 语言及其核心库提供了一些机制来帮助维持线程封闭性，例如局部变量和 ThreadLoal 类，但即便如此，程序员仍需要负责确保封闭在线程内的对象不会从线程中逸出。</p>
<h3 id=331-ad-hoc-线程封闭>3.3.1 Ad-hoc 线程封闭</h3>
<p>Ad-hoc 线程封闭是指，维护线程封闭性的职责完全由程序实现来承担。Ad-hoc 线程封闭是非常脆弱的，因为没有任何一种语言特性，例如可见性修饰符或局部变量，能将对象封闭到目标线程上。事实上，对线程封闭对象(如 GUI 应用程序中的可视化组件或数据模型等)的引用通常保存在公有变量中。</p>
<p>当决定使用线程封闭技术时，通常是因为要将某个特定的子系统实现为一个单线程子系统。在某些情况下，单线程子系统提供的简单性要胜过 Ad-hoc 线程封闭技术的脆弱性。</p>
<p>在 volatile 变量上存在一种特殊的线程封闭。只要你能确保只有单个线程对共享的 volatile 变量执行写入操作，那么就可以安全的在这些共享的 volatile 变量上执行“读-改-写”操作。在这种情况下，相当于将修改操作封闭在单个线程中以防止发生竟态条件，并且 volatile 变量的可见性确保了其他线程能够看到最新的值。</p>
<p>由于 Ad-hoc 线程封闭技术的脆弱性，因此在程序中尽量少用它，在可能的情况下，应该使用更强的线程封闭技术(如栈封闭或 ThreadLocal 类)。</p>
<h3 id=332-栈封闭>3.3.2 栈封闭</h3>
<p>栈封闭是线程封闭的一种特例，在栈封闭中，只能通过局部变量才能访问对象。正如封装能使得代码更容易维持不变性条件那样，同步变量也能使对象更易于封闭在线程中。局部变量的固有属性之一就是封闭在执行线程中。它们位于执行线程的栈中，其他线程无法访问这个栈。栈封闭(也被称为线程内部使用或线程局部使用，不要与核心类库中的 ThreadLocal 混淆)比 Ad-hoc 线程封闭更易于维护，也更加健壮。</p>
<p>对于基本类型的局部变量，例如程序清单 3-9 中的 loadTheArk 方法的 numPairs，无论如何都不会破坏栈封闭性。由于任何方法都不会获得基本类型的引用，因此 Java 语言的这种语义就确保了基本类型的局部变量始终封闭在线程内。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>loadTheArk</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>Collection</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>Animal</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>candidates</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
  <span style=color:#000>SortedSet</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>Animal</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>animals</span><span style=color:#ce5c00;font-weight:700>;</span>
  <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>numPairs</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>0</span><span style=color:#ce5c00;font-weight:700>;</span>
  <span style=color:#000>Animal</span> <span style=color:#000>candidate</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>null</span><span style=color:#ce5c00;font-weight:700>;</span>
  
  <span style=color:#8f5902;font-style:italic>// animals 被封闭在方法中，不要使它们逸出
</span><span style=color:#8f5902;font-style:italic></span>  <span style=color:#000>animals</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>TreeSet</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>Animal</span><span style=color:#ce5c00;font-weight:700>&gt;(</span><span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>SpeciesGenderComparator</span><span style=color:#ce5c00;font-weight:700>());</span>
  <span style=color:#000>animals</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>addAll</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>candidates</span><span style=color:#ce5c00;font-weight:700>);</span>
  <span style=color:#204a87;font-weight:700>for</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>Animal</span> <span style=color:#000>a</span><span style=color:#ce5c00;font-weight:700>:</span> <span style=color:#000>animals</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#204a87;font-weight:700>if</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>candidate</span> <span style=color:#ce5c00;font-weight:700>==</span> <span style=color:#204a87;font-weight:700>null</span> <span style=color:#ce5c00;font-weight:700>||</span> <span style=color:#ce5c00;font-weight:700>!</span><span style=color:#000>candidate</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>isPotentialMate</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>a</span><span style=color:#ce5c00;font-weight:700>))</span>
      <span style=color:#000>candidate</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>a</span><span style=color:#ce5c00;font-weight:700>;</span>
    <span style=color:#204a87;font-weight:700>else</span> <span style=color:#ce5c00;font-weight:700>{</span>
      <span style=color:#000>ark</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>load</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>AnimalPari</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>candidate</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>a</span><span style=color:#ce5c00;font-weight:700>));</span>
      <span style=color:#ce5c00;font-weight:700>++</span><span style=color:#000>numPairs</span><span style=color:#ce5c00;font-weight:700>;</span>
      <span style=color:#000>candidate</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>null</span><span style=color:#ce5c00;font-weight:700>;</span>
    <span style=color:#ce5c00;font-weight:700>}</span>
  <span style=color:#ce5c00;font-weight:700>}</span>
  <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>numPairs</span><span style=color:#ce5c00;font-weight:700>;</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>在维持对象引用的栈封闭性时，程序员需要多做一些工作以确保被引用的对象不会逸出。在 loadTheArk 中实例化一个 TreeSet 对象，并将指向该对象的一个引用保存到 animals 中。此时，只有一个引用指向集合 animals，这个引用被封装在局部变量中，因此也被封装在执行线程中。然而，如果发布了对象集合 animals(或者该对象中的任何内部数据)的引用，那么封闭性将被破坏，并导致对象 animals 的逸出。</p>
<p>如果在线程内部上下文中使用非线程安全的对象，那么该对象仍然是线程安全的。然而，要小心的是，只有编写代码的开发人员才知道哪些对象需要被封闭到执行线程内，以及被封闭的对象是否是线程安全的。如果没有明确的说明这些需求，那么后续的维护人员很容易错误的使对象逸出。</p>
<h3 id=333-threadlocal>3.3.3 ThreadLocal</h3>
<p>维持线程封闭性的一种更规范的方法是使用 ThreadLocal，该类能使线程中的某个值与保存值的对象关联起来。ThreadLocal 提供了 get 与 set 等访问接口或方法，这些方法为每个使用该变量的线程都存有一份独立的副本，因此 get 总是返回由当前执行线程在调用 set 时设置的最新值。</p>
<p>“ThreadLocal 对象通常用于放置对可变的单实例变量或全局变量进行共享”。例如，在单线程应用程序中可能会维持一个全局的数据库连接，并在程序启动时初始化这个连接对象，从而避免在调用这个方法时都要传递一个 Connection 对象。由于 JDBC 的连接对象不一定是线程安全的，因此，当多线程程序在没有协同的情况下使用全局变量时，就不是线程安全的。通过将 JDBC 的连接保存到 ThreadLocal 对象中，每个线程都会拥有属于自己的连接，如程序清单 3-10 中的 ConnectionHolder 所示。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>static</span> <span style=color:#000>ThreadLocal</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>Connection</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>connectionHolder</span> <span style=color:#ce5c00;font-weight:700>=</span> 
  <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>ThreadLocal</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>Connection</span><span style=color:#ce5c00;font-weight:700>&gt;()</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#204a87;font-weight:700>public</span> <span style=color:#000>Connection</span> <span style=color:#000>initialValue</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span>
      <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>DriverManager</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>getConnection</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>DB_URL</span><span style=color:#ce5c00;font-weight:700>);</span>
    <span style=color:#ce5c00;font-weight:700>}</span>
  <span style=color:#ce5c00;font-weight:700>};</span>
  
<span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>static</span> <span style=color:#000>Connection</span> <span style=color:#000>getConnection</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span>
  <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>conenctionHolder</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>get</span><span style=color:#ce5c00;font-weight:700>();</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>当某个频繁执行的操作需要一个临时对象，例如一个缓冲区，而同时又希望避免在每次执行时都分配该临时对象时，就可以使用这项技术。例如在 Java 5.0 之前，Integer.toString() 方法使用 ThreadLocal 对象来保存一个 12 字节大小的缓冲区，用于对结果进行格式化，而不是使用共享的静态缓冲区(这需要使用锁机制)或者在每次调用时都分配一个新的缓冲区。</p>
<p>当某个线程初次调用 ThreadLocal.get 方法时，就会调用 initialValue 来获取初始值。从概念上来看，你可以将 ThreadLocal<t> 视为包含了 Map&lt;Thread, T> 对象，其中保存了特定于该线程的值，但 ThreadLocal 的实现并非如此。这些特定于线程的值保存在 Thread 对象中，当线程终止后，这些值会作为垃圾被回收。</p>
<p>假设你需要将一个单线程应用程序移植到多线程环境中，通过将共享的全局变量转换为 ThreadLocal 对象(如果全局变量的语义允许这么做)，可以维持线程安全性。然而，如果将应用程序范围内的缓存转换为线程局部的缓存，就不会有太大作用。</p>
<p>在实现应用程序框架时大量使用了 ThreadLocal。例如，在 EJB 调用期间，J2EE 容器需要将一个事务上下文与某个执行中的线程关联起来。通过将事务上下文保存在静态的 ThreadLocal 对象中，可以很容易的实现这个功能：当框架代码需要判断当前运行的是哪一个事务时，只需要从 ThreadLocal 对象中读取事务上下文。这种机制很方便，因为它避免了在调用每个方法时都要传递执行上下文信息，然而这也将该机制的代码与框架耦合在一起。</p>
<p>开发人员经常滥用 ThreadLocal，例如将所有全局变量都作为 ThreadLocal 对象，或者作为一种“隐藏”方法参数的手段。ThreadLocal 变量类似于全局变量，它会降低代码的可重用性，并在类之间引入隐含的耦合性，因此在使用时要格外小心。</p>
<h2 id=34-不变性>3.4 不变性</h2>
<p>满足同步需求的另一种做法是使用不可变对象。到目前为止，我们介绍了许多原子性和可见性相关的问题，例如得到失效数据、丢失更新操作或观察到某个对象处于不一致的状态等等，都与多线程视图同时访问同一个可变的状态相关。如果对象的状态不会改变，那么这些问题与复杂性自然也就消失了。</p>
<p>如果某个对象在被创建后其状态不能被修改，那么这个对象就称为不可变对象。线程安全性是不可变对象的固有属性之一，它们的不变性条件是由构造函数创建的，只要它们的状态不改变，那么这些不变性条件就能得以维持。</p>
<blockquote>
<p>不可变对象一定是线程安全的。</p>
</blockquote>
<p>不可变对象很简单。它们只有一种状态，并且该状态由构造函数来控制。在程序设计中，一个最困难的地方就是判断复杂对象的可能状态。然而，判断不可变对象的状态却很简单。</p>
<p>同样，不可变对象也更加安全。如果将一个可变对象传递给不可信的代码，或者将该对象发布到不可信代码可以访问到的地方，那么就很危险——不可信代码会改变它们的状态，更糟糕的是，在代码中将保留一个对该对象的引用或者有问题的代码破坏，因此可以安全的共享和发布这些对象，而无需创建保护性的副本。</p>
<p>虽然在 Java 语言规范和 Java 内存模型中都没有给出不可变性的正式定义，但不可变性并不等于将对象中所有的域都声明为 final 类型，即使对象中所有的域都是 final 类型的，这个对象仍然是可变的，因为在 final 类型的域中可以保存可变对象的引用。</p>
<blockquote>
<p>当满足以下条件时，对象才是不可变的：</p>
<ol>
<li>对象创建以后其状态就不能被修改。</li>
<li>对象的所有域都是 final 类型。</li>
<li>对象是正确创建的(在对象的创建期间，this 引用没有逸出)。</li>
</ol>
</blockquote>
<p>在不可变对象的内部仍然可以使用可变对象来管理其状态，如程序清单 3-11 中的 ThreeStooges 所示。尽管保存姓名的 Set 对象是可变的，但是从 ThreeStooges 的设计中可以看到，在 Set 对象构造完成后无法对其进行修改。stooges 是一个 final 类型的引用变量，因此所有对象状态都通过一个 final 域来访问。最后一个要求是“正确的构造对象”，这个要求很容易满足，因为构造函数能使该引用由除了构造函数及其调用者之外的代码来访问。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#5c35cc;font-weight:700>@Immutable</span>
<span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>final</span> <span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>ThreeStooges</span> <span style=color:#ce5c00;font-weight:700>{</span>
  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>Set</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>String</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>stooges</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>HashSet</span><span style=color:#ce5c00;font-weight:700>&lt;&gt;();</span>
  
  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#000>ThreeStooges</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#000>stooges</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>add</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#4e9a06>&#34;Moe&#34;</span><span style=color:#ce5c00;font-weight:700>);</span>
    <span style=color:#000>stooges</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>add</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#4e9a06>&#34;Larry&#34;</span><span style=color:#ce5c00;font-weight:700>);</span>
    <span style=color:#000>stooges</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>add</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#4e9a06>&#34;Curly&#34;</span><span style=color:#ce5c00;font-weight:700>);</span>
  <span style=color:#ce5c00;font-weight:700>}</span>
  
  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>boolean</span> <span style=color:#000>isStooge</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>String</span> <span style=color:#000>name</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>stooges</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>contains</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>name</span><span style=color:#ce5c00;font-weight:700>);</span>
  <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>由于程序的状态总是在不断改变，你可能会认为需要使用不可变对象的地方不多，但实际情况并非如此。在“不可变对象”与“不可变的对象引用”之间存在很多差异。保存在不可变对象中的状态仍然可以更新，即通过将一个保存新状态的实例来“替换”原有的不可变对象。</p>
<h3 id=341-final>3.4.1 Final</h3>
<p>关键字 final 可以视为 C++ 中 const 机制的一种受限版本，用于构造不可变的对象。final 类型的域是不能被修改的，但如果 final 域所引用的对象是可变的，那么这些被引用的对象是可以修改的。然而，在 Java 内存模型中，final 域还有着特殊的语义。final 域能够确保初始化过程的安全性，从而可以不受限制的访问不可变对象，并在共享这些对象时无需同步。</p>
<p>即使对象是可变的，通过将对象的某些域声明为 fianl 类型，仍然可以简化对状态的判断，因此限制对象的可变性也就相当于限制了该对象可能的状态集合。仅包含一个或两个可变状态的“基本不可变”对象仍然比包含多个可变状态的对象简单。通过将域声明为 fianl 类型，也相当于告诉维护人员这些域是不会变化的。</p>
<h3 id=342-示例使用-volatile-类型来发布不可变对象>3.4.2 示例：使用 volatile 类型来发布不可变对象</h3>
<p>在前面的 UnsafeCachingFactorizer 类中，我们尝试用 AtomicReference 变量来保存最新的数值机器因数分解结果，但这种方式并非线程安全，因为我们无法以原子方式来同时读取或更新两个相关的值。同样，用 volatile 类型的变量来保存这些值也不是线程安全的。然而，在某些情况下，不可变对象能够提供一种弱形式的原子性。</p>
<p>因数分解 Servlet 将执行两个原子操作：更新缓存的结果，以及通过判断缓存中的数值是否等于请求的数值来决定是否直接读取缓存中的因数分解结果。每当需要一组相关数据以原子方式执行某个操作时，就可以考虑创建一个不可变的类来包含这些数据，例如程序清单 3-12 中的 OneValueCache。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#5c35cc;font-weight:700>@Immutable</span>
<span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>OneValueCache</span> <span style=color:#ce5c00;font-weight:700>{</span>
  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>BigInteger</span> <span style=color:#000>lastNumber</span><span style=color:#ce5c00;font-weight:700>;</span>
  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>BigInteger</span><span style=color:#ce5c00;font-weight:700>[]</span> <span style=color:#000>lastFactors</span><span style=color:#ce5c00;font-weight:700>;</span>
  
  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#000>OneValueCache</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>BitInteger</span> <span style=color:#000>i</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>BigInteger</span><span style=color:#ce5c00;font-weight:700>[]</span> <span style=color:#000>factors</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#000>lastNumber</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>i</span><span style=color:#ce5c00;font-weight:700>;</span>
    <span style=color:#000>lastFactors</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>Arrays</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>copy</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>factors</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>factors</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>length</span><span style=color:#ce5c00;font-weight:700>);</span>
  <span style=color:#ce5c00;font-weight:700>}</span>
  
  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#000>BigInteger</span><span style=color:#ce5c00;font-weight:700>[]</span> <span style=color:#000>getFactors</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>BigInteger</span> <span style=color:#000>i</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#204a87;font-weight:700>if</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>lastNumber</span> <span style=color:#ce5c00;font-weight:700>==</span> <span style=color:#204a87;font-weight:700>null</span> <span style=color:#ce5c00;font-weight:700>||</span> <span style=color:#ce5c00;font-weight:700>!</span><span style=color:#000>lastNumber</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>equals</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>i</span><span style=color:#ce5c00;font-weight:700>))</span>
      <span style=color:#204a87;font-weight:700>return</span> <span style=color:#204a87;font-weight:700>null</span><span style=color:#ce5c00;font-weight:700>;</span>
    <span style=color:#204a87;font-weight:700>else</span> 
      <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>Arrays</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>copy</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>lastFactors</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>lastFactors</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>length</span><span style=color:#ce5c00;font-weight:700>);</span>
  <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>对于在访问和更新多个相关变量时出现的竟态条件问题，可以通过将所有这些变量保存在一个不可变对象中来消除。如果是一个可变的对象，就必须使用锁来确保原子性。如果是一个不可变的对象，那么当线程获得了对该对象的引用后，就不必担心另一个线程会修改对象的状态。如果要更新这些变量，那么可以创建一个新的容器对象，但其他使用原子变量的线程仍然会看到对象处于一致的状态。</p>
<p>程序清单 3-13 中的 VolatileCachedFactorizer 使用了 OneValueCache 来保存缓存的数值机器因数。当一个线程将 volatile 类型的 cache 设置为引用一个新的 OneValueCache 时，其他线程就会立即看到新缓存的数据。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#5c35cc;font-weight:700>@ThreadSafe</span>
<span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>VolatileCachedFactorizer</span> <span style=color:#204a87;font-weight:700>implements</span> <span style=color:#000>Servlet</span> <span style=color:#ce5c00;font-weight:700>{</span>
  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>volatile</span> <span style=color:#000>OneValueCache</span> <span style=color:#000>cache</span> <span style=color:#ce5c00;font-weight:700>=</span> 
    <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>OneValueCache</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>null</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#204a87;font-weight:700>null</span><span style=color:#ce5c00;font-weight:700>);</span>
  
  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>service</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>ServletRequest</span> <span style=color:#000>req</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>ServletResponse</span> <span style=color:#000>resp</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#000>BigInteger</span> <span style=color:#000>i</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>extractFromRequest</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>req</span><span style=color:#ce5c00;font-weight:700>);</span>
    <span style=color:#000>BitInteger</span><span style=color:#ce5c00;font-weight:700>[]</span> <span style=color:#000>factors</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>cache</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>getFactors</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>i</span><span style=color:#ce5c00;font-weight:700>);</span>
    <span style=color:#204a87;font-weight:700>if</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>factors</span> <span style=color:#ce5c00;font-weight:700>==</span> <span style=color:#204a87;font-weight:700>null</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
      <span style=color:#000>factors</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>factor</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>i</span><span style=color:#ce5c00;font-weight:700>);</span>
      <span style=color:#000>cache</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>OneValueCache</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>i</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>factors</span><span style=color:#ce5c00;font-weight:700>);</span>
    <span style=color:#ce5c00;font-weight:700>}</span>
    <span style=color:#000>encodeIntoResponse</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>resp</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>factors</span><span style=color:#ce5c00;font-weight:700>);</span>
  <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>与 cache 相关的操作不会互相干扰，因为 OneValueCache 是不可变的，并且在每条相应的代码路劲中只会访问它一次。通过使用包含多个状态变量的容器来维持不变性条件，并使用一个 volatile 类型的引用来确保可见性，使得 VolatileCachedFactorizer 在没有使用显式锁的情况下依然是线程安全的。</p>
<h2 id=35-安全发布>3.5 安全发布</h2>
<p>到目前为止，我们重点讨论的是如何确保对象不会被发布，例如让对象封闭在线程或另一个对象的内部。当然，在某些情况下我们希望在多个线程间共享对象，此时必须确保安全的进行共享。然而，如果只是像程序清单 3-14 那样将对象引用保存到公有域中，那么还不足以安全的发布这个对象。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#8f5902;font-style:italic>// 不安全的发布
</span><span style=color:#8f5902;font-style:italic></span><span style=color:#204a87;font-weight:700>public</span> <span style=color:#000>Holder</span> <span style=color:#000>holder</span><span style=color:#ce5c00;font-weight:700>;</span>

<span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>initialize</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span>
  <span style=color:#000>holder</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span>  <span style=color:#000>Holder</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>42</span><span style=color:#ce5c00;font-weight:700>);</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>你可能会奇怪，这个看似没有问题的示例为何会运行失败。由于存在可见性问题，其他线程看到的 Holder 对象将处于不一致的状态，即便在该对象的构建函数中已经正确的构建了不变性条件。这种不正确的发布导致其他线程能够看到尚未创建完成的对象。</p>
<h3 id=351-不正确的发布正确的对象被发布>3.5.1 不正确的发布：正确的对象被发布</h3>
<p>你不能指望一个尚未被完全创建的对象拥有完整性。某个观察该对象的线程将看到对象处于不一致的状态，然后看到对象的状态突然发生变化，即使线程在对象发布后还没有修改过它。事实上，如果程序清单 3-15 中的 Holder 使用程序清单 3-14 中的不安全方式发布，那么另一个线程在调用 assertSanity 时将抛出 AssertionError。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>Holder</span> <span style=color:#ce5c00;font-weight:700>{</span>
  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>n</span><span style=color:#ce5c00;font-weight:700>;</span>
  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#000>Holder</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>n</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span><span style=color:#204a87;font-weight:700>this</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>n</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>n</span><span style=color:#ce5c00;font-weight:700>;}</span>
  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>assertSanity</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#204a87;font-weight:700>if</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>n</span> <span style=color:#ce5c00;font-weight:700>!=</span> <span style=color:#000>n</span><span style=color:#ce5c00;font-weight:700>)</span>
      <span style=color:#204a87;font-weight:700>throw</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>AssertionError</span><span style=color:#ce5c00;font-weight:700>()</span>
  <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>由于没有使用同步来确保 Holder 对象对其他线程可见，因此将 Holder 称为“未被正确发布”。在未被正确发布的对象中存在两个问题。首先，除了发布对象的线程外，其他线程可以看到 Holder 域是一个失效值，因此将看到一个空引用或者之前的旧值。然而，更糟糕的情况是，线程看到 Holder 引用的值是最新的，某个线程在第一次读取域时得到失效值，而在此读取这个域时会得到一个更新值，这也是 assertSainty 抛出异常的原因。</p>
<p>如果没有足够的同步，那么当在多个线程间共享数据时将发生一些非常奇怪的事情。</p>
<h3 id=352-不可变对象与初始化安全性>3.5.2 不可变对象与初始化安全性</h3>
<p>由于不可变对象是一种非常重要的对象，因此 Java 内存模型为不可变对象的共享提供了一种特殊的初始化安全性保证。我们已经知道，即使某个对象的引用对其他线程是可见的，也并不意味着对象状态对于使用该对象的线程来说一定是可见的。为了确保对象状态呈现出一致的视图，就必须使用同步。</p>
<p>另一方面，即使在发布不可变对象的引用时没有使用同步，也仍然可以安全的访问该对象。为了维持这种初始化安全性保证，必须满足不可变性的所有需求：状态不可修改、所有域都是 final 类型、以及正确的构造过程。</p>
<blockquote>
<p>任何线程都可以在不需要额外同步的情况下安全的访问不可变对象，即使在发布这些对象时没有使用同步。</p>
</blockquote>
<p>这种保证还将延伸到被正确创建对象中所有 final 类型的域。在没有额外同步的情况下，也可以安全的访问 final 类型的域。然而，如果 final 类型的域所指向的是可变对象，那么在访问这些域所指向的对象的状态时仍然需要同步。</p>
<h3 id=353-安全发布的常用模式>3.5.3 安全发布的常用模式</h3>
<p>可变对象必须通过安全的方式来发布，这通常意味着在发布和使用该对象的线程时都必须使用同步。现在，我们将重点介绍如何确保使用对象的线程能够看到该对象处于已发布的状态，并稍后介绍如何在对象发布后对其可见性进行修改。</p>
<blockquote>
<p>要安全的发布一个对象，对象的引用以及对象的状态必须同时对其他线程可见。一个正确构造的对象可以通过以下方式来安全的发布：</p>
<ol>
<li>在静态初始化函数中初始化一个对象引用。</li>
<li>将对象的引用保存到 volatile 类型的域或者 AtomicReference 对象中。</li>
<li>将对象的引用保存到某个正确构造对象的 fianl 类域中。</li>
<li>将对象的引用保存到一个由锁保护的域中。</li>
</ol>
</blockquote>
<p>在线程安全容器内部的同步意味着，在将对象放入到某个容器，例如 Vector 或者 synchronizedList 时，将满足上述最后一条需求。如果线程 A 将对象 X 放入一个线程安全的容器，随后线程 B 读取这个对象，那么可以确保 B 看到 A 设置的 X 状态，即便在这段 读/写 X 的应用程序代码中没有包含显式的同步。尽管 Javadoc 在这个主题上没有给出清晰的说明，但线程安全库中的容器类提供了以下安全发布保证：</p>
<ul>
<li>通过将一个键或值放入到 Hashtable、synchronizedList 或 ConcurrentMap 中，可以安全的将它发布给任何从这些容器中访问它的线程(无论是直接访问还是通过迭代器访问)。</li>
<li>通过将某个元素放入 Vector、CopyOnWriteArrayList、CopyOnWriteArraySet、SynchronizedList、SynchronizedSet 中，可以将该元素安全的发布到任何从这些容器中访问该元素的线程。
通过将某个元素放入 BlockingQueue 或 ConcurrentLinkedQueue 中，可以将该元素安全的帆布到任何从这些队列中访问该元素的线程。</li>
</ul>
<p>类库中的其他数据传递机制(如 Future 或 Exchanger)同样能实现安全发布，在介绍这些机制时将讨论它们的安全发布功能。</p>
<p>通常，要发布一个静态构造的对象，最简单和最安全的方式是使用静态的初始化器：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>static</span> <span style=color:#000>Holder</span> <span style=color:#000>holder</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>Holder</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>42</span><span style=color:#ce5c00;font-weight:700>);</span>
</code></pre></div><p>静态初始化器由 JVM 在类的初始化阶段执行。由于 JVM 内部存在同步机制，因此通过这种方式初始化的任何对象都可以被安全的发布。</p>
<h3 id=354-事实不可变对象>3.5.4 事实不可变对象</h3>
<p>如果对象在发布后不会被修改，那么对于其他在没有额外同步的情况下安全的访问这些对象的线程来说，安全发布是足够的。所有的安全发布机制都能确保，当对象的引用对所有访问该对象的线程可见时，对象发布时的状态对于所有线程都是可见的，并且如果对象状态不会再改变，那么久足以保证任何访问都是安全的。</p>
<p>如果对象从技术上看是可变的，但其状态在发布后不会再改变，那么把这种对象称为“事实不可变对象”。这些对象不需要满足 3.4 节中提出的不可变性的严格定义。在这些对象发布后，程序只需要将它们视为不可变对象即可。通过使用事实不可变对象，不仅可以简化开发过程，而且还能由于减少了同步而提高性能。</p>
<blockquote>
<p>没有额外的同步的情况下，任何线程都可以安全的使用被安全发布的事实不可变对象。</p>
</blockquote>
<p>例如，Date 本身是不可变的，但如果将其作为不可变对象来使用，那么在多个线程之间共享 Date 对象时，就可以省去对锁的使用。假设要维护一个 Map 对象，其中保存了每位用户的最近登录时间：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#204a87;font-weight:700>public</span> <span style=color:#000>Map</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>String</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>Date</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>lastLogin</span> <span style=color:#ce5c00;font-weight:700>=</span> 
  <span style=color:#000>Collection</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>synchronizedMap</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>HashMap</span><span style=color:#ce5c00;font-weight:700>&lt;&gt;());</span>
</code></pre></div><p>如果 Date 对象的值在被放入 Map 后就不再会被改变，那么 synchronizedMap 中的同步机制就足以使 Date 值被安全的发布，并且在访问这些 Date 值时不需要使用额外的同步。</p>
<h3 id=355-可变对象>3.5.5 可变对象</h3>
<p>如果对象在构造之后可以被修改，那么安全发布只能确保“发布当时”状态的可见性。对于可变对象，不仅在发布对象时需要使用同步，而且在每次对象访问时同样需要使用同步来确保后续修改操作的可见性。要安全的共享可变对象，这些对象就必须被安全的发布，并且必须是线程安全的或者由某个锁保护起来。</p>
<blockquote>
<p>对象的发布需求取决于它的可变性：</p>
<ol>
<li>不可变对象可以通过任意机制来发布。</li>
<li>事实不可变对象必须通过安全方式来发布。</li>
<li>可变对象必须通过安全方式来发布，并且必须是线程安全的或者由某个锁保护起来。</li>
</ol>
</blockquote>
<h3 id=356-安全地共享对象>3.5.6 安全地共享对象</h3>
<p>当获得对象的一个引用时，你需要知道在这个引用上可以执行哪些操作。在使用它之前是否要获得一个锁？是否可以修改它的状态？或者只能读取它？许多并发错误都是由于没有理解共享对象的这些“既定规则”而导致的。当发布一个对象时，必须明确的说明对象的访问方式。</p>
<blockquote>
<p>在并发编程中使用和共享对象时，可以使用一些实用的策略，包括：</p>
<ul>
<li>线程封闭。线程封闭的对象只能由一个线程拥有，对象对封闭在该线程内，并且只能由这个线程修改。</li>
<li>只读共享。线程安全的对象在其内部实现同步，因此多个线程可以通过对象的公有接口来进行访问而无需进一步的同步。</li>
<li>保护对象。被保护的对象只能通过持有特定的锁来访问。保护对象包括封装在其他线程安全对象中的对象，以及已发布的并且由某个特定锁保护的对象。</li>
</ul>
</blockquote>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-9f6825bf562acd8b247cf517233cbbfc>4 - CH04-对象组合</h1>
<p>到目前为止，我们已经介绍了关于线程安全与同步的一些基础知识。然而，我们并不希望对每一次的内存访问都进行分析以确保程序是线程安全的，而是希望将一些现有的线程安全组件组合为更大规模的组件或程序。本章将介绍一些组合模式，这些模式能够使一个类更容易实现线程安全，并且在维护这些类时不会在无意中破坏类的安全性保证。</p>
<h2 id=41-设计线程安全的类>4.1 设计线程安全的类</h2>
<p>在线程安全的程序中，虽然可以将程序的所有状态都保存在公有的静态域中，但与那些将状态封装起来的程序相比，这些程序的线程安全性更难以得到验证，并且在修改时也更难以始终确保其线程安全性。通过使用封装技术，可以使得在不对整个程序进行分析的情况下就可以判断一个类是否是线程安全的。</p>
<blockquote>
<p>在设计线程安全类的过程中，需要包含以下三个基本要素：</p>
<ul>
<li>找出构成对象状态的所有变量。</li>
<li>找出约束状态变量的不变性条件。</li>
<li>建立对象状态的并发访问管理策略。</li>
</ul>
</blockquote>
<p>要分析对象的状态，首先从对象的域开始。如果对象中所有的域都是基本类型的变量，那么这些域将构成对象的全部状态。程序清单 4-1 中的 Counter 只有一个域——value，因此这个域就是 Counter 的全部状态。对于含有 n 个基本类型的域的对象，其状态就是这些域构成的 n 元组。例如，二维点的状态就是它的坐标值 (x,y)。如果在对象的域中引用了其他对象，那么该对象的状态将包含被引用对象的域。例如，LinkedList 的状态就包括该链表中所有节点对象的状态。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#5c35cc;font-weight:700>@ThreadSafe</span>
<span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>final</span> <span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>Counter</span> <span style=color:#ce5c00;font-weight:700>{</span>
  <span style=color:#5c35cc;font-weight:700>@GuardedBy</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#4e9a06>&#34;this&#34;</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>long</span> <span style=color:#000>value</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>0</span><span style=color:#ce5c00;font-weight:700>;</span>
  
  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>synchronized</span> <span style=color:#204a87;font-weight:700>long</span> <span style=color:#000>getValue</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>value</span><span style=color:#ce5c00;font-weight:700>;</span>
  <span style=color:#ce5c00;font-weight:700>}</span>
  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>synchronized</span> <span style=color:#204a87;font-weight:700>long</span> <span style=color:#000>increment</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#204a87;font-weight:700>if</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>value</span> <span style=color:#ce5c00;font-weight:700>==</span> <span style=color:#000>Long</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>MAX_VALUE</span><span style=color:#ce5c00;font-weight:700>)</span>
      <span style=color:#204a87;font-weight:700>throw</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>IllegalStateException</span><span style=color:#ce5c00;font-weight:700>();</span>
    <span style=color:#204a87;font-weight:700>return</span> <span style=color:#ce5c00;font-weight:700>++</span><span style=color:#000>value</span><span style=color:#ce5c00;font-weight:700>;</span>
  <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>“同步策略”定义了如何在不违背对象不变性条件或后验条件的情况下对其状态的访问操作进行协同。同步策略规定了如何将不可变性、线程封闭、加锁机制等结合起来以维护线程的安全性，并且还规定了哪些变量由哪些锁来保护。要确保开发人员可以对这个类进行分析和维护，就必须将同步策略写为正式文档。</p>
<h3 id=411-收集同步需求>4.1.1 收集同步需求</h3>
<p>要确保类的线程安全性，就需要确保它的不变性条件不会在并发访问的情况下被破坏，这就需要对其状态进行推断。对象与变量都有一个状态空间，即所有可能的取值。状态空间越小，就越容易判断线程的状态。final 类型的域越多，就越能简化对象可能状态的分析过程。(在极端情况下，不可变对象只有唯一的状态)</p>
<p>在许多类中都定义了一些不可变条件，用于判断状态的有效性。Counter 中的 value 域是 long 类型的变量，其状态空间从 Long.MIN_VALUE 到 Long.MAX_VALUE，但 Counter 中 value 在取值范围上存在着一个限制，即不能是负值。</p>
<p>同样，在操作中还会包含一些后验条件来判断状态迁移是否有效。如果 Counter 的当前状态为 17，那么下一个有效状态只能是 18。当下一个状态需要依赖当前状态时，这个操作就必须是一个复合操作。并非所有的操作都会在状态转换上施加限制，例如，当更新一个保存当前温度的变量时，该变量之前的值并不会影响计算结果。</p>
<p>由于不变性条件以及后验条件在状态转换上施加了各种约束，因此就需要额外的同步与封装。如果某些状态是无效的，那么必须对底层的状态变量进行封装，否则客户代码可能会使对象处于无效状态。如果在某个操作中存在无效的状态转换，那么该操作必须是原子的。另外，如果在类中没有施加这种约束，那么就可以放宽封装性或序列化等需求，以便获得更高的灵活性或性能。</p>
<p>在类中可以包含同时约束多个状态变量的不变性条件。在一个表示数值范围的类中可以包含两个状态变量，分别表示范围的上下界。这些变量必须遵循的约束是，下界值应该小于等于上界值。类似于这种包含多个变量的不变性条件将带来原子性需求：这些相关的变量必须在原子操作中进行读取或更新。不能首先更新一个变量值然后释放锁并再次获得锁，然后再更新其他变量。因为释放锁后，可能会使对象处于无效状态。如果在一个不变性条件中包含多个变量，那么在执行任何访问相关变量的操作时，都必须持持有保护这些变量的锁。</p>
<blockquote>
<p>如果不了解对象的不变性条件和后验条件，就不能确保线程安全性。要满足在状态变量的有效值或在状态转换上的各种约束条件，就需要借助于原子性和封装性。</p>
</blockquote>
<h3 id=412-依赖状态的操作>4.1.2 依赖状态的操作</h3>
<p>类的不变性条件与后验条件约束了在对象上有哪些状态和状态转换是有效的。在某些对象的方法中还包含一些基于状态的先验条件。例如，不能从空队列中移除一个元素，在删除元素前，队列必须处于“非空的”状态。如果在某个操作中包含有基于状态的先验条件，那么这个操作就称为依赖状态的操作。</p>
<p>在单线程程序中，如果某个操作无法满足先验条件，那么就只能失败。但在并发程序中，先验条件可能会由其他线程执行的操作而变为真。在并发程序中要一直等到先验条件为真，然后再执行该操作。</p>
<p>在 Java 中，等待某个条件为真的各种内置机制(包括等待和通知等机制)都与内置加锁机制紧密关联，要想正确的使用它们并不容易。要想实现某个等待先验条件为真时才执行的操作，一种更简单的方法是通过现有库中的类来实现依赖状态的行为。</p>
<h3 id=413-状态的所有权>4.1.3 状态的所有权</h3>
<p>4.1 节曾指出，如果以某个对象为根节点构造一张对象图，那么该对象的状态将是对象图中所有对象包含的域的一个子集。为什么是一个子集？在从该对象可以到达的所有域中，需要满足哪些条件才不属于该对象状态的一部分？</p>
<p>在定义将由哪些变量构成对象的状态时，只考虑对象拥有的数据。所有权在 Java 中并没有得到充分的体现，而是属于类设计中的一个要素。如果分配并填充了一个 HashMap 对象，那么就相当于创建了多个对象：HashMap 对象，在 HashMap 对象中包含的多个对象，以及在 Map.Entry 中可能包含的内部对象。HashMap 对象的逻辑状态包含所有的 Map.Entry 对象以及内部对象，即使这些对象都是一些独立的对象。</p>
<p>无论如何，垃圾回收机制使我们避免了如何处理所有权的问题。在 C++ 中，当把一个对象传递给某个方法时，必须认真考虑这种操作是否传递对象的所有权，是短期的所有权还是长期的所有权。在 Java 中同样存在这样的所有权模型，只不过垃圾回收器为我们减少了许多在引用共享方面常见的错误，因此降低了在所有权处理上的开销。</p>
<p>许多情况下，所有权与封装性总是互相关联的：对象封装它拥有的状态，反之也成立，即对它封装的状态拥有所有权。状态变量的所有者将决定采用何种加锁协议来维持变量状态的完整性。所有权意味着控制权。然而，如果发布了某个不可变对象的引用，那么久不再拥有独占的控制权，最多是“共享控制权”。对于从构造函数或者从方法中传递进来的对象，类通常并不拥有这些对象，除非这些方法是专门设计为转义传递进来的对象的所有权的。</p>
<p>容器类通常表现出一种“所有权分离”的形式，其中容器类拥有自身的状态，而客户端代码则拥有容器中各个对象的状态。Servlet 框架中的 ServletContext 就是其中一个示例。ServletContext 为 Servlet 提供了类似于 Map 形式的对象容器服务，在 ServletContext 中可以通过名称来注册或获取应用程序对象。由 Servlet 容器实现的 ServletContext 对象必须是线程安全的，因为它肯定会被多个线程同时访问。当调用 setAttribute 和 getAttribute 时，Servlet 不需要使用同步，但当使用保存在 ServletContext 中的对象时，则可能需要使用同步。这些对象由应用程序拥有，Servlet 容器只是替应用程序保管它们。与所有共享对象一样，它们必须安全的被共享。为了防止多个线程在并发访问同一个对象时产生的相互干扰，这些对象应该要么是线程安全的对象，要么是事实不可变的对象，或者由锁来保护的对象。</p>
<h2 id=42-实例封闭>4.2 实例封闭</h2>
<p>如果某对象不是线程安全的，那么可以通过多种技术使其在多线程程序中安全的使用。你可以确保该对象只能由单个线程访问(线程封闭)，或者由锁来保护对该对象的所有访问。</p>
<p>封装简化了线程安全类的实现过程，它实现了一种实例封闭机制，通常简称为“封闭”。当一个对象被封装到另一个对象中时，能够访问被封装对象的所有代码路径都是已知的。与对象可以由整个程序访问的情况相比，更易于对代码进行分析。通过将封闭机制与合适的加锁策略结合起来，可以确保以线程安全的方式来使用非线程安全的对象。</p>
<blockquote>
<p>将数据封装在对象内部，可以将数据的访问限制在对象的方法上，从而更容易确保线程在访问数据时总能持有正确的锁。</p>
</blockquote>
<p>被封闭对象一定不能超出它们既定的作用域。对象可以封装在类的一个实例(如作为类的私有成员)中，或者封装在一个作用域内(如作为一个局部变量)，再或者封闭在线程内(如在某个线程中将对象从一个方法传递到另一个方法，而不是在多个线程间共享该对象)。当然，对象本身不会逸出——发生逸出通常是由于开发人员在发布对象时超出了对象既定的作用域。</p>
<p>程序清单 4-2 中的 PersonSet 说明了如何通过封闭与加锁等机制是一个类称为线程安全的。PersonSet 的状态由 HashSet 来管理，而 HashSet 并非线程安全，但由于 mySet 是私有的且不会逸出，因此 HashSet 被封闭在 PersonSet 中。唯一能访问 mySet 的代码路径是 addPerson 与 containsPerson，在执行它们时都需要获得一个 PersonSet 上的锁。PersonSet 的状态完全由它的内置锁保护，因而 PersonSet 是一个线程安全的类。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#5c35cc;font-weight:700>@ThreadSafe</span>
<span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>PersonSet</span> <span style=color:#ce5c00;font-weight:700>{</span>
  <span style=color:#5c35cc;font-weight:700>@GuardedBy</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#4e9a06>&#34;this&#34;</span><span style=color:#ce5c00;font-weight:700>)</span>
  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>Set</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>Person</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>mySet</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>HashSet</span><span style=color:#ce5c00;font-weight:700>&lt;&gt;();</span>
  
  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>synchronized</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>addPerson</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>Person</span> <span style=color:#000>p</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#000>mySet</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>add</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>p</span><span style=color:#ce5c00;font-weight:700>);</span>
  <span style=color:#ce5c00;font-weight:700>}</span>
  
  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>synchronized</span> <span style=color:#204a87;font-weight:700>boolean</span> <span style=color:#000>contains</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>Person</span> <span style=color:#000>p</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>mySet</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>contains</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>p</span><span style=color:#ce5c00;font-weight:700>);</span>
  <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>这个示例并未对 Person 类的线程安全性做任何假设，但如果 Person 类是可变的，那么在访问从 PersonSet 中获得的 Person 对象时，还需要额外的同步。要想安全的使用 Person 对象，最可靠的方法就是使 Person 成为一个线程安全的类。另外，也可以使用锁来保护 Person 对象，并确保所有客户端代码在访问 Person 对象之前都已经获得了正确的锁。</p>
<p>实例封闭是构建线程安全的一个最简单方式，它还是的在锁策略的选择上拥有了更多的灵活性。在 PersonSet 中使用了它的内置锁来保护状态，但对于其他形式的锁来说，只要至始至终都使用同一个锁，就可以保护状态。实例封闭还使得不同的状态变量可以由不同的锁来保护。</p>
<p>在 Java 平台的类库中还有很多线程封闭的实例，其中有些类的唯一用途就是将非线程安全的类转换为线程安全。一些基本容器并非线程安全，例如 ArrayList 和 HashMap，但类库提供了包装工厂方法，使得这些非线程安全的类可以在多线程环境中安全的使用。这些工厂方法通过“装饰器”模式将容器类封装在一个同步的包装器对象中，而包装器能将接口中的每个方法都实现为同步方法，并将调用请求转发到底层的容器对象上。只要包装器对象拥有对底层容器对象的唯一引用(即把底层容器对象封闭在包装器中)，那么他就是线程安全的。在这些方法的 Javadoc 中指出，对底层容器对象的所有访问必须通过包装器来进行。</p>
<p>当然，如果将一个本该封闭的对象发布出去，那么也能破坏封装性。如果一个对象本应该封闭在特定的作用域中，那么让该对象逸出作用域就是一个错误。当发布其他对象时，例如迭代器或内部的类实例，可能会间接的发布被封闭的对象，同样会使封闭对象逸出。</p>
<blockquote>
<p>封闭机制更易于构造线程安全的类，因为当封闭类的状态时，在分析类的线程安全性时就无需检查整个程序。</p>
</blockquote>
<h3 id=421-java-监视器模式>4.2.1 Java 监视器模式</h3>
<p>从线程封闭原则及其逻辑推论可以得出 Java 监视器模式。遵循 Java 监视器模式的对象会把对象的所有可变状态都封装起来，并由对象的内置锁来保护。</p>
<p>在代码清单 4-1 的 Counter 中给出了这种模式的一个典型示例。在 Counter 中封装了一个状态变量 value，对该变量的所有访问都需要通过 Counter 的方法来执行，并且这些方法都是同步的。</p>
<p>在许多类中都使用了 Java 监视器模式，例如 Vector 和 Hashtable。在某些情况下，程序需要一种更复杂的同步策略。第 11 章将介绍如何通过细粒度的加锁策略来提高可伸缩性。Java 监视器模式的主要优势在于它的简单性。</p>
<p>Java 监视器模式仅仅是一种编写代码的约定，对于任何一种锁对象，只要至始至终的使用该锁对象，都可以用来保护对象的状态。程序清单 4-3 给出了如何使用私有锁来保护状态。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>PrivateLock</span> <span style=color:#ce5c00;font-weight:700>{</span>
  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>Object</span> <span style=color:#000>myLock</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>Object</span><span style=color:#ce5c00;font-weight:700>();</span>
  <span style=color:#5c35cc;font-weight:700>@GuardedBy</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#4e9a06>&#34;myLock&#34;</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#000>Widget</span> <span style=color:#000>widget</span><span style=color:#ce5c00;font-weight:700>;</span>
  
  <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>someMethod</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#204a87;font-weight:700>synchronized</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>myLock</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
      <span style=color:#8f5902;font-style:italic>// 访问或修改 Widget 的状态
</span><span style=color:#8f5902;font-style:italic></span>    <span style=color:#ce5c00;font-weight:700>}</span>
  <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>使用私有锁对象而不是内置锁(或其他任何可以通过共有方式访问的锁)，有许多优点。私有的锁对象可以将锁封装起来，使客户端代码无法获得锁，但客户端可以通过公有方法访问锁，以便参与到它的同步策略中。如果客户端代码错误的获得了另一个对象的锁，那么可能会产生活跃性问题。此外，要想验证某个公有方法的锁在程序中是否本正确的使用，则需要检查整个程序，而不是单个的类。</p>
<h3 id=422-示例车辆追踪>4.2.2 示例：车辆追踪</h3>
<p>程序清单 4-1 中的 Counter 是一个简单但用处不大的 Java 监视器示例。我们来看一个更有用处的示例：一个用于调度车辆的“车辆追踪器”，例如出租车、警车、货车等。首先使用监视器模式来构建追踪器，然后再尝试放宽某些封装性需求同时又保证线程安全性。</p>
<p>每台车都由一个 String 对象来标识，并且拥有一个相应的坐标位置 (x,y)。在 VehicleTracker 类中封装了车辆的标识和位置，因而它非常适合作为基于 MVC 模式的 GUI 应用程序中的数据模型，并且该模型将由一个视图线程和多个执行更新操作的线程共享。视图线程会读取车辆的标识和位置，并将它们展示在界面上：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#000>Map</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>String</span><span style=color:#ce5c00;font-weight:700>,</span><span style=color:#000>Point</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>locations</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>vehicles</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>getLocations</span><span style=color:#ce5c00;font-weight:700>();</span>
<span style=color:#204a87;font-weight:700>for</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>String</span> <span style=color:#000>key</span><span style=color:#ce5c00;font-weight:700>:</span> <span style=color:#000>locations</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>keySet</span><span style=color:#ce5c00;font-weight:700>())</span> 
  <span style=color:#000>renderVehicle</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>key</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>locations</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>get</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>key</span><span style=color:#ce5c00;font-weight:700>));</span>
</code></pre></div><p>类似的，执行更新操作的线程通过从 GPS 设备上获取的数据或者调度员从 GUI 界面上输入的数据来修改车辆的位置。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>vehicleMoved</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>VehicleMovedEvent</span> <span style=color:#000>evt</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
  <span style=color:#000>Point</span> <span style=color:#000>loc</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>evt</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>getNewLocation</span><span style=color:#ce5c00;font-weight:700>();</span>
  <span style=color:#000>vehicles</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>setLocation</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>evt</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>getVehicleId</span><span style=color:#ce5c00;font-weight:700>(),</span> <span style=color:#000>loc</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>x</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>loc</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>y</span><span style=color:#ce5c00;font-weight:700>);</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>从视图线程与执行更新操作的线程将并发的访问数据模型，因此该模型必须是线程安全的。程序清单 4-4 给出了一个基于 Java 监视器模式实现的“车辆追踪器”，其中使用了程序清单 4-5 中的 MutanlePoint 来表示车辆位置。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#5c35cc;font-weight:700>@ThreadSafe</span> 
<span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>MonitorVehicleTracker</span> <span style=color:#ce5c00;font-weight:700>{</span>

  <span style=color:#5c35cc;font-weight:700>@GuardedBy</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#4e9a06>&#34;this&#34;</span><span style=color:#ce5c00;font-weight:700>)</span> 
  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>Map</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>String</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>MutablePoint</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>locations</span><span style=color:#ce5c00;font-weight:700>;</span>

  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#000>MonitorVehicleTracker</span><span style=color:#ce5c00;font-weight:700>(</span> <span style=color:#000>Map</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>String</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>MutablePoint</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>locations</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span> 
    <span style=color:#204a87;font-weight:700>this</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>locations</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>deepCopy</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>locations</span><span style=color:#ce5c00;font-weight:700>);</span> 
  <span style=color:#ce5c00;font-weight:700>}</span>

  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>synchronized</span> <span style=color:#000>Map</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>String</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>MutablePoint</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>getLocations</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span> 
    <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>deepCopy</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>locations</span><span style=color:#ce5c00;font-weight:700>);</span> 
  <span style=color:#ce5c00;font-weight:700>}</span>

  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>synchronized</span> <span style=color:#000>MutablePoint</span> <span style=color:#000>getLocation</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>String</span> <span style=color:#000>id</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#000>MutablePoint</span> <span style=color:#000>loc</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>locations</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>get</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>id</span><span style=color:#ce5c00;font-weight:700>);</span> 
    <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>loc</span> <span style=color:#ce5c00;font-weight:700>==</span> <span style=color:#204a87;font-weight:700>null</span> <span style=color:#ce5c00;font-weight:700>?</span> <span style=color:#204a87;font-weight:700>null</span> <span style=color:#ce5c00;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>MutablePoint</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>loc</span><span style=color:#ce5c00;font-weight:700>);</span> 
  <span style=color:#ce5c00;font-weight:700>}</span>

  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>synchronized</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>setLocation</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>String</span> <span style=color:#000>id</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>x</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>y</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span> 
    <span style=color:#000>MutablePoint</span> <span style=color:#000>loc</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>locations</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>get</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>id</span><span style=color:#ce5c00;font-weight:700>);</span> 
    <span style=color:#204a87;font-weight:700>if</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>loc</span> <span style=color:#ce5c00;font-weight:700>==</span> <span style=color:#204a87;font-weight:700>null</span><span style=color:#ce5c00;font-weight:700>)</span> 
      <span style=color:#204a87;font-weight:700>throw</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>IllegalArgumentException</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#4e9a06>&#34;No such ID: &#34;</span> <span style=color:#ce5c00;font-weight:700>+</span> <span style=color:#000>id</span><span style=color:#ce5c00;font-weight:700>);</span> 
    <span style=color:#000>loc</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>x</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>x</span><span style=color:#ce5c00;font-weight:700>;</span> <span style=color:#000>loc</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>y</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>y</span><span style=color:#ce5c00;font-weight:700>;</span> 
  <span style=color:#ce5c00;font-weight:700>}</span>

  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>static</span> <span style=color:#000>Map</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>String</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>MutablePoint</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>deepCopy</span><span style=color:#ce5c00;font-weight:700>(</span> <span style=color:#000>Map</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>String</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>MutablePoint</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>m</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span> 
    <span style=color:#000>Map</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>String</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>MutablePoint</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>result</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>HashMap</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>String</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>MutablePoint</span><span style=color:#ce5c00;font-weight:700>&gt;();</span> 
    <span style=color:#204a87;font-weight:700>for</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>String</span> <span style=color:#000>id</span> <span style=color:#ce5c00;font-weight:700>:</span> <span style=color:#000>m</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>keySet</span><span style=color:#ce5c00;font-weight:700>())</span> 
      <span style=color:#000>result</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>put</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>id</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>MutablePoint</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>m</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>get</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>id</span><span style=color:#ce5c00;font-weight:700>)));</span> 
    <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>Collections</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>unmodifiableMap</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>result</span><span style=color:#ce5c00;font-weight:700>);</span> 
  <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#ce5c00;font-weight:700>}</span>

<span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>MutablePoint</span> <span style=color:#ce5c00;font-weight:700>{</span> <span style=color:#8f5902;font-style:italic>/* Listing 4.5 */</span> <span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>虽然类 MutablePoint 不是线程安全的，但追踪器类是线程安全的。它所包含的 Map 对象和可变的 Point 对象都未曾发布。当需要返回车辆的位置时，通过 MutablePoint 拷贝构造函数或者 deepCopy 方法来复制正确的值，从而生成一个新的 Map 对象，并且该对象中的值与原有 Map 对象中的 key、value 值都相同。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#5c35cc;font-weight:700>@NotThreadSafe</span> 
<span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>MutablePoint</span> <span style=color:#ce5c00;font-weight:700>{</span> 
  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>x</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>y</span><span style=color:#ce5c00;font-weight:700>;</span>
  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#000>MutablePoint</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span> <span style=color:#000>x</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>0</span><span style=color:#ce5c00;font-weight:700>;</span> <span style=color:#000>y</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>0</span><span style=color:#ce5c00;font-weight:700>;</span> <span style=color:#ce5c00;font-weight:700>}</span> 
  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#000>MutablePoint</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>MutablePoint</span> <span style=color:#000>p</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#204a87;font-weight:700>this</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>x</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>p</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>x</span><span style=color:#ce5c00;font-weight:700>;</span>
    <span style=color:#204a87;font-weight:700>this</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>y</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>p</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>y</span><span style=color:#ce5c00;font-weight:700>;</span> 
  <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>在某种程度上，这种实现方式是通过在返回客户端代码之前复制可变数据来维持安全性的。通常情况下，这并不存在性能问题，但在车辆容器非常大的情况下将极大降低性能。此外，由于每次调用 getLocation 就要复制数据，因此将出现一种错误的情况——虽然车辆的实际位置发生了改变，但返回的信息却保持不变。这种情况的好坏，取决于你的需求。如果在 location 集合上存在内部的一致性需求，那么这就是有点，在这种情况下返回一致的快照就非常重要。然而，如果调用者需要每辆车的最新信息，那么这就是缺点，因为这需要非常频繁的刷新快照。</p>
<h3 id=43-线程安全性的委托>4.3 线程安全性的委托</h3>
<p>大多数对象都是组合对象。当从头开始构建一个类，或者将多个非线程安全的类组合成一个类时，Java 监视器模式是非常有用的。但是，如果类中的各个组件都已经是线程安全的，会是什么情况呢？我们是否需要再增加一个额外的线程安全层？答案是“视情况而定”。在某些情况下，通过多个线程安全类组合而成的类是线程安全的，而在某些情况下，这仅仅是一个好的开端。</p>
<p>在前面的 CountingFactorizer 类中，我们在一个无状态的类中增加了一个 Atomiclong 类型的域，并且得到的组合对象仍然是线程安全的。由于 CountingFactorizer 的状态就是 AtomicLong 的状态，而 AtomicLong 是线程安全的，因此 CountingFactorizer 不会对 counter 的状态施加额外的有效性约束，所以很容易知道 CountingFactorizer 是线程安全的。我们可以说 CountingFactorizer 将它的线程安全性委托给 AtomicLong 来保证：之所以 CountingFactorizer 是线程安全的，是因为 AtomicLong 是线程安全的。</p>
<h3 id=431-示例基于委托的车辆追踪器>4.3.1 示例：基于委托的车辆追踪器</h3>
<p>下面将介绍一下更实际的委托示例，构造一个委托给线程安全类的车辆追踪器。我们将车辆的位置保存到一个 Map 对象中，因此首先要实现一个线程安全的 Map 类，ConcurrentHashMap。我们还可以用一个不可变的 Point 类来代替 MutablePoint 以保存位置，如程序清单 4-6 所示。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#5c35cc;font-weight:700>@Immutable</span>
<span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>Point</span> <span style=color:#ce5c00;font-weight:700>{</span>
  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>final</span> <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>x</span><span style=color:#ce5c00;font-weight:700>,</span><span style=color:#000>y</span><span style=color:#ce5c00;font-weight:700>;</span>
  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#000>Point</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>x</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>y</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#204a87;font-weight:700>this</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>x</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>x</span><span style=color:#ce5c00;font-weight:700>;</span>
    <span style=color:#204a87;font-weight:700>this</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>y</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>y</span><span style=color:#ce5c00;font-weight:700>;</span>
  <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>由于 Point 类是不可变的，因而它是线程安全的。不可变的值可以被自由的共享与发布，因此在返回 location 时不需要复制。</p>
<p>在程序清单 4-7 的 DelegatingVehicleTracker 中没有使用任何显式的同步，所有对状态的访问都由 ConcurrentHashMap 来管理，而且 Map 所有的键和值都是不可变的。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#5c35cc;font-weight:700>@ThreadSafe</span>
<span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>DelegatingVehicleTracker</span> <span style=color:#ce5c00;font-weight:700>{</span>
  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>ConcurrentMap</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>String</span><span style=color:#ce5c00;font-weight:700>,</span><span style=color:#000>Point</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>locations</span><span style=color:#ce5c00;font-weight:700>;</span>
  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>Map</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>String</span><span style=color:#ce5c00;font-weight:700>,</span><span style=color:#000>Poing</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>unmodifiableMap</span><span style=color:#ce5c00;font-weight:700>;</span>
  
  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#000>DelegatingVehicleTracker</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>Map</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>String</span><span style=color:#ce5c00;font-weight:700>,</span><span style=color:#000>Poing</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>points</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#000>locaitions</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>ConcurrentHashMap</span><span style=color:#ce5c00;font-weight:700>&lt;&gt;(</span><span style=color:#000>points</span><span style=color:#ce5c00;font-weight:700>);</span>
    <span style=color:#000>unmodifiableMap</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>Collections</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>unmodifiableMap</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>locations</span><span style=color:#ce5c00;font-weight:700>);</span>
  <span style=color:#ce5c00;font-weight:700>}</span>
  
  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#000>Map</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>String</span><span style=color:#ce5c00;font-weight:700>,</span><span style=color:#000>Poing</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>getLocations</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>unmodifiableMap</span><span style=color:#ce5c00;font-weight:700>;</span>
  <span style=color:#ce5c00;font-weight:700>}</span>
  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#000>Point</span> <span style=color:#000>geg</span> <span style=color:#000>Location</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>String</span> <span style=color:#000>id</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>locations</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>get</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>id</span><span style=color:#ce5c00;font-weight:700>);</span>
  <span style=color:#ce5c00;font-weight:700>}</span>
  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>setLocation</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>String</span> <span style=color:#000>id</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>x</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>y</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#204a87;font-weight:700>if</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>locations</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>replace</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>id</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>Point</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>x</span><span style=color:#ce5c00;font-weight:700>,</span><span style=color:#000>y</span><span style=color:#ce5c00;font-weight:700>))</span> <span style=color:#ce5c00;font-weight:700>==</span> <span style=color:#204a87;font-weight:700>null</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
      <span style=color:#204a87;font-weight:700>throw</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>IllegalArgumentException</span><span style=color:#ce5c00;font-weight:700>();</span>
    <span style=color:#ce5c00;font-weight:700>}</span>
  <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>如果使用最初的 MutablePoint 而不是 Point 类就会破坏封装性，因为 getLocations 会发布一个指向可变状态的引用，而这个引用不是线程安全的。需要注意的是，我们稍微改变了车辆追踪器的行为。在使用监视器模式的车辆追踪器中返回的是车辆位置的快照，而在使用委托的车辆追踪器中放回的是一个不可修改但却保持实时的车辆位置视图。这意味着，如果线程 A 调用 getLocations，而线程 B 在随后修改了某些点的位置，那么在返回给线程 A 的 Map 中将反应出这些变化。在前面提到过，这可能是一种优点，也可能是一种缺点，取决于具体需求。</p>
<p>如果需要一个不会发生变化的车辆视图，那么 getlocations 可以返回对 locations 这个 Map 对象的一个浅拷贝。由于 Map 的内容是不可变的，因此只需复制 Map 的结构，而不用复制它的内容，如程序清单 4-8 所示。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#204a87;font-weight:700>public</span> <span style=color:#000>Map</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>Stirng</span><span style=color:#ce5c00;font-weight:700>,</span><span style=color:#000>Point</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>getLocations</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span>
  <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>Collections</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>unmodifiableMap</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>HashMap</span><span style=color:#ce5c00;font-weight:700>&lt;&gt;(</span><span style=color:#000>locations</span><span style=color:#ce5c00;font-weight:700>));</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><h3 id=432-独立的状态变量>4.3.2 独立的状态变量</h3>
<p>到目前为止，这些委托实例都仅仅委托给了单个线程安全的状态变量。我们还可以将线程安全性委托给多个状态变量，只要这些变量是彼此独立的，即“组合而成的类不会在其包含的多个状态变量上增加任何不变性条件”。</p>
<p>程序清单 4-9 中的 VisualConponet 是一个图形组件，允许客户端程序注册鼠标事件和键盘事件的监听器。因为每种类型的事件都备有一个已注册监听器列表，因此当某个事件发生时，就会调用相应的监听器。然而，在鼠标事件监听器与键盘事件监听器之间不存在任何关联，二者是彼此独立的，因此 VisualComponet 可以将其线程安全性委托给这两个线程安全的监听器列表。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>VisualComponet</span> <span style=color:#ce5c00;font-weight:700>{</span>
  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>List</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>KeyListener</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>keyListeners</span> <span style=color:#ce5c00;font-weight:700>=</span> 
    <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>CopyOnWriteArrayList</span><span style=color:#ce5c00;font-weight:700>&lt;&gt;();</span>
  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>List</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>MouseListener</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>mouseListeners</span> <span style=color:#ce5c00;font-weight:700>=</span> 
    <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>CopyOnWriteArrayList</span><span style=color:#ce5c00;font-weight:700>&lt;&gt;();</span>
  
  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>addKeyListener</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>KeyListener</span> <span style=color:#000>listener</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#000>keyListeners</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>add</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>listener</span><span style=color:#ce5c00;font-weight:700>);</span>
  <span style=color:#ce5c00;font-weight:700>}</span>
  
  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>addMouseListener</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>MouseListener</span> <span style=color:#000>listener</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#000>mouseListeners</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>add</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>listener</span><span style=color:#ce5c00;font-weight:700>);</span>
  <span style=color:#ce5c00;font-weight:700>}</span>
  
  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>removeKeyListener</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>KeyListener</span> <span style=color:#000>listener</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#000>keyListeners</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>remove</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>listener</span><span style=color:#ce5c00;font-weight:700>);</span>
  <span style=color:#ce5c00;font-weight:700>}</span>
  
  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>removeMouseListener</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>MouseListener</span> <span style=color:#000>listener</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#000>mouseListeners</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>remove</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>listener</span><span style=color:#ce5c00;font-weight:700>);</span>
  <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>VisualComponet 使用 CopyOnWriteArrayList 来保存各个监听器列表。它是一个线程安全的链表，特别适用于管理监听器列表。每个链表都是线程安全的，此外，由于各个状态之间不存在耦合关系，因此 VisualComponet 可以将它的线程安全性委托给 mouseListeners 和 keyListeners。</p>
<h3 id=433-当委托失效时>4.3.3 当委托失效时</h3>
<p>大多数组合对象都不会像 VisualComponet 这样简单：在它们的状态变量之间存在着某些不变性条件。程序清单 4-10 中的 NumberRange 使用了两个 AtomicInteger 来管理状态，并且含有一个约束条件，即第一个数值要小于或等于第二个数值。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>NumberRange</span> <span style=color:#ce5c00;font-weight:700>{</span>
  <span style=color:#8f5902;font-style:italic>// 不变性条件：lower &lt;= upper
</span><span style=color:#8f5902;font-style:italic></span>  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>AtomicInteger</span> <span style=color:#000>lower</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>AtomicInteger</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>0</span><span style=color:#ce5c00;font-weight:700>);</span>
  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>AtomicInteger</span> <span style=color:#000>upper</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>AtomicInteger</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>0</span><span style=color:#ce5c00;font-weight:700>);</span>
  
  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>setLower</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>i</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#8f5902;font-style:italic>// 注意：不安全的“先检查后执行”
</span><span style=color:#8f5902;font-style:italic></span>    <span style=color:#204a87;font-weight:700>if</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>i</span> <span style=color:#ce5c00;font-weight:700>&lt;</span> <span style=color:#000>upper</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>get</span><span style=color:#ce5c00;font-weight:700>())</span> <span style=color:#ce5c00;font-weight:700>{</span>
      <span style=color:#204a87;font-weight:700>throw</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#ce5c00;font-weight:700>...</span>
    <span style=color:#ce5c00;font-weight:700>}</span>
    <span style=color:#000>lower</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>set</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>i</span><span style=color:#ce5c00;font-weight:700>);</span>
  <span style=color:#ce5c00;font-weight:700>}</span>
  
  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>setUpper</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>i</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#8f5902;font-style:italic>// 注意：不安全的“先检查后执行”
</span><span style=color:#8f5902;font-style:italic></span>    <span style=color:#204a87;font-weight:700>if</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>i</span> <span style=color:#ce5c00;font-weight:700>&lt;</span> <span style=color:#000>lower</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>get</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
      <span style=color:#204a87;font-weight:700>throw</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#ce5c00;font-weight:700>...</span>
    <span style=color:#ce5c00;font-weight:700>}</span>
    <span style=color:#000>upper</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>set</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>i</span><span style=color:#ce5c00;font-weight:700>);</span>
  <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>NumberRange 不是线程安全的，没有维持对上界和下界进行约束的不变性条件。setLower 和 setUpper 等方法都尝试维持不变性条件，但却无法做到。setLower 和 setUpper 都是“先检查后执行”操作，但它们没有使用足够的加锁机制来保证这些操作的原子性。假设取值范围为 (0,10)，如果一个线程调用 setLower(5)，另一个线程调用 setUpper(4)，那么在一些错误的执行时序中，这两个调用都将通过检查，并且都能设置成功。结果得到的取值范围是 (5,4)，那么这是一个无效的状态。因此，虽然 AtomicInteger 是线程安全的，但经过组合得到的类却不是。由于状态变量 lower 和 upper 不是彼此独立的，因此 NumberRange 不能将线程安全委托给它的线程安全状态变量。</p>
<p>NumberRange 可以通过加锁机制来维护不变性条件以确保其线程安全性，例如使用一个锁来保护 lower 和 upper。此外，它还必须避免发布 lower 和 upper，从而防止客户端代码破坏其不变性条件。</p>
<p>如果某各类含有复合操作，例如 NumberRange，那么紧靠委托并不足以实现线程安全性。在这种情况下，这个类必须提供自己的加锁机制以保证这些复合操作都是原子操作，除非整个复合操作都可以委托给状态变量。</p>
<blockquote>
<p>如果一个类是由多个独立且线程安全的变量组成的，并且在所有的操作中都不包含无效状态转换，那么可以将线程安全性委托给底层的状态变量。</p>
</blockquote>
<p>即使 NumberRange 的各个组件部分都是线程安全的，也不能保证 NumberRange 的线程安全性，这种问题非常类似于 3.1.4 节介绍的 volatile 变量规则：仅当一个变量参与到包含其他状态变量的不变性条件时，才可以声明为 volatile 变量。</p>
<h3 id=434-发布底层的状态变量>4.3.4 发布底层的状态变量</h3>
<p>当把线程安全性委托给某个对象底层的状态变量时，在什么条件下才可以发布这些变量从而使其他类能够修改它们？答案仍然取决于在类中对这些变量施加了哪些不变性条件。虽然 Counter 中的 value 域可以为任意整数值，但 Counter 施加的约束条件是只能取正整数，此外递增操作同样约束了下一个状态的有效取值范围。如果将 value 声明为一个共有域，那么客户端代码可以将它修改为一个无效值，因此发布 value 会导致这个类出错。另一方面，如果某个变量表示的是当前温度或者最近登录用户的 ID，那么即使另一个类在某个时刻修改了这个值，也不会破坏任何不变性条件，因此发布这个变量也是可以接受的。(这或许不是个好注意，因为发布可变的变量将对下一步的开发和派生子类带来限制，但不会破坏类的线程安全性。)</p>
<p>例如，发布 VisualComponent 中的 mouseListeners 和 keyListeners 等变量是线程安全的。由于 VisualComponet 并没有在其监听器列表的合法状态上施加任何约束，因此这些域可以声明为公有域或者发布，而不会破坏线程安全性。</p>
<h3 id=435-示例发布状态的车辆追踪器>4.3.5 示例：发布状态的车辆追踪器</h3>
<p>我们来构造车辆追踪器的另一个版本，并在这个版本中发布底层的可变状态。我们需要修改接口以适应这种变化，即使用可变且线程安全的 Point 类。</p>
<p>程序清单 4-11 中的 SafePoint 提供的 get 方法同时获得 x 和 y 的值，并将二者放在一个数组中返回。如果 x 和 y 分别提供 get 方法，那么在获得者两个不同坐标的操作之间，x 和 y 的值发生变化，从而导致调用者看到不一致的值：车辆重来没有到达过位置 (x,y)。通过使用 SafePoint，可以构造一个发布其底层可变状态的车辆追踪器，还能确保其线程安全性不被破坏，如程序清单 4-12 中的 PublishingVehicleTracker 类所示。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#5c35cc;font-weight:700>@ThreadSafe</span> 
<span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>SafePoint</span> <span style=color:#ce5c00;font-weight:700>{</span> 
  <span style=color:#5c35cc;font-weight:700>@GuardedBy</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#4e9a06>&#34;this&#34;</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>x</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>y</span><span style=color:#ce5c00;font-weight:700>;</span>
  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#000>SafePoint</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>int</span><span style=color:#ce5c00;font-weight:700>[]</span> <span style=color:#000>a</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span> <span style=color:#204a87;font-weight:700>this</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>a</span><span style=color:#ce5c00;font-weight:700>[</span><span style=color:#000>0</span><span style=color:#ce5c00;font-weight:700>],</span> <span style=color:#000>a</span><span style=color:#ce5c00;font-weight:700>[</span><span style=color:#000>1</span><span style=color:#ce5c00;font-weight:700>]);</span> <span style=color:#ce5c00;font-weight:700>}</span>
  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#000>SafePoint</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>SafePoint</span> <span style=color:#000>p</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span> <span style=color:#204a87;font-weight:700>this</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>p</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>get</span><span style=color:#ce5c00;font-weight:700>());</span> <span style=color:#ce5c00;font-weight:700>}</span>
  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#000>SafePoint</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>x</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>y</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span> 
    <span style=color:#204a87;font-weight:700>this</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>x</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>x</span><span style=color:#ce5c00;font-weight:700>;</span> <span style=color:#204a87;font-weight:700>this</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>y</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>y</span><span style=color:#ce5c00;font-weight:700>;</span> 
  <span style=color:#ce5c00;font-weight:700>}</span>

  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>synchronized</span> <span style=color:#204a87;font-weight:700>int</span><span style=color:#ce5c00;font-weight:700>[]</span> <span style=color:#000>get</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span> 
    <span style=color:#204a87;font-weight:700>return</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#204a87;font-weight:700>int</span><span style=color:#ce5c00;font-weight:700>[]</span> <span style=color:#ce5c00;font-weight:700>{</span> <span style=color:#000>x</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>y</span> <span style=color:#ce5c00;font-weight:700>};</span> 
  <span style=color:#ce5c00;font-weight:700>}</span>

  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>synchronized</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>set</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>x</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>y</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span> 
    <span style=color:#204a87;font-weight:700>this</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>x</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>x</span><span style=color:#ce5c00;font-weight:700>;</span> <span style=color:#204a87;font-weight:700>this</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>y</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>y</span><span style=color:#ce5c00;font-weight:700>;</span> 
  <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#5c35cc;font-weight:700>@ThreadSafe</span> 
<span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>PublishingVehicleTracker</span> <span style=color:#ce5c00;font-weight:700>{</span>

  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>Map</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>String</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>SafePoint</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>locations</span><span style=color:#ce5c00;font-weight:700>;</span> 
  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>Map</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>String</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>SafePoint</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>unmodifiableMap</span><span style=color:#ce5c00;font-weight:700>;</span>

  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#000>PublishingVehicleTracker</span><span style=color:#ce5c00;font-weight:700>(</span> <span style=color:#000>Map</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>String</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>SafePoint</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>locations</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#204a87;font-weight:700>this</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>locations</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>ConcurrentHashMap</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>String</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>SafePoint</span><span style=color:#ce5c00;font-weight:700>&gt;(</span><span style=color:#000>locations</span><span style=color:#ce5c00;font-weight:700>);</span> 
    <span style=color:#204a87;font-weight:700>this</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>unmodifiableMap</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>Collections</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>unmodifiableMap</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>this</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>locations</span><span style=color:#ce5c00;font-weight:700>);</span> 
  <span style=color:#ce5c00;font-weight:700>}</span>

  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#000>Map</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>String</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>SafePoint</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>getLocations</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span> 
    <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>unmodifiableMap</span><span style=color:#ce5c00;font-weight:700>;</span> 
  <span style=color:#ce5c00;font-weight:700>}</span>

  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#000>SafePoint</span> <span style=color:#000>getLocation</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>String</span> <span style=color:#000>id</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span> 
    <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>locations</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>get</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>id</span><span style=color:#ce5c00;font-weight:700>);</span> 
  <span style=color:#ce5c00;font-weight:700>}</span>

  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>setLocation</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>String</span> <span style=color:#000>id</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>x</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>y</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span> 
    <span style=color:#204a87;font-weight:700>if</span> <span style=color:#ce5c00;font-weight:700>(!</span><span style=color:#000>locations</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>containsKey</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>id</span><span style=color:#ce5c00;font-weight:700>))</span> 
      <span style=color:#204a87;font-weight:700>throw</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>IllegalArgumentException</span><span style=color:#ce5c00;font-weight:700>(</span> <span style=color:#4e9a06>&#34;invalid vehicle name: &#34;</span> <span style=color:#ce5c00;font-weight:700>+</span> <span style=color:#000>id</span><span style=color:#ce5c00;font-weight:700>);</span> 
    <span style=color:#000>locations</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>get</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>id</span><span style=color:#ce5c00;font-weight:700>).</span><span style=color:#c4a000>set</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>x</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>y</span><span style=color:#ce5c00;font-weight:700>);</span> 
  <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>PublishingVehicleTracker 将其线程安全性委托给底层的 PublishingVehicleTracker，只是 Map 中的元素是线程安全的且可变的 Point，而并非不可变的。getLocation 方法返回底层 Map 对象的一个不可变副本。调用者不能增加或删除车辆，但却可以通过修改返回 Map 中的 SafePoint 值来改变车辆的位置。再次指出，Map 的这种“实时特性”究竟是带来了好处还是坏处，仍然取决于实际的需求。PublishingVehicleTracker 是线程安全的，但如果它在车辆位置的有效值上施加了任何约束，那么就不再是线程安全的了。如果需要对车辆位置的变化进行判断或者当位置变化时执行一些操作，那么 PublishingVehicleTracker 中采用的方式并不合适。</p>
<h2 id=44-在现有的线程安全类中添加功能>4.4 在现有的线程安全类中添加功能</h2>
<p>Java 类库包含许多有用的“基础模块”类。通常，我们应该优先选择重用这些现有的类而不是创建新类：重用能降低开发工作量、开发风险(因为现有的类都已通过测试)以及维护成本。有时候，某个现有的线程安全类能支持我们需要的所有工作，但更多时候，现有的类只能支持大部分的操作，此时就需要在不破坏线程安全性的情况下添加一个新的操作。</p>
<p>例如，假设需要一个线程安全的链表，它需要提供一个原子的“若没有则添加”的操作。同步的 List 类已经实现了大部分的功能，我们可以根据它提供的 contains 方法和 add 方法构造一个这样的操作。</p>
<p>“若没有则添加”的概念很简单，在向容器添加元素前，首先检查该元素是否已经存在，如果存在就不再添加。由于这个类必须是线程安全的，因此就隐含的增加了另一个需求，即“若没有则添加”这个操作必须是原子的。这意味着，如果在链表中没有包含对象 X，那么在执行两次“若没有则添加” X 后，在容器中只能包含一个 X 对象。然而，如果“若没有则添加”并非原子操作，那么在某些执行情况下，有两个线程将看到 X 不再容器中，并且都执行了添加 X 的操作，从而使容器中包含两个相同的 X 对象。</p>
<p>要添加一个新的原子操作，最安全的方式是修改原始类，但这通常无法做到，因为你可能无法访问或修改类的原始代码。要想修改原始的类，就需要理解代码中的同步策略，这样增加的功能才能与原有的设计保持一致。如果直接将新方法添加到类中，那么意味着实现同步策略的所有代码仍然处于一个源代码文件中，从而更容易理解和维护。</p>
<p>另一种方法是扩展这个类，假定在设计这个类的时候考虑了扩展性。程序清单 4-13 中的 BetterVector 对 Vector 进行了扩展，并添加了一个新的 putIfAbsent。扩展 Vector 很简单，但并非所有的类都想 Vector 那样将状态向子类公开，因此也就不适合采用这种方法。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#5c35cc;font-weight:700>@ThreadSafe</span>
<span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>BetterVector</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>E</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#204a87;font-weight:700>extends</span> <span style=color:#000>Vector</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>E</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#ce5c00;font-weight:700>{</span>
  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>synchronized</span> <span style=color:#204a87;font-weight:700>boolean</span> <span style=color:#000>putIfAbsend</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>E</span> <span style=color:#000>e</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#204a87;font-weight:700>boolean</span> <span style=color:#000>absent</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#ce5c00;font-weight:700>!</span><span style=color:#000>contains</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>e</span><span style=color:#ce5c00;font-weight:700>);</span>
    <span style=color:#204a87;font-weight:700>if</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>absent</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#000>add</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>e</span><span style=color:#ce5c00;font-weight:700>);</span>
    <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>absent</span><span style=color:#ce5c00;font-weight:700>;</span>
  <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>“扩展方法”比直接将代码添加到类中更加脆弱，因为现在的同步策略实现被分布到多个单独维护的源代码文件中。如果底层的类改变了同步策略并选择了不同的锁来保护它的状态变量，那么子类会被破坏，因为在同步策略改变后它无法再使用正确的锁来控制对基类状态的并发访问。(在 Vector 的规范中定义了它的同步策略，因此 BetterVector 不存在该问题。)</p>
<h3 id=441-客户端加锁机制>4.4.1 客户端加锁机制</h3>
<p>对于由 Collections.synchronizedList 封装的 ArrayList，这两种方法在原始类中添加一个方法或者对类进行扩展都行不通，因为客户端代码并不知道在同步封装器工厂方法中返回的 List 对象的类型。第三中策略是扩展类的功能，但并不扩展类本身，而是将扩展放入一个辅助类。</p>
<p>程序清单 4-14 实现了一个包含“若没有则添加”操作的辅助类，用于对线程安全的 List 执行操作，但其中的代码是错误的。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#5c35cc;font-weight:700>@NotThreadSafe</span>
<span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>ListHelper</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>E</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#ce5c00;font-weight:700>{</span>
  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#000>List</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>E</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>list</span> <span style=color:#ce5c00;font-weight:700>=</span> 
    <span style=color:#000>Collections</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>synchronizedList</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>ArrayList</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>E</span><span style=color:#ce5c00;font-weight:700>&gt;());</span>
  <span style=color:#ce5c00;font-weight:700>...</span>
  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>synchronized</span> <span style=color:#204a87;font-weight:700>boolean</span> <span style=color:#000>putIfAbsent</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>E</span> <span style=color:#000>x</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#204a87;font-weight:700>boolean</span> <span style=color:#000>absent</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#ce5c00;font-weight:700>!</span><span style=color:#000>list</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>contains</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>x</span><span style=color:#ce5c00;font-weight:700>);</span>
    <span style=color:#204a87;font-weight:700>if</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>absent</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
      <span style=color:#000>list</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>add</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>x</span><span style=color:#ce5c00;font-weight:700>);</span>
    <span style=color:#ce5c00;font-weight:700>}</span>
    <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>absent</span><span style=color:#ce5c00;font-weight:700>;</span>
  <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>为什么这种方式不能实现线程安全性？毕竟，putIfAbsent 已经声明为 synchronized 类型的变量，对不对？问题在于在错误的锁上进行了同步。无论 List 使用哪个锁来保护它的状态，可以确定的是，这个锁不会是 ListHelper 上的锁。ListHelper 只是带来了同步的假象，尽管所有的链表操作都被声明为 synchronized，但却使用了不同的锁，这意味着 putIfAbsent 相对于 List 的其他同步操作来说并不是原子的，因此就无法确保当 putIfAbsent 执行时另一个线程不会修改链表。</p>
<p>要想使这个方法变得有效，必须使 List 在实现客户端加锁或外部加锁时使用同一个锁。客户端加锁指的是，对于使用某个对象 X 的客户端代码，使用 X 本身用于保护其状态的锁来保护这段客户端代码。要使用客户端加锁，你必须知道对象 X 使用的是哪个锁。</p>
<p>在 Vector 和同步封装器类的文档中指出，他们通过使用 Vector 或封装器容器的内置锁来支持客户端加锁。程序清单 4-15 给出了在线程安全的 List 上执行 putIfAbsent 操作，其中使用了正确的客户端加锁。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#5c35cc;font-weight:700>@ThreadSafe</span> 
<span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>ListHelper</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>E</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#ce5c00;font-weight:700>{</span>
  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#000>List</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>E</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>list</span> <span style=color:#ce5c00;font-weight:700>=</span> 
    <span style=color:#000>Collections</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>synchronizedList</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>ArrayList</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>E</span><span style=color:#ce5c00;font-weight:700>&gt;());</span> 
  <span style=color:#ce5c00;font-weight:700>...</span>
  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>boolean</span> <span style=color:#000>putIfAbsent</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>E</span> <span style=color:#000>x</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span> 
    <span style=color:#204a87;font-weight:700>synchronized</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>list</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span> 
      <span style=color:#204a87;font-weight:700>boolean</span> <span style=color:#000>absent</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#ce5c00;font-weight:700>!</span><span style=color:#000>list</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>contains</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>x</span><span style=color:#ce5c00;font-weight:700>);</span> 
      <span style=color:#204a87;font-weight:700>if</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>absent</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#000>list</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>add</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>x</span><span style=color:#ce5c00;font-weight:700>);</span> 
      <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>absent</span><span style=color:#ce5c00;font-weight:700>;</span>
    <span style=color:#ce5c00;font-weight:700>}</span> 
  <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>通过添加一个原子操作来扩展类是脆弱的，因为它将类的加锁代码分布到多个类中。然而，客户端加锁却更加脆弱，因为它将类 C 的加锁代码放到与 C 完全无关的其他类中。当在那些并不承诺遵循加锁策略的类上使用客户端加锁时，要特别小心。</p>
<p>客户端加锁机制与扩展类机制有很多相同点，二者都是将派生类的行为与基类的实现耦合在一起。正如扩展会破坏实现的封装性，客户端加锁同样会破坏同步策略的封装性。</p>
<h3 id=442-组合>4.4.2 组合</h3>
<p>当为现有的类添加一个原子操作时，有一种更好的方法：组合。程序清单 4-16 中的 ImporvedList 通过将 List 对象的操作委托给底层的 List 实例来实现 List 的操作，同时还添加了一个原子的 putIfAbsent 方法。(与 Collections.synchronizedList 和其他容器封装器一样，ImprovedList 假设把某个链表对象传递给构造函数之后，客户端代码就不会再直接使用这个对象，而只能通过 ImprovedList 来访问它。)</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#5c35cc;font-weight:700>@ThreadSafe</span> 
<span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>ImprovedList</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>T</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#204a87;font-weight:700>implements</span> <span style=color:#000>List</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>T</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#ce5c00;font-weight:700>{</span> 
  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>List</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>T</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>list</span><span style=color:#ce5c00;font-weight:700>;</span>
  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#000>ImprovedList</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>List</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>T</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>list</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span> 
    <span style=color:#204a87;font-weight:700>this</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>list</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>list</span><span style=color:#ce5c00;font-weight:700>;</span> 
  <span style=color:#ce5c00;font-weight:700>}</span>

  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>synchronized</span> <span style=color:#204a87;font-weight:700>boolean</span> <span style=color:#000>putIfAbsent</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>T</span> <span style=color:#000>x</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span> 
    <span style=color:#204a87;font-weight:700>boolean</span> <span style=color:#000>contains</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>list</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>contains</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>x</span><span style=color:#ce5c00;font-weight:700>);</span> 
    <span style=color:#204a87;font-weight:700>if</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>contains</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#000>list</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>add</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>x</span><span style=color:#ce5c00;font-weight:700>);</span> 
    <span style=color:#204a87;font-weight:700>return</span> <span style=color:#ce5c00;font-weight:700>!</span><span style=color:#000>contains</span><span style=color:#ce5c00;font-weight:700>;</span> 
  <span style=color:#ce5c00;font-weight:700>}</span>

  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>synchronized</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>clear</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span> <span style=color:#000>list</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>clear</span><span style=color:#ce5c00;font-weight:700>();</span> <span style=color:#ce5c00;font-weight:700>}</span> 
  <span style=color:#8f5902;font-style:italic>// ... similarly delegate other List methods
</span><span style=color:#8f5902;font-style:italic></span><span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>ImprovedList 通过自身的内置锁增加了一层额外的加锁。它并不关心底层的 List 是否是线程安全的，即使 List 不是线程安全的或者修改了它的加锁实现，ImprovedList 也会提供一致性的加锁机制来实现线程安全性。虽然额外的同步层可能导致轻微的性能损失，但与模拟另外一个对象的加锁策略相比，ImprovedList 更加健壮。事实上，我们使用了 Java 监视器模式来封装现有的 List，并且只要在类中拥有指向底层 List 的唯一外部引用，就能确保线程安全性。</p>
<h2 id=45-将同步策略文档化>4.5 将同步策略文档化</h2>
<p>在维护线程安全性时，文档是最强大的工具之一。用户可以通过查阅文档来判断某个类是否是线程安全的，而维护人员也可以通过查阅文档来理解其中的实现策略，避免在维护过程中破坏安全性。然而，通常人们从文档中获取的信息少之又少。</p>
<p>synchronized、volatile 或者任何一个线程安全类都对应一个同步策略，用于在并发访问时保证数据的完整性。这种策略是程序设计的要素之一，因此应该将其文档化。当然，设计阶段是编写设计决策文档的最佳时间。这之后经过数周或数月后，一些设计细节会逐渐变得模糊，因此一定要在忘记之前将他们记录下来。</p>
<p>在设计同步策略时需要考虑多个方面，例如，将哪些变量声明为 volatile 类型，哪些变量用锁来保护，哪些锁保护哪些变量，哪些变量必修是不可变的或者被封闭在线程内，哪些操作必须是原子的等。其中某些方面是严格的实现细节，应该将他们文档化以便日后维护。还有一些方面会影响类中加锁行为的外在表现，也应该将其作为规范的一部分写入文档。</p>
<p>最起码，应该保证类中的线程安全性文档化。它是否是线程安全的？在执行回调时是否持有一个锁？是否有某些特定的锁会影响其行为？不要让客户端冒着风险去猜测。如果你不想支持客户端加锁也是可以的，但一定要明确的指出来。如果你希望客户端代码能够在类中添加新的原子操作，如 4.4 节所示，那么就需要在文档中索命需要获得哪些锁才能实现安全的原子操作。如果使用锁来保护状态，那么也要将其写入文档以便日后维护，这很简单，只需要使用注解 <code>@GuardedBy</code> 即可。如果要使用更复杂的方法来维护线程安全性，那么一定要将它们写入文档，因为维护者们通常很难发现它们。</p>
<p>甚至在平台类库中，线程安全性方面的文档也是很难令人满意。当你阅读某个类的 Javadoc 时，是否曾怀疑过他是否是线程安全的？大多数类都没有给出任何提示。许多正式的 Java 技术规范，例如 Servlet 和 JDBC，也没有在它们的文档中给出线程安全性的保证和需求。</p>
<p>尽管我们不应该对规范之外的行为进行猜测，但有时候处于工作需要，将不得不面对各种糟糕的假设。我们是否应该因为某个对象看上去是线程安全的就假设它是安全的？是否可以假设通过获取对象的锁来确保对象访问的线程安全性？(只有当我们能够控制所有访问该对象的代码时，才能使用这种带有风险的技术，否则，这这能带来线程安全性的假象。)无论做出哪种选择都很难令人满意。</p>
<p>更糟糕的是，我们的直觉通常是错误的：我们认为“可能是线程安全的”的类通常不是线程安全的。例如，java.text.SimpleDateFormat 并不线程安全，但 JDK 1.4 之前的 Javadoc 并没有提到这点。许多开发人员都对这个事实感到惊讶。有多少程序已经错误的生成了这种非线程安全的对象，并在多线程中使用它们？这些程序没有意识到这将在高负载的情况下导致错误的结果。</p>
<p>如果某个类没有明确的声明是线程安全的，那么就不要假设它是线程安全的，从而有效的避免类似于 SimpleDateFormat 中的问题。而另一方面，如果不对容器提供对象(如 HttpSession) 的线程安全性做出某种有问题的假设，也就不可能开发出一个基于 Servlet 的应用程序。不要使你的客户或同事做这样的猜测。</p>
<h4 id=解释含糊的文档>解释含糊的文档</h4>
<p>许多 Java 技术规范都没有说明接口的线程安全性，例如 ServletContext、HttpSession、DataSource。这些接口是由容器或者数据库供应商来实现的，而你通常无法通过查看其源码来了解细节功能。此外，你也不希望依赖于某个特定的 JDBC 驱动的实现细节——你希望遵从标准，这样代码可以基于任何一个 JDBC 驱动工作。但在 JDBC 的规范中从未出现“线程”和“并发”这些术语，同样在 Servlet 规范中也很少提到。那么你改做些什么？</p>
<p>你只能取猜测。一个提高猜测准确性的做法是，从实现者的角度去解释规范，而不是从使用者的角度去解释。Servlet 通常是在容器管理的线程中调用的，因此可以安全的假设：如果有多个这样的线程在运行，那么容器是知道这种情况的。Servlet 容器能生成一些为多个 Servlet 提供服务的对象，例如 HttpSession 或 ServletContext。因此，Servlet 容器应该预见到这些对象将被并发访问，因为它创建了多个线程，并且从这些线程中调用像 Servlet.service 这样的方法，而这个方法很可能会访问 ServletContext。</p>
<p>由于这些对象在单线程的上下文中很少是有用的，因此我们不得不假设它们已被实现为线程安全的，即使在规范中没有明确的说明。此外，如果需要客户端加锁，那么客户端代码应该在哪个锁上同步？在文档中没有说明这一点，而要猜测的话也不知从何猜起。在规范和正式手册中给出的如何访问 ServletContext 或 HttpSession 的示例中进一步强调了这种合理的假设，因为么有使用任何客户端同步。</p>
<p>另一方面，通过把 setAttribute 放到 ServletContext 中或者将 HttpSession 的对象由 Web 应用程序拥有，而不是由 Servlet 容器拥有。在 Servlet 规范中没有给出任何机制来协调对这些共享属性的并发访问。因此，由容器代替 Web 应用程序来保存这些属性应用是线程安全的，或者是不可变的。如果容器的工作只是代替 Web 应用程序来保存这些属性，那么当从 Servlet 应用程序代码访问他们时，应该确保他们始终由同一个锁保护。但由于容器可能需要序列化 HttpSession 中的对象复制或者钝化等操作，并且容器不可能知道你的加锁协议，因此你要自己确保这些对象是线程安全的。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-8b4a307e1ad6bded17f168b1dc6154b3>5 - CH05-基础构建块</h1>
<p>第四章介绍了构建线程安全类时采用的一些技术，例如将线程安全性委托给现有的线程安全类。委托是创建线程安全类的一个最有效的策略：只需让现有的线程安全类管理所有的状态即可。</p>
<p>Java 平台类库包含了丰富的并发基础构建块，例如线程安全的容器类以及各种用于协调多个相互协作的线程控制流的同步工具(synchronizer)。本章将介绍其中一些最有用的并发构建模块，特别是在 Java 5 和 6 中引入的新模块，以及在使用这些模块来构建并发应用程序时的一些常用模式。</p>
<h2 id=51-同步容器类>5.1 同步容器类</h2>
<p>同步容器类包括 Vector 和 Hashtable，二者是早期 JDK 的一部分，此外还包括一些在 JDK 1.2 中添加的功能相似的类，这些同步的封装容器类是由 Collections.synchronizedXxx 等工厂方法创建的。这些类实现线程安全的方式是：将它们的状态封装起来，并对每个公有方法都进行同步，使得每次只有一个线程能访问容器的状态。</p>
<h3 id=511-同步容器类的问题>5.1.1 同步容器类的问题</h3>
<p>同步容器类都是线程安全的，但在某些情况下可能需要额外的客户端加锁来来保护复合操作。容器上最常见的复合操作包括：迭代、跳转、条件运算，例如“若没有则添加”。在同步容器中，这些复合操作在没有客户端加锁的情况下仍然是线程安全的，但在其他线程并发的修改容器时，它们可能会表现出意料之外的行为。</p>
<p>程序清单 5-1 给出了 Vector 中定义的两个方法：getLast 和 deleteLast，它们都会执行“先检查再运行”。每个方法首先都获得数组的大小，然后通过结果来获取或删除最后一个元素。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>static</span> <span style=color:#000>Object</span> <span style=color:#000>getLast</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>Vector</span> <span style=color:#000>list</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
  <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>lastIndex</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>list</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>size</span> <span style=color:#ce5c00;font-weight:700>-</span><span style=color:#000>1</span><span style=color:#ce5c00;font-weight:700>;</span>
  <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>list</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>get</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>lastIndex</span><span style=color:#ce5c00;font-weight:700>);</span>
<span style=color:#ce5c00;font-weight:700>}</span>

<span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>static</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>deleteLast</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>Vector</span> <span style=color:#000>list</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
  <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>lastIndex</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>list</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>size</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>-</span><span style=color:#000>1</span><span style=color:#ce5c00;font-weight:700>;</span>
  <span style=color:#000>list</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>remove</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>lastIndex</span><span style=color:#ce5c00;font-weight:700>);</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>这些方法看似没有任何问题，从某种程度上来看也确实如此——无论多少个线程同时调用它们也不会破坏 Vector。但从这些方法的调用者角度来看，情况就不同了。如果线程 A 在包含 10 个元素的 Vector 上调用 getLast，同时线程 B 在同一个 Vector 上调用 deleteLast，这些操作的交替执行如图 5-1 所示，getLast 将抛出数组索引越界异常。在调用 size 与调用 getLast 这两个操作之间，Vector 变小了，因此在调用 size 时得到的索引将不再有效。这种情况很好的遵循了 Vector 的规范——如果请求一个不存在的元素，那么将抛出一个异常。但这并不是 getLast 的调用者希望得到的结果(即使是在并发修改的情况下也不希望看到)，除非 Vector 从一开始就是空的。</p>
<div align=center>
<img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20181118172738.png style=display:block;width:70% alt=5-1 align=center>
</div>
<p>由于同步容器类要遵循同步策略，即支持客户端加锁，因此可能会创建一些新的操作，只要我们知道应该使用哪个锁，那么这些操作就会与容器的其他操作一样都是原子的。同步容器类通过其自身的锁来保护它的每个方法。通过获得容器类的锁，我们可以使 getLast 和 deleteLast 成为原子操作，并确保 Vector 的大小在调用 size 和 get 之间不会发生变化，如程序清单 5-2 所示。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>static</span> <span style=color:#000>Object</span> <span style=color:#000>getLast</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>Vector</span> <span style=color:#000>list</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
  <span style=color:#204a87;font-weight:700>synchronized</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>list</span><span style=color:#ce5c00;font-weight:700>){</span>
    <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>lastIndex</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>list</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>size</span> <span style=color:#ce5c00;font-weight:700>-</span><span style=color:#000>1</span><span style=color:#ce5c00;font-weight:700>;</span>
    <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>list</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>get</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>lastIndex</span><span style=color:#ce5c00;font-weight:700>);</span>
  <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#ce5c00;font-weight:700>}</span>

<span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>static</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>deleteLast</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>Vector</span> <span style=color:#000>list</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
  <span style=color:#204a87;font-weight:700>synchronized</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>list</span><span style=color:#ce5c00;font-weight:700>){</span>
    <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>lastIndex</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>list</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>size</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>-</span><span style=color:#000>1</span><span style=color:#ce5c00;font-weight:700>;</span>
    <span style=color:#000>list</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>remove</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>lastIndex</span><span style=color:#ce5c00;font-weight:700>);</span>
  <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>在调用 size 和相应的 get 之间，Vector 的长度可能会发生变化，这种风险在于对 Vector 中的元素进行迭代时仍然会出现，如程序清单 5-3 所示。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#204a87;font-weight:700>for</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>i</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#000>0</span><span style=color:#ce5c00;font-weight:700>;</span> <span style=color:#000>i</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>vector</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>size</span><span style=color:#ce5c00;font-weight:700>();</span> <span style=color:#000>i</span><span style=color:#ce5c00;font-weight:700>++){</span>
  <span style=color:#000>doSomething</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>vector</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>get</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>i</span><span style=color:#ce5c00;font-weight:700>));</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>这种迭代操作的正确性要依赖运气，即在调用 size 和 get 之间没有线程会修改 Vector。在单线程环境下，这种假设完全成立，但在有其他线程并发的修改 Vector 时，则可能导致麻烦。与 getLast 一样，如果在对 Vector 进行迭代时，另一个线程删除了一个元素，并且这两个操作交替执行，那么这种迭代方法将抛出数组索引越界异常。</p>
<p>虽然在程序清单 5-3 的迭代操作中可能抛出异常，并并不意味着 Vector 就不是线程安全的。Vector 的状态仍然是有效的，而抛出的异常也与其规范保持一致。然而，像在读取最后一个元素或者迭代等这样简单的操作中抛出异常显然不是人们所期望的。</p>
<p>我们可以通过在客户端加锁来解决不可迭代的问题，但要牺牲一些伸缩性。通过在迭代期间持有 Vector 的锁，可以防止其他线程在迭代期间修改 Vector，如程序清单 5-4 所示。然而，着同样会导致其他线程在迭代期间无法访问它，因此降低了并发性。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#204a87;font-weight:700>synchronized</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>vector</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
  <span style=color:#204a87;font-weight:700>for</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>i</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#000>0</span><span style=color:#ce5c00;font-weight:700>;</span> <span style=color:#000>i</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>vector</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>size</span><span style=color:#ce5c00;font-weight:700>();</span> <span style=color:#000>i</span><span style=color:#ce5c00;font-weight:700>++){</span>
    <span style=color:#000>doSomething</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>vector</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>get</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>i</span><span style=color:#ce5c00;font-weight:700>));</span>
  <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><h3 id=512-迭代器与-concurrentmodificationexception>5.1.2 迭代器与 ConcurrentModificationException</h3>
<p>为了将问题阐述清楚，我们使用了 Vector，虽然这是一个古老的容器类。然而，许多现代的容器类也并没有消除复合操作中的问题。无论直接迭代还是 Java 5.0 引入的 foreach 循环语法中，对容器类迭代的标准方式都是使用 Iterator。然而，如果有其他线程并发的修改容器，那么即使是使用迭代器也无法避免在迭代期间对容器加锁。在设计同步容器类的迭代器时并没有考虑到并发修改的问题，并且它们表现出的行为是“及时失败”的。这意味着，当它们发现容器在迭代过程中被修改时，就会抛出 ConcurrentModificationException。</p>
<p>这种“及时失败”的迭代器并不是一种完备的处理器机制，而只是“善意的”捕获并发错误。因此只能作为并发问题的预警指示器。它们采用的实现方式是，将计数器的变化与容器关联起来：如果迭代器件计数器被修改，那么 hasNext 或 next 将抛出异常。然而，这种检查是在没有同步的情况下进行的，因此可能会看到失效的计数值，而迭代器可能并没有意识到已经发生了修改。这是一种设计上的权衡，从而降低并发修改操作的检测代码对程序性能带来的影响。</p>
<p>程序清单 5-5 说明了如何使用 for-each 循环语法对 List 容器进行迭代。从内部来看，javac 将生成使用 iterator 的代码，返回调用 hasNex 和 next 来迭代 List 对象。与迭代 Vector 一样，要想避免出现并发修改异常，就必须在迭代过程中持有锁。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#000>List</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>Widget</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>widgetList</span> <span style=color:#ce5c00;font-weight:700>=</span> 
  <span style=color:#000>Collections</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>synchronizedList</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>ArrayList</span><span style=color:#ce5c00;font-weight:700>&lt;&gt;());</span>
<span style=color:#ce5c00;font-weight:700>...</span>
<span style=color:#8f5902;font-style:italic>// 可能抛出并发修改异常
</span><span style=color:#8f5902;font-style:italic></span><span style=color:#204a87;font-weight:700>for</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>Widget</span> <span style=color:#000>w</span><span style=color:#ce5c00;font-weight:700>:</span> <span style=color:#000>widgetList</span><span style=color:#ce5c00;font-weight:700>)</span>
  <span style=color:#000>doSomething</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>w</span><span style=color:#ce5c00;font-weight:700>);</span>
</code></pre></div><p>然而，有时候开发人员并不希望在迭代期间对容器加锁。例如，某些线程在可以访问容器之前，必须等待迭代过程结束，如果容器的规模很大，或者在每个元素上执行操作的时间很长，那么这些线程将长时间等待。同样，如果容器像程序清单 5-4 中那样的锁，那么在调用 doSomething 时将持有一个锁，还可能会产生死锁。即使不存在饥饿或死锁等风险，长时间对容器加锁也会降低程序的可伸缩性。持有锁的时间越长，那么在锁上的竞争就可能越激烈，如果许多线程都在等待锁被释放，那么将极大的降低吞吐量和 CPU 的利用率。</p>
<p>如果不希望在迭代期间对容器加锁，那么一种替代方法就是“克隆”容器，并在副本上进行迭代。由于副本被封闭在线程内，因此其他线程不会在迭代期间对其进行修改，这样就避免了抛出并发修改异常。在克隆容器时存在显著的性能开销。这种方式的好坏取决于多个因素，包括容器的大小、在每个元素上执行的工作，迭代操作相对于容器其他操作的调用频率，以及在响应时间和吞吐量等方面的需求。</p>
<h3 id=513-隐藏迭代器>5.1.3 隐藏迭代器</h3>
<p>虽然加锁可以放置迭代器抛出并发修改异常，但你必须记住在所有对共享容器进行迭代的地方都需要锁。实际情况要更加复杂，因为在某些情况下，迭代器会隐藏起来，如程序清单 5-6 中的 HiddenIterator 所示。在 HiddenIterator 中没有显式的迭代操作，但在粗体标出的代码中将执行迭代操作。编译器将字符串的连接操作转换为调用 StringBuilder.append(Object)，而这个方法又会调用容器的 toString 方法，标准容器的 toString 方法将迭代容器，并在每个元素上调用 toString 来生成容器内容的格式化表示。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>HiddenIterator</span> <span style=color:#ce5c00;font-weight:700>{</span>
  <span style=color:#5c35cc;font-weight:700>@GuardedBy</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#4e9a06>&#34;this&#34;</span><span style=color:#ce5c00;font-weight:700>)</span>
  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>Set</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>Integer</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>set</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>HashSet</span><span style=color:#ce5c00;font-weight:700>&lt;&gt;();</span>
  
  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>synchronized</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>add</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>Integer</span> <span style=color:#000>i</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#000>set</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>add</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>i</span><span style=color:#ce5c00;font-weight:700>);</span>
  <span style=color:#ce5c00;font-weight:700>}</span>
  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>synchronized</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>remove</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>Integer</span> <span style=color:#000>i</span><span style=color:#ce5c00;font-weight:700>){</span>
    <span style=color:#000>set</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>remove</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>i</span><span style=color:#ce5c00;font-weight:700>);</span>
  <span style=color:#ce5c00;font-weight:700>}</span>
  
  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>addTenThings</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#000>Random</span> <span style=color:#000>r</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>Random</span><span style=color:#ce5c00;font-weight:700>();</span>
    <span style=color:#204a87;font-weight:700>for</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>i</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#000>0</span><span style=color:#ce5c00;font-weight:700>;</span> <span style=color:#000>i</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>10</span><span style=color:#ce5c00;font-weight:700>;</span> <span style=color:#000>i</span><span style=color:#ce5c00;font-weight:700>++)</span>
      <span style=color:#000>add</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>r</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>nexInt</span><span style=color:#ce5c00;font-weight:700>());</span>
    <span style=color:#000>System</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>out</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>println</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#4e9a06>&#34;DEBUG...&#34;</span> <span style=color:#ce5c00;font-weight:700>+</span> <span style=color:#000>set</span><span style=color:#ce5c00;font-weight:700>);</span>
  <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>addTenThings 方法可能会抛出并发修改异常，因为在生成调试信息的过程中，toString 对容器进行迭代。当然，真正的问题在于 HiddenIterator 不是线程安全的。在使用 printlng 中的 set 之前必须首先获取 HiddenIterator 的锁，但在调试代码和日志代码中通常会忽视这个要求。</p>
<p>这里得到的教训是，如果状态与保护它的代码之间相隔甚远，那么开发人员就越容易忘记在访问状态时使用正确的同步。如果 HiddenIterator 用 synchronizedSet 来包装 HashSet，并且对同步代码进行封装，那么就不会发生这种错误。</p>
<blockquote>
<p>正如封装对象的状态有助于维持不变性条件一样，封装对象的同步机制同样有助于确保实施同步策略。</p>
</blockquote>
<p>容器的 hashCode 和 equals 等方法也会间接的执行迭代操作，当容器作为另一个容器的元素或键值时，就会出现这种情况。同样，containsAll、removeAll、retainAll 等方法，以及把容器作为参数的构造函数，都会对容器进行迭代。所有这些间接的迭代操作都可能抛出并发修改异常。</p>
<h2 id=52-并发容器>5.2 并发容器</h2>
<p>Java 5.0 提供了多种并发容器来改进同步容器的性能。同步容器将所有对容器状态的访问都串行化，以实现它们的线程安全性。这种方法的代价是验证降低并发性，当多个线程竞争容器的锁时，吞吐量会严重降低。</p>
<p>另一方面，并发容器是针对多个线程并发访问设计的。在 Java 5.0 中增加了 ConcurrentHashMap，用来代替同步且基于散列的 Map，以及 CopyOnWriteArrayList，用于在遍历操作为主要操作的情况下代替同步的 List。在新的 ConcurrentMap 接口中增加了对一些常见复合操作的支持，例如“若没有则添加”、替换、有条件删除等。</p>
<blockquote>
<p>通过并发容器来代替同步容器，可以极大的提高伸缩性并降低风险。</p>
</blockquote>
<p>Java 5.0 增加了两种新的容器类型：Queue 和 BlockingQueue。Queue 用来临时保存一组等待处理的元素。它提供了几组实现，包括：ConcurrentLinkedQueue，这是一个传统的 FIFO 队列，以及 PriorityQueue，这是一个(非并发的)优先级队列。Queue 上的操作不会阻塞，如果队列为空，那么获取元素的操作将返回空值。虽然可以用 List 来模拟 Queue 的行为——事实上，正是通过 LinkedList 来实现 Queue 的，但还是需要一个 Queue 的类，因为它能去掉 List 的随机访问需求，从而实现高效的并发。</p>
<p>BlockingQueue 扩展了 Queue，增加了可阻塞的插入和获取等操作。如果队列为空，那么获取元素的操作将一直阻塞，直到队列中出现一个可用的元素。如果队列已满(对于有界队列来说)，那么插入元素的操作将一直阻塞，直到队列中出现可用的空间。在“生产者-消费者”这种设计模式中，阻塞队列是非常有用的。</p>
<p>正如 ConcurrentHashMap 用于代替基于散列的同步 Map，Java 6 也引入了 ConcurrentSkipListMap 和 ConcurrentSkipListSet，分别作为同步的 SortedMap 和 SortedSet 的并发替代品。</p>
<h3 id=521-concurrenthashmap>5.2.1 ConcurrentHashMap</h3>
<p>同步容器类在执行每个操作期间都持有一个锁。在一些操作中，例如 HashMap.get 或 List.contains，可能包含大量的工作：当遍历散列桶或链表来查找特定对象时，必须在许多元素上调用 equals(这包含一定的计算量)。在基于散列的容器中，如果 hashCode 不能很均匀的分布散列值，那么容器中的元素就不会均匀的分布在整个容器中。某些情况下，某个糟糕的散列函数还会把一个散列表编程线性链表。当遍历很长的链表并且在某些或全部元素上调用 equals 方法时，会花费很长的时间，而其他线程在这段时间内都不能访问该容器。</p>
<p>与 HashMap 一样，ConcurrentHashMap 也是一个基于散列的 Map，但它使用了一种完全不同的加锁策略来提供更高的并发性和伸缩性。ConcurrentHashMap 并不是将每个方法多在同一个锁上同步并且每次只能有一个线程访问容器，而是使用一种粒度更细的加锁机制来实现更更大程度的共享，这种机制称为“分段锁”。在这种机制中，任意数量的读取线程都可以并发的访问 Map，执行读取操作的线程和执行写入操作的线程可以并发的访问 Map，并且一定数量的写入线程可以并发的修改 Map。ConcurrentHashMap 带来的结果是，在并发访问环境下将实现更高的吞吐量，而在单线程环境中只有非常小的性能损失。</p>
<p>ConcurrentHashMap 与其他并发容器一起增强了同步容器类：它们提供的迭代器不会抛出并发修改异常，因此不需要在迭代过程中对容器加锁。ConcurrentHashMap 返回的迭代器具有弱一致性，而并非“及时失败”。弱一致性的迭代器可以容忍并发的修改，当创建迭代器时会遍历已有的元素，并可以(但是不保证)在迭代器被构造后将修改操作反映给容器。</p>
<p>尽管有这些改进，但仍存存在一些需要权衡的因素。对于一些需要在整个 Map 上进行计算的方法，比如 size 和 isEmpty，这些方法的语义被略微减弱了，以反映容器的并发特性。由于 size 放回的结果在计算时可能已经过期了，它实际上只是一个估计值，因此允许 size 返回一个近似值而非精确值。虽然看上去有些令人不安，但事实上 size 和 isEmpty 这样的方法在并发环境下的用处很小，因为它们的返回值总是在不断变化。因此，这些操作的需求被弱化了，以换取对其他更重要操作的性能优化，比如 get、put、containsKey、remove 等。</p>
<p>在 ConcurrentHashMap 中没有实现对 Map 加锁以提供独占访问。在 Hashtable 和 synchronizedMap 中，获得 Map 的锁能防止其他线程访问该 Map。在一些不常见的情况中需要这种功能，例如通过原子方式添加一些映射，或者对 Map 迭代若干次并在此期间保持元素顺序相同。然而，总体来说这种权衡是合理的，因为并发容器的内容会持续变化。</p>
<p>与 Hashtable 和 synchronizedMap 相比，ConcurrentHashMap 有着更多的优势以及更少的劣势，因此在大多数情况下，用 ConcurrentHashMap 来代替同步 Map 能进一步提高代码的可伸缩性。只有当应用程序需要加锁 Map 以进行独占访问时，才应该放弃使用 ConcurrentHashMap。</p>
<h3 id=522-额外的原子-map-操作>5.2.2 额外的原子 Map 操作</h3>
<p>由于 ConcurrentHashMap 中不能被加锁以执行独占访问，因此我们无法使用客户端加锁来创建新的原子操作，例如 4.4.1 节中对 Vector 增加原子操作“若没有则添加”。但是，一些常见的复合操作，例如“若没有则添加”、“若相等则移除”和“若相等则替换”等，都已经实现为原子操作并且在 ConcurrentMap 中声明为接口，如程序清单 5-7 所示。如果你需要在现有的 Map 中添加这样的功能，那么很可能就意味着应该考虑使用 ConcurrentMap 了。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>interface</span> <span style=color:#000>ConcurrentMap</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>K</span><span style=color:#ce5c00;font-weight:700>,</span><span style=color:#000>V</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#204a87;font-weight:700>extends</span> <span style=color:#000>Map</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>K</span><span style=color:#ce5c00;font-weight:700>,</span><span style=color:#000>V</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#ce5c00;font-weight:700>{</span>
  <span style=color:#000>V</span> <span style=color:#000>putIfAbsent</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>K</span> <span style=color:#000>key</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>V</span> <span style=color:#000>value</span><span style=color:#ce5c00;font-weight:700>);</span>
  <span style=color:#204a87;font-weight:700>boolean</span> <span style=color:#000>remove</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>K</span> <span style=color:#000>key</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>V</span> <span style=color:#000>value</span><span style=color:#ce5c00;font-weight:700>);</span>
  <span style=color:#204a87;font-weight:700>boolean</span> <span style=color:#000>replace</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>K</span> <span style=color:#000>key</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>V</span> <span style=color:#000>oldValue</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>V</span> <span style=color:#000>newValue</span><span style=color:#ce5c00;font-weight:700>);</span>
  <span style=color:#000>V</span> <span style=color:#000>replace</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>K</span> <span style=color:#000>key</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>V</span> <span style=color:#000>newValue</span><span style=color:#ce5c00;font-weight:700>);</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><h3 id=523-copyonwritearraylist>5.2.3 CopyOnWriteArrayList</h3>
<p>CopyOnWriteArrayList 用于替代同步 List，在某些情况下它提供了更好的并发性能，并且在迭代期间不需要对容器进行加锁或复制。</p>
<p>“写时复制”容器的线程安全性在于，只要正确的发布一个事实不可变的对象，那么在访问该对象时就不再需要进一步的同步。在每次修改时，都会创建并重新发布一个新的容器副本，从而实现可变性。“写时复制”容器的迭代器保留一个指向底层基础数组的引用，这个数组当前位于迭代器的起始位置，由于他不会被修改，因此在对其进行同步时只需要确保数组内容的可见性。因此，多个线程可以同时对这个容器进行迭代，而不会彼此干扰或者与修改容器的线程相互干扰。“写时复制”容器返回的迭代器不会抛出并发修改异常，并且返回的元素与迭代器创建时的元素保持一致，而不必考虑之后修改操作所带来的影响。</p>
<p>显然，每当修改容器时都会复制底层数组，这需要一定的开销，特别是当容器的规模较大时。仅当迭代操作远远多于修改操作时，才应该使用“写时复制”容器。这个准则很好的描述了许多事件通知系统：在分发通知时需要迭代已注册的监听器列表，并调用每个监听器，在大多数情况下，注册和注销事件监听器的操作远少于接收事件通知的操作。</p>
<h2 id=53-阻塞队列和生产者-消费者模式>5.3 阻塞队列和生产者-消费者模式</h2>
<p>阻塞队列提供了可阻塞的 put 和 take 方法，以及支持定时的 offer 和 poll 方法。如果队列已经满了，那么 put 方法将持续阻塞直到有空间可用；如果队列为空，那么 take 方法将只需阻塞直到有元素可用。队列可以是有界的或无界的，无界队列永远不会满，因此无界队列上的 put 操作永远不会阻塞。</p>
<p>阻塞队列支持生产者-消费者设计模式。该模式将“找出需要完成的工作”与“执行工作”这两个过程分离，并把工作项放入一个“待完成”列表中以便在随后处理，而不是找出后立即处理。生产者—消费者模式能简化开发过程，因为它消除了生产者类和消费者类之间的代码依赖性，此外，该模式还将生产数据的过程与使用数据的过程解耦开来以简化工作负载的管理，因为这两个过程在处理数据的速率上可以有所不同。</p>
<p>在基于阻塞队列的生产者—消费者设计中，当生产数据时，生产者将数据放入队列，而当消费者准备处理数据时，将从队列中获取数据。生产者不需要知道消费者的标识或数量，或者它们是否是唯一的生产者，而只需要将数据放入队列即可。同样，消费者也不需要知道生产者是谁，或者工作来自何处。BlockingQueue 简化了生产者-消费者设计的实现过程，它支持任意数量的生产者和消费者。一种最常见的生产者-消费者设计模式就是将线程池与工作队列的组合，在 Executor 任务执行框架中体现了这种模式。</p>
<p>一两个人洗盘子为例，二者的劳动分工也是一种生产消费模式：其中一个人把喜好的盘子放在架子上，而另一个人从架子上取出盘子并把它们烘干。在这个实例中，架子相当于阻塞队列。如果架子上没有盘子，那么消费者会一直等待，知道有盘子需要烘干。如果架子上放满了，那么生产者会停止清洗直到架子上有更多的空间。我们可以将这种类比扩展为多个生产者和多个消费者，每个工人只需要与架子打交道。人们不需要知道究竟有多少生产者或消费者，或者是谁生产了某个指定的工作项。</p>
<p>“生产者”和“消费者”的角色是相对的，某种环境中的消费者在另一种不同的环境中可能会成为生产者。烘干盘子的工人将“消费”洗干净的盘子，而产生干燥的盘子。第三个工人把烘干后的盘子整理好，在这种情况下，烘干盘子的工人既是生产者、又是消费者，从而就有了两个共享的工作队列。</p>
<p>阻塞队列简化了消费者程序的编码，因为 take 操作会一直阻塞直到有可用的数据。如果生产者不能尽快产生工作项使消费者保持忙碌，那么消费者就只能保持等待，直到有工作可做。在某些情况下，这种方式是非常合适的，而在其他一些情况下，这也表示需要调整生产者线程数量和消费者线程数量之间的比例，从而实现更高的资源利用率。</p>
<p>如果生产者生成工作的效率比消费者处理工作的效率快，那么工作项会在队列中基类起来，最终耗尽内存。同样，put 方法的阻塞特性也极大地简化了生产者的编码。如果使用有界队列，那么当队列充满时，生产者将阻塞并且不能继续生成工作，而消费者就有时间来赶上工作处理速度。</p>
<p>阻塞队列同样提供了一个 offer 方法，如果数据项不能被添加到队列中，那么将返回一个失败状态。这样你就能够创建更多灵活的策略来处理符合过载的情况，例如减轻负载，将多余的工作项序列化并写入磁盘，减少生产者线程的数量，或者通过某种方式来抑制生产者线程。</p>
<blockquote>
<p>在构建可靠的应用程序时，有界队列是一种强大的资源管理工具：它能能抑制并防止产生过多的工作项，使应用程序在符合过载的情况下变得更加健壮。</p>
</blockquote>
<p>虽然生产者和消费者模式能够将生产者和消费者的代码彼此解耦，但它们的行为依然会通过共享队列间接耦合在一起。开发人员总会假设消费者处理工作的速率能够赶上生产者生成工作项的速率，因此通常不会为工作队列的大小设置边界，但这将导致在之后需要重新设计系统架构。因此，应该尽早通过阻塞队列在设计中构建资源管理机制——这件事情做得越早就越容易。在许多情况下，阻塞队列能够使这项工作更加简单，如果阻塞队列并不完全符合设计需求，那么还可以通过信号量来创建其他的阻塞数据结构。</p>
<p>在类库中包含了 BlockingQueue 的多种实现，其中 LinkedBlockingQueue 和 ArrayBlockingQueue 是 FIFO 队列，二者分别于 LinkedList 和 ArrayList 类似，但比同步 List 拥有更好的并发性能。PriorityBlockingQueue 是一个按优先级排序的队列，当你希望按照某种顺序而不是 FIFO 来处理元素时，这个队列将非常有用。正如其他有序的容器一样，PriorityBlockingQueue 既可以根据元素的自然顺序来比较元素，也可以自定义 Comparator。</p>
<p>最后一个 BlockingQueue 实现是 SynchronousQueue，实际上他不是一个真正的队列，因为他不会为队列中元素维护存储空间。与其他队列不同的是，它维护一组线程，这些线程在等待着把元素加入或移出队列。如果以洗盘子的比喻为例，那么就相当于没有架子，而是将喜好的盘子直接放入下一个空闲的烘干机中。这种实现队列的方式看似很奇怪，但由于可以直接交付工作，从而降低了间数据从生产者移动到消费者的延迟。直接交付方式还会将更多关于任务状态的信息反馈给生产者。当交付被接受时，它就知道消费者已经得到了任务，而不是把任务简单的放入一个队列——这种区别就好比将文件直接交给同事，还是将文件放到它的邮箱中并希望它尽快拿到文件。因为 SynchronousQueue 没有存储功能，因此 put 和 take 会一直阻塞，知道有另一个线程已经准备好参与到交付工作中。仅当有足够多的消费者，并且总有一个消费者准备好后去交付的工作时，才适合使用同步队列。</p>
<h3 id=531-示例桌面搜索>5.3.1 示例：桌面搜索</h3>
<p>有一种类型的程序适合被分解为生产者和消费者，如代理程序，它将扫描本地驱动器上的文件并建立索引以便随后进行搜索，类似于这些桌面搜索程序或者 Windows 索引服务。在程序清单 5-8 的 DiskCrawler 中给出了一个生产者任务，即在某个文件层次架构中搜索符合索引标准的文件，并将它们的名称放入工作队列。而且，在 Indexer 中还给出了一个消费者任务，即从队列中取出文件名称并对它们建立索引。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>FileCrawler</span> <span style=color:#204a87;font-weight:700>implements</span> <span style=color:#000>Runnable</span> <span style=color:#ce5c00;font-weight:700>{</span>
  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>BlockingQueue</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>File</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>fileQueue</span><span style=color:#ce5c00;font-weight:700>;</span>
  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>FileFilter</span> <span style=color:#000>fileFilter</span><span style=color:#ce5c00;font-weight:700>;</span>
  <span style=color:#000>pribate</span> <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>File</span> <span style=color:#000>root</span><span style=color:#ce5c00;font-weight:700>;</span>
  <span style=color:#ce5c00;font-weight:700>...</span>
  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>run</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#204a87;font-weight:700>try</span> <span style=color:#ce5c00;font-weight:700>{</span>
      <span style=color:#000>crawl</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>root</span><span style=color:#ce5c00;font-weight:700>);</span>
    <span style=color:#ce5c00;font-weight:700>}</span> <span style=color:#204a87;font-weight:700>catch</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>InterruptedException</span> <span style=color:#000>e</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
      <span style=color:#000>Thread</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>currentThread</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>interrupt</span><span style=color:#ce5c00;font-weight:700>();</span>
    <span style=color:#ce5c00;font-weight:700>}</span>
  <span style=color:#ce5c00;font-weight:700>}</span>
  
  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>crawl</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>File</span> <span style=color:#000>root</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#000>thorows</span> <span style=color:#000>InterruptedException</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#000>File</span><span style=color:#ce5c00;font-weight:700>[]</span> <span style=color:#000>entries</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>root</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>listFiles</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>fileFilter</span><span style=color:#ce5c00;font-weight:700>);</span>
    <span style=color:#204a87;font-weight:700>if</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>entries</span> <span style=color:#ce5c00;font-weight:700>!=</span> <span style=color:#204a87;font-weight:700>null</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
      <span style=color:#204a87;font-weight:700>for</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>File</span> <span style=color:#000>entry</span> <span style=color:#ce5c00;font-weight:700>:</span> <span style=color:#000>entries</span><span style=color:#ce5c00;font-weight:700>){</span>
        <span style=color:#204a87;font-weight:700>if</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>entry</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>isDierctory</span><span style=color:#ce5c00;font-weight:700>())</span> 
          <span style=color:#000>crawl</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>entry</span><span style=color:#ce5c00;font-weight:700>);</span>
        <span style=color:#204a87;font-weight:700>else</span> <span style=color:#204a87;font-weight:700>if</span><span style=color:#ce5c00;font-weight:700>(!</span><span style=color:#000>alreadyIndexed</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>entry</span><span style=color:#ce5c00;font-weight:700>))</span>
          <span style=color:#000>fileQueue</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>put</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>entry</span><span style=color:#ce5c00;font-weight:700>);</span>
      <span style=color:#ce5c00;font-weight:700>}</span>
    <span style=color:#ce5c00;font-weight:700>}</span>
  <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#ce5c00;font-weight:700>}</span>

<span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>Indexer</span> <span style=color:#204a87;font-weight:700>implements</span> <span style=color:#000>Runnable</span> <span style=color:#ce5c00;font-weight:700>{</span>
  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>BlockingQueue</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>File</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>queue</span><span style=color:#ce5c00;font-weight:700>;</span>
  
  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#000>Indexer</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>BlockingQueue</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>File</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>queue</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#204a87;font-weight:700>this</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>queue</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>queue</span><span style=color:#ce5c00;font-weight:700>;</span>
  <span style=color:#ce5c00;font-weight:700>}</span>
  
  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>run</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#204a87;font-weight:700>try</span> <span style=color:#ce5c00;font-weight:700>{</span>
      <span style=color:#204a87;font-weight:700>while</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>true</span><span style=color:#ce5c00;font-weight:700>){</span>
        <span style=color:#000>indexFile</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>queue</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>take</span><span style=color:#ce5c00;font-weight:700>());</span>
      <span style=color:#ce5c00;font-weight:700>}</span>
    <span style=color:#ce5c00;font-weight:700>}</span> <span style=color:#204a87;font-weight:700>catch</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>InterruptedException</span> <span style=color:#000>e</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
      <span style=color:#000>Thread</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>currentThread</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>interrupt</span><span style=color:#ce5c00;font-weight:700>();</span>
    <span style=color:#ce5c00;font-weight:700>}</span>
  <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>生产者消费者模式提供了一种适合线程的方法将桌面搜索问题分解为更简单的组件。将文件遍历与建立索引等功能分解为独立的操作，比将所有功能都放在一个操作中实现有着更高的代码可读性和可重用性：每个操作只需完成一个任务，并且阻塞队列将负责所有的控制流，因此每个功能的代码更加清晰简单。</p>
<p>生产消费模式同样能带来许多性能优势。生产者和消费者可以并发的执行。如果一个是 IO 密集型，另一个是 CPU 密集型，那么并发执行的吞吐率要高于串行执行的吞吐率。如果生产者和消费者的并行度不同，那么将它们紧密耦合在一起会把整体并行度降低为二者中更小的并行度。</p>
<p>在程序清单 5-9 中启动了多个爬虫程序和索引建立程序，每个程序都在各自的线程中运行。前面曾讲，消费者线程永远不会退出，因而程序无法终止，第 7 章将介绍多种技术来解决这个问题。虽然这个示例使用了显式管理的线程，但许多生产消费者设计也可以通过 Executor 任务执行框架来实现，其本身也使用了生产消费模式。</p>
<h3 id=532-串行线程封闭>5.3.2 串行线程封闭</h3>
<p>在 JUC 中实现的各种阻塞队列都包含了足够的内部同步机制，从而安全的将对象从生产者线程发布到消费者线程。</p>
<p>对于可变对象，生产消费这种设计与阻塞队列一起，促进了串行线程封闭，从而将对象所有权从生产者交付给消费者。线程封闭对象只能由单个线程拥有，但可以通过安全的发布该对象来转移所有权。在转移所有权之后，也只有另一个线程能获得这个对象的访问权限，并且发布该对象的线程无法再访问它。这种安全的发布确保了对象状态对于新的所有者来说是可见的，并且由于最初的所有者不会再访问它，因此对象被封闭在新的线程中。新的所有者线程可以对该线程做任意修改，因为它拥有独占的访问权。</p>
<p>对象池利用了串行封闭技术，将对象“借给”一个请求线程。只要对象池包含足够的内部同步来安全的发布池中的对象，并且只要客户端本身不会发布池中的对象，或者在将对象返回给对象池后就不再使用它，那么就可以安全的在线程之间传递所有权。</p>
<p>我们也可以使用其他发布机制来传递可变对象的所有权，但必须确保只有一个线程能接收被转移的对象。阻塞队列简化了这项工作。除此之外，可以通过 ConcurrentMap 的原子方法 remove 或 AtomicReference 的原子方法 compareAndSet 来完成这项工作。</p>
<h3 id=533-双端队列与工作密取>5.3.3 双端队列与工作密取</h3>
<p>Java 6 增加了两种容器类型，Deque(读作 “deck”) 和 BlockingQueue，它们分别对 Queue 和 BlockingQueue 进行了扩展。Deque 是一个双端队列，实现了在队列头和队列尾的高效插入和移除。具体实现还包括 ArrayDeque、LinkedBlockingDeque。</p>
<p>正如阻塞队列适用于生产消费模式，双端队列同样适用于另一种相关的模式，即工作窃取(Work Stealing)。在生产消费设计中，所有消费者有一个共享的工作队列，而在工作窃取设计中，每个消费者都有各自的双端队列。如果一个消费者完成了自己的双段队列的全部工作，那么它可以从其他消费者双端队列末尾窃取工作。窃取工作模式比传统的的生产消费模式具有更高的可伸缩性，这是因为工作者线程不会在单个共享队列上发生竞争。在大多数时候，它们只是访问自己的双端队列，从而极大减少了竞争。当工作者线程需要访问另一个队列时，它会从队列的尾部而不是从头部获取工作，因此进一步降低了队列上的竞争程度。</p>
<p>工作窃取非常适用于既是消费者又是生产者的问题——当执行某个工作时可能导致出现更多的工作。例如，在网页爬虫程序中处理一个页面时，通常会发现有更多的页面需要处理。类似的还有许多图搜索算法，例如在垃圾回收阶段对堆进行标记，都可以通过工作窃取机制来实现高效并发。当一个工作线程找到新的任务单元时，它会将其放到自己队列的末尾(或者在工作共享设计模式中，放入其他工作者线程的队列中)。当双端队列为空时，它会在另一个线程的队列末尾查找新的任务，从而确保每个线程都保持忙碌状态。</p>
<h2 id=54-阻塞方法与中断方法>5.4 阻塞方法与中断方法</h2>
<p>线程可能会阻塞或暂停执行，原因有多种：等待 IO 操作结束，等待获得一个锁，等待从 Thread.sleep 方法中醒来，或者是等待另一个线程的计算结果。当线程阻塞时，它通常会被挂起，并处于某种阻塞状态(BLOCKED/WAITING/TIMED_WAITING)。阻塞操作与执行时间很长的普通操作的差别在于，被阻塞的线程必须等待某个不受它控制的事件的发生后才能继续执行，比如等待 IO 操作完成，等待某个锁变为可用，或者等待外部计算结束。当某个外部事件发生时，线程被置回 RUNNABLE 状态，并可以再次被调用执行。</p>
<p>BlockingQueue 的 put 和 take 等方法会抛出受检异常 InterruptedException，这与类库中其他一些方法的做法相同，例如 Thread.sleep。当某个方法被声明为会抛出中断异常时，表示该方法是一个阻塞方法，如果这个方法被中断，那么它将努力提前结束阻塞状态。</p>
<p>Thread 提供了 interrupt 方法，用于中断线程或查询线程是否已经被中断。每个线程都有一个布尔值属性，表示线程的中断状态，当中断线程时将设置该状态为 true。</p>
<p>中断是一种协作机制，一个线程不能强制其他线程停止正在执行的操作而去执行其他的操作。当线程 A 中断 B 时，A 仅仅是要求 B 在执行到某个可暂停的地方时停止正在执行的操作——前提是如果线程 B 愿意停下来。虽然在 API 或者语言规范中并没有为中断定义任何特定应用级别的语义，但最常用中断的情况就是取消某个操作。方法对中断请求的响应度越高，就越容易及时取消那些执行时间很长的操作。</p>
<p>当在代码中调用一个将抛出中断异常的方法时，你自己的方法也就变成了一个阻塞方法，并且必须要处理中断的响应。对于库代码来说，有两种方案可供选择：</p>
<ul>
<li>传递中断异常。避开这个异常通常是最明智的选择——只需要把中断异常继续传递给外层调用者。传递中断异常的方法包括，根本不捕获该异常，或者捕获该异常，然后在执行某种简单的轻量工作后再次抛出该异常。</li>
<li>恢复中断。有时候不能抛出中断异常，例如当代码是 Runnable 的一部分时。在有些情况下，必须捕获中断异常，并通过调用当前线程上的 interrupt 方法恢复到中断状态，这样在调用栈中更高层的代码将看到引发了一个中断，如程序清单 5-10 所示。</li>
</ul>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>TaskRunnable</span> <span style=color:#204a87;font-weight:700>implements</span> <span style=color:#000>Runnable</span> <span style=color:#ce5c00;font-weight:700>{</span>
  <span style=color:#000>BlockingQuque</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>Task</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>queue</span><span style=color:#ce5c00;font-weight:700>;</span>
  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>run</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#204a87;font-weight:700>try</span> <span style=color:#ce5c00;font-weight:700>{</span>
      <span style=color:#000>process</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>queue</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>take</span><span style=color:#ce5c00;font-weight:700>());</span>
    <span style=color:#ce5c00;font-weight:700>}</span> <span style=color:#204a87;font-weight:700>catch</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>InterruptedException</span> <span style=color:#000>e</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
      <span style=color:#8f5902;font-style:italic>// 恢复被中断的状态
</span><span style=color:#8f5902;font-style:italic></span>      <span style=color:#000>Thread</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>currentThread</span><span style=color:#ce5c00;font-weight:700>().</span><span style=color:#c4a000>interrupt</span><span style=color:#ce5c00;font-weight:700>();</span>
    <span style=color:#ce5c00;font-weight:700>}</span>
  <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>还可以采用一些更复杂的中断处理方法，但上述两种方法已经可以应付大多数场景了。然而在出现中断异常时不应该做的事情是，捕获它但不做任何响应。这将使调用栈上更高层的代码无法对中断采取处理措施，因为线程被中断的证据已经丢失。只有在一种特殊的情况下才可以屏蔽中断，即对 Thread 进行扩展，并且能够控制调用栈上所有更高层的代码。第 7 章将进一步介绍取消和中断操作。</p>
<h2 id=55-同步工具类>5.5 同步工具类</h2>
<p>在容器类中，阻塞队列是一种特殊的类：它们不仅作为保存对象的容器，还能协调生产者和消费者之间的控制流，因为 take 和 put 等方法将阻塞，直到队列达到期望的状态(对既非空也不满)。</p>
<p>同步工具类可以是任何一个对象，只要它根据其自身的状态来协调线程的控制流。阻塞队列可以作为一个同步工具类，其他类型的同步工具类还有信号量(Semaphore)、栅栏(Barrier)、闭锁(Latch)。在平台类库中还包含一些其他同步工具类，如果这些类无法满足需要，那么可以按照第 14 章给出的机制来构建自己的同步工具类。</p>
<p>所有的同步工具类都包含一些特定的结构化属性：它们封装了状态，这些状态将决定执行同步工作类的线程是继续执行还是等待，此外还提供了一些方法对状态进行操作，以及另一些方法用于高效的等待同步工具类进入预期状态。</p>
<h3 id=551-闭锁>5.5.1 闭锁</h3>
<p>闭锁是一种同步工具类，可以延迟线程的进度直到其到达终止状态。闭锁的作用相当于一扇门：在闭锁到达结束状态之前，这扇门一直是关闭的，并且没有任何线程可以通过，当到达状态时，这扇门会打开并允许所有的线程通过。当闭锁到达结束状态后，将不会在改变状态，因此这扇门将永远保持打开状态。闭锁可以用来确保某些活动直到其他活动都完成后才继续进行，比如：</p>
<ul>
<li>确保某个计算在其需要的所有资源都被初始化之后才继续进行。二元闭锁(包含两个状态)可以用来表示“资源 R 已经被初始化”，而所有需要 R 的操作都必须先在这个闭锁上等待。</li>
<li>确保某个服务在其依赖的所有其他服务都已启动之后才启动。每个服务都有一个相关的二元闭锁。当启动服务 S 时，将首先在 S 依赖的其他服务的闭锁上等待，在所有依赖的服务都启动后会释放闭锁 S，这样其他依赖 S 的服务才能继续执行。</li>
<li>等待直到某个操作的所有参与者(例如在多玩家游戏中的所有玩家)都就绪再继续执行。在这种情况下，当所有玩家都准备继续时，闭锁将到达结束状态。</li>
</ul>
<p>CountDownLatch 是一种灵活的闭锁实现，可以在上述各种情况中使用，它可以使一个或多个线程等待一组事件发生。闭锁状态包括一个计数器，该计数器被初始化为一个正数，表示需要等待的事件数量。countDown 方法将递减计数器，表示已经发生了一个事件，而 await 方法等待计数器到达零，或者等待中的线程中断，或者等待超时。</p>
<p>在程序清单 5-11 中的 TestHarness 中给出了闭锁的两种常见方法。TestHarness 创建一定数量的线程，利用它们并发执行指定的任务。它使用两个闭锁，分别表示“起始门”和“结束门”。起始门的计数器为 1，而结束门的计数器为工作线程的数量。每个工作线程首先要做的事就是在启动门上等待，从而确保所有线程都已就绪后才开始执行。而每个线程要做的最后一件事就是调用结束门的 countDown 方法将计数器递减 1，这能使主线程高效的等待直到所有工作线程都执行完成，因此可以统计所消耗的时间。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>TestHarness</span> <span style=color:#ce5c00;font-weight:700>{</span>
  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>long</span> <span style=color:#000>timeTasks</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>nThreads</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>Runnable</span> <span style=color:#000>task</span><span style=color:#ce5c00;font-weight:700>)</span> 
    <span style=color:#204a87;font-weight:700>throws</span> <span style=color:#000>InterruptedException</span> <span style=color:#ce5c00;font-weight:700>{</span> 
  <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>CountDownLatch</span> <span style=color:#000>startGate</span> <span style=color:#ce5c00;font-weight:700>=</span> 
    <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>CountDownLatch</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>1</span><span style=color:#ce5c00;font-weight:700>);</span> 	
  <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>CountDownLatch</span> <span style=color:#000>endGate</span> <span style=color:#ce5c00;font-weight:700>=</span> 
    <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>CountDownLatch</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>nThreads</span><span style=color:#ce5c00;font-weight:700>);</span>

  <span style=color:#204a87;font-weight:700>for</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>i</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>0</span><span style=color:#ce5c00;font-weight:700>;</span> <span style=color:#000>i</span> <span style=color:#ce5c00;font-weight:700>&lt;</span> <span style=color:#000>nThreads</span><span style=color:#ce5c00;font-weight:700>;</span> <span style=color:#000>i</span><span style=color:#ce5c00;font-weight:700>++)</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#000>Thread</span> <span style=color:#000>t</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>Thread</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span> 
      <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>run</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span> 
        <span style=color:#204a87;font-weight:700>try</span> <span style=color:#ce5c00;font-weight:700>{</span> 
          <span style=color:#000>startGate</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>await</span><span style=color:#ce5c00;font-weight:700>();</span> 
          <span style=color:#204a87;font-weight:700>try</span> <span style=color:#ce5c00;font-weight:700>{</span> <span style=color:#000>task</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>run</span><span style=color:#ce5c00;font-weight:700>();</span> <span style=color:#ce5c00;font-weight:700>}</span> 
          <span style=color:#204a87;font-weight:700>finally</span> <span style=color:#ce5c00;font-weight:700>{</span> <span style=color:#000>endGate</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>countDown</span><span style=color:#ce5c00;font-weight:700>();</span> <span style=color:#ce5c00;font-weight:700>}</span>
        <span style=color:#ce5c00;font-weight:700>}</span> <span style=color:#204a87;font-weight:700>catch</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>InterruptedException</span> <span style=color:#000>ignored</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span> <span style=color:#ce5c00;font-weight:700>}</span>
      <span style=color:#ce5c00;font-weight:700>}</span>
    <span style=color:#ce5c00;font-weight:700>};</span> 
    <span style=color:#000>t</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>start</span><span style=color:#ce5c00;font-weight:700>();</span>
  <span style=color:#ce5c00;font-weight:700>}</span>

  <span style=color:#204a87;font-weight:700>long</span> <span style=color:#000>start</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>System</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>nanoTime</span><span style=color:#ce5c00;font-weight:700>();</span> 
  <span style=color:#000>startGate</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>countDown</span><span style=color:#ce5c00;font-weight:700>();</span> 
  <span style=color:#000>endGate</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>await</span><span style=color:#ce5c00;font-weight:700>();</span> 
  <span style=color:#204a87;font-weight:700>long</span> <span style=color:#000>end</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>System</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>nanoTime</span><span style=color:#ce5c00;font-weight:700>();</span> 
  <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>end</span><span style=color:#ce5c00;font-weight:700>-</span><span style=color:#000>start</span><span style=color:#ce5c00;font-weight:700>;</span>
  <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>这里为什么要使用闭锁，而不是在线程创建后直接启动？或许，我们希望测试 N 个线程并发执行某个任务时需要的时间。如果在创建线程后立即启动，那么先启动的线程将“领先”后启动的线程，并且活跃线程数量会随着时间的推移而增加或减少，蒋政程度也在不断的发生变化。启动门将使得主线程能够同时释放所有都工作线程，而将结束门则使主线程能够等待最后一个线程执行完成，而不是顺序的等待各个线程执行完成。</p>
<h3 id=552-futuretask>5.5.2 FutureTask</h3>
<p>FutureTask 也可以用作闭锁。FutureTask 实现了 Future 语义，表示一种可生产结果的计算。FutureTask 表示的计算是通过 Callable 来实现的，相当于一种可生成结果的 Runnable，并且可以处于以下三种状态：等待运行、正在运行、运行完成。“执行完成”表示计算的所有可能的结束方式，包括正常结束、由于取消而结束、由于异常而结束等。当 FutureTask 进入完成状态后，它会永远停止在这个状态上。</p>
<p>Future.get 的行为取决于任务的状态。如果任务已经完成，会立即返回结果，否则，get 调用将阻塞直到任务进入完成状态，然后返回结果或抛出异常。FutureTask 将计算结果从执行计算的线程传递到获取结果的线程，而 FutureTask 的规范确保了这种传递过程能实现结果的安全发布。</p>
<p>FutureTask 在 Executor 框架中表示异步任务，此外还可以用于表示一些时间较长的计算，这些计算可以在使用计算结果之前启动。程序清单 5-12 中的 Preloader 就使用了 FutureTask 来执行一个高开销的计算，并且计算结果将在稍后使用。通过提前启动计算，可以减少在等待结束时需要的时间。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>Preloader</span> <span style=color:#ce5c00;font-weight:700>{</span>
  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>FutureTask</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>ProductInfo</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>future</span> <span style=color:#ce5c00;font-weight:700>=</span> 
    <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>FutureTask</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>ProductInfo</span><span style=color:#ce5c00;font-weight:700>&gt;(</span><span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>Callable</span><span style=color:#ce5c00;font-weight:700>&lt;&gt;(){</span>
      <span style=color:#204a87;font-weight:700>public</span> <span style=color:#000>ProductInfo</span> <span style=color:#000>call</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#204a87;font-weight:700>throws</span> <span style=color:#000>DataLoadException</span> <span style=color:#ce5c00;font-weight:700>{</span>
        <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>loadProductInfo</span><span style=color:#ce5c00;font-weight:700>();</span>
      <span style=color:#ce5c00;font-weight:700>}</span>
    <span style=color:#ce5c00;font-weight:700>});</span>
  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>Thread</span> <span style=color:#000>thread</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>Thread</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>future</span><span style=color:#ce5c00;font-weight:700>);</span>
  
  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>start</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span> <span style=color:#000>thread</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>start</span><span style=color:#ce5c00;font-weight:700>();</span> <span style=color:#ce5c00;font-weight:700>}</span>
  
  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#000>ProductInfo</span> <span style=color:#000>get</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#204a87;font-weight:700>throws</span> <span style=color:#000>ex</span><span style=color:#ce5c00;font-weight:700>..{</span>
    <span style=color:#204a87;font-weight:700>try</span> <span style=color:#ce5c00;font-weight:700>{</span>
      <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>future</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>get</span><span style=color:#ce5c00;font-weight:700>();</span>
    <span style=color:#ce5c00;font-weight:700>}</span> <span style=color:#204a87;font-weight:700>catch</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>ExecutionException</span> <span style=color:#000>e</span><span style=color:#ce5c00;font-weight:700>){</span>
      <span style=color:#000>Throwable</span> <span style=color:#000>cause</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>e</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>getCause</span><span style=color:#ce5c00;font-weight:700>();</span> 
      <span style=color:#204a87;font-weight:700>if</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>cause</span> <span style=color:#204a87;font-weight:700>instanceof</span> <span style=color:#000>DataLoadException</span><span style=color:#ce5c00;font-weight:700>)</span> 
        <span style=color:#204a87;font-weight:700>throw</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>DataLoadException</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#000>cause</span><span style=color:#ce5c00;font-weight:700>;</span> 
      <span style=color:#204a87;font-weight:700>else</span> <span style=color:#204a87;font-weight:700>throw</span> <span style=color:#000>launderThrowable</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>cause</span><span style=color:#ce5c00;font-weight:700>);</span>
    <span style=color:#ce5c00;font-weight:700>}</span>
  <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>Preloader 创建了一个 FutureTask，其中包含从数据库加载产品信息的任务，以及一个执行运算的线程。由于在构造函数或静态初始化方法中启动线程并不是一种好方法，因此提供了一个 start 方法来启动线程。当程序随后需要 ProductInfo 时，可以调用 get 方法，如果数据已经加载，那么将返回这些数据，否则将等待直到加载完成后再返回。</p>
<p>Callable 表示的任务可以抛出受检异常或未检异常，并且任何代码都可能抛出一个 Error。无论任务代码抛出什么异常，都会被封装到一个 ExecutionException 中，并在 Future.get 中重新被抛出。这将使调用 get 的代码变得复杂，因为不仅要处理可能出现的 ExecutionException，而且还由于 ExecutionException 是座椅个 Throwable 返回的，因此处理起来并不容易。</p>
<p>在 Preloader 中，当 get 方法抛出 ExecutionException 时，可能是以下三种情况之一：Callable 抛出的受检异常、RuntimeException、Error。我们必须对每种情况进行单独处理，但我们将使用程序清单 5-13 中的 launderThrowable 辅助方法来封装一些复杂的异常处理逻辑。在调用 launderThrowable 之前，Preloader 会首先检查已知的受检异常，并重新抛出它们，Preloader 将调用 launderThrowable 并抛出结果。如果 Throwable 传递给 launderThrowable 的是一个 Error，那么 launderThrowable 将直接再次将其抛出；如果不是 RuntimeException，那么将抛出一个非法状态异常表示这是一个逻辑错误。剩下的 RuntimeException，launderThrowable 将把它返回给调用者，而调用者通常会重新抛出这些异常。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#8f5902;font-style:italic>/** If the Throwable is an Error, throw it; if it is a 
</span><span style=color:#8f5902;font-style:italic>*  RuntimeException return it, otherwise throw IllegalStateException 
</span><span style=color:#8f5902;font-style:italic>*/</span> 
<span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>static</span> <span style=color:#000>RuntimeException</span> <span style=color:#000>launderThrowable</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>Throwable</span> <span style=color:#000>t</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
  <span style=color:#204a87;font-weight:700>if</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>t</span> <span style=color:#204a87;font-weight:700>instanceof</span> <span style=color:#000>RuntimeException</span><span style=color:#ce5c00;font-weight:700>)</span> 
    <span style=color:#204a87;font-weight:700>return</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>RuntimeException</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#000>t</span><span style=color:#ce5c00;font-weight:700>;</span> 
  <span style=color:#204a87;font-weight:700>else</span> <span style=color:#204a87;font-weight:700>if</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>t</span> <span style=color:#204a87;font-weight:700>instanceof</span> <span style=color:#000>Error</span><span style=color:#ce5c00;font-weight:700>)</span> 
    <span style=color:#204a87;font-weight:700>throw</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>Error</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#000>t</span><span style=color:#ce5c00;font-weight:700>;</span> 
  <span style=color:#204a87;font-weight:700>else</span> 
    <span style=color:#204a87;font-weight:700>throw</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>IllegalStateException</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#4e9a06>&#34;Not unchecked&#34;</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>t</span><span style=color:#ce5c00;font-weight:700>);</span> <span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><h3 id=553-信号量>5.5.3 信号量</h3>
<p>计数信号量用来控制同时访问某个特定资源的操作数量，或者同时执行某个指定操作的数量。计数信号量还可以用来实现某种资源池，或者对容器施加边界。</p>
<p>Semaphore 中管理着一组虚拟许可，许可的和数量可以通过构造函数来指定。在执行操作时可以首先获得许可(如果还有剩余的许可)，并在使用后释放许可。如果没有许可，那么 acquire 将阻塞直到有许可(或者直到被中断或者操作超时)。release 方法将返回一个许可给信号量。计算信号量的一种简化形式是二值信号量，即初始值为 1 的 Semaphore。二值信号量可以用作互斥体(mutex)，并具备不可重入的加锁语义：谁拥有这个唯一的许可，谁就拥有了互斥锁。</p>
<p>Semaphore 可以用于实现资源池，例如数据库连接池。我们可以构造一个固定长度的资源池，当池为空时，请求资源将会失败，但你真正希望看到的行为是阻塞而不是失败，并且当池非空时解除阻塞。如果将 Semaphore 的计数值初始化为池的大小，并在池中获取一个资源之前首先调用 acquire 方法获得一个许可，在将资源返回给池之后调用 release 释放许可，那么 acquire 将一直阻塞直到资源池不为空。在第 12 章的有界缓冲类中将使用这项技术。(在构造阻塞对象池时，一种更简单的方法是使用 BlockingQueue 来保存池的资源。)</p>
<p>同样，你也可以使用 Semaphore 将任何一种容器变为有界阻塞容器，如程序清单 5-14 中的 BoundledHashSet 所示。信号量的计数值会初始化为容器容量的最大值。add 操作在向底层容器中添加一个元素之前，首先要获取一个许可。如果 add 操作没有添加任何一个元素，那么会立刻释放许可。同样，remove 操作释放一个许可，使更多元素能够添加到容器中。底层的 Set 实现并不知道关于边界的任何信息，这是由 BoundedHashSet 来处理的。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>BoundedHashSet</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>T</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#ce5c00;font-weight:700>{</span>
  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>Set</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>T</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>set</span><span style=color:#ce5c00;font-weight:700>;</span>
  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>Semaphore</span> <span style=color:#000>sem</span><span style=color:#ce5c00;font-weight:700>;</span>
  
  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#000>BoundedHashSet</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>bound</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#204a87;font-weight:700>this</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>set</span> <span style=color:#ce5c00;font-weight:700>=</span> 
      <span style=color:#000>Collecitons</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>synchronizedSet</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>HashSet</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>T</span><span style=color:#ce5c00;font-weight:700>&gt;());</span>
    <span style=color:#204a87;font-weight:700>this</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>sem</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>Semaphore</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>bound</span><span style=color:#ce5c00;font-weight:700>);</span>
  <span style=color:#ce5c00;font-weight:700>}</span>
  
  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>boolean</span> <span style=color:#000>add</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>T</span> <span style=color:#000>o</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#204a87;font-weight:700>throws</span> <span style=color:#000>InterruptedException</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#000>sem</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>acquire</span><span style=color:#ce5c00;font-weight:700>();</span>
    <span style=color:#204a87;font-weight:700>boolean</span> <span style=color:#000>wasAdded</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>false</span><span style=color:#ce5c00;font-weight:700>;</span>
    <span style=color:#204a87;font-weight:700>try</span> <span style=color:#ce5c00;font-weight:700>{</span>
      <span style=color:#000>wasAdded</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>set</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>add</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>o</span><span style=color:#ce5c00;font-weight:700>);</span>
      <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>wasAdded</span><span style=color:#ce5c00;font-weight:700>;</span>
    <span style=color:#ce5c00;font-weight:700>}</span> <span style=color:#204a87;font-weight:700>finally</span> <span style=color:#ce5c00;font-weight:700>{</span>
      <span style=color:#204a87;font-weight:700>if</span><span style=color:#ce5c00;font-weight:700>(!</span><span style=color:#000>wasAdded</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#000>sem</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>release</span><span style=color:#ce5c00;font-weight:700>();</span>
    <span style=color:#ce5c00;font-weight:700>}</span>
  <span style=color:#ce5c00;font-weight:700>}</span>
  
  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>boolean</span> <span style=color:#000>remove</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>Object</span> <span style=color:#000>o</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#204a87;font-weight:700>boolean</span> <span style=color:#000>wasRemoved</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>set</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>remove</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>o</span><span style=color:#ce5c00;font-weight:700>);</span>
    <span style=color:#204a87;font-weight:700>if</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>wasRemoved</span><span style=color:#ce5c00;font-weight:700>)</span>
      <span style=color:#000>sem</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>release</span><span style=color:#ce5c00;font-weight:700>();</span>
    <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>wasRemoved</span><span style=color:#ce5c00;font-weight:700>;</span>
  <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><h3 id=554-栅栏>5.5.4 栅栏</h3>
<p>我们已经看到通过闭锁来启动一组相关的操作，或者等待一组相关的操作结束。闭锁是一次性对象，一旦进入终止状态，就不能再被重置。</p>
<p>栅栏类似于闭锁，它能阻塞一组线程直到某个事件繁盛。栅栏与闭锁的关键区别在于，所有线程必须同时到达栅栏位置，才能继续执行。闭锁用于等待事件，而栅栏用于等待其他线程。栅栏用于实现一些协议，例如几个家庭决定在某个地方回合：“所有人 6:00 在麦当劳碰头，到了以后要等其他人，之后再讨论下一步要做的事情。”</p>
<p>CyclicBarrier 可以使用一定数量的参与方反复的在栅栏处汇集，它在并行迭代算法中非常有用：这种算法通常将一个问题拆分成一系列互相独立的子问题。当线程到达栅栏位置时将调用 await 方法，这个方法将阻塞直到所有线程都到达栅栏位置。如果所有线程都到达了栅栏位置，那么栅栏将打开，此时所有线程都被释放，而栅栏将被重置以便下次使用。如果对 await 的调用超时，或者 await 阻塞的线程被中断，那么栅栏就被认为是打破了，所有阻塞的 await 调用都将终止并抛出 BrokenArrierException。如果成功通过栅栏，那么 await 将为每个线程返回一个唯一的到达索引号，我们可以利用这些索引来“选举”产生一个领导线程，并在下一次迭代中由该领导线程执行一些特殊的工作。CyclicBarrier 还可以使你将一个栅栏操作传递给构造函数，这是一个 Runnable，当成功通过栅栏时会(在一个子任务线程中)执行它，但在阻塞线程被释放之前是不能执行的。</p>
<p>在模拟程序中通常要使用栅栏，例如某个步骤中的计算可以并行执行，但必须等到该步骤中的所有计算都执行完毕才能进入下一个步骤。例如，在 n-body 粒子迷模拟系统中，每个步骤都根据其他粒子的位置和属性来计算各个粒子的新位置。通过在么两次调用之间等待栅栏，能够确保在第 K 步中的所有操作都已经计算完成，才进入第 k+1 步。</p>
<p>在程序清单 5-15 的 CellularAutomata 中给出了如何通过栅栏来计算细胞的自动化模拟，例如 Conway 的生命游戏。在吧模拟过程并行化后，为么个元素(在该例子中相当于一个细胞)分配一个独立的线程是不现实的，因为浙江产生过多的线程，而在协调这些线程上导致的开销将降低计算性能。合理的做法是，将问题分解成一定数量的子问题，为每个子问题分配一个线程来进行求解，之后再将所有的结果合并起来。CellularAutomata 将问题分解为 N(CPU) 个子问题，其中 N 等于 CPU 的数量，并将每个子问题分配给一个线程。在每个步骤中，工作线程都为各自问题中的所有细胞计算新值。但所有工作线程都到达栅栏时，栅栏会把这些新值提交给数据模型。在栅栏的操作执行完成以后，工作线程将开始下一步的计算，包括调用 isDone 方法来判断是否还需要进行下一步迭代。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>CellularAutomata</span> <span style=color:#ce5c00;font-weight:700>{</span>
  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>Board</span> <span style=color:#000>minBoard</span><span style=color:#ce5c00;font-weight:700>;</span>
  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>CyclicBarrier</span> <span style=color:#000>barrier</span><span style=color:#ce5c00;font-weight:700>;</span>
  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>Worker</span><span style=color:#ce5c00;font-weight:700>[]</span> <span style=color:#000>workers</span><span style=color:#ce5c00;font-weight:700>;</span>
  
  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#000>CellularAutomate</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>Board</span> <span style=color:#000>board</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#204a87;font-weight:700>this</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>mainBoard</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>board</span><span style=color:#ce5c00;font-weight:700>;</span>
    <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>count</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>Runtime</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>getRuntime</span><span style=color:#ce5c00;font-weight:700>().</span><span style=color:#c4a000>availiableProcessessors</span><span style=color:#ce5c00;font-weight:700>();</span>
    <span style=color:#204a87;font-weight:700>this</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>barrier</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>CyclicBarrier</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>count</span><span style=color:#ce5c00;font-weight:700>,</span> 
      <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>Runnable</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span>
        <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>run</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span>
          <span style=color:#000>mainBoard</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>commitNewValues</span><span style=color:#ce5c00;font-weight:700>();</span>
      <span style=color:#ce5c00;font-weight:700>}});</span>
    <span style=color:#204a87;font-weight:700>this</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>workers</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>Wokrer</span><span style=color:#ce5c00;font-weight:700>[</span><span style=color:#000>count</span><span style=color:#ce5c00;font-weight:700>];</span>
    <span style=color:#204a87;font-weight:700>for</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>i</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#000>0</span><span style=color:#ce5c00;font-weight:700>;</span> <span style=color:#000>i</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>count</span><span style=color:#ce5c00;font-weight:700>;</span> <span style=color:#000>i</span><span style=color:#ce5c00;font-weight:700>++)</span>
      <span style=color:#000>workers</span><span style=color:#ce5c00;font-weight:700>[</span><span style=color:#000>i</span><span style=color:#ce5c00;font-weight:700>]</span> <span style=color:#ce5c00;font-weight:700>=</span> 
        <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>Worker</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>mainBoard</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>getSubBoard</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>count</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>i</span><span style=color:#ce5c00;font-weight:700>));</span>
  <span style=color:#ce5c00;font-weight:700>}</span>
  
  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>Worker</span> <span style=color:#204a87;font-weight:700>implements</span> <span style=color:#000>Runnable</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>Board</span> <span style=color:#000>board</span><span style=color:#ce5c00;font-weight:700>;</span>
    <span style=color:#204a87;font-weight:700>public</span> <span style=color:#000>Worker</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>Board</span> <span style=color:#000>board</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
      <span style=color:#204a87;font-weight:700>this</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>board</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>board</span><span style=color:#ce5c00;font-weight:700>;</span>
    <span style=color:#ce5c00;font-weight:700>}</span>
    <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>run</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span>
      <span style=color:#204a87;font-weight:700>while</span><span style=color:#ce5c00;font-weight:700>(!</span><span style=color:#000>board</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>hasConverged</span><span style=color:#ce5c00;font-weight:700>())</span> <span style=color:#ce5c00;font-weight:700>{</span>
        <span style=color:#204a87;font-weight:700>for</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>x</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#000>0</span><span style=color:#ce5c00;font-weight:700>;</span> <span style=color:#000>x</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>board</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>getMaxX</span><span style=color:#ce5c00;font-weight:700>();</span> <span style=color:#000>x</span><span style=color:#ce5c00;font-weight:700>++)</span>
          <span style=color:#204a87;font-weight:700>for</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>y</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#000>0</span><span style=color:#ce5c00;font-weight:700>;</span> <span style=color:#000>y</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>board</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>getMaxY</span><span style=color:#ce5c00;font-weight:700>();</span> <span style=color:#000>y</span><span style=color:#ce5c00;font-weight:700>++)</span>
            <span style=color:#000>board</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>setNewValue</span><span style=color:#ce5c00;font-weight:700>(</span>
              <span style=color:#000>x</span><span style=color:#ce5c00;font-weight:700>,</span><span style=color:#000>y</span><span style=color:#ce5c00;font-weight:700>,</span><span style=color:#000>computeValue</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>x</span><span style=color:#ce5c00;font-weight:700>,</span><span style=color:#000>y</span><span style=color:#ce5c00;font-weight:700>));</span>
        <span style=color:#204a87;font-weight:700>try</span> <span style=color:#ce5c00;font-weight:700>{</span>
          <span style=color:#000>barrier</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>await</span><span style=color:#ce5c00;font-weight:700>();</span>
        <span style=color:#ce5c00;font-weight:700>}</span> <span style=color:#204a87;font-weight:700>catch</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>InterruptedException</span> <span style=color:#000>ex</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
          <span style=color:#204a87;font-weight:700>return</span><span style=color:#ce5c00;font-weight:700>;</span>
        <span style=color:#ce5c00;font-weight:700>}</span> <span style=color:#204a87;font-weight:700>catch</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>BrokenBarrierException</span> <span style=color:#000>ex</span><span style=color:#ce5c00;font-weight:700>){</span>
          <span style=color:#204a87;font-weight:700>return</span><span style=color:#ce5c00;font-weight:700>;</span>
        <span style=color:#ce5c00;font-weight:700>}</span>
      <span style=color:#ce5c00;font-weight:700>}</span>
    <span style=color:#ce5c00;font-weight:700>}</span>
  <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>另一种形式的栅栏是 Excheanger，它是一种两方栅栏，各方在栅栏位置上交换数据。当两方执行不对称的操作时，Exchanger 会非常有用，比如当一个线程向缓冲区写入数据，而另一个线程从缓冲区中读取数据。这些线程可以使用 Exchanger 来汇合，并将满的缓冲区与空的缓冲区交换。当两个线程通过 Exchanger 交换对象时，这种交换就把这两个对象安全的发布给对方。</p>
<p>数据交换的时机取决于应用程序的响应需求。最简单的方案是，当缓冲区被填满时，由填充任务进行交换，当缓冲区为空时，由清空任务进行交换。这样会把需要交换的次数将至最低，但如果新数据的到达率不可预测，那么一些数据的处理过程就将延迟。另一个方法是，不仅当缓冲区被填满时进行交换，并且当缓冲被填充到一定程度并保持一段时间后，也进行交换。</p>
<h2 id=56-构建高效且可伸缩的结果缓存>5.6 构建高效且可伸缩的结果缓存</h2>
<p>几乎所有的服务器应用程序都会使用某种形式的缓存。重用之前的计算结果能降低延迟，提供吞吐量，但却需要消耗更多的内存。</p>
<p>像许多重复发明的轮子一样，缓存看上去都非常简单。然而，简单的缓存可能会将性能瓶颈转换为可伸缩性瓶颈，即使缓存是用于提升单线程的性能。本节我们将开发一个高效且可伸缩的缓存，用于改进一个高计算开销的函数。我们首先从简单的 HashMap 开始，然后分析它的并发缺陷性，并讨论如何修复它。</p>
<p>在程序清单 5-16 的 <code>Computable&lt;A,V></code> 接口中声明了一个函数 Computable，其输入类型为 A，输出类型为 V。在 ExpensiveFunction 中实现的 Conputable，需要很长时间来计算结果，我们将创建一个 Computable 包装器，用于记住之前的计算结果，并将缓存过程封装起来。这被称为记忆化。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>interface</span> <span style=color:#000>Computable</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>A</span><span style=color:#ce5c00;font-weight:700>,</span><span style=color:#000>V</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#ce5c00;font-weight:700>{</span>
  <span style=color:#000>V</span> <span style=color:#000>compute</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>A</span> <span style=color:#000>arg</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#204a87;font-weight:700>throws</span> <span style=color:#000>InterruptedException</span><span style=color:#ce5c00;font-weight:700>;</span>
<span style=color:#ce5c00;font-weight:700>}</span>

<span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>ExpensiveFunction</span> <span style=color:#204a87;font-weight:700>implements</span> <span style=color:#000>Computable</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>String</span><span style=color:#ce5c00;font-weight:700>,</span><span style=color:#000>BigInteger</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#ce5c00;font-weight:700>{</span>
  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#000>BigInteger</span> <span style=color:#000>compute</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>String</span> <span style=color:#000>arg</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#8f5902;font-style:italic>// 在经过长时间的计算后
</span><span style=color:#8f5902;font-style:italic></span>    <span style=color:#204a87;font-weight:700>return</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>BigInteger</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>arg</span><span style=color:#ce5c00;font-weight:700>);</span>
  <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#ce5c00;font-weight:700>}</span>

<span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>Memoizer1</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>A</span><span style=color:#ce5c00;font-weight:700>,</span><span style=color:#000>V</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#204a87;font-weight:700>implements</span> <span style=color:#000>Computable</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>A</span><span style=color:#ce5c00;font-weight:700>,</span><span style=color:#000>V</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#ce5c00;font-weight:700>{</span>
  <span style=color:#5c35cc;font-weight:700>@GuardedBy</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#4e9a06>&#34;this&#34;</span><span style=color:#ce5c00;font-weight:700>)</span>
  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#000>fianl</span> <span style=color:#000>Map</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>A</span><span style=color:#ce5c00;font-weight:700>,</span><span style=color:#000>V</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>cache</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>HashMap</span><span style=color:#ce5c00;font-weight:700>&lt;&gt;();</span>
  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#000>fianl</span> <span style=color:#000>Computable</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>A</span><span style=color:#ce5c00;font-weight:700>,</span><span style=color:#000>V</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>c</span><span style=color:#ce5c00;font-weight:700>;</span>
  
  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#000>Memorizer</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>Computable</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>A</span><span style=color:#ce5c00;font-weight:700>,</span><span style=color:#000>V</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>c</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#204a87;font-weight:700>this</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>c</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>c</span><span style=color:#ce5c00;font-weight:700>;</span>
  <span style=color:#ce5c00;font-weight:700>}</span>
  
  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>synchronized</span> <span style=color:#000>V</span> <span style=color:#000>compute</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>A</span> <span style=color:#000>arg</span><span style=color:#ce5c00;font-weight:700>)</span> 
    <span style=color:#204a87;font-weight:700>throws</span> <span style=color:#000>InterruptedEx</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#000>V</span> <span style=color:#000>result</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>cache</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>get</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>arg</span><span style=color:#ce5c00;font-weight:700>);</span>
    <span style=color:#204a87;font-weight:700>if</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>result</span> <span style=color:#ce5c00;font-weight:700>==</span> <span style=color:#204a87;font-weight:700>null</span><span style=color:#ce5c00;font-weight:700>){</span>
      <span style=color:#000>result</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>c</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>compute</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>arg</span><span style=color:#ce5c00;font-weight:700>);</span>
      <span style=color:#000>cache</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>put</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>arg</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>result</span><span style=color:#ce5c00;font-weight:700>);</span>
    <span style=color:#ce5c00;font-weight:700>}</span>
    <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>result</span><span style=color:#ce5c00;font-weight:700>;</span>
  <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>在程序清单 5-16 中的 Memorizer1 中给出了第一种尝试：使用 HashMap 来保存之前计算的结果。compute 方法首先将检查需要的结果是否已经在缓存中，如果存在则返回之前计算的结果。否则，将把计算结果缓存在 HashMap，然后再返回。</p>
<p>HashMap 不是线程安全的，因此要确保两个线程不会同时访问 HashMap，Memorizer1 采用了一种保守的方法，即对整个 compute 方法进行同步。这种方法能确保线程安全性，但会带来一种明显的可伸缩性问题：每次只有一个线程能够执行 compute。如果另一个线程正在计算结果，那么其他调用 conpute 的线程可能需要被阻塞很长一段时间。如果有多个线程在排队等待还未计算出的结果，那么 compute 方法的计算时间可能比没有记忆操作的计算时间更长。在图 5-2 中给出了当多个线程使用这种方法中的记忆操作时发生的情况，这显然不是我们希望通过缓存获得的性能提升结果。</p>
<div align=center>
<img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20181118172851.png style=display:block;width:70% alt=5-2 align=center>
</div>
<p>程序清单 5-17 中的 Memorizer2 用 ConcurrentHashMap 代替 HashMap 来改进 Memorizer1 中糟糕的并发行文。由于 ConcurrentHashMap 是线程安全的，因此在访问底层 Map 时就不需要进行同步，因而避免了在对 Memorizer1 中的 compute 方法进行同步时带来的串行性。</p>
<p>Memorizer2 比 Memorizer1 有着更好的并发行为：多线程可以并发的使用它。但它在作为缓存时仍然存在一些不足——当两个线程同时调用 compute 时存在一个漏洞，可能会导致计算得到相同的值。在使用 memorization 的情况下，这只会带来低效，因为缓存的作用是避免相同的数据被计算多次。但对于更通用的缓存机制来说，这种情况将更为糟糕。对于只提供单词初始化的对象缓存来说，这个漏洞就会带来安全风险。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>Memorizer2</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>A</span><span style=color:#ce5c00;font-weight:700>,</span><span style=color:#000>V</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#204a87;font-weight:700>implements</span> <span style=color:#000>Computable</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>A</span><span style=color:#ce5c00;font-weight:700>,</span><span style=color:#000>V</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#ce5c00;font-weight:700>{</span>
  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>Map</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>A</span><span style=color:#ce5c00;font-weight:700>,</span><span style=color:#000>V</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>cache</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>ConcurrentHashMap</span><span style=color:#ce5c00;font-weight:700>&lt;&gt;();</span>
  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>Computable</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>A</span><span style=color:#ce5c00;font-weight:700>,</span><span style=color:#000>V</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>c</span><span style=color:#ce5c00;font-weight:700>;</span>
  
  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#000>Memorizer2</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>Computable</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>A</span><span style=color:#ce5c00;font-weight:700>,</span><span style=color:#000>V</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>c</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#204a87;font-weight:700>this</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>c</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>c</span><span style=color:#ce5c00;font-weight:700>;</span>
  <span style=color:#ce5c00;font-weight:700>}</span>
  
  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#000>V</span> <span style=color:#000>compute</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>A</span> <span style=color:#000>arg</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#204a87;font-weight:700>throws</span> <span style=color:#000>InterrputedEx</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#000>V</span> <span style=color:#000>result</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>cache</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>get</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>arg</span><span style=color:#ce5c00;font-weight:700>);</span>
    <span style=color:#204a87;font-weight:700>if</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>result</span> <span style=color:#ce5c00;font-weight:700>==</span> <span style=color:#204a87;font-weight:700>null</span><span style=color:#ce5c00;font-weight:700>){</span>
      <span style=color:#000>result</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>c</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>compute</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>arg</span><span style=color:#ce5c00;font-weight:700>);</span>
      <span style=color:#000>cache</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>put</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>arg</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>result</span><span style=color:#ce5c00;font-weight:700>);</span>
    <span style=color:#ce5c00;font-weight:700>}</span>
    <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>result</span><span style=color:#ce5c00;font-weight:700>;</span>
  <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>Memorizer2 的问题在于，如果某个线程启动了一个开销很大的计算，而其他线程并不知道这个计算正在进行，那么很可能会重复计算，如图 5-3 所示。我们系统通过某种方法来表达“线程 X 正在计算 f(27)” 这种情况，这样当另一个线程查找 f(27) 时，它能够知道最高效的方法是等待线程 X 计算完成，然后再去查询缓存。</p>
<p>我们已经知道有一个类能够实现这个功能：FutureTask。FuturTask 表示一个计算的过程，该过程可能已经计算完成，也可能正在进行。如果有结果可用，那么 FutureTask.get 将立即返回结果，否则它会一直阻塞，直到结果结算出来再将其返回。</p>
<div align=center>
<img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20181118172910.png style=display:block;width:70% alt=5-3 align=center>
</div>
<p>程序清单 5-18 中的 Memorizer3 将用于缓存值的 Map 重新定义为 ConcurrentHashMap&lt;A, Future<v>>。Memorizer3 首先检查某个相应的机损是否已经开始(这与 Memorizer2 相反，它首先判断某个计算是否已经完成)。如果还没有启动，那么就创建一个 FutureTask，并注册到 Map 中，然后启动计算：如果已经启动，那么等待现有的计算结果。结果可能很快就会得到，也可能还在运算过程中，但这对于 FutureTask 的调用者阿狸说是透明的。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>Memorizer3</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>A</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>V</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#204a87;font-weight:700>implements</span> <span style=color:#000>Computable</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>A</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>V</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#ce5c00;font-weight:700>{</span> 	<span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>Map</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>A</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>Future</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>V</span><span style=color:#ce5c00;font-weight:700>&gt;&gt;</span> <span style=color:#000>cache</span> <span style=color:#ce5c00;font-weight:700>=</span> 
    <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>ConcurrentHashMap</span><span style=color:#ce5c00;font-weight:700>&lt;&gt;();</span>
  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>Computable</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>A</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>V</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>c</span><span style=color:#ce5c00;font-weight:700>;</span>

  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#000>Memorizer3</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>Computable</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>A</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>V</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>c</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span> <span style=color:#204a87;font-weight:700>this</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>c</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>c</span><span style=color:#ce5c00;font-weight:700>;</span> <span style=color:#ce5c00;font-weight:700>}</span>

  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#000>V</span> <span style=color:#000>compute</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>A</span> <span style=color:#000>arg</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#204a87;font-weight:700>throws</span> <span style=color:#000>InterruptedEx</span> <span style=color:#ce5c00;font-weight:700>{</span> 			<span style=color:#000>Future</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>V</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>f</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>cache</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>get</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>arg</span><span style=color:#ce5c00;font-weight:700>);</span> 
    <span style=color:#204a87;font-weight:700>if</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>f</span> <span style=color:#ce5c00;font-weight:700>==</span> <span style=color:#204a87;font-weight:700>null</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span> 
      <span style=color:#000>Callable</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>V</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>eval</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>Callable</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>V</span><span style=color:#ce5c00;font-weight:700>&gt;()</span> <span style=color:#ce5c00;font-weight:700>{</span> 
        <span style=color:#204a87;font-weight:700>public</span> <span style=color:#000>V</span> <span style=color:#000>call</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#204a87;font-weight:700>throws</span> <span style=color:#000>InterruptedException</span> <span style=color:#ce5c00;font-weight:700>{</span>
          <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>c</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>compute</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>arg</span><span style=color:#ce5c00;font-weight:700>);</span> 
        <span style=color:#ce5c00;font-weight:700>}</span> 
      <span style=color:#ce5c00;font-weight:700>};</span> 
      <span style=color:#000>FutureTask</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>V</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>ft</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>FutureTask</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>V</span><span style=color:#ce5c00;font-weight:700>&gt;(</span><span style=color:#000>eval</span><span style=color:#ce5c00;font-weight:700>);</span> 
      <span style=color:#000>f</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>ft</span><span style=color:#ce5c00;font-weight:700>;</span> 
      <span style=color:#000>cache</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>put</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>arg</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>ft</span><span style=color:#ce5c00;font-weight:700>);</span> 
      <span style=color:#000>ft</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>run</span><span style=color:#ce5c00;font-weight:700>();</span> <span style=color:#8f5902;font-style:italic>// call to c.compute happens here
</span><span style=color:#8f5902;font-style:italic></span>    <span style=color:#ce5c00;font-weight:700>}</span> 
    <span style=color:#204a87;font-weight:700>try</span> <span style=color:#ce5c00;font-weight:700>{</span>
      <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>f</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>get</span><span style=color:#ce5c00;font-weight:700>();</span> 
    <span style=color:#ce5c00;font-weight:700>}</span> <span style=color:#204a87;font-weight:700>catch</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>ExecutionException</span> <span style=color:#000>e</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
      <span style=color:#204a87;font-weight:700>throw</span> <span style=color:#000>launderThrowable</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>e</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>getCause</span><span style=color:#ce5c00;font-weight:700>());</span> 
    <span style=color:#ce5c00;font-weight:700>}</span>
  <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>Memorizer3 的实现几乎是完美的：它表现出了非常好的并发性(基本上是源自 ConcurrentHashMap 的并发性)，如果结果已经计算出来，那么将立即返回。如果其他线程正在计算该结果，那么新到的线程将一直等待这个结果被计算出来。它只有一个缺陷，即仍然存在两个线程计算出相同值的漏洞。该漏洞这时的发生概率要远小于 Memorizer2，但由于 conpute 方法中的 if 代码块仍然是非原子的“先检查再执行”操作，因此两个线程仍有可能在同一时间内调用 compute 来计算相同的值，即二者都没有在缓存中找到期望的值，因此都开始计算。这个错误的执行时序如图 5-4 所示：</p>
<div align=center>
<img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20181118172927.png style=display:block;width:70% alt=5-4 align=center>
</div>
<p>Memorizer3 中存在这个问题的原因是，符合操作是在底层的 Map 对象上执行的，而这个对象无法通过加锁来确保原子性。程序清单 5-19 中的 Memorizer 使用了 ConcurrentMap 中的原子方法 putIfAbsent，避免了 Memorizer3 的漏洞。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>Memorizer</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>A</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>V</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#204a87;font-weight:700>implements</span> <span style=color:#000>Computable</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>A</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>V</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#ce5c00;font-weight:700>{</span> 
  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>ConcurrentMap</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>A</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>Future</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>V</span><span style=color:#ce5c00;font-weight:700>&gt;&gt;</span> <span style=color:#000>cache</span> <span style=color:#ce5c00;font-weight:700>=</span> 
    <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>ConcurrentHashMap</span><span style=color:#ce5c00;font-weight:700>&lt;&gt;();</span> 
  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>Computable</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>A</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>V</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>c</span><span style=color:#ce5c00;font-weight:700>;</span>

  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#000>Memorizer</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>Computable</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>A</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>V</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>c</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span> <span style=color:#204a87;font-weight:700>this</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>c</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>c</span><span style=color:#ce5c00;font-weight:700>;</span> <span style=color:#ce5c00;font-weight:700>}</span>

  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#000>V</span> <span style=color:#000>compute</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>A</span> <span style=color:#000>arg</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#204a87;font-weight:700>throws</span> <span style=color:#000>InterruptedEx</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#204a87;font-weight:700>while</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>true</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span> 
      <span style=color:#000>Future</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>V</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>f</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>cache</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>get</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>arg</span><span style=color:#ce5c00;font-weight:700>);</span> 
      <span style=color:#204a87;font-weight:700>if</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>f</span> <span style=color:#ce5c00;font-weight:700>==</span> <span style=color:#204a87;font-weight:700>null</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span> 
        <span style=color:#000>Callable</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>V</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>eval</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>Callable</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>V</span><span style=color:#ce5c00;font-weight:700>&gt;()</span> <span style=color:#ce5c00;font-weight:700>{</span> 
          <span style=color:#204a87;font-weight:700>public</span> <span style=color:#000>V</span> <span style=color:#000>call</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#204a87;font-weight:700>throws</span> <span style=color:#000>InterruptedEx</span> <span style=color:#ce5c00;font-weight:700>{</span> 
            <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>c</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>compute</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>arg</span><span style=color:#ce5c00;font-weight:700>);</span> 
          <span style=color:#ce5c00;font-weight:700>}};</span> 
        <span style=color:#000>FutureTask</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>V</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>ft</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>FutureTask</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>V</span><span style=color:#ce5c00;font-weight:700>&gt;(</span><span style=color:#000>eval</span><span style=color:#ce5c00;font-weight:700>);</span> 
        <span style=color:#000>f</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>cache</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>putIfAbsent</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>arg</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>ft</span><span style=color:#ce5c00;font-weight:700>);</span> 
        <span style=color:#204a87;font-weight:700>if</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>f</span> <span style=color:#ce5c00;font-weight:700>==</span> <span style=color:#204a87;font-weight:700>null</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span> 
          <span style=color:#000>f</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>ft</span><span style=color:#ce5c00;font-weight:700>;</span> <span style=color:#000>ft</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>run</span><span style=color:#ce5c00;font-weight:700>();</span> 
        <span style=color:#ce5c00;font-weight:700>}</span> 
      <span style=color:#ce5c00;font-weight:700>}</span> 
      <span style=color:#204a87;font-weight:700>try</span> <span style=color:#ce5c00;font-weight:700>{</span> <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>f</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>get</span><span style=color:#ce5c00;font-weight:700>();</span> <span style=color:#ce5c00;font-weight:700>}</span> 
      <span style=color:#204a87;font-weight:700>catch</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>CancellationException</span> <span style=color:#000>e</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span> 
        <span style=color:#000>cache</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>remove</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>arg</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>f</span><span style=color:#ce5c00;font-weight:700>);</span> 
      <span style=color:#ce5c00;font-weight:700>}</span> <span style=color:#204a87;font-weight:700>catch</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>ExecutionException</span> <span style=color:#000>e</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span> 
        <span style=color:#204a87;font-weight:700>throw</span> <span style=color:#000>launderThrowable</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>e</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>getCause</span><span style=color:#ce5c00;font-weight:700>());</span> 
      <span style=color:#ce5c00;font-weight:700>}</span>
    <span style=color:#ce5c00;font-weight:700>}</span>
  <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>当缓存的是 Future 而不是值时，将导致缓存污染问题：如果某个计算被取消或失败，那么在计算这个结果时将指明计算过程被取消或失败。为了避免这种情况，如果 Memorizer 发现计算被取消，那么将把 Future 从缓存中删除。如果检测到 RuntimeException，那么也会移除 Future，这样将来的计算结果才能成功。Memorizer 同样没有解决缓存逾期的问题，但它可以通过使用 FutureTask 子类来解决，在子类中为每个结果指定一个预期时间，并定期扫描缓存中逾期的元素。(同样，它没有解决缓存清理的问题，即移除旧的计算结果以便为新的计算腾出空间，从而避免缓存效果过多的内存)。</p>
<p>在完成并发缓存的实现后，就可以为第二章中因式分解 servlet 添加结果缓存。程序清单 5-20 中的 Factorizer 使用 Memorizer 来缓存之前计算的结果，这种方式不仅高效，而且扩展性也高。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#5c35cc;font-weight:700>@ThreadSafe</span> <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>Factorizer</span> <span style=color:#204a87;font-weight:700>implements</span> <span style=color:#000>Servlet</span> <span style=color:#ce5c00;font-weight:700>{</span>
  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>Computable</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>BigInteger</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>BigInteger</span><span style=color:#ce5c00;font-weight:700>[]&gt;</span> <span style=color:#000>c</span> <span style=color:#ce5c00;font-weight:700>=</span> 
    <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>Computable</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>BigInteger</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>BigInteger</span><span style=color:#ce5c00;font-weight:700>[]&gt;()</span> <span style=color:#ce5c00;font-weight:700>{</span> 
      <span style=color:#204a87;font-weight:700>public</span> <span style=color:#000>BigInteger</span><span style=color:#ce5c00;font-weight:700>[]</span> <span style=color:#000>compute</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>BigInteger</span> <span style=color:#000>arg</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span> 
        <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>factor</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>arg</span><span style=color:#ce5c00;font-weight:700>);</span> 
      <span style=color:#ce5c00;font-weight:700>}</span> 
    <span style=color:#ce5c00;font-weight:700>};</span> 
  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>Computable</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>BigInteger</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>BigInteger</span><span style=color:#ce5c00;font-weight:700>[]&gt;</span> <span style=color:#000>cache</span> <span style=color:#ce5c00;font-weight:700>=</span> 
    <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>Memorizer</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>BigInteger</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>BigInteger</span><span style=color:#ce5c00;font-weight:700>[]&gt;(</span><span style=color:#000>c</span><span style=color:#ce5c00;font-weight:700>);</span>

  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>service</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>ServletRequest</span> <span style=color:#000>req</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>ServletResponse</span> <span style=color:#000>resp</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span> 
    <span style=color:#204a87;font-weight:700>try</span> <span style=color:#ce5c00;font-weight:700>{</span> 
      <span style=color:#000>BigInteger</span> <span style=color:#000>i</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>extractFromRequest</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>req</span><span style=color:#ce5c00;font-weight:700>);</span> 
      <span style=color:#000>encodeIntoResponse</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>resp</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>cache</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>compute</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>i</span><span style=color:#ce5c00;font-weight:700>));</span> 
    <span style=color:#ce5c00;font-weight:700>}</span> <span style=color:#204a87;font-weight:700>catch</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>InterruptedException</span> <span style=color:#000>e</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span> 
      <span style=color:#000>encodeError</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>resp</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#4e9a06>&#34;factorization interrupted&#34;</span><span style=color:#ce5c00;font-weight:700>);</span> 
    <span style=color:#ce5c00;font-weight:700>}</span> 
  <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><h2 id=第一部分小节>第一部分小节</h2>
<ul>
<li>可变状态是至关重要的。所有的并发问题都可以归结为如何协调对并发状态的访问。可变状态越少，就越容易确保线程安全。</li>
<li>尽量将域声明为 final 类型，除非需要它们是可变的。</li>
<li>不可变对象一定是线程安全的。不可变对象能极大的降低并发编程的复杂性。它们更为简单且安全，可以任意共享而无需使用加锁或保护性复制等机制。</li>
<li>封装有助于管理复杂性。在编写线程安全的程序时，虽然可以将所有数据都保存在全局变量中，但为什么还要封装？将数据封装在对象中，更易于维持不变性条件：将同步机制封装在对象中，更易于遵循同步策略。</li>
<li>用锁来保护每个可变变量。</li>
<li>当保护一个不变形条件中的所有变量时，要使用同一个锁。</li>
<li>在执行符合操作期间，要持有锁。</li>
<li>如果从多个线程中访问同一个可变变量时没有同步机制，那么程序会出错。</li>
<li>不要故作聪明的推断出不需要使用同步。</li>
<li>在设计过程中考虑线程安全，或者在文档中明确指出是否是线程安全的。</li>
<li>将同步策略文档化。</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-229d8c951e541a78268751629a09c23c>6 - CH06-任务执行</h1>
<p>大多数并发应用都是围绕“任务执行”来构造的：任务通常是一些抽象的离散的工作单元。通过把应用程序的工作分解到多个任务中，可以简化程序的组织结构，提供一种自然的事务边界来优化错误恢复过程，以及提供一种自然的并行工作结构来提升并发性。</p>
<h2 id=61-在线程中执行任务>6.1 在线程中执行任务</h2>
<p>当围绕“任务执行”来设计应用程序结构时，第一步就是要找出清晰的任务边界。在理想情况下，各个任务之间是相互独立的：任务并不依赖于其他任务的状态、结果或边界效应。独立性有助于实现并发，因为如果存在足够多的处理资源，那么这些独立的任务都可以并行执行。为了在调度与负载均衡过程中实现更高的灵活性，每项任务还应该表示应用程序的一部分处理能力。</p>
<p>在正常的负载下，服务器应用程序应该同时表现出良好的吞吐量和快速的响应性。应用程序提供商希望程序支持尽可能多的用户，从而降低每用户的服务成本，而用户则希望获得尽快的响应。而且，当符合过载时，应用程序的性能应该是逐渐降低，而不是直接失败。要实现上述目标，应该选择清晰的任务边界以及明确的任务执行策略。</p>
<p>大多数服务器应用程序都提供了一种自然的任务边界选择方式：以独立的客户请求为边界。Web 服务器、邮件服务器、文件服务器、EJB 容器以及数据库服务器等，这些服务器都能通过网络接受远程客户的连接请求。将独立的请求作为任务边界，既可以实现任务的独立性，又可以实现合理的任务规模。例如，在向邮件服务器提交一个消息得到的结果，并不会受其他正在处理的消息的影响，而在处理消息时通常只需要服务器总处理能力的很小一部分。</p>
<h3 id=611-串行的执行任务>6.1.1 串行的执行任务</h3>
<p>在应用程序中可以通过多种策略来调度任务，而其中一些策略能够更好的利用潜在的并发性。最简单的策略就是在单个线程中串行执行各项任务。程序清单 6-1 中的 SingleThreadWebServer 将串行的处理它的任务。至于如何处理请求的细节问题，在这里并不重要，我们感兴趣的是如何表征不同调度策略的同步特性。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>SingleThreadWebServer</span> <span style=color:#ce5c00;font-weight:700>{</span>
  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>static</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>main</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>String</span><span style=color:#ce5c00;font-weight:700>...</span><span style=color:#c4a000>args</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#204a87;font-weight:700>throws</span> <span style=color:#000>IOEx</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#000>ServerSocket</span> <span style=color:#000>socket</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>ServerSocket</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>80</span><span style=color:#ce5c00;font-weight:700>);</span>
    <span style=color:#204a87;font-weight:700>while</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>true</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
      <span style=color:#000>Socket</span> <span style=color:#000>connection</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>socket</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>accept</span><span style=color:#ce5c00;font-weight:700>();</span>
      <span style=color:#000>handleRequest</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>connection</span><span style=color:#ce5c00;font-weight:700>);</span>
    <span style=color:#ce5c00;font-weight:700>}</span>
  <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>SingleThreadWebServer 很简单，且在理论上是正确的，但在实际生产环境中的执行性能却很糟糕，因为它每次只能处理一个请求。主线程在接受与处理请求等操作之间不断的交替运行。当服务器正在处理请求时，新到来的连接必须等待直到请求处理完成，然后服务器将再次调用 accept。如果处理请求的速度很快并且 handleRequest 可以立即返回，那么这种方法是可行的，但现实世界中的 Web 服务器的情况却并非如此。</p>
<p>在 Web 请求的处理中包含了一组不同的运算与 IO 操作。服务器必须处理套接字 IO 以读取请求和写回响应，这些操作通常会由于网络拥堵或连通性问题而被阻塞。此外，服务器还可能处理文件 IO 或数据库请求，这些操作同样会阻塞。在单线程的服务器中，阻塞不仅会推迟当前请求的完成时间，而且还将彻底阻止等待中的请求被处理。如果请求阻塞的时间过长，用户将任务服务器是不可用的，因为服务器看似失去了响应。同时，服务器的资源利用率却非常低，因为当单线程在等待 IO 操作完成时，CPU 将处于空闲状态。</p>
<p>在服务器应用程序中，串行处理机制通常无法提供高吞吐率或快速响应性。也有一些例外，例如，当任务数量很少且执行时间很长时，或者当服务器只需要单个用户提供服务，并且该用户每次只发出一个请求——但大多数服务器应用程序并不是按照这种方式工作的。</p>
<h3 id=612-显式的为任务创建线程>6.1.2 显式的为任务创建线程</h3>
<p>通过为每个请求创建一个新的线程来提供服务，从而实现更好的响应性，如程序清单 6-2 中的 ThreadPerTaskWebServer 所示。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>ThreadPerTaskWebServer</span> <span style=color:#ce5c00;font-weight:700>{</span>
  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>static</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>main</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>String</span><span style=color:#ce5c00;font-weight:700>...</span><span style=color:#c4a000>args</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#000>ServerSocket</span> <span style=color:#000>socket</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>ServerSocket</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>80</span><span style=color:#ce5c00;font-weight:700>);</span>
    <span style=color:#204a87;font-weight:700>while</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>true</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
      <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>Socket</span> <span style=color:#000>connection</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>socket</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>accept</span><span style=color:#ce5c00;font-weight:700>();</span>
      <span style=color:#000>Runnable</span> <span style=color:#000>task</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>Runnable</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span>
        <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>run</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span>
          <span style=color:#000>handleRequest</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>connection</span><span style=color:#ce5c00;font-weight:700>);</span>
        <span style=color:#ce5c00;font-weight:700>}</span>
      <span style=color:#ce5c00;font-weight:700>};</span>
      <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>Thread</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>task</span><span style=color:#ce5c00;font-weight:700>).</span><span style=color:#c4a000>start</span><span style=color:#ce5c00;font-weight:700>();</span>
    <span style=color:#ce5c00;font-weight:700>}</span>
  <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>ThreadPerTaskWebServer 在架构上类似于前面的单线程版本——主线程仍然不断的交替执行“接受外部连接”与“分发请求”等操作。区别在于，对于每个连接，主循环都将创建一个新线程来处理请求，而不是在主循环中进行处理。由此可以得出 3 个主要结论：</p>
<ul>
<li>任务处理过程从主线程中分离出来，使得主循环能够更快的重新等待下一个到来的连接。这使得程序在完成前面的请求之前可以接受更多的请求，从而提高响应性。</li>
<li>任务可以并行处理，从而能同时服务多个请求。如果有多个服务器，或者任务由于某种原因被阻塞，例如等待 IO 完成、获取锁或资源可用性等，程序的吞吐量将得到提升。</li>
<li>任务处理代码必须是线程安全的，因为会有多个任务并发的调用这段代码。</li>
</ul>
<p>在正常负载情况下，“为每个任务分配一个线程”的方法能提升串行执行的性能。只要请求的到达率不超出服务器的请求处理能力，那么这种方法可以同时带来更快的响应性和更高的吞吐率。</p>
<h3 id=613-无限制创建线程的不足>6.1.3 无限制创建线程的不足</h3>
<p>在生产环境中，“为每个任务分配一个线程”这种方法是存在缺陷的，尤其是当需要创建大量线程时。</p>
<p><strong>线程生命周期的开销很高。</strong> 线程的创建与销毁并不是没有代价的。根据平台的不同，实际的开销也会有所不同，但线程的创建过程都需要时间，延迟处理的请求，并且需要 JVM 和操作系统提供一些辅助操作。如果请求的到达率非常高且处理过程是轻量级的，例如大多数服务器应用程序就是这种情况，那么为么个请求创建一个新的线程将消耗大量计算资源。</p>
<p><strong>资源消耗。</strong> 活跃的线程会消耗系统资源，尤其是内存。如果可运行的线程数量对于可用处理器的数量，那么有些线程将闲置。大量空闲的线程会占用许多内存，给垃圾回收器带来压力，而且大量线程在竞争 CPU 资源时还将产生其他的性能开销。如果你已经拥有足够多的线程使所有 CPU 保持忙碌状态，那么再创建更多的线程反而会降低性能。</p>
<p><strong>稳定性。</strong> 在可创建线程的数量上存在一个限制。这个限制值将随平台的不同而变化，并且受多个因素影响，包括 JVM 的启动参数、Thread 构造函数中请求的栈大小，以及底层操作系统对线程的限制等。如果破坏了这些限制，那么很可能抛出 OOM 异常，要想从这种错误中恢复过来是非常危险的，更简单的办法设是通过构造程序来避免超出这些限制。</p>
<p>在一定的范围内，增加线程可以提高系统的吞吐率，但如果超出了这个范围，再创建更多的线程只会降低程序的执行速度，并且如果过多的创建一个线程，那么整个应用程序将会崩溃。要想避免这种危险，就应该对应用程序可以创建的线程数量进行限制，并且全面的测试应用程序，从而确保在线程数量到达限制时，程序也不会耗尽资源。</p>
<p>“为每个任务分配一个线程”这种方法的问题在于，他没有限制可创建线程的数量，只限制了远程用户提交 HTTP 请求的速率。与其他的并发危险一样，在原型设计和开发阶段，无限制的创建线程或许还能较好的运行，但在应用程序部署后并处于高负载运行时，才会有问题不断的暴露出来。因此，某个恶意的用户或过多的用户，都会使 Web 服务器的负载达到某个阈值，从而使服务器崩溃。如果服务器需要提供高可用性，并且在高负载情况下能平缓的降低性能，那么这将是一个严重的故障。</p>
<h2 id=62-executor-框架>6.2 Executor 框架</h2>
<p>任务是一组逻辑工作单元，而线程则是使任务异步执行的机制。我们已经分析了两种通过线程来执行任务的策略，即把所有任务都放在单个线程中串行执行，以及将每个任务放在各自的线程中执行。这两种方式都存在一些严格的限制：串行执行的问题在于其糟糕的响应性和吞吐量，而“为每个任务分配一个线程”的问题在于资源管理的复杂性。</p>
<p>在第 5 章，我们介绍了如何通过有界队列来防止高负载的应用程序耗尽内存。线程池简化了线程的管理工作，并且 JUC 提供了一种灵活的线程池实现作为 Executor 框架的一部分。在 Java 类库中，任务执行的只要抽闲不是 Thread，而是 Executor，如程序清单 6-3 所示。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>interface</span> <span style=color:#000>Executor</span> <span style=color:#ce5c00;font-weight:700>{</span>
  <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>execute</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>Runnable</span> <span style=color:#000>command</span><span style=color:#ce5c00;font-weight:700>);</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>虽然 Executor 是一个简单的接口，但它却为灵活且强大的异步任务执行框架提供了基础，该框架能支持多种不同类型的任务执行策略。它提供了一种标准的方法将任务的提交过程与执行过程解耦开来，并且用 Runnable 来表示任务。Executor 的实现还提供了对生命周期的支持，以及统计信息收集、应用程序管理机制和性能监视器等机制。</p>
<p>Executor 基于生产者——消费者模式，提交的操作相当于生产者(生成待完成的工作单元)，执行任务的线程则相当于消费者(执行完这些工作单元)。如果要在程序中实现一个生产消费设计，那么最简单的方式通常就是使用 Executor。</p>
<h3 id=621-示例基于-executor-的-web-服务器>6.2.1 示例：基于 Executor 的 Web 服务器</h3>
<p>基于 Executor 来构建 Web 服务器是非常容易的。在程序清单 6-4 中用 Executor 代替了硬编码的线程创建过程。在这种情况下使用了一种标准的 Executor 实现，即一个固定长度的线程池，可以容纳 100 个线程。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>TaskExecutionWebServer</span> <span style=color:#ce5c00;font-weight:700>{</span>
  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>static</span> <span style=color:#204a87;font-weight:700>final</span> <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>NTHREADS</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>100</span><span style=color:#ce5c00;font-weight:700>;</span>
  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>static</span> <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>Executor</span> <span style=color:#000>exec</span> <span style=color:#ce5c00;font-weight:700>=</span> 
    <span style=color:#000>Executor</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>newFixedThreadPool</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>NTHREADS</span><span style=color:#ce5c00;font-weight:700>);</span>
  
  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>static</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>main</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>String</span><span style=color:#ce5c00;font-weight:700>..</span><span style=color:#c4a000>args</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#204a87;font-weight:700>throws</span> <span style=color:#000>IOEx</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#000>ServerSocket</span> <span style=color:#000>socket</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>ServerSocket</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>80</span><span style=color:#ce5c00;font-weight:700>);</span>
    <span style=color:#204a87;font-weight:700>while</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>true</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
      <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>Socket</span> <span style=color:#000>connection</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>socket</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>accept</span><span style=color:#ce5c00;font-weight:700>();</span>
      <span style=color:#000>Runnable</span> <span style=color:#000>task</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>Runnable</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span>
        <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>run</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span>
          <span style=color:#000>handleRequest</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>connection</span><span style=color:#ce5c00;font-weight:700>);</span>
        <span style=color:#ce5c00;font-weight:700>}</span>
      <span style=color:#ce5c00;font-weight:700>};</span>
      <span style=color:#000>exec</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>execute</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>task</span><span style=color:#ce5c00;font-weight:700>);</span>
    <span style=color:#ce5c00;font-weight:700>}</span>
  <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>在 TaskExecutionWebServer 中，通过使用 Executor，将请求处理任务的提交与任务的实际执行解耦开来，并且只需要采用另一种不同的 Executor 实现，就可以改变服务器的行为。改变 Executor 实现或配置所带来的影响要远远小于改变任务提交方式带来的影响。通常，Executor 的配置是一次性的，因此在部署阶段可以完成，而提交任务的代码却会不断的扩散到整个程序中，增加了修改的难度。</p>
<p>我们可以很容易的将 TaskExecutionWebServer 修改为类似 ThreadPerTaskWebServer 的行为，只需要使用一个为每个请求创建新线程的 Executor。编写这样的 Executor 很简单，如程序清单 6-5 中的 ThreadPerTaskExecutor 所示。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>ThreadPerTaskExecutor</span> <span style=color:#204a87;font-weight:700>implements</span> <span style=color:#000>Executor</span> <span style=color:#ce5c00;font-weight:700>{</span>
  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>execute</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>Runnable</span> <span style=color:#000>r</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>Thread</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>r</span><span style=color:#ce5c00;font-weight:700>).</span><span style=color:#c4a000>start</span><span style=color:#ce5c00;font-weight:700>();</span>
  <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>同样，还可以编写一个 Executor 使 TaskExecutionWebServer 的行为类似于单线程的行为，即以同步的方式执行每个任务，然后再返回，如程序清单 6-6 中的 WithinThreadExecutor 所示。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>WithinThreadExecutor</span> <span style=color:#204a87;font-weight:700>implements</span> <span style=color:#000>Executor</span> <span style=color:#ce5c00;font-weight:700>{</span>
  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>execute</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>Runnable</span> <span style=color:#000>r</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#000>r</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>run</span><span style=color:#ce5c00;font-weight:700>();</span>
  <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><h3 id=622-执行策略>6.2.2 执行策略</h3>
<p>通过将任务的提交与执行解耦出来，从而无需太大的困难就可以为某种类型的任务指定或修改执行策略。在执行策略中定义了任务执行的 What、Where、When、How 等方面，包括：</p>
<ul>
<li>在什么(What)线程中执行任务？</li>
<li>任务按照什么(What)属性怒执行(FIFO/LIFO/优先级)？</li>
<li>有多少个(How many)任务并发执行？</li>
<li>在队列中有多少个(How many)任务在等待执行？</li>
<li>如果系统由于过载而需要拒绝一个任务，那么应该选择拒绝哪个任务？另外，如何通知应用程序有任务被拒绝？</li>
<li>在执行一个任务之前或之后，应该进行哪些动作？</li>
</ul>
<p>各种执行策略都是一种资源管理工具，最佳策略取决于可用的计算资源以及对服务质量的需求。通过限制并发任务的数量，可以确保应用程序不会由资源耗尽而失败，或者由于在稀缺资源上发生竞争而严重影响性能。通过将任务的提交与任务的执行策略分离开来，有助于在部署阶段选择与硬件资源匹配的执行策略。</p>
<h3 id=623-线程池>6.2.3 线程池</h3>
<p>线程池，从字面含义来看，是指管理一组同构工作线程的资源池。线程池是与工作队列密切相关的，其中在工作队列保存了所有了所有等待执行的任务。工作者线程的任务很简单：从工作队列中取出一个任务，执行任务，然后返回线程池并等待下一个任务。</p>
<p>“在线程池中执行任务”比“没每个任务分配一个线程”优势更多。通过重用现有的线程而不是创建新线程，可以在处理多个请求时分摊在线程创建和销毁过程中产生的巨大开销。另一个额外的好处是，当请求到达时，工作线程通常已经存在，因此不会犹豫等待创建线程而延迟任务的执行，从而提高了响应性。通过适当调整线程池的大小，可以创建足够的线程以便使处理器保持忙碌状态，同时还可以防止过多线程互相竞争资源而使应用程序耗尽内存或失败。</p>
<p>类库提供了一个灵活的线程池以及一些有用的默认配置。可以通过调用 Executors 中的静态工厂方法之一来创建线程池实例：</p>
<p><strong>newFixedThreadPool</strong> 将创建一个固定长度的线程池，每当提交一个任务时就创建一个线程，直到达到线程池的最大数量，这时线程池的规模将不再变化(如果某个线程由于发生了未预期的异常而结束，那么线程池将会补充一个新的线程)。</p>
<p><strong>newCachedThreadPool</strong> 将创建一个可缓存的线程池，如果线程池的当前规模超过了处理需求时，那么将回收空闲的线程，而当需求增加时，则可以添加新的线程，线程池的规模不存在任何限制。</p>
<p><strong>newSingleThreadExecutor</strong> 是一个单线程的 Executor，它创建单个工作者线程来执行任务，如果这个线程异常结束，会创建另一个线程来替代。它能确保任务在队列中的顺序来串行执行(如 FIFO/LIFO/优先级)。</p>
<p><strong>newScheduledThreadPool</strong> 创建一个固定长度的线程池，而且以延迟或定时的方式来执行任务，类似于 Timer。</p>
<p><strong>newFixedThreadPool/newCachedThreadPool</strong> 这两个工厂方法返回通用的 ThreadPoolExecutor 实例，这些实例可以直接用来构造专门用途的 executor。我们将在第八章深入讨论线程池的各个配置项。</p>
<p>TaskExecutionWebServer 中的 Web 服务器使用了一个带有有界线程池的 Executor。通过 execute 方法将任务提交到工作队列中，工作线程反复的从工作队列中取出任务并执行它们。</p>
<p>从“为每任务分配一个线程”策略变成基于线程池的策略，将对应用程序的稳定性产生重大的影响：Web 服务器不会再在高负载情况下失败。由于服务器不会创建数千个线程来争夺有限的 CPU 和内存资源，因此服务器的性能将平缓的降低。通过使用 Executor，可以实现各种调优、管理、监视、记录日志、错误报告和其他功能，如果不使用任务执行框架，那么要增加这些功能是非常困难的。</p>
<h3 id=624-executor-的生命周期>6.2.4 Executor 的生命周期</h3>
<p>我们已经知道如何创建一个 Executor，但并没有讨论如何关闭它。Executor 的实现通常会创建线程来执行任务。但 JVM 只有在所有(非守护)线程全部终止后才会退出。因此，如果无法正确的关闭 Executor，那么 JVM 将无法结束。</p>
<p>由于 Executor 以异步方式来执行任务，因此在任何时刻，之前提交任务的状态不是立即可见的。有些任务可能已经完成，有些可能正在运行，而其他的任务可能在队列中等待执行。当关闭应用程序时，可能采用最平缓的关闭方式(完成所有已启动的任务，并且不再接受任何新的任务)，也可能采用最粗暴的关闭方式(直接关闭机房的电源)，以及其他各种可能的形式。既然 Executor 是为应用程序提供服务的，因而它们也是可关闭的(无论采用平缓或粗暴的方式)，并将在关闭操作中受影响的任务的状态反馈给应用程序。</p>
<p>为了解决执行服务的生命周期问题，Executor 扩展了 ExecutorService 接口，添加了一些用于生命周期管理的方法(同时还有一些用于任务提交的便利方法)。在程序清单 6-7 中给出了 ExecutorService 中的生命周期管理方法。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>interface</span> <span style=color:#000>ExecutorService</span> <span style=color:#204a87;font-weight:700>extends</span> <span style=color:#000>Executor</span> <span style=color:#ce5c00;font-weight:700>{</span>
  <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>shutdown</span><span style=color:#ce5c00;font-weight:700>();</span>
  <span style=color:#000>List</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>Runnable</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>shutdownNow</span><span style=color:#ce5c00;font-weight:700>();</span>
  <span style=color:#204a87;font-weight:700>boolean</span> <span style=color:#000>isShutdown</span><span style=color:#ce5c00;font-weight:700>();</span>
  <span style=color:#204a87;font-weight:700>boolean</span> <span style=color:#000>isTerminated</span><span style=color:#ce5c00;font-weight:700>();</span>
  <span style=color:#204a87;font-weight:700>boolean</span> <span style=color:#000>awaitTermination</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>long</span> <span style=color:#000>timeout</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>TimeUnit</span> <span style=color:#000>unit</span><span style=color:#ce5c00;font-weight:700>)</span>
    <span style=color:#000>thorws</span> <span style=color:#000>InterruptedException</span>
  <span style=color:#8f5902;font-style:italic>// 其他用于任务提交的便利方法...
</span><span style=color:#8f5902;font-style:italic></span><span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>ExecutorService 的生命周期有三种状态：运行、关闭、已终止。ExecutorService 在初始化创建时处于运行状态。shutdown 方法将执行平缓的关闭过程：不再接受新任务，同时等待已经提交的任务执行完成——包括那些还未开始执行的任务。shutdownNow 方法将执行粗暴的关闭过程：它将尝试取消所有运行中的任务，并且不再启动队列中尚未开始执行的任务。</p>
<p>在 ExecutorService 关闭后提交的任务将由“拒绝执行处理器”来处理，它会抛弃任务，或者使得 execute 方法抛出一个未检的 RejectedExecutionException。等所有任务都完成后，ExecutorService 将转入终止状态。可以调用 awaitTermination 来等待 ExecutorService 到达终止状态，或者通过调用 isTerminated 来轮询 ExecutorService 是否已经终止。通常在调用 awaitTermination 之后会立即调用 shutdown，从而产生同步的关闭 ExecutorService 的效果。(第七章将进一步介绍 Executor 的关闭和任务取消等方面的内容)</p>
<p>程序清单 6-8 的 LifecycleWebServer 通过增加生命周期支持来扩展 Web 服务器的功能。可以通过两种方法来关闭 Web 服务器：在程序中调用 stop，或者以客户端请求的形式向 Web 服务器发送一个特定格式的 HTTP 请求。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>LifecycleWebServer</span> <span style=color:#ce5c00;font-weight:700>{</span>
  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>ExecutorService</span> <span style=color:#000>exec</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#ce5c00;font-weight:700>...;</span>
  
  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>start</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#204a87;font-weight:700>throws</span> <span style=color:#000>IOException</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#000>ServerSocker</span> <span style=color:#000>socket</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>ServerSocket</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>80</span><span style=color:#ce5c00;font-weight:700>);</span>
    <span style=color:#204a87;font-weight:700>while</span><span style=color:#ce5c00;font-weight:700>(!</span><span style=color:#000>exec</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>isShutdown</span><span style=color:#ce5c00;font-weight:700>())</span> <span style=color:#ce5c00;font-weight:700>{</span>
      <span style=color:#204a87;font-weight:700>try</span> <span style=color:#ce5c00;font-weight:700>{</span>
        <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>Socket</span> <span style=color:#000>conn</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>socket</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>accept</span><span style=color:#ce5c00;font-weight:700>();</span>
        <span style=color:#000>exec</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>execute</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>Runnable</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span>
          <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>run</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span>
            <span style=color:#000>handleRequest</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>conn</span><span style=color:#ce5c00;font-weight:700>);</span>
          <span style=color:#ce5c00;font-weight:700>}</span>
        <span style=color:#ce5c00;font-weight:700>});</span>
      <span style=color:#ce5c00;font-weight:700>}</span> <span style=color:#204a87;font-weight:700>catch</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>RejectedExecutionException</span> <span style=color:#000>e</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
        <span style=color:#204a87;font-weight:700>if</span><span style=color:#ce5c00;font-weight:700>(!</span><span style=color:#000>exec</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>isShutdown</span><span style=color:#ce5c00;font-weight:700>())</span>
          <span style=color:#000>log</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#4e9a06>&#34;task submission rejected&#34;</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>e</span><span style=color:#ce5c00;font-weight:700>);</span>
      <span style=color:#ce5c00;font-weight:700>}</span>
    <span style=color:#ce5c00;font-weight:700>}</span>
  <span style=color:#ce5c00;font-weight:700>}</span>
  
  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>stop</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#000>exec</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>shutdown</span><span style=color:#ce5c00;font-weight:700>();</span>
  <span style=color:#ce5c00;font-weight:700>}</span>
  
  <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>handleRequest</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>Socket</span> <span style=color:#000>conn</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#000>Request</span> <span style=color:#000>req</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>readRequest</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>conn</span><span style=color:#ce5c00;font-weight:700>);</span>
    <span style=color:#204a87;font-weight:700>if</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>isShutdownRequest</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>req</span><span style=color:#ce5c00;font-weight:700>))</span>
      <span style=color:#000>stop</span><span style=color:#ce5c00;font-weight:700>();</span>
    <span style=color:#204a87;font-weight:700>else</span>
      <span style=color:#000>dispatchRequest</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>req</span><span style=color:#ce5c00;font-weight:700>);</span>
  <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><h3 id=625-延时任务与周期性任务>6.2.5 延时任务与周期性任务</h3>
<p>Timer 类负责管理延迟任务以及周期性任务。然而，Timer 存在一些缺陷，因此应该考虑使用 ScheduledThreadPoolExecutor 来代替它。可以通过 ScheduledThreadPoolExecutor 的构造函数或 newScheduledThreadPool 工厂方法来创建类的对象。</p>
<p>Timer 在执行所有定时任务时只会创建一个线程。如果某个任务的执行实现过长，那么将破坏其他 TimerTask 的定时精确性。例如某个周期 TimerTask 需要每 10ms 执行一次，而另一个 TimerTask 需要执行 40ms，那么这个周期性任务或者在 40ms 任务执行完成后快速连续的调用 4 次，或者彻底丢失 4 次调用(取决于它是基于固定速率来调度还是基于固定延时来调度)。线程池能弥补这个缺陷，它可以提供多个线程来执行延时任务和周期任务。</p>
<p>Timer 的另一个问题是，如果 TimerTask 抛出一个未检异常，那么 Timer 将表现出糟糕的行为。Timer 线程并不捕获异常，因此当 TimerTask 抛出未检异常时将终止定时线程。这种情况下，Timer 也不会恢复线程的执行，而是会错误的任务整个 Timer 被取消了。因此，已经被调度但尚未执行的 TimerTask 将不会再执行，新的任务也不能被调度。该问题被称为线程泄露，7.3 将介绍如何避免该问题。</p>
<p>在程序清单 6-9 的 OutOfTime 中给出了 Timer 中为什么会出现这种问题，以及如何使得视图提交 TimerTask 的调用者出现问题。你可能任务程序会运行 6 秒后退出，但实际情况是运行 1 秒就结束了，并抛出了一个异常消息“Timer already cancelled”。ScheduledThreadPoolExecutor 能正确处理这些表现出错误行为的任务。在 Java 5.0 或更高的 JDK 中，将减少使用 Timer。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>OutOfTime</span> <span style=color:#ce5c00;font-weight:700>{</span>
  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>static</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>main</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>String</span><span style=color:#ce5c00;font-weight:700>...</span><span style=color:#c4a000>args</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#204a87;font-weight:700>throws</span> <span style=color:#000>Exception</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#000>Timer</span> <span style=color:#000>timer</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>Timer</span><span style=color:#ce5c00;font-weight:700>();</span>
    <span style=color:#000>timer</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>schedule</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>ThrowTask</span><span style=color:#ce5c00;font-weight:700>(),</span> <span style=color:#000>1</span><span style=color:#ce5c00;font-weight:700>);</span>
    <span style=color:#000>SECONDS</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>sleep</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>1</span><span style=color:#ce5c00;font-weight:700>);</span>
    <span style=color:#000>timer</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>schedule</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>ThrowTask</span><span style=color:#ce5c00;font-weight:700>(),</span> <span style=color:#000>1</span><span style=color:#ce5c00;font-weight:700>);</span>
    <span style=color:#000>SECONDS</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>sleep</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>5</span><span style=color:#ce5c00;font-weight:700>);</span>
  <span style=color:#ce5c00;font-weight:700>}</span>
  
  <span style=color:#204a87;font-weight:700>static</span> <span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>ThrowTask</span> <span style=color:#204a87;font-weight:700>extends</span> <span style=color:#000>TimerTask</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>run</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span>
      <span style=color:#204a87;font-weight:700>throw</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>RuntimeException</span><span style=color:#ce5c00;font-weight:700>();</span>
    <span style=color:#ce5c00;font-weight:700>}</span>
  <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>如果要构建自己的调度服务，那么可以使用 DelayQueue，它实现了 BlockingQueue，并为 ScheduledThreadPoolExecutor 提供调度功能。DelayQueue 管理着一组 Delayed 对象。每个 Delayed 对象都有一个相应的延迟时间：在 DelayQueue 中，只有某个元素逾期后，才能从 DelayQueue 中执行 take 操作。从 DelayQueue 中返回的对象将根据它们的延迟时间进行排序。</p>
<h2 id=63-找出可利用的并行性>6.3 找出可利用的并行性</h2>
<p>Executor 框架帮助指定执行策略，但如果要使用 Executor，必须将任务表述为一个 Runnable。在大多数服务器应用程序中都存在一个明显的任务边界：单个客户请求。但有时候，任务边界并非是显而易见的，例如在很多桌面应用程序中。即使是服务器应用程序，在单个客户请求中仍可能存在可发掘的并行性，例如数据库服务器。</p>
<p>本节我们将开发一些不同版本的组件，并且每个版本都实现了不同程度的并发性。该示例组件实现浏览器中的页面渲染功能，它的作用是将 HTML 页面绘制到图像缓存中。为了简便，假设 HTML 页面只包含标签文本，以及预定义大小的图片和 URL。</p>
<h3 id=631-示例串行的页面渲染器>6.3.1 示例：串行的页面渲染器</h3>
<p>最简单的方法是对 HTML 文档进行串行化处理。当遇到文本标签时，将其绘制到图像缓存中。当遇到图像引用时，先通过网络获取它，然后将其绘制到图像缓存中。这很容易实现，程序只需要将输入中的元素处理一次(甚至不需要缓存文档)，但这种方法可能会令用户感到烦恼，他们必须等待很长时间，直到显示所有文本。</p>
<p>另一种串行执行方法更好一些，它绘制文本元素，同时为图像预留出矩形的占位空间，在处理完第一遍文本后，程序开始下载图像，并将他们绘制到相应的占位空间中。在程序清单 6-10 的 SingleThreadRenderer 中给出了这种方法的实现。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>SingleThreadRenderer</span> <span style=color:#ce5c00;font-weight:700>{</span>
  <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>renaderPage</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>CharSequence</span> <span style=color:#000>source</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#000>renaderText</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>suorce</span><span style=color:#ce5c00;font-weight:700>);</span>
    <span style=color:#000>List</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>ImageInfo</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>imageData</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>ArrayList</span><span style=color:#ce5c00;font-weight:700>&lt;&gt;();</span>
    <span style=color:#204a87;font-weight:700>for</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>ImageInfo</span> <span style=color:#000>imageInfo</span> <span style=color:#ce5c00;font-weight:700>:</span> <span style=color:#000>scanFroImageInfo</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>source</span><span style=color:#ce5c00;font-weight:700>))</span> <span style=color:#ce5c00;font-weight:700>{</span>
      <span style=color:#000>imageData</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>add</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>imageInfo</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>downloadImae</span><span style=color:#ce5c00;font-weight:700>());</span>
    <span style=color:#ce5c00;font-weight:700>}</span>
    <span style=color:#204a87;font-weight:700>for</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>ImageData</span> <span style=color:#000>data</span> <span style=color:#ce5c00;font-weight:700>:</span> <span style=color:#000>imageData</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
      <span style=color:#000>renderImage</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>data</span><span style=color:#ce5c00;font-weight:700>);</span>
    <span style=color:#ce5c00;font-weight:700>}</span>
  <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>图像下载过程的大部分时间都是在等待 IO 操作执行完成，在这期间 CPU 几乎不做任何工作。因此，这种串行执行方法没有充分利用 CPU，使得用户在看到最终页面之前需要等待过长的时间。通过将问题分解为多个独立的任务并发执行，能够获得更好的 CPU 利用率和响应灵敏度。</p>
<h3 id=632-携带结果的任务calllable-与-future>6.3.2 携带结果的任务：Calllable 与 Future</h3>
<p>Executor 框架使用 Runnable 作为其基本的任务表示形式。Runnable 是一种局限很大的抽象，虽然 run 能写入到日志文件或者将结果放入某个数据结构，但它不能返回一个值或抛出一个受检异常。</p>
<p>许多任务实际上都是存在延迟的计算——执行数据库查询，从网络上获取资源，或者计算某个复杂的功能。对于这些任务，Callable 是一种更好的抽象：它认为主入口点(call)将返回一个值，并可抛出一个异常。在 Executor 中包含了一些辅助方法能将其他类型的任务封装为一个 Callable，例如 Runnable 和 java.security.PrivilegedAction。</p>
<p>Runnable 和 Callable 描述的都是抽象的计算任务。这些任务通常是有范围的，即都有一个明确的起始点，并且最终会结束。Executor 执行的任务有 4 个生命周期：创建、提交、开始、完成。由于有些任务可能需要执行很长时间，因此通常希望能够取消这些任务。在 Executor 框架中，已提交单尚未开始的任务可以取消，但对于那些已经开始执行的任务，只有当他们能够响应中断时，才能被取消。取消一个已经完成的任务不会有任何影响。</p>
<p>Future 表示一个任务的生命周期，并提供了相应的方法来判断是否已经完成或取消，以及获取任务的结果或取消任务等。在程序清单 6-11 中给出了 Callable 和 Future。在 Future 规范中包含的隐含意义是，任务的生命周期只能前进不能后退，就像 ExecutorService 的生命周期一样。当某个任务完成后，它就永远停留在“完成”状态上。</p>
<p>get 方法的行为取决于任务的状态，如果任务已经完成，那么 get 会立即返回或抛出一个异常，如果任务没有完成，那么 get 将阻塞并直到任务完成。如果任务抛出了异常，那么 get 将该异常封装为 ExecutionException 并重新抛出。如果任务被取消，那么 get 将抛出 CancellationException。如果 get 抛出了 ExecutionException，那么可以通过 getCause 来获得被封装的原始异常。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>interface</span> <span style=color:#000>Callable</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>V</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#ce5c00;font-weight:700>{</span> 
  <span style=color:#000>V</span> <span style=color:#000>call</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#204a87;font-weight:700>throws</span> <span style=color:#000>Exception</span><span style=color:#ce5c00;font-weight:700>;</span> 
<span style=color:#ce5c00;font-weight:700>}</span>

<span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>interface</span> <span style=color:#000>Future</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>V</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#ce5c00;font-weight:700>{</span> 
  <span style=color:#204a87;font-weight:700>boolean</span> <span style=color:#000>cancel</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>boolean</span> <span style=color:#000>mayInterruptIfRunning</span><span style=color:#ce5c00;font-weight:700>);</span> 
  <span style=color:#204a87;font-weight:700>boolean</span> <span style=color:#000>isCancelled</span><span style=color:#ce5c00;font-weight:700>();</span> <span style=color:#204a87;font-weight:700>boolean</span> <span style=color:#000>isDone</span><span style=color:#ce5c00;font-weight:700>();</span> 
  <span style=color:#000>V</span> <span style=color:#000>get</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#204a87;font-weight:700>throws</span> 
    <span style=color:#000>InterruptedException</span><span style=color:#ce5c00;font-weight:700>,</span> 
    <span style=color:#000>ExecutionException</span><span style=color:#ce5c00;font-weight:700>,</span> 
    <span style=color:#000>CancellationException</span><span style=color:#ce5c00;font-weight:700>;</span> 
  <span style=color:#000>V</span> <span style=color:#000>get</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>long</span> <span style=color:#000>timeout</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>TimeUnit</span> <span style=color:#000>unit</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#204a87;font-weight:700>throws</span> 
    <span style=color:#000>InterruptedException</span><span style=color:#ce5c00;font-weight:700>,</span> 
    <span style=color:#000>ExecutionException</span><span style=color:#ce5c00;font-weight:700>,</span> 
    <span style=color:#000>CancellationException</span><span style=color:#ce5c00;font-weight:700>,</span> 
    <span style=color:#000>TimeoutException</span><span style=color:#ce5c00;font-weight:700>;</span> 
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>可以通过多种方法创建一个 Future 来描述任务。ExecutorService 中的所有 submit 方法都将返回个 Future，从而将一个 Runnable 或 Callable 提交给 Executor，并得到一个 Future 用来获得任务的执行结果或取消任务。还可以显式的为某个指定的 Runnable 或 Callable 实例化一个 FutureTask。(由于 FutureTask 实现了 Runnable，因此可以将它提交给 Executor 来执行，或者直接调用它的 run 方法。)</p>
<p>从 Java 6 开始，ExecutorService 实现可以改写 AstractExecutorService 中的 newTaskFor 方法，从而根据已提交的 Runnable 或 Callable 来控制 Future 的实例化过程。在默认实现中仅创建了一个新的 FutureTask，如程序清单 6-12 所示。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#204a87;font-weight:700>protected</span> <span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>T</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>RunnableFuture</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>T</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>newTaskFor</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>Callable</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>T</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>task</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
  <span style=color:#204a87;font-weight:700>return</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>FutureTask</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>T</span><span style=color:#ce5c00;font-weight:700>&gt;(</span><span style=color:#000>task</span><span style=color:#ce5c00;font-weight:700>);</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>在将 Runnable 或 Callable 提交到 Executor 的过程中，包含了一个安全发布过程，即将 Runnable 或 Callable 从提交线程发布到最终执行任务的线程。类似的，在设置 Future 结果的过程也包含了一个安全发布，即将这个结果从计算它的线程发布到任何通过 get 获得它的线程。</p>
<h3 id=633-示例使用-future-实现页面渲染器>6.3.3 示例：使用 Future 实现页面渲染器</h3>
<p>为了使页面渲染器实现更高的并发性，首先将渲染过程分解为两个任务，一个是渲染所有文本，另一个是下载所有的图像。(因为其中一个任务是 CPU 密集型，而另一个任务是 IO 密集型，因此这种方法即使应用在单 CPU 系统上也能提升性能)。</p>
<p>Callable 和 Future 有助于表示这些协同任务之间的交互。在程序清单 6-13 的 FutureRenderer 中创建了一个 Callable 来下载所有图像，并将其提交到一个 ExecutorService。这将返回一个描述任务执行情况的 Future。当主任务需要图像时，它会等待 Future.get 的调用结果。如果幸运的话，当开始请求时所有图像就已经下载完成了，即使没有，至少图像的下载任务也已经提前开始了。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>FutureRenderer</span> <span style=color:#ce5c00;font-weight:700>{</span> 
  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>ExecutorService</span> <span style=color:#000>executor</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#ce5c00;font-weight:700>...;</span>

  <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>renderPage</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>CharSequence</span> <span style=color:#000>source</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>List</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>ImageInfo</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>imageInfos</span> <span style=color:#ce5c00;font-weight:700>=</span> 
      <span style=color:#000>scanForImageInfo</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>source</span><span style=color:#ce5c00;font-weight:700>);</span>
    <span style=color:#000>Callable</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>List</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>ImageData</span><span style=color:#ce5c00;font-weight:700>&gt;&gt;</span> <span style=color:#000>task</span> <span style=color:#ce5c00;font-weight:700>=</span>
      <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>Callable</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>List</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>ImageData</span><span style=color:#ce5c00;font-weight:700>&gt;&gt;()</span> <span style=color:#ce5c00;font-weight:700>{</span> 
        <span style=color:#204a87;font-weight:700>public</span> <span style=color:#000>List</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>ImageData</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>call</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span> 			
          <span style=color:#000>List</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>ImageData</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>result</span> <span style=color:#ce5c00;font-weight:700>=</span> 
            <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>ArrayList</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>ImageData</span><span style=color:#ce5c00;font-weight:700>&gt;();</span> 
          <span style=color:#204a87;font-weight:700>for</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>ImageInfo</span> <span style=color:#000>imageInfo</span> <span style=color:#ce5c00;font-weight:700>:</span> <span style=color:#000>imageInfos</span><span style=color:#ce5c00;font-weight:700>)</span> 	
            <span style=color:#000>result</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>add</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>imageInfo</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>downloadImage</span><span style=color:#ce5c00;font-weight:700>());</span> 
          <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>result</span><span style=color:#ce5c00;font-weight:700>;</span> 
        <span style=color:#ce5c00;font-weight:700>}</span>
      <span style=color:#ce5c00;font-weight:700>};</span>

    <span style=color:#000>Future</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>List</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>ImageData</span><span style=color:#ce5c00;font-weight:700>&gt;&gt;</span> <span style=color:#000>future</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>renderText</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>source</span><span style=color:#ce5c00;font-weight:700>);</span>
    <span style=color:#000>executor</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>submit</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>task</span><span style=color:#ce5c00;font-weight:700>);</span>

    <span style=color:#204a87;font-weight:700>try</span> <span style=color:#ce5c00;font-weight:700>{</span> 
      <span style=color:#000>List</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>ImageData</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>imageData</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>future</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>get</span><span style=color:#ce5c00;font-weight:700>();</span> 
      <span style=color:#204a87;font-weight:700>for</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>ImageData</span> <span style=color:#000>data</span> <span style=color:#ce5c00;font-weight:700>:</span> <span style=color:#000>imageData</span><span style=color:#ce5c00;font-weight:700>)</span> 	
        <span style=color:#000>renderImage</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>data</span><span style=color:#ce5c00;font-weight:700>);</span> 
    <span style=color:#ce5c00;font-weight:700>}</span> <span style=color:#204a87;font-weight:700>catch</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>InterruptedException</span> <span style=color:#000>e</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span> 
      <span style=color:#8f5902;font-style:italic>// Re-assert the thread&#39;s interrupted status 
</span><span style=color:#8f5902;font-style:italic></span>      <span style=color:#000>Thread</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>currentThread</span><span style=color:#ce5c00;font-weight:700>().</span><span style=color:#c4a000>interrupt</span><span style=color:#ce5c00;font-weight:700>();</span> 
      <span style=color:#8f5902;font-style:italic>// We don&#39;t need the result, so cancel the task too 
</span><span style=color:#8f5902;font-style:italic></span>      <span style=color:#000>future</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>cancel</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>true</span><span style=color:#ce5c00;font-weight:700>);</span> 
    <span style=color:#ce5c00;font-weight:700>}</span> <span style=color:#204a87;font-weight:700>catch</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>ExecutionException</span> <span style=color:#000>e</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span> 
      <span style=color:#204a87;font-weight:700>throw</span> <span style=color:#000>launderThrowable</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>e</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>getCause</span><span style=color:#ce5c00;font-weight:700>());</span> 
    <span style=color:#ce5c00;font-weight:700>}</span>
  <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>get 方法拥有“状态依赖”的内在特性，因而调用者不需要知道任务的状态，此外在任务提交和获得结果中包含的安全发布属性也确保了这个方法是线程安全的。Future.get 的异常处理代码将处理两个可能问题：任务遇到一个异常，或者调用 get 的线程在获得结果之前被中断。</p>
<p>FutureRenderer 使得渲染文本任务与下载图像数据的任务并发的执行。当所有图像下载完成后，会显示到页面上。这将提升用户体验，不仅使用户更快的看到结果，还有效利用了并行性，但我们还可以做得更好。用户不必等到所有的图像都下载完成，而希望看到每当下载一完一副图像时就立即显示出来。</p>
<h3 id=634-在异构任务并行化中存在的局限>6.3.4 在异构任务并行化中存在的局限</h3>
<p>在上个例子中，我们尝试并行的执行两个不同类型的任务——下载图像与渲染页面。然而，通过对异构任务执行并行化来获得重大的性能提升是很困难的。</p>
<p>两个人可以很好的分担洗碗的工作：其中一个人负责清洗，另一个人负责烘干。然而，要将不同类型的任务平均分配给每个工人并不容易。但人数增加时，如何确保他们能帮忙而不是妨碍其他人工作，或者在重新分配工作时，并不是很容易的事情。如果没有在相似的任务之间找出细粒度的并行性，那么这种方法带来的好处将减少。</p>
<p>当在多个工人之间分配异构的任务时，还有一个问题就是各个任务的大小可能完全不同。如果将两个任务 A 和 B 分配给两个工人，但 A 的执行时间是 B 的 10 倍，那么整个过程也只能加速 9%。最后，当在多个工人之间分解任务时，还需要一定的任务协调开销：为了使任务分解能提高性能，这种开销不能高于并行性实现的提升。</p>
<p>FutureRenderer 使用了两个任务，其中一个负责渲染文本，另一个负责下载图像。如果渲染文本的速度远远高于下载图像的速度，那么程序的最终性能与串行执行时的性能差别不大，而代码却更加复杂了。当使用两个线程时，至多能将速度提升一倍。因此，虽然做了许多工作来并发执行异构任务以提高并发度，但从中获得的并发性却是十分有限的。</p>
<p>只有当大量相互独立且同构的任务可以并行处理时，才能体现出将程序的工作负载分配到多个任务中带来的真正性能提升。</p>
<h3 id=635-completionserviceexecutor-与-blockingqueue>6.3.5 CompletionService：Executor 与 BlockingQueue</h3>
<p>如果向 Executor 提交一组计算任务，并且希望在计算完成后获得结果，那么可以保留与每个任务关联的 Future，然后反复使用 get 方法，同时将参数 timeout 设定为 0，从而通过轮询来判断任务是否完成。这种方法虽然可行，但却十分繁琐。幸运的是，还有一种更好的方法：CompletionService。</p>
<p>CompletionService 将 Executor 与 BlockingQueue 的功能融合在一起。你可以将 Callable 任务提交给它来执行，然后使用类似于队列操作的 take 和 poll 等方法来获得已完成的结果，而这些结果会在完成时将被封装为 Future。ExecutorCompletionService 实现了 CompletionService，并将计算部分委托给一个 Executor。</p>
<p>ExecutorCompletionService 的实现非常简单。在构造函数中创建一个 BlockingQueue 来保存计算完成的结果。当计算完成时，调用 FutureTask 中的 done 方法。当提交某个任务时，该任务首先将包装为一个 QueueingFuture，这是 FutureTask 的一个子类，然后再改写子类的 done 方法，并将结果放入 BlockingQueue 中，如程序清单 6-14 所示。take 和 poll 方法委托给了 BlockingQueue，这些方法会在得出结果之前阻塞。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>QueueingFuture</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>V</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#204a87;font-weight:700>extends</span> <span style=color:#000>FutureTask</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>V</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#ce5c00;font-weight:700>{</span>
  <span style=color:#000>QueueingFuture</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>Callable</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>V</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>c</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span> <span style=color:#204a87;font-weight:700>super</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>c</span><span style=color:#ce5c00;font-weight:700>);</span> <span style=color:#ce5c00;font-weight:700>}</span>
  <span style=color:#000>QueueingFuture</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>Runnable</span> <span style=color:#000>t</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>V</span> <span style=color:#000>r</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span> <span style=color:#204a87;font-weight:700>super</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>t</span><span style=color:#ce5c00;font-weight:700>,</span><span style=color:#000>r</span><span style=color:#ce5c00;font-weight:700>);</span> <span style=color:#ce5c00;font-weight:700>}</span>
  
  <span style=color:#204a87;font-weight:700>protected</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>done</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#000>completionQueue</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>add</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>this</span><span style=color:#ce5c00;font-weight:700>);</span>
  <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><h3 id=636-示例使用-completionservice-实现页面渲染器>6.3.6 示例：使用 CompletionService 实现页面渲染器</h3>
<p>可以通过 CompletionService 从两个方面来提高页面渲染器的性能：缩短总运行时间以及提高响应性。为每个图像的下载都创建一个独立任务，并在线程池中执行他们，从而将串行的下载过程转换为并行的过程：这将减少下载所有图像的总时间。此外，通过从 CompletionService 中获得结果以及使每张图片在下载完成后立即显示出来，能使用户得到一个更加动态和更高响应性的用户界面。如程序清单 6-15 的 Renderer 所示。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>Renderer</span> <span style=color:#ce5c00;font-weight:700>{</span> 
  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>ExecutorService</span> <span style=color:#000>executor</span><span style=color:#ce5c00;font-weight:700>;</span>

  <span style=color:#000>Renderer</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>ExecutorService</span> <span style=color:#000>executor</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span> 
    <span style=color:#204a87;font-weight:700>this</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>executor</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>executor</span><span style=color:#ce5c00;font-weight:700>;</span> 
  <span style=color:#ce5c00;font-weight:700>}</span>

  <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>renderPage</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>CharSequence</span> <span style=color:#000>source</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>List</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>ImageInfo</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>info</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>scanForImageInfo</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>source</span><span style=color:#ce5c00;font-weight:700>);</span> 			<span style=color:#000>CompletionService</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>ImageData</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>completionService</span> <span style=color:#ce5c00;font-weight:700>=</span>
      <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>ExecutorCompletionService</span><span style=color:#ce5c00;font-weight:700>&lt;&gt;(</span><span style=color:#000>executor</span><span style=color:#ce5c00;font-weight:700>);</span> 
    <span style=color:#204a87;font-weight:700>for</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>ImageInfo</span> <span style=color:#000>imageInfo</span> <span style=color:#ce5c00;font-weight:700>:</span> <span style=color:#000>info</span><span style=color:#ce5c00;font-weight:700>)</span>
      <span style=color:#000>completionService</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>submit</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>Callable</span><span style=color:#ce5c00;font-weight:700>&lt;&gt;()</span> <span style=color:#ce5c00;font-weight:700>{</span> 
        <span style=color:#204a87;font-weight:700>public</span> <span style=color:#000>ImageData</span> <span style=color:#000>call</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span> 
          <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>imageInfo</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>downloadImage</span><span style=color:#ce5c00;font-weight:700>();</span> 
        <span style=color:#ce5c00;font-weight:700>}</span>
      <span style=color:#ce5c00;font-weight:700>});</span>
    <span style=color:#000>renderText</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>source</span><span style=color:#ce5c00;font-weight:700>);</span>

    <span style=color:#204a87;font-weight:700>try</span> <span style=color:#ce5c00;font-weight:700>{</span> 
      <span style=color:#204a87;font-weight:700>for</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>t</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>0</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>n</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>info</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>size</span><span style=color:#ce5c00;font-weight:700>();</span> <span style=color:#000>t</span> <span style=color:#ce5c00;font-weight:700>&lt;</span> <span style=color:#000>n</span><span style=color:#ce5c00;font-weight:700>;</span> <span style=color:#000>t</span><span style=color:#ce5c00;font-weight:700>++)</span> <span style=color:#ce5c00;font-weight:700>{</span> 
        <span style=color:#000>Future</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>ImageData</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>f</span> <span style=color:#ce5c00;font-weight:700>=</span> 
          <span style=color:#000>completionService</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>take</span><span style=color:#ce5c00;font-weight:700>();</span> 
        <span style=color:#000>ImageData</span> <span style=color:#000>imageData</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>f</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>get</span><span style=color:#ce5c00;font-weight:700>();</span> 
        <span style=color:#000>renderImage</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>imageData</span><span style=color:#ce5c00;font-weight:700>);</span> 
      <span style=color:#ce5c00;font-weight:700>}</span> 
    <span style=color:#ce5c00;font-weight:700>}</span> <span style=color:#204a87;font-weight:700>catch</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>InterruptedException</span> <span style=color:#000>e</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span> 	
      <span style=color:#000>Thread</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>currentThread</span><span style=color:#ce5c00;font-weight:700>().</span><span style=color:#c4a000>interrupt</span><span style=color:#ce5c00;font-weight:700>();</span> 
    <span style=color:#ce5c00;font-weight:700>}</span> <span style=color:#204a87;font-weight:700>catch</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>ExecutionException</span> <span style=color:#000>e</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span> 
      <span style=color:#204a87;font-weight:700>throw</span> <span style=color:#000>launderThrowable</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>e</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>getCause</span><span style=color:#ce5c00;font-weight:700>());</span> 
    <span style=color:#ce5c00;font-weight:700>}</span>
  <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>多个 ExecutorCompletionService 可以共享同一个 Executor，因此可以创建一个对于特定计算私有，又能共享一个公共 Executor 的 ExecutorCompletionService。因此，CompletionService 的作用就相当于一组计算的句柄，这与 Future 作为单个计算的句柄是非常类似的。通过记录提交给 CompletionService 的任务数量，并计算出已经获得的已经完成计算结果的数量，即使使用一个共享的 Executor，也能知道已经获得了所有任务结果的时间。</p>
<h3 id=637-为任务设置时限>6.3.7 为任务设置时限</h3>
<p>有时候，如果某个任务无法在指定时间内完成，那将不再需要它的结果，此时可以放弃这个任务。例如，某个 Web 应用程序从外部的广告服务器上获取广告信息，但如果该应用程序在两秒钟内得不到响应，那么将显示一个默认的广告，这样即使不能获得广告信息，也不会降低站点的响应性能。类似的，一个门户网站可以从多个数据源并行的获取数据，但可能只会在指定的时间内等待数据，如果超出了等待时间，那么只显示已经获得的数据。</p>
<p>在有限时间内执行任务的主要困难在于，要确保得到答案的时间不会超过限定的时间，或者在限定时间内无法得到答案。在支持时间限制的 Future.get 中支持这种需求：当结果可用时将理解返回，如果在指定的时间内没有计算出结果，那么将抛出 TimeoutException。</p>
<p>在使用限时任务时需要注意，当这些任务超时后应该立即停止执行，从而避免为继续计算一个不再使用的结果而浪费计算资源。要实现这个功能，可以由任务本身来管理它的限定时间，并且在超时后中止执行或取消任务。此时可以再次使用 Futute，如果一个限时的 get 方法抛出了 TimeoutException，那么可以通过 Future 来取消任务。如果编写的任务是可取消的，那么可以提前中止它，以免消耗过多资源。在程序清单 6-13 和 6-16 中的代码使用了这项技术。</p>
<p>程序清单 6-16 给出了限时 Future.get 的一种典型应用。在它生成的页面中包括响应用户请求的内容以及从广告服务器上获得的广告。它将获取广告的任务提交给一个 Executor，然后计算剩余的文本页面的内容，最后等待广告信息，直到超出指定的时间。如果 get 超时，那么将取消广告获取任务，并转而使用默认的广告信息。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#000>Page</span> <span style=color:#000>renderPageWithAd</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#204a87;font-weight:700>throws</span> <span style=color:#000>InterrutedException</span> <span style=color:#ce5c00;font-weight:700>{</span>
  <span style=color:#204a87;font-weight:700>long</span> <span style=color:#000>endNanos</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>System</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>nanoTime</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>+</span> <span style=color:#000>TIME_BUDGET</span><span style=color:#ce5c00;font-weight:700>;</span>
  <span style=color:#000>Future</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>Ad</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>f</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>exec</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>submit</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>FetchAdTask</span><span style=color:#ce5c00;font-weight:700>());</span>
  <span style=color:#8f5902;font-style:italic>// 在等待广告的同时显示页面
</span><span style=color:#8f5902;font-style:italic></span>  <span style=color:#000>Page</span> <span style=color:#000>page</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>renderPageBody</span><span style=color:#ce5c00;font-weight:700>();</span>
  <span style=color:#000>Ad</span> <span style=color:#000>ad</span><span style=color:#ce5c00;font-weight:700>;</span>
  <span style=color:#204a87;font-weight:700>try</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#8f5902;font-style:italic>// 等待指定的时长
</span><span style=color:#8f5902;font-style:italic></span>    <span style=color:#204a87;font-weight:700>long</span> <span style=color:#000>timeLeft</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>endNanos</span> <span style=color:#ce5c00;font-weight:700>-</span> <span style=color:#000>System</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>nanoTime</span><span style=color:#ce5c00;font-weight:700>();</span>
    <span style=color:#000>ad</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>f</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>get</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>timeLeft</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>NANOSECONDS</span><span style=color:#ce5c00;font-weight:700>);</span>
  <span style=color:#ce5c00;font-weight:700>}</span> <span style=color:#204a87;font-weight:700>catch</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>ExecutionException</span> <span style=color:#000>e</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#000>ad</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>DEFAULT_AD</span><span style=color:#ce5c00;font-weight:700>;</span>
  <span style=color:#ce5c00;font-weight:700>}</span> <span style=color:#204a87;font-weight:700>catch</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>TimeoutException</span> <span style=color:#000>e</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#000>ad</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>DEFAULT_AD</span><span style=color:#ce5c00;font-weight:700>;</span>
    <span style=color:#000>f</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>cancel</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>true</span><span style=color:#ce5c00;font-weight:700>);</span>
  <span style=color:#ce5c00;font-weight:700>}</span>
  <span style=color:#000>page</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>setAd</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>ad</span><span style=color:#ce5c00;font-weight:700>);</span>
  <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>page</span><span style=color:#ce5c00;font-weight:700>;</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><h3 id=638-示例旅行预订网站>6.3.8 示例：旅行预订网站</h3>
<p>“预订时间”方法可以很容易的扩展到任意数量的任务上。考虑这样一个旅行预订网站：用户输入旅行的日期和其他要求，网站获取并展示来自多条航线、旅店或汽车租赁公司的报价。在获取不同公司报价的过程中，可能会调用 Web 服务、访问数据库、执行一个 EDI 事务或其他机制。在这种情况下，不宜让页面的响应时间受限于最慢的响应时间，而应该只显示在指定时间内收到的信息。对于没有及时响应的服务提供者，页面可以忽略它们，或者显示一个提示信息。</p>
<p>从一个公司获得报价的过程与从其他公司获得报价的过程无关，因此可以将获取报价的过程当成一个任务，从而使得获取报价的过程并发执行。创建 N 个任务，将其提交到一个线程池，保留 N 个 Future 并使用限时的 get 方法通过 Future 串行的获取每一个结果，这一切都很简单，但还有一个更简单的方法——invokeAll。</p>
<p>程序清单 6-17 使用了支持限时的 invokeAll，将多个任务提交到一个 ExecutorService 并获得结果。InvokeAll 方法参数为一组任务，并返回一组 Future。这两个集合有着相同的结构。invokeAll 按照任务集合中迭代器的顺序将所有的 Future 添加到返回的集合中，从而使调用者能将各个 Future 与其表示的 Callable 关联起来。当所有任务都执行完毕时，或者调用者线程被中断时，又或者超过指定时限时，invokeAll 将返回。当超过执行时限后，任何还未完成的任务都将被取消。当 invokeAll 返回后，每个任务要么正常的完成，要么被取消，而客户端代码可以调用 get 或 isCancelled 来判断具体的情况。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>QuoteTask</span> <span style=color:#204a87;font-weight:700>implements</span> <span style=color:#000>Callable</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>TravelQuote</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#ce5c00;font-weight:700>{</span> 
  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>TravelCompany</span> <span style=color:#000>company</span><span style=color:#ce5c00;font-weight:700>;</span> 
  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>TravelInfo</span> <span style=color:#000>travelInfo</span><span style=color:#ce5c00;font-weight:700>;</span> 
  <span style=color:#ce5c00;font-weight:700>...</span>

  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#000>TravelQuote</span> <span style=color:#000>call</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#204a87;font-weight:700>throws</span> <span style=color:#000>Exception</span> <span style=color:#ce5c00;font-weight:700>{</span> 
    <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>company</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>solicitQuote</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>travelInfo</span><span style=color:#ce5c00;font-weight:700>);</span> 
  <span style=color:#ce5c00;font-weight:700>}</span> 
<span style=color:#ce5c00;font-weight:700>}</span>

<span style=color:#204a87;font-weight:700>public</span> <span style=color:#000>List</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>TravelQuote</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>getRankedTravelQuotes</span><span style=color:#ce5c00;font-weight:700>(</span>
  <span style=color:#000>TravelInfo</span> <span style=color:#000>travelInfo</span><span style=color:#ce5c00;font-weight:700>,</span> 
  <span style=color:#000>Set</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>TravelCompany</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>companies</span><span style=color:#ce5c00;font-weight:700>,</span> 
  <span style=color:#000>Comparator</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>TravelQuote</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>ranking</span><span style=color:#ce5c00;font-weight:700>,</span> 
  <span style=color:#204a87;font-weight:700>long</span> <span style=color:#000>time</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>TimeUnit</span> <span style=color:#000>unit</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#204a87;font-weight:700>throws</span> <span style=color:#000>InterruptedException</span> <span style=color:#ce5c00;font-weight:700>{</span> 
  <span style=color:#000>List</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>QuoteTask</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>tasks</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>ArrayList</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>QuoteTask</span><span style=color:#ce5c00;font-weight:700>&gt;();</span> 
  <span style=color:#204a87;font-weight:700>for</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>TravelCompany</span> <span style=color:#000>company</span> <span style=color:#ce5c00;font-weight:700>:</span> <span style=color:#000>companies</span><span style=color:#ce5c00;font-weight:700>)</span> 
    <span style=color:#000>tasks</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>add</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>QuoteTask</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>company</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>travelInfo</span><span style=color:#ce5c00;font-weight:700>));</span>
  <span style=color:#000>List</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>Future</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>TravelQuote</span><span style=color:#ce5c00;font-weight:700>&gt;&gt;</span> <span style=color:#000>futures</span> <span style=color:#ce5c00;font-weight:700>=</span> 
    <span style=color:#000>exec</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>invokeAll</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>tasks</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>time</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>unit</span><span style=color:#ce5c00;font-weight:700>);</span>
  <span style=color:#000>List</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>TravelQuote</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>quotes</span> <span style=color:#ce5c00;font-weight:700>=</span> 
    <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>ArrayList</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>TravelQuote</span><span style=color:#ce5c00;font-weight:700>&gt;(</span><span style=color:#000>tasks</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>size</span><span style=color:#ce5c00;font-weight:700>());</span> 
  <span style=color:#000>Iterator</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>QuoteTask</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>taskIter</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>tasks</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>iterator</span><span style=color:#ce5c00;font-weight:700>();</span> 
  <span style=color:#204a87;font-weight:700>for</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>Future</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>TravelQuote</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>f</span> <span style=color:#ce5c00;font-weight:700>:</span> <span style=color:#000>futures</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span> 
    <span style=color:#000>QuoteTask</span> <span style=color:#000>task</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>taskIter</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>next</span><span style=color:#ce5c00;font-weight:700>();</span> 
    <span style=color:#204a87;font-weight:700>try</span> <span style=color:#ce5c00;font-weight:700>{</span> 
      <span style=color:#000>quotes</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>add</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>f</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>get</span><span style=color:#ce5c00;font-weight:700>());</span> 
    <span style=color:#ce5c00;font-weight:700>}</span> <span style=color:#204a87;font-weight:700>catch</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>ExecutionException</span> <span style=color:#000>e</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span> 		
      <span style=color:#000>quotes</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>add</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>task</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>getFailureQuote</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>e</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>getCause</span><span style=color:#ce5c00;font-weight:700>()));</span> 
    <span style=color:#ce5c00;font-weight:700>}</span> <span style=color:#204a87;font-weight:700>catch</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>CancellationException</span> <span style=color:#000>e</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span> 	
      <span style=color:#000>quotes</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>add</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>task</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>getTimeoutQuote</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>e</span><span style=color:#ce5c00;font-weight:700>));</span>
    <span style=color:#ce5c00;font-weight:700>}</span> 
  <span style=color:#ce5c00;font-weight:700>}</span>

  <span style=color:#000>Collections</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>sort</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>quotes</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>ranking</span><span style=color:#ce5c00;font-weight:700>);</span> 
  <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>quotes</span><span style=color:#ce5c00;font-weight:700>;</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><h2 id=小结>小结</h2>
<p>通过围绕任务执行来设计应用程序，可以简化开发过程，并有助于实现并发。Executor 框架将任务提交与执行策略解耦开来，同时还支持不同类型的执行策略。当需要创建线程来执行任务时，可以考虑使用 Executor。要想在将应用程序分解为不同的任务时获得最大的好处，必须定义清晰的任务边界。某些应用程序中存在着比较明显的任务边界，而在其他一些程序中则需要进一步分析才能揭示出粒度更细的并行性。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-17b3a37a702dffa06994fadaf5e04650>7 - CH07-取消关闭</h1>
<p>任务和线程的启动很容易。在大多数时候，我们都会让它们运行直到结束，或者让它们自行停止。然而，有时候我们希望提前结束任务或线程，或许是因为用户取消了操作，或者应用程序需要被快速关闭。</p>
<p>要使任务和线程能够安全、快速、可靠的停止下来，并不是一件容易的事。Java 没有提供任何机制来安全的终止线程。但它提供了中断，这是一种协作机制，能够使一个线程终止另一个线程的当前工作。</p>
<p>这种协作式的方法是必要的，我们很少希望某个任务、线程或服务立即停止，因为这种立即停止会使共享的数据结构处于不一致的状态。相反，在编写任务和服务时可以使用一种协作的方式：因为任务本身的代码比发出取消请求的代码更清除如何执行清除工作。</p>
<p>生命周期结束的问题会使任务、服务以及程序的设计和实现等过程变得复杂，而这个在程序设计中非常重要的要素却经常被忽略。一个在行为良好的软件与勉强运行的软件之间的最主要区别就是，行为良好的软件很完善的处理失败、关闭和取消等过程。本章将给出各种实现、取消、中断的机制，以及如何编写任务和服务，使它们能对取消请求做出响应。</p>
<h2 id=71-任务取消>7.1 任务取消</h2>
<p>如果外部代码能在某个操作正常完成之前将其置入“完成”状态，那么这个操作就可以成为可取消的。取消某个操作的原因可能会是：</p>
<ul>
<li><strong>用户请求取消。</strong> 用户点击图形界面中的“取消”按钮，或者通过管理接口发出取消请求，例如 JMX。</li>
<li><strong>有时限的操作。</strong> 例如，应用程序对某个问题空间进行分解并搜索，从而使不同的任务可以搜索问题空间中的不同区域。当其中一个任务找到了解决方案时，所有其他仍在搜索的任务都将被取消。</li>
<li><strong>错误。</strong> 网页爬虫程序搜索相关的页面，将页面或摘要数据保存到硬盘。当一个爬虫任务发生错误时，那么所有搜索任务都会取消，此时可能会记录它们的当前状态，以便稍后重新启动。</li>
<li><strong>关闭。</strong> 当一个程序或服务关闭时，必须对正在处理和等待处理的工作执行某种操作。在平缓的关闭过程中，当前正在执行的任务将继续执行直到完成，而在立即关闭过程中，当前的任务则可能取消。</li>
</ul>
<p>在 Java 中没有一种安全的抢占式的方法来停止线程，因此也就没有安全的抢占式的方法来停止任务。只有一些协作式的机制，使请求取消的任务和代码都遵循一种协商好的协议。</p>
<p>其中一种协作机制能设置某个“已请求取消”标志，而任务将定期来查看该标志。如果设置了这个标志，那么任务将提前结束。程序清单 7-1 中就使用了这项技术，其中的 PrimeGenerator 持续的枚举素数，直到它被取消。cancel 方法将设置 cancelled 标志，并且主循环在搜索下一个素数之前会首先检查这个标志。(为了使该过程可靠的工作，标志 cancelled 必须为 volatile 类型。)</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#5c35cc;font-weight:700>@ThreadSafe</span>
<span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>PrimeGenerator</span> <span style=color:#204a87;font-weight:700>implements</span> <span style=color:#000>Runnable</span> <span style=color:#ce5c00;font-weight:700>{</span>
  <span style=color:#5c35cc;font-weight:700>@GuardedBy</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#4e9a06>&#34;this&#34;</span><span style=color:#ce5c00;font-weight:700>)</span>
  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>List</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>BigInteger</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>primes</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>ArrayList</span><span style=color:#ce5c00;font-weight:700>&lt;&gt;();</span>
  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>volatile</span> <span style=color:#204a87;font-weight:700>boolean</span> <span style=color:#000>cancelled</span><span style=color:#ce5c00;font-weight:700>;</span>
  
  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>run</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#000>BigInteger</span> <span style=color:#000>p</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>BigInteger</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>ONE</span><span style=color:#ce5c00;font-weight:700>;</span>
    <span style=color:#204a87;font-weight:700>while</span><span style=color:#ce5c00;font-weight:700>(!</span><span style=color:#000>cancelled</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
      <span style=color:#000>p</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>p</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>nextProbablePrime</span><span style=color:#ce5c00;font-weight:700>();</span>
      <span style=color:#204a87;font-weight:700>synchronized</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>this</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
        <span style=color:#000>primes</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>add</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>p</span><span style=color:#ce5c00;font-weight:700>);</span>
      <span style=color:#ce5c00;font-weight:700>}</span>
    <span style=color:#ce5c00;font-weight:700>}</span>
  <span style=color:#ce5c00;font-weight:700>}</span>
  
  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>cancel</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span> <span style=color:#000>cancelled</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>true</span><span style=color:#ce5c00;font-weight:700>;</span> <span style=color:#ce5c00;font-weight:700>}</span>
  
  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#204a87;font-weight:700>synchronized</span> <span style=color:#000>List</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>BigInteger</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>get</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#204a87;font-weight:700>return</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>ArrayList</span><span style=color:#ce5c00;font-weight:700>&lt;&gt;(</span><span style=color:#000>primes</span><span style=color:#ce5c00;font-weight:700>);</span>
  <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>程序清单 7-2 给出了这个类的使用示例，即让素数生成器运行 1 秒钟后取消。素数生成器通常并不会刚好在运行一秒钟后停止，因为在请求取消的时刻和 run 方法中循环执行下一次检查之间可能存在延迟。cancel 方法由 finally 块调用，从而确保即使在调用 sleep 时被中断也能取消素数生成器的执行。如果 cancel 没有被调用，那么搜索素数的线程将永远运行下去，不断消耗 CPU 的时钟周期，并使得 JVM 不能正常退出。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#000>List</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>BigInteger</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>aSecondOfPrimes</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#204a87;font-weight:700>throws</span> <span style=color:#000>InterruptedEx</span> <span style=color:#ce5c00;font-weight:700>{</span>
  <span style=color:#000>primeGenerator</span> <span style=color:#000>generator</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>PrimeGenerator</span><span style=color:#ce5c00;font-weight:700>();</span>
  <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>Thread</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>generator</span><span style=color:#ce5c00;font-weight:700>).</span><span style=color:#c4a000>start</span><span style=color:#ce5c00;font-weight:700>();</span>
  <span style=color:#204a87;font-weight:700>try</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#000>SECONDS</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>sleep</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>1</span><span style=color:#ce5c00;font-weight:700>);</span>
  <span style=color:#ce5c00;font-weight:700>}</span> <span style=color:#204a87;font-weight:700>finally</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#000>generator</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>cancel</span><span style=color:#ce5c00;font-weight:700>();</span>
  <span style=color:#ce5c00;font-weight:700>}</span>
  <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>generator</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>get</span><span style=color:#ce5c00;font-weight:700>();</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>一个可取消的任务必须拥有取消策略，在这个策略中将详细地定义取消操作的 How、When、What，即其他代码如何请求取消该任务，任务在何时检查是否已经请求了取消，以及在响应取消请求时应该执行哪些操作。</p>
<p>考虑现实世界中停止支付支票的示例。银行通常会规定如何提交一个停止支付的请求，在处理这些请求时需要作出哪些响应性保证，以及当支付终端后需要遵守哪些流程。这些流程和保证放在一起构成了支票支付的取消策略。</p>
<p>PrimeGenerator 使用了一种简单的取消策略：客户代码通过调用 cancel 来请求取消，PrimeGenerator 在每次搜索素数前首先检查是否存在取消请求，如果存在则退出。</p>
<h3 id=711-中断>7.1.1 中断</h3>
<p>PrimeGenerator 中的取消机制最终会使得搜索素数的任务退出，但在退出过程中需要花费一定的时间。然而，如果使用这种方法的任务调用了一个阻塞方法，例如 BlockingQueue.put，那么可能会产生一个更严重的问题——任务永远不会检查取消标志，因此永远不会停止。</p>
<p>在程序清单 7-3 中的 BrokenPrimeProducer 就说明了这个问题。生产者线程生成素数，put 方法也会阻塞。当生产者在 put 方法中阻塞时，如果消费者希望取消生产任务，那么将发生什么情况？它可以调用 cancel 方法来设置 cancelled 标志，但此时生产者却永远不会检查这个标志，因为它无法从阻塞的 put 方法中恢复过来(因为消费者此时已经停止从队列中取出素数，所以 put 方法将一直保持阻塞状态)。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>BrokenPrimeProducer</span> <span style=color:#204a87;font-weight:700>extends</span> <span style=color:#000>Thread</span> <span style=color:#ce5c00;font-weight:700>{</span>
  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>BlockingQueue</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>BigInteger</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>queue</span><span style=color:#ce5c00;font-weight:700>;</span> 
  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>volatile</span> <span style=color:#204a87;font-weight:700>boolean</span> <span style=color:#000>cancelled</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>false</span><span style=color:#ce5c00;font-weight:700>;</span>

  <span style=color:#000>BrokenPrimeProducer</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>BlockingQueue</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>BigInteger</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>queue</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span> 	
    <span style=color:#204a87;font-weight:700>this</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>queue</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>queue</span><span style=color:#ce5c00;font-weight:700>;</span> 
  <span style=color:#ce5c00;font-weight:700>}</span>

  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>run</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span> 
    <span style=color:#204a87;font-weight:700>try</span> <span style=color:#ce5c00;font-weight:700>{</span>
      <span style=color:#000>BigInteger</span> <span style=color:#000>p</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>BigInteger</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>ONE</span><span style=color:#ce5c00;font-weight:700>;</span> 
      <span style=color:#204a87;font-weight:700>while</span> <span style=color:#ce5c00;font-weight:700>(!</span><span style=color:#000>cancelled</span><span style=color:#ce5c00;font-weight:700>)</span> 
        <span style=color:#000>queue</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>put</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>p</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>p</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>nextProbablePrime</span><span style=color:#ce5c00;font-weight:700>());</span> 
    <span style=color:#ce5c00;font-weight:700>}</span> <span style=color:#204a87;font-weight:700>catch</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>InterruptedException</span> <span style=color:#000>consumed</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span> <span style=color:#ce5c00;font-weight:700>}</span> 
  <span style=color:#ce5c00;font-weight:700>}</span>

  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>cancel</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span> <span style=color:#000>cancelled</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>true</span><span style=color:#ce5c00;font-weight:700>;</span> <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#ce5c00;font-weight:700>}</span>

<span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>consumePrimes</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#204a87;font-weight:700>throws</span> <span style=color:#000>InterruptedException</span> <span style=color:#ce5c00;font-weight:700>{</span>
  <span style=color:#000>BlockingQueue</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>BigInteger</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>primes</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#ce5c00;font-weight:700>...;</span> 
  <span style=color:#000>BrokenPrimeProducer</span> <span style=color:#000>producer</span> <span style=color:#ce5c00;font-weight:700>=</span> 
    <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>BrokenPrimeProducer</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>primes</span><span style=color:#ce5c00;font-weight:700>);</span> 
  <span style=color:#000>producer</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>start</span><span style=color:#ce5c00;font-weight:700>();</span> 
  
  <span style=color:#204a87;font-weight:700>try</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#204a87;font-weight:700>while</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>needMorePrimes</span><span style=color:#ce5c00;font-weight:700>())</span>
      <span style=color:#000>consume</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>primes</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>take</span><span style=color:#ce5c00;font-weight:700>());</span> 
  <span style=color:#ce5c00;font-weight:700>}</span> <span style=color:#204a87;font-weight:700>finally</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#000>producer</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>cancel</span><span style=color:#ce5c00;font-weight:700>();</span> 
  <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>第五章曾提到，一些特殊的阻塞库的方法支持中断。线程中断是一种协作机制，线程可以通过这种机制来通知另一个线程，告诉它在合适的或者可能的情况下停止当前工作，并转而执行其他工作。</p>
<blockquote>
<p>在 Java 的 API 或语言规范中，并没有将中断与任何取消语义关联起来，但实际上如果在取消之外的其他操作中使用中断，那么都是不合适的，并且很难支撑起更大的应用。</p>
</blockquote>
<p>每个线程都有一个 boolean 类型的中断状态。当中断线程时，这个线程的中断状态将被设置为 true。在 Thread 中包含了中断线程以及查询线程中断状态的方法，如程序清单 7-4 所示。interrupt 方法将清除当前线程的中断状态，并返回它之前的值，这也是清除中断状态的唯一方法。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>Thread</span> <span style=color:#ce5c00;font-weight:700>{</span>
  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>interrupt</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{...}</span>
  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>boolean</span> <span style=color:#000>isInterrupted</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{...}</span>
  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>static</span> <span style=color:#204a87;font-weight:700>boolean</span> <span style=color:#000>interrupted</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{...}</span>
  <span style=color:#ce5c00;font-weight:700>...</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>阻塞库方法，例如 Thread.sleep 和 Object.wait 等，都会检查线程何时中断，并且在发现中断时提前返回。它们在响应中断时执行的操作包括：清除中断状态，抛出 InterruptedException，表示阻塞操作由于中断而提前结束。JVM 并不保证阻塞方法检测到中断的速度，但在实际情况中响应速度还是非常快的。</p>
<p>当线程在非阻塞状态下中断时，它的中断状态被设置，然后根据将被取消的操作来检查中断状态以判断发生了中断。通过这样的方法，中断操作将变得“有粘性”——如果不触发中断异常，那么中断状态将一直保持，直到明确的清除中断状态。</p>
<blockquote>
<p>调用 interrput 并不意味着立即停止目标线程正在进行的工作，而只是传递了请求中断的消息。</p>
</blockquote>
<p>对中断操作的正确理解是：它并不会真正的中断一个正在运行的线程，而只是发出中断请求，然后由线程在下一个合适的时刻中断自己。(这些时刻也被称为取消点)。有些方法，例如 wait、sleep、join 等，将严格的处理这种请求，当它们收到中断请求或者在开始执行时发现某个已被设置好的中断状态时，将抛出一个异常。设计良好的方法可以完全忽略这种请求，只要它们能使调用者代码对中断请求进行某种处理。设计糟糕的方法可能会屏蔽中断请求，从而导致调用栈中的其他代码无法对中断请求做出响应。</p>
<p>在使用静态的 interrupted 时应该小心，因为它会清除单签线程的中断状态。如果在调用 interrupted 时返回了 true，那么除非你想屏蔽这个中断，否则必须对它进行处理——可以抛出中断异常，或者通过再次调用 interrupt 来恢复中断状态，如程序清单 5-10 所示。</p>
<p>BrokenPromeProducer 说明了一些自定义的取消机制无法与可阻塞的库函数实现良好交互的原因。如果任务代码能够响应中断，那么可以使用中断作为取消机制，并且利用许多库中提供的中断支持。</p>
<blockquote>
<p>通常，中断是实现取消的最合理方式。</p>
</blockquote>
<p>BrokenPrimeProducer 中的问题可以很容易解决或简化：使用中断而不是 boolean 标志来请求取消，如程序清单 7-5 所示。在每次迭代循环中，有两个位置可以检测出中断：在阻塞的 put 方法调用中，以及在循环开始处查询中断中断状态时。由于调用了阻塞的 put 方法，因此这里并不需要进行显式的检测，但执行检测却会使 PrimeProducer 对中断具有更高的响应性，因为它是在启动寻找素数任务之前检测中断的，而不是在任务完成之后。如果可中断的阻塞方法的调用频率并不高，不足以获得足够的响应性，那么显式的检测中断状态能起到一定的帮助作用。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>PrimeProducer</span> <span style=color:#204a87;font-weight:700>extends</span> <span style=color:#000>Thread</span> <span style=color:#ce5c00;font-weight:700>{</span>
  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>BlockingQueue</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>BigIngeger</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>queue</span><span style=color:#ce5c00;font-weight:700>;</span>
  
  <span style=color:#000>PrimeProducer</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>BlockingQueue</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>BitInteger</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>queue</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#204a87;font-weight:700>this</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>queue</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>queue</span><span style=color:#ce5c00;font-weight:700>;</span>
  <span style=color:#ce5c00;font-weight:700>}</span>
  
  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>run</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#204a87;font-weight:700>try</span> <span style=color:#ce5c00;font-weight:700>{</span>
      <span style=color:#000>BigInteger</span> <span style=color:#000>p</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>BigInteger</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>ONE</span><span style=color:#ce5c00;font-weight:700>;</span>
      <span style=color:#204a87;font-weight:700>while</span><span style=color:#ce5c00;font-weight:700>(!</span><span style=color:#000>Thread</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>currentThread</span><span style=color:#ce5c00;font-weight:700>().</span><span style=color:#c4a000>isInterrupted</span><span style=color:#ce5c00;font-weight:700>())</span>
        <span style=color:#000>queue</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>put</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>p</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#000>p</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>nexProbablePrime</span><span style=color:#ce5c00;font-weight:700>());</span>
    <span style=color:#ce5c00;font-weight:700>}</span> <span style=color:#204a87;font-weight:700>catch</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>InterruptedException</span> <span style=color:#000>ignore</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
      <span style=color:#8f5902;font-style:italic>// 允许线程退出
</span><span style=color:#8f5902;font-style:italic></span>    <span style=color:#ce5c00;font-weight:700>}</span>
  <span style=color:#ce5c00;font-weight:700>}</span>
  
  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>cancel</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span> <span style=color:#000>interrupt</span><span style=color:#ce5c00;font-weight:700>();</span> <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><h3 id=712-中断策略>7.1.2 中断策略</h3>
<p>正如任务中应该包含取消策略一样，线程同样应该包含中断策略。中断策略规定线程如何解释某个中断请求——当发现中断请求时，应该做哪些工作(如果需要的话)，哪些工作单元对于中断来说是原子操作，以及以多快的速度响应中断。</p>
<p>最合理的中断策略是某种形式的线程级取消操作或服务级取消操作：尽快退出，在必要时进行清理，通知某个所有者该线程已经退出。此外还可以建立其他的中断策略，例如暂停服务或重新开始服务，但对于那些包含非标准中断策略的线程或线程池，只能用于能够知道这些策略的任务中。</p>
<p>区分任务和线程对中断的反应是很重要的。一个中断请求可以有一个或多个接收者——中断线程池中的工作者线程，同时意味着“取消工作者任务”和“关闭工作者线程”。</p>
<p>任务不会在其自己拥有的线程中执行，而是在某个服务(如线程池)拥有的线程中执行。对于非线程持有者的代码来说(如对于线程池而言，任何在线程池以外实现的代码)，应该小心的保存中断状态，这样拥有线程的代码才能对中断做出响应，即使“非所有者”代码也可以做出响应。(当你为一户人家打扫房间时，即使主人不在，也不应该把这段时间内收到的邮件扔掉，而应该把邮件收起来，等主人回来后再交给他们处理，尽管你可以阅读他们的杂志)。</p>
<p>这既是为什么大多数可阻塞的库函数只是抛出 InterruptedException 作为终端响应。他们永远不会在某个由自己拥有的线程中运行，因此他们为任务或库代码实现了最合理的取消策略：尽快推出执行流程，并把中断信息传递给调用者，从而使调用栈中的上层代码可以采取进一步的操作。</p>
<p>当检查到中断请求时，任务并不需要放弃所有的操作——它可以推迟处理中断请求，并直到某个更合适的时刻。因此需要记住中断请求，并在完成当前任务后抛出 InterruptedException 或者表示已接收到中断请求。这项技术能够确保在更新过程中发生中断时，数据结构不会被破坏。</p>
<p>任务不应该对执行该任务的线程的中断策略做出任何假设，除非该任务被专门设计为在服务中运行，并且在这些服务中包含特定的中断策略。无论任务把中断视为取消，还是其他某个中断响应操作，都应该小心的保存执行线程的中断状态。如果出了将中断异常传递给调用者外还需要执行其他操作，那么应该在捕获中断异常之后恢复中断状态：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#000>Thread</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>currentThread</span><span style=color:#ce5c00;font-weight:700>().</span><span style=color:#c4a000>interrupt</span><span style=color:#ce5c00;font-weight:700>();</span>
</code></pre></div><p>正如任务代码不应该对其执行所在的线程的中断策略做出假设，执行取消操作的代码也不应该对线程的中断策略做出假设。线程应该只能由其所有者中断，所有者可以将线程的中断策略信息封装到某个合适的取消机制中，例如关闭方法。</p>
<blockquote>
<p>由于每个线程又有各自的中断策略，因此除非你知道中断对线程的含义，否在就不应该中断这个线程。</p>
</blockquote>
<p>批评者层嘲笑 Java 的中断功能，因为它没有提供抢占式中断机制，而且还强迫开发人员必须处理中断异常。然而，通过推迟中断请求的处理，开发人员能够制定更灵活的中断策略，从而使应用程序在响应性和健壮性之间实现合理的平衡。</p>
<h3 id=713-响应中断>7.1.3 响应中断</h3>
<p>在 5.4 节中，当调用可阻塞的阻塞函数式，例如 Thread.sleep 或 BlockingQueue.put 等，有两种实用策略可用于处理 InterruptedException：</p>
<ul>
<li>传递异常(可能在执行某个特定于任务的清除操作之后)，从而使你的方法也成为可中断的阻塞方法。</li>
<li>恢复中断状态，从而使调用栈的上层代码能够对其进行处理。</li>
</ul>
<p>传递中断异常与将中断异常添加到 throws 子句中一样容易，如程序清单 7-6 中的 getNextTask 所示。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#000>BlockingQueue</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>Task</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>queue</span><span style=color:#ce5c00;font-weight:700>;</span>
<span style=color:#ce5c00;font-weight:700>...</span>
<span style=color:#204a87;font-weight:700>public</span> <span style=color:#000>Task</span> <span style=color:#000>getNextTask</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#204a87;font-weight:700>throws</span> <span style=color:#000>InterruptedException</span> <span style=color:#ce5c00;font-weight:700>{</span>
  <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>queue</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>take</span><span style=color:#ce5c00;font-weight:700>();</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>如果不想或无法传递中断异常(或许通过 Runnable 来定义任务)，那么需要寻找一另一种方式来保存中断请求。一种标准的方法是通过再次调用 interrupt 来恢复中断状态。你不能屏蔽 InterruptedException，例如 catch 块中捕获到异常却不做任何处理，除非在你的代码中实现了线程的中断策略。虽然 PrimeProducer 屏蔽了中断，但这是因为它已经知道线程将要结束，因此在调用栈中已经没有上层代码需要知道中断信息。由于大多数代码并不知道它们将在哪个线程上运行，因此应该保存中断状态。</p>
<blockquote>
<p>只有实现了线程中断策略的代码才可以屏蔽中断请求。在常规的任务和库代码中都不应该屏蔽中断请求。</p>
</blockquote>
<p>对于一些不支持取消单仍可以调用阻塞方法的操作，他们必须在循环中调用这些方法，并在发现中断后重新尝试。在这种情况下，它们应该在本地保存中断状态，并在返回前恢复状态而不是在捕获中断异常时恢复状态，如程序清单 7-7 所示。如果过早的设置中断状态，就可能引起无限循环，因为大多数可中断的阻塞方法都会在入口检查中断状态，并且当返现该状态已被设置时会立即抛出 InterruptedException。(通常，可中断的方法会在阻塞或进行重要的工作前首先检查中断，从而尽快的响应中断)。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#204a87;font-weight:700>public</span> <span style=color:#000>Task</span> <span style=color:#000>getNextTask</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>BlockingQueue</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>Task</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>queue</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
  <span style=color:#204a87;font-weight:700>boolean</span> <span style=color:#000>interrupted</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>false</span><span style=color:#ce5c00;font-weight:700>;</span>
  <span style=color:#204a87;font-weight:700>try</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#204a87;font-weight:700>while</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>true</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
      <span style=color:#204a87;font-weight:700>try</span> <span style=color:#ce5c00;font-weight:700>{</span>
        <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>queue</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>take</span><span style=color:#ce5c00;font-weight:700>();</span>
      <span style=color:#ce5c00;font-weight:700>}</span> <span style=color:#204a87;font-weight:700>catch</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>InterruptedException</span> <span style=color:#000>e</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
        <span style=color:#000>interrupted</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>true</span><span style=color:#ce5c00;font-weight:700>;</span>
        <span style=color:#8f5902;font-style:italic>//重试
</span><span style=color:#8f5902;font-style:italic></span>      <span style=color:#ce5c00;font-weight:700>}</span>
    <span style=color:#ce5c00;font-weight:700>}</span>
  <span style=color:#ce5c00;font-weight:700>}</span> <span style=color:#204a87;font-weight:700>finally</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#204a87;font-weight:700>if</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>interrupted</span><span style=color:#ce5c00;font-weight:700>)</span>
      <span style=color:#000>Thread</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>currentThread</span><span style=color:#ce5c00;font-weight:700>().</span><span style=color:#c4a000>interrupt</span><span style=color:#ce5c00;font-weight:700>();</span>
  <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>如果代码不会调用可中断的阻塞方法，那么仍然可以通过在任务代码中轮询当前线程的中断状态来响应中断。要选择合适的轮询频率，就需要在效率和响应性之间进行权衡。如果响应性要求较高，那么不应该调用那些执行时间较长并且不影响中断的方法，从而对可调用的库代码进行一些限制。</p>
<p>在取消过程中可能涉及中断状态之外的其他状态。中断可以用来获得线程的注意，并且由中断线程保存的信息，可以为中断的线程提供进一步的指示。(当访问这些信息时，要确保使用同步)</p>
<p>例如，当一个由 ThreadPoolExecutor 拥有的工作线程检测到中断时，它会检查线程是否正在关闭。如果是，它会在结束前执行一些线程池清理工作，否则它可能创建一个新线程以将线程池恢复到合理的规模。</p>
<h3 id=714-示例计时运行>7.1.4 示例：计时运行</h3>
<p>许多问题永远也无法解决(如枚举所有的素数)，而某些问题，能很快得到答案，也可能永远得不到答案。在这些情况下，如果能够指定“最多花10分钟搜索答案”或者“枚举出在 10 分钟内能找到的答案”，那么将是非常有用的。</p>
<p>程序清单 7-2 中的 aSecondOfPrimes 方法将启动一个 PrimeGenerator，并在 1 秒钟后中断。尽管 PrimeGenerator 可能需要超过 1 秒钟的时间才能停止，但它最终会发现中断，然后停止，并使线程结束。在执行任务时的另一个方面是，你希望知道在任务执行过程中是否会抛出异常。如果 PrimeGenerator 在指定时限内抛出了一个未检异常，那么这个异常可能会被忽略，因为素数生成器在另一个独立的线程中运行，而这个线程并不会显式的处理异常。</p>
<p>在程序清单 7-8 中给出了在指定时间内运行一个任意的 Runnable 的示例。它在调用线程中运行任务，并安排了一个取消任务，在运行指定的时间间隔后中断它。这解决了从任务中抛出未检查异常的问题，因为该异常会被 timedRun 的调用者捕获。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>static</span> <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>ScheduledExecutorService</span> <span style=color:#000>cancelExec</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#ce5c00;font-weight:700>...;</span>

<span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>static</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>timedRun</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>Runnable</span> <span style=color:#000>r</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#204a87;font-weight:700>long</span> <span style=color:#000>timeout</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>TimeUnit</span> <span style=color:#000>unit</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
  <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>Thread</span> <span style=color:#000>taskThread</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>Thread</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>currentThread</span><span style=color:#ce5c00;font-weight:700>();</span>
  <span style=color:#000>cancelExec</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>schedule</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>Runnable</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>run</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span>
      <span style=color:#000>taskThread</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>interrupt</span><span style=color:#ce5c00;font-weight:700>();</span>
    <span style=color:#ce5c00;font-weight:700>}</span>
  <span style=color:#ce5c00;font-weight:700>},</span> <span style=color:#000>timeout</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>unit</span><span style=color:#ce5c00;font-weight:700>);</span>
  <span style=color:#000>r</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>run</span><span style=color:#ce5c00;font-weight:700>();</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>这是一种非常简单的方法，但却破坏了以下原则：在中断线程之前，应该了解它的中断策略。由于 TimeRun 可以从任意一个线程中调用，因此它无法找到这个调用线程的中断策略。如果任务在超时之前完成，那么中断 timedRun 所在线程的取消任务将在 tumedRun 返回到调用者之后启动。我们不知道在这种情况下将运行什么代码，但结果一定不是好的。(可以使用 schedule 返回的 ScheduleFuture 来取消这个取消任务以避免这种风险，这种做法虽然可行，但却非常复杂)</p>
<p>而且，如果任务不响应中断，那么 timedRun 会在任务结束时才返回，此时可能已经超过了指定的时限(或者尚未超过时限)。如果某个限时运行的服务没有在指定时间内返回，那么将对调用者带来负面影响。</p>
<p>在程序清单 7-9 中解决了 aSecondOfPrimes 的异常处理问题以及之前解决方案中的问题。执行任务的线程拥有自己的执行策略，即使任务不响应中断，限时运行的方法仍能返回到它的调用者。在启动任务线程之后，timedRun 将执行一个限时的 join 方法。在 join 返回后，它将检查任务中是否有异常抛出，如果有的话，则会在调用 timedRun 的线程中再次抛出该异常。由于 Throwable 将在两个线程之间共享，因此该变量被声明为 volatile 类型，从而确保线程安全的将其从任务线程中发布到 timedRun 线程。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>static</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>timedRun</span><span style=color:#ce5c00;font-weight:700>(</span>
  <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>Runnable</span> <span style=color:#000>r</span><span style=color:#ce5c00;font-weight:700>,</span>
  <span style=color:#204a87;font-weight:700>long</span> <span style=color:#000>timeout</span><span style=color:#ce5c00;font-weight:700>,</span> 
  <span style=color:#000>TimeUnit</span> <span style=color:#000>unit</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#204a87;font-weight:700>throws</span> <span style=color:#000>InterruptedException</span> <span style=color:#ce5c00;font-weight:700>{</span> 
  <span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>RethrowableTask</span> <span style=color:#204a87;font-weight:700>implements</span> <span style=color:#000>Runnable</span> <span style=color:#ce5c00;font-weight:700>{</span> 
    <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>volatile</span> <span style=color:#000>Throwable</span> <span style=color:#000>t</span><span style=color:#ce5c00;font-weight:700>;</span> 
    <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>run</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span> 
      <span style=color:#204a87;font-weight:700>try</span> <span style=color:#ce5c00;font-weight:700>{</span> <span style=color:#000>r</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>run</span><span style=color:#ce5c00;font-weight:700>();</span> <span style=color:#ce5c00;font-weight:700>}</span> 
      <span style=color:#204a87;font-weight:700>catch</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>Throwable</span> <span style=color:#000>t</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span> <span style=color:#204a87;font-weight:700>this</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>t</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>t</span><span style=color:#ce5c00;font-weight:700>;</span> <span style=color:#ce5c00;font-weight:700>}</span> 
    <span style=color:#ce5c00;font-weight:700>}</span> 
    
    <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>rethrow</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span> 
      <span style=color:#204a87;font-weight:700>if</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>t</span> <span style=color:#ce5c00;font-weight:700>!=</span> <span style=color:#204a87;font-weight:700>null</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#204a87;font-weight:700>throw</span> <span style=color:#000>launderThrowable</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>t</span><span style=color:#ce5c00;font-weight:700>);</span> 
    <span style=color:#ce5c00;font-weight:700>}</span>
  <span style=color:#ce5c00;font-weight:700>}</span>

  <span style=color:#000>RethrowableTask</span> <span style=color:#000>task</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>RethrowableTask</span><span style=color:#ce5c00;font-weight:700>();</span> 
  <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>Thread</span> <span style=color:#000>taskThread</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>Thread</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>task</span><span style=color:#ce5c00;font-weight:700>);</span> 
  <span style=color:#000>taskThread</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>start</span><span style=color:#ce5c00;font-weight:700>();</span> 
  <span style=color:#000>cancelExec</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>schedule</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>Runnable</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span> 
    <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>run</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span> 
      <span style=color:#000>taskThread</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>interrupt</span><span style=color:#ce5c00;font-weight:700>();</span> 
    <span style=color:#ce5c00;font-weight:700>},</span> <span style=color:#000>timeout</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>unit</span><span style=color:#ce5c00;font-weight:700>);</span> 
  <span style=color:#000>taskThread</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>join</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>unit</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>toMillis</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>timeout</span><span style=color:#ce5c00;font-weight:700>));</span> 
  <span style=color:#000>task</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>rethrow</span><span style=color:#ce5c00;font-weight:700>();</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>在这个示例代码中解决了前面示例中的问题，但由于它依赖于一个限时的 join，因此存在着 join 的不足：无法知道执行控制是因为线程正常退出而返回还是因为 join 超时而返回。</p>
<h3 id=715-通过-future-实现取消>7.1.5 通过 Future 实现取消</h3>
<p>我们已经使用了一种抽象机制来管理任务的生命周期、处理异常、实现取消，即 Future。通常，使用现有库中的类比自行编写更好，因此我们将继续使用 Future 和任务执行框架来构建 timedRun。</p>
<p>ExecutorService.submit 将返回一个 Future 来描述任务。Future 拥有一个 cancel 方法，该方法带有一个 boolean 类型的参数 mayInterruptIfRunning，表示取消操作是否成功。(这只是表示任务是否能够接收终端，而不是表示任务是否能检测并处理终端)。如果 mayInterruptIfRunning 为 true 并且任务当前正在某个线程中运行，那么这个线程能被中断，如果这个参数为 false，那么意味着“若任务还没有启动，就不要运行它”，这种方式应该用于那些不处理中断的任务中。</p>
<p>除非你清除线程的中断策略，否则不要中断线程，那么在什么情况下调用 cancel 可以将参数指定为 true 呢？执行任务的线程是由标准的 Executor 创建的，它实现了一种中断策略使得任务可以通过中断被取消，所以如果任务在标准 Executor 中运行，并通过它们的 Future 来取消任务，那么可以设置 mayInterruptIfRunning。当尝试取消某个任务时，不宜直接中断线程池，因为你并不知道当中断请求时要将中断视为一个取消请求的另一个理由：可以通过任务的 Future 来取消它们。</p>
<p>程序清单 7-10 给出了另一个版本的 timedRun：将任务提交给一个 ExecutorService，并通过一个定时的 Future.get 来获得结果。如果 get 在返回时抛出了一个 TimeoutException，那么任务将通过它的 Future 来取消。(为了简化代码，这个版本的 timeRun 在 finally 块中将直接调用 Future.cancel，因为取消一个已经完成的任务不会带来任何影响)。如果任务在被取消前就抛出一个异常，那么该异常将被重新抛出以便由调用者来处理。在程序清单 7-10 中还给出了另一种良好的编程习惯：取消那些不再需要结果的任务。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>static</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>timedRun</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>Runnable</span> <span style=color:#000>r</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#204a87;font-weight:700>long</span> <span style=color:#000>timeout</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>TimeUnit</span> <span style=color:#000>unit</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#204a87;font-weight:700>throws</span> <span style=color:#000>InterruptedException</span> <span style=color:#ce5c00;font-weight:700>{</span>
  <span style=color:#000>Future</span><span style=color:#ce5c00;font-weight:700>&lt;?&gt;</span> <span style=color:#000>task</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>taskExec</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>submit</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>r</span><span style=color:#ce5c00;font-weight:700>);</span>
  <span style=color:#204a87;font-weight:700>try</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#000>task</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>get</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>timeout</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>unit</span><span style=color:#ce5c00;font-weight:700>);</span>
  <span style=color:#ce5c00;font-weight:700>}</span> <span style=color:#204a87;font-weight:700>catch</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>TimeoutExcetion</span> <span style=color:#000>e</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#8f5902;font-style:italic>// 接下来任务将被取消
</span><span style=color:#8f5902;font-style:italic></span>  <span style=color:#ce5c00;font-weight:700>}</span> <span style=color:#204a87;font-weight:700>catch</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>ExecutionException</span> <span style=color:#000>e</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#8f5902;font-style:italic>// 如果在任务中抛出了异常，那么重新抛出该异常
</span><span style=color:#8f5902;font-style:italic></span>    <span style=color:#204a87;font-weight:700>throw</span> <span style=color:#000>launderThrowable</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>e</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>getCause</span><span style=color:#ce5c00;font-weight:700>());</span>
  <span style=color:#ce5c00;font-weight:700>}</span> <span style=color:#204a87;font-weight:700>finally</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#8f5902;font-style:italic>// 如果任务已经结束，执行取消操作不会带来任何影响
</span><span style=color:#8f5902;font-style:italic></span>    <span style=color:#8f5902;font-style:italic>// 如果任务正在运行，那么将被中断
</span><span style=color:#8f5902;font-style:italic></span>    <span style=color:#000>task</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>cancel</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>true</span><span style=color:#ce5c00;font-weight:700>);</span>
  <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><blockquote>
<p>当 Future.get 抛出中断或超时异常时，如果你知道不再需要结果，那么就可以调用 Future.cancel 来取消任务。</p>
</blockquote>
<h3 id=716-处理不可中断的阻塞>7.1.6 处理不可中断的阻塞</h3>
<p>在 Java 库中，许多阻塞的方法都是通过提前返回或抛出中断异常来响应中断请求的，从而使开发人员更容易构建出能够响应取消请求的任务。然而，并非所有的可阻塞方法或者阻塞机制都能够响应中断：如果一个线程由于执行同步的 Socket IO 或者等待获得内置锁而阻塞，那么中断请求只能设置线程的中断状态，除此之外没有其他任何作用。对于那些由于执行不可中断操作而被阻塞的线程，可以使用类似于中断的手段来停止这些线程，但这要求我们必须知道线程阻塞的原因。</p>
<p><strong>Java.io 包中的同步 Socket IO</strong>，在服务器应用中，最常见的 IO 形式就是对套接字进行读写，虽然 InputStream 和 OutputStream 中的 read 和 write 等方法都不会响应中断，但通过关闭底层的套接字，可以使得由于执行 read 或 write 等方法而被阻塞的线程抛出一个 SocketException。</p>
<p><strong>Java.io 包中的同步 IO</strong>，当中断一个正在 InterruptibleChannel 上等待的线程时，将抛出 ClosedByInterruptException 并关闭链路(这还会使得其他在这条链路上阻塞的线程同样抛出该异常)。当关闭一个 InterruptibleChannel 时，将导致所有在链路操作上阻塞的线程都抛出 AsynchronousCloseException。大多数标准的 Channel 都实现了 InterruptibleChannel。</p>
<p><strong>Selector 的异步 IO</strong>，如果一个线程在调用 Selector.select 方法时阻塞了，那么调用 close 或 wakeup 方法会使线程抛出 ClosedSelectorException 并提前返回。</p>
<p><strong>获取某个锁</strong>，如果一个线程由于等待某个内置锁而阻塞，那么将无法响应中断，因为线程任务它肯定会获得锁，所以不会理会中断请求。但是，在 Lock 类中提供了 lockInterruptibly 方法，该方法允许在等待一个锁的同时仍能响应中断，请参见第 13 章。</p>
<p>程序清单 7-11 的 ReaderThread 给出了如何封装非标准的取消操作。ReaderThread 管理了一个套接字连接，它采用同步方式从该套接字中读取数据，并将接收到的数据传递给 processBuffer。为了结束某个用户的连接或者关闭服务器，ReaderThread 改写了 interrupt 方法，使其既能处理标准的中断，也能关闭底层的套接字。因此，无论 ReaderThread 线程是在 read 方法中阻塞还是在某个可中断的阻塞方法中阻塞，都可以被中断并停止执行当前的工作。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>ReaderThread</span> <span style=color:#204a87;font-weight:700>extends</span> <span style=color:#000>Thread</span> <span style=color:#ce5c00;font-weight:700>{</span>
  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>Socket</span> <span style=color:#000>socket</span><span style=color:#ce5c00;font-weight:700>;</span>
  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>InputStream</span> <span style=color:#000>in</span><span style=color:#ce5c00;font-weight:700>;</span>
  
  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#000>ReaderThread</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>Socket</span> <span style=color:#000>socket</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#204a87;font-weight:700>throws</span> <span style=color:#000>IOException</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#204a87;font-weight:700>this</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>socket</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>socket</span><span style=color:#ce5c00;font-weight:700>;</span>
    <span style=color:#204a87;font-weight:700>this</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>in</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>socket</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>getInputStream</span><span style=color:#ce5c00;font-weight:700>();</span>
  <span style=color:#ce5c00;font-weight:700>}</span>
  
  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>interrupt</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#204a87;font-weight:700>try</span> <span style=color:#ce5c00;font-weight:700>{</span>
      <span style=color:#000>socket</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>close</span><span style=color:#ce5c00;font-weight:700>();</span>
    <span style=color:#ce5c00;font-weight:700>}</span> 
    <span style=color:#204a87;font-weight:700>catch</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>IOException</span> <span style=color:#000>ignored</span><span style=color:#ce5c00;font-weight:700>){}</span>
    <span style=color:#204a87;font-weight:700>finally</span> <span style=color:#ce5c00;font-weight:700>{</span>
      <span style=color:#204a87;font-weight:700>super</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>interrupt</span><span style=color:#ce5c00;font-weight:700>();</span>
    <span style=color:#ce5c00;font-weight:700>}</span>
  <span style=color:#ce5c00;font-weight:700>}</span>
  
  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>run</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#204a87;font-weight:700>try</span> <span style=color:#ce5c00;font-weight:700>{</span>
      <span style=color:#204a87;font-weight:700>byte</span><span style=color:#ce5c00;font-weight:700>[]</span> <span style=color:#000>buf</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#204a87;font-weight:700>byte</span><span style=color:#ce5c00;font-weight:700>[</span><span style=color:#000>BUFSZ</span><span style=color:#ce5c00;font-weight:700>];</span>
      <span style=color:#204a87;font-weight:700>while</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>true</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
        <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>count</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>in</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>read</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>buf</span><span style=color:#ce5c00;font-weight:700>);</span>
        <span style=color:#204a87;font-weight:700>if</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>count</span> <span style=color:#ce5c00;font-weight:700>&lt;</span> <span style=color:#000>0</span><span style=color:#ce5c00;font-weight:700>)</span>
          <span style=color:#204a87;font-weight:700>break</span><span style=color:#ce5c00;font-weight:700>;</span>
        <span style=color:#204a87;font-weight:700>else</span> <span style=color:#204a87;font-weight:700>if</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>count</span> <span style=color:#ce5c00;font-weight:700>&gt;</span><span style=color:#000>0</span><span style=color:#ce5c00;font-weight:700>)</span>
          <span style=color:#000>pricessBuffer</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>buf</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>count</span><span style=color:#ce5c00;font-weight:700>);</span>
      <span style=color:#ce5c00;font-weight:700>}</span>
    <span style=color:#ce5c00;font-weight:700>}</span> <span style=color:#204a87;font-weight:700>catch</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>IOException</span> <span style=color:#000>e</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
      <span style=color:#8f5902;font-style:italic>// 允许线程退出
</span><span style=color:#8f5902;font-style:italic></span>    <span style=color:#ce5c00;font-weight:700>}</span>
  <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><h3 id=717-采用-newtaskfor-来封装非标准的取消>7.1.7 采用 newTaskFor 来封装非标准的取消</h3>
<p>我们可以通过 newTaskFor 方法来进一步优化 ReaderThread 中封装非标准取消的技术，这是 Java 6 在 ThreadPoolExecutor 中的新增功能。当把一个 Callable 提交给 ExecutorService 时，sunbmit 方法会返回一个 Future，我们可以通过这个 Future 来取消任务。newTaskFor 是一个工厂方法，它将创建 Future 来代表任务。newTaskFor 还能返回一个 RunnableFuture 接口，该接口扩展了 Future 和 Runnable(并由 FutureTask 实现)。</p>
<p>通过定制表示任务的 Future 可以改变 Future.cancel 的行为。例如，定制的取消代码可以实现日志记录或者收集取消操作的统计信息，以及取消一个写不响应中断的操作。通过改写 inturrupt 方法，ReaderThread 可以取消基于套接字的线程。同样，通过改写任务的 Future.cancel 方法可以实现类似的功能。</p>
<p>在程序清单 7-12 的 CancellableTask 中定义一个 CancellableTask 接口，该接口扩展了 Callable，并增加了一个 cancel 方法和一个 newTask 工厂方法来构造 RunnableFuture。cancellingExecutor 扩展了 ThreadPoolExecutor，并通过改写 newTaskFor 使得 CancellableTask 可以创建自己的 Future。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>interface</span> <span style=color:#000>CancellableTask</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>T</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#204a87;font-weight:700>extends</span> <span style=color:#000>Callable</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>T</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#ce5c00;font-weight:700>{</span> 
  <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>cancel</span><span style=color:#ce5c00;font-weight:700>();</span> 
  <span style=color:#000>RunnableFuture</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>T</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>newTask</span><span style=color:#ce5c00;font-weight:700>();</span> 
<span style=color:#ce5c00;font-weight:700>}</span>

<span style=color:#5c35cc;font-weight:700>@ThreadSafe</span> 
<span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>CancellingExecutor</span> <span style=color:#204a87;font-weight:700>extends</span> <span style=color:#000>ThreadPoolExecutor</span> <span style=color:#ce5c00;font-weight:700>{</span>
  <span style=color:#ce5c00;font-weight:700>...</span>

  <span style=color:#204a87;font-weight:700>protected</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>T</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>RunnableFuture</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>T</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>newTaskFor</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>Callable</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>T</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>callable</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
  <span style=color:#204a87;font-weight:700>if</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>callable</span> <span style=color:#204a87;font-weight:700>instanceof</span> <span style=color:#000>CancellableTask</span><span style=color:#ce5c00;font-weight:700>)</span> 
    <span style=color:#204a87;font-weight:700>return</span> <span style=color:#ce5c00;font-weight:700>((</span><span style=color:#000>CancellableTask</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>T</span><span style=color:#ce5c00;font-weight:700>&gt;)</span> <span style=color:#000>callable</span><span style=color:#ce5c00;font-weight:700>).</span><span style=color:#c4a000>newTask</span><span style=color:#ce5c00;font-weight:700>();</span>
  <span style=color:#204a87;font-weight:700>else</span> <span style=color:#204a87;font-weight:700>return</span> <span style=color:#204a87;font-weight:700>super</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>newTaskFor</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>callable</span><span style=color:#ce5c00;font-weight:700>);</span>
  <span style=color:#ce5c00;font-weight:700>}</span> 
<span style=color:#ce5c00;font-weight:700>}</span>

<span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>abstract</span> <span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>SocketUsingTask</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>T</span><span style=color:#ce5c00;font-weight:700>&gt;</span> 
  <span style=color:#204a87;font-weight:700>implements</span> <span style=color:#000>CancellableTask</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>T</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#ce5c00;font-weight:700>{</span> 
  <span style=color:#5c35cc;font-weight:700>@GuardedBy</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#4e9a06>&#34;this&#34;</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#204a87;font-weight:700>private</span> <span style=color:#000>Socket</span> <span style=color:#000>socket</span><span style=color:#ce5c00;font-weight:700>;</span>
  
  <span style=color:#204a87;font-weight:700>protected</span> <span style=color:#204a87;font-weight:700>synchronized</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>setSocket</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>Socket</span> <span style=color:#000>s</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span> 
    <span style=color:#000>socket</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>s</span><span style=color:#ce5c00;font-weight:700>;</span> 
  <span style=color:#ce5c00;font-weight:700>}</span>

  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>synchronized</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>cancel</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span> 
    <span style=color:#204a87;font-weight:700>try</span> <span style=color:#ce5c00;font-weight:700>{</span> 
      <span style=color:#204a87;font-weight:700>if</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>socket</span> <span style=color:#ce5c00;font-weight:700>!=</span> <span style=color:#204a87;font-weight:700>null</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#000>socket</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>close</span><span style=color:#ce5c00;font-weight:700>();</span>
    <span style=color:#ce5c00;font-weight:700>}</span> <span style=color:#204a87;font-weight:700>catch</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>IOException</span> <span style=color:#000>ignored</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span> <span style=color:#ce5c00;font-weight:700>}</span> 
  <span style=color:#ce5c00;font-weight:700>}</span>

  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#000>RunnableFuture</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>T</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>newTask</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#204a87;font-weight:700>return</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>FutureTask</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>T</span><span style=color:#ce5c00;font-weight:700>&gt;(</span><span style=color:#204a87;font-weight:700>this</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span> 
      <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>boolean</span> <span style=color:#000>cancel</span><span style=color:#ce5c00;font-weight:700>(</span>
        <span style=color:#204a87;font-weight:700>boolean</span> <span style=color:#000>mayInterruptIfRunning</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span> 
        <span style=color:#204a87;font-weight:700>try</span> <span style=color:#ce5c00;font-weight:700>{</span> <span style=color:#000>SocketUsingTask</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>this</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>cancel</span><span style=color:#ce5c00;font-weight:700>();</span> <span style=color:#ce5c00;font-weight:700>}</span> 
        <span style=color:#204a87;font-weight:700>finally</span> <span style=color:#ce5c00;font-weight:700>{</span> 
          <span style=color:#204a87;font-weight:700>return</span> <span style=color:#204a87;font-weight:700>super</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>cancel</span><span style=color:#ce5c00;font-weight:700>(</span>
            <span style=color:#000>mayInterruptIfRunning</span><span style=color:#ce5c00;font-weight:700>);</span> 
        <span style=color:#ce5c00;font-weight:700>}</span> 
      <span style=color:#ce5c00;font-weight:700>}</span> 
    <span style=color:#ce5c00;font-weight:700>};</span>
  <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>SocketUsingTask 实现了 CancellTask，并定义了 Future.cancel 来关闭套接字和调用 super.cancel。如果 SocketUsingTask 通过自己的 Future 来取消，那么底层的套接字将被关闭且线程将被中断。因此它提高了任务对取消操作的响应性：不仅能够在调用可中断方法的同时确保响应取消操作，而且还能调用可阻塞的套接字 IO 方法。</p>
<h2 id=72-停止基于线程的服务>7.2 停止基于线程的服务</h2>
<p>应用程序通常会创建拥有多个线程的服务，比如线程池，并且这些服务的生命周期通常比创建它们的方法的生命周期要长。如果应用程序准备退出，那么这些服务所拥有的线程也需要结束。由于服务通过抢占式的方法来停止线程，因此它们需要自行结束。</p>
<p>正确的封装原则是：除非拥有某个线程，否则不能对该线程继续操控。例如，中断线程或者修改线程的优先级。在线程 API 中，并没有对线程所有权给出正式的定义：线程由 Thread 对象表示，并且像其他对象一样可以被自由共享。然而，线程有一个相应的所有者，即创建该线程的类。因此线程池是其工作者线程的所有者，如果要中断这些线程，那么应该使用线程池。</p>
<p>与其他封装对象一样，线程的所有权是不可传递的：应用程序可以拥有服务，服务也可以拥有工作者线程，但应用程序并不能拥有工作者线程，因此应用程序不能直接停止工作者线程。相反，服务应该提供生命周期方法来关闭它自己以及他所拥有的线程。这样，当应用程序关闭该服务时，服务就可以关闭所有的线程了。在 ExecutorService 中提供了 shutdown 和 shutdownNow 等方法。同样，在其他拥有线程的服务中也应该提供类似的关闭机制。</p>
<blockquote>
<p>对于持有线程的服务，只要服务的存在时间大于创建线程的方法存在的时间，那么久应该提供生命周期方法。</p>
</blockquote>
<h3 id=示例日志服务>示例：日志服务</h3>
<p>在大多数服务器应该程序中都会用到日志，例如，在代码中插入 pringln 语句就是一种简单的日志。像 PrintWriter 这样的字符流是线程安全的，因此这种简单的方法不需要显式的同步。然而，在 11.6 节中，我们将看到这种内联日志功能会给一些高容量的应用程序带来一定的性能开销。另外一种替代方法是通过调用 log 方法将日志消息放入某个队列中，并由其他线程来处理。</p>
<p>在程序清单 7-13 的 LogWriter 中给出了一个简单的日志服务示例，其中日志操作在单独的日志线程中执行。产生日志消息的线程并不会将消息直接写入输出流，而是由 LogWriter 通过 BlockingQueue 将消息提交给日志线程，并由日志线程写入。这是一种多生产者单消费者的设计方式：每个调用 log 的操作相当于一个生产者，而后台的日志线程相当于消费者。如果消费者的处理速度低于生产者的生产速度，那么 BlockingQueue 将阻塞生产者，直到日志线程有能力处理新的日志消息。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>LogWriter</span> <span style=color:#ce5c00;font-weight:700>{</span>
  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>BlockingQueue</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>String</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>queue</span><span style=color:#ce5c00;font-weight:700>;</span> 
  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>LoggerThread</span> <span style=color:#000>logger</span><span style=color:#ce5c00;font-weight:700>;</span>

  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#000>LogWriter</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>Writer</span> <span style=color:#000>writer</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span> 
    <span style=color:#204a87;font-weight:700>this</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>queue</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>LinkedBlockingQueue</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>String</span><span style=color:#ce5c00;font-weight:700>&gt;(</span><span style=color:#000>CAPACITY</span><span style=color:#ce5c00;font-weight:700>);</span> 
    <span style=color:#204a87;font-weight:700>this</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>logger</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>LoggerThread</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>writer</span><span style=color:#ce5c00;font-weight:700>);</span> 
  <span style=color:#ce5c00;font-weight:700>}</span>

  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>start</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span> <span style=color:#000>logger</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>start</span><span style=color:#ce5c00;font-weight:700>();</span> <span style=color:#ce5c00;font-weight:700>}</span>

  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>log</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>String</span> <span style=color:#000>msg</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#204a87;font-weight:700>throws</span> <span style=color:#000>InterruptedException</span> <span style=color:#ce5c00;font-weight:700>{</span> 
    <span style=color:#000>queue</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>put</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>msg</span><span style=color:#ce5c00;font-weight:700>);</span> 
  <span style=color:#ce5c00;font-weight:700>}</span>

  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>LoggerThread</span> <span style=color:#204a87;font-weight:700>extends</span> <span style=color:#000>Thread</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>PrintWriter</span> <span style=color:#000>writer</span><span style=color:#ce5c00;font-weight:700>;</span> 
    <span style=color:#ce5c00;font-weight:700>...</span>
    <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>run</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span> 
      <span style=color:#204a87;font-weight:700>try</span> <span style=color:#ce5c00;font-weight:700>{</span> 	
        <span style=color:#204a87;font-weight:700>while</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>true</span><span style=color:#ce5c00;font-weight:700>)</span> 
          <span style=color:#000>writer</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>println</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>queue</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>take</span><span style=color:#ce5c00;font-weight:700>());</span> 
      <span style=color:#ce5c00;font-weight:700>}</span> <span style=color:#204a87;font-weight:700>catch</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>InterruptedException</span> <span style=color:#000>ignored</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span> <span style=color:#ce5c00;font-weight:700>}</span> 
      <span style=color:#204a87;font-weight:700>finally</span> <span style=color:#ce5c00;font-weight:700>{</span> <span style=color:#000>writer</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>close</span><span style=color:#ce5c00;font-weight:700>();</span> <span style=color:#ce5c00;font-weight:700>}</span> 
    <span style=color:#ce5c00;font-weight:700>}</span>
  <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>为了使像 LogWriter 这样的服务在软件产品中发挥实际的作用，还需要实现一种终止日志线程的方法，从而避免使 JVM 无法正常关闭。要停止日志线程是很容易的，因为他会反复调用 take，而 take 能响应中断。如果将日志线程修改为当捕获到 InterruptedException 时推出，那么只需中断日志线程就能停止服务。</p>
<p>然而，如果只是日志线程推出，那么还不是一种完备的关闭机制。这种直接关闭的做法会丢失那些正在等待被写入日志的信息，不仅如此，其他线程将在调用 log 时被阻塞，因为日志队列是满的，因此这些线程将无法解除阻塞状态。当取消一个生产者消费者操作时，需要同时取消生产者和消费者。在中断日志线程时会处理消费者，但在这个示例中，由于生产者并不是专门的线程，因此要取消它们非常困难。</p>
<p>另一种关闭 LogWriter 的方式是，设置某个“已请求关闭”标志，以避免进一步提交日志消息，如程序清单 7-14 所示。在收到关闭请求后，消费者会把队列中的所有消息写入日志，并解除所有在调用 log 时阻塞的生产者。然而，在这个方法中存在竟态条件，使得该方法并不可靠。log 的实现是一种“先判断再运行”的代码序列：生产者发现该服务还没有关闭，因此在关闭服务后仍然会将日志消费放入队列，这同样会使得生产者可能在调用 log 时阻塞并且无法解除阻塞状态。可以通过一些技巧来降低这种情况的发生概率(比如在宣布队列被清空之前，让消费者等待数秒钟)，但这都没有解决问题的本质，即使很小的概率也可能导致程序故障。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>log</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>String</span> <span style=color:#000>msg</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#204a87;font-weight:700>throws</span> <span style=color:#000>InterruptedException</span> <span style=color:#ce5c00;font-weight:700>{</span>
  <span style=color:#204a87;font-weight:700>if</span><span style=color:#ce5c00;font-weight:700>(!</span><span style=color:#000>shutdownRequested</span><span style=color:#ce5c00;font-weight:700>)</span>
    <span style=color:#000>queue</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>put</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>msg</span><span style=color:#ce5c00;font-weight:700>);</span>
  <span style=color:#204a87;font-weight:700>else</span>
    <span style=color:#204a87;font-weight:700>throw</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>IllegalStateException</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#4e9a06>&#34;logger is shutdown&#34;</span><span style=color:#ce5c00;font-weight:700>);</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>为 LogWriter 提供可靠关闭操作的方法是解决静态条件问题，因为要使日志消息的提交操作称为原子操作。然而，我们不希望在消息加入队列时去持有一把锁，因为 put 方法本身就可以阻塞。我们采用的方法是：通过原子方式来检查关闭请求，并且有条件的递增一个计数器来“保持”提交消息的权利，如程序清单 7-15 中的 LogService 所示。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>LogService</span> <span style=color:#ce5c00;font-weight:700>{</span>
  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>BlockingQueue</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>String</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>queue</span><span style=color:#ce5c00;font-weight:700>;</span> 
  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>LoggerThread</span> <span style=color:#000>loggerThread</span><span style=color:#ce5c00;font-weight:700>;</span> 
  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>PrintWriter</span> <span style=color:#000>writer</span><span style=color:#ce5c00;font-weight:700>;</span> 
  <span style=color:#5c35cc;font-weight:700>@GuardedBy</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#4e9a06>&#34;this&#34;</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>boolean</span> <span style=color:#000>isShutdown</span><span style=color:#ce5c00;font-weight:700>;</span>
  <span style=color:#5c35cc;font-weight:700>@GuardedBy</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#4e9a06>&#34;this&#34;</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>reservations</span><span style=color:#ce5c00;font-weight:700>;</span>

  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>start</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span> <span style=color:#000>loggerThread</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>start</span><span style=color:#ce5c00;font-weight:700>();</span> <span style=color:#ce5c00;font-weight:700>}</span>

  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>stop</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span> 
    <span style=color:#204a87;font-weight:700>synchronized</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>this</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span> <span style=color:#000>isShutdown</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>true</span><span style=color:#ce5c00;font-weight:700>;</span> <span style=color:#ce5c00;font-weight:700>}</span> 	
    <span style=color:#000>loggerThread</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>interrupt</span><span style=color:#ce5c00;font-weight:700>();</span> 
  <span style=color:#ce5c00;font-weight:700>}</span>

  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>log</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>String</span> <span style=color:#000>msg</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#204a87;font-weight:700>throws</span> <span style=color:#000>InterruptedException</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#204a87;font-weight:700>synchronized</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>this</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span> 
      <span style=color:#204a87;font-weight:700>if</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>isShutdown</span><span style=color:#ce5c00;font-weight:700>)</span> 
        <span style=color:#204a87;font-weight:700>throw</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>IllegalStateException</span><span style=color:#ce5c00;font-weight:700>(...);</span> 	
        <span style=color:#ce5c00;font-weight:700>++</span><span style=color:#000>reservations</span><span style=color:#ce5c00;font-weight:700>;</span> 
      <span style=color:#ce5c00;font-weight:700>}</span> 
      <span style=color:#000>queue</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>put</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>msg</span><span style=color:#ce5c00;font-weight:700>);</span> 
    <span style=color:#ce5c00;font-weight:700>}</span>

  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>LoggerThread</span> <span style=color:#204a87;font-weight:700>extends</span> <span style=color:#000>Thread</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>run</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span> 
      <span style=color:#204a87;font-weight:700>try</span> <span style=color:#ce5c00;font-weight:700>{</span> 
        <span style=color:#204a87;font-weight:700>while</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>true</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span> 
          <span style=color:#204a87;font-weight:700>try</span> <span style=color:#ce5c00;font-weight:700>{</span> 
            <span style=color:#204a87;font-weight:700>synchronized</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>this</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span> 
              <span style=color:#204a87;font-weight:700>if</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>isShutdown</span> <span style=color:#ce5c00;font-weight:700>&amp;&amp;</span> <span style=color:#000>reservations</span> <span style=color:#ce5c00;font-weight:700>==</span> <span style=color:#000>0</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#204a87;font-weight:700>break</span><span style=color:#ce5c00;font-weight:700>;</span> 
            <span style=color:#ce5c00;font-weight:700>}</span> 
            <span style=color:#000>String</span> <span style=color:#000>msg</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>queue</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>take</span><span style=color:#ce5c00;font-weight:700>();</span> 	
            <span style=color:#204a87;font-weight:700>synchronized</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>this</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span> <span style=color:#ce5c00;font-weight:700>--</span><span style=color:#000>reservations</span><span style=color:#ce5c00;font-weight:700>;</span> <span style=color:#ce5c00;font-weight:700>}</span> <span style=color:#000>writer</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>println</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>msg</span><span style=color:#ce5c00;font-weight:700>);</span> 
          <span style=color:#ce5c00;font-weight:700>}</span> <span style=color:#204a87;font-weight:700>catch</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>InterruptedException</span> <span style=color:#000>e</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span> 
            <span style=color:#8f5902;font-style:italic>/* retry*/</span> 
          <span style=color:#ce5c00;font-weight:700>}</span>
        <span style=color:#ce5c00;font-weight:700>}</span> 
      <span style=color:#ce5c00;font-weight:700>}</span> <span style=color:#204a87;font-weight:700>finally</span> <span style=color:#ce5c00;font-weight:700>{</span>
        <span style=color:#000>writer</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>close</span><span style=color:#ce5c00;font-weight:700>();</span> 
      <span style=color:#ce5c00;font-weight:700>}</span>
    <span style=color:#ce5c00;font-weight:700>}</span>
  <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><h3 id=722-关闭-executorservice>7.2.2 关闭 ExecutorService</h3>
<p>在 6.2.4 节中，我们看到 ExecutorService 提供了两种关闭方法：使用 shutdown 正常关闭，以及使用 shutdownNow 强行关闭。在进行强行关闭时，shutdownNow 首先关闭正在执行的任务，然后返回所有尚未启动的任务清单。</p>
<p>这两种关闭的方式的差别在于各自的安全性和响应性：强行关闭的速度更快，但风险也更大，因为任务很可能在执行到一半时被结束：而正常关闭虽然速度慢，但却更安全，因为 ExecutorService 会一直等到队列中的所有任务都执行完毕才关闭。在其他拥有线程的服务中也应该考虑提供类似的关闭方式以供选择。</p>
<p>简单的程序可以直接在 main 函数中启动和关闭全局的 ExecutorService。而在复杂程序中，通常会将 ExecutorService 封装在某个更高级别的服务中，并且该服务能提供自己的生命周期方法，例如程序清单 7-16 中 LogService 的一种变化形式，它将管理线程的工作委托给一个 ExecutorService，而不是由其自行管理。通过封装 ExecutorService，可以将所有权链(Ownership Chain)从应用程序扩展到服务以及线程，所有权链上的各个成员都将管理它拥有的服务或线程的生命周期。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>LogService</span> <span style=color:#ce5c00;font-weight:700>{</span>
  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>ExecutorService</span> <span style=color:#000>exec</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>newSingleThreadExecutor</span><span style=color:#ce5c00;font-weight:700>();</span>
  <span style=color:#ce5c00;font-weight:700>...</span>
  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>start</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{}</span>
  
  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>stop</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#204a87;font-weight:700>throws</span> <span style=color:#000>InterruptedException</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#204a87;font-weight:700>try</span> <span style=color:#ce5c00;font-weight:700>{</span>
      <span style=color:#000>exec</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>shutdown</span><span style=color:#ce5c00;font-weight:700>();</span>
      <span style=color:#000>exec</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>awaitTermination</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>TIMOUT</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>UNIT</span><span style=color:#ce5c00;font-weight:700>);</span>
    <span style=color:#ce5c00;font-weight:700>}</span> <span style=color:#204a87;font-weight:700>finally</span> <span style=color:#ce5c00;font-weight:700>{</span>
      <span style=color:#000>writer</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>close</span><span style=color:#ce5c00;font-weight:700>();</span>
    <span style=color:#ce5c00;font-weight:700>}</span>
  <span style=color:#ce5c00;font-weight:700>}</span>
  
  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>log</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>String</span> <span style=color:#000>msg</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#204a87;font-weight:700>try</span> <span style=color:#ce5c00;font-weight:700>{</span>
      <span style=color:#000>exec</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>execute</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>WriteTask</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>msg</span><span style=color:#ce5c00;font-weight:700>));</span>
    <span style=color:#ce5c00;font-weight:700>}</span> <span style=color:#204a87;font-weight:700>catch</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>RejectedExecutionException</span> <span style=color:#000>ignored</span><span style=color:#ce5c00;font-weight:700>){}</span>
  <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><h3 id=723-毒丸对象>7.2.3 “毒丸”对象</h3>
<p>另一种关闭生产者——消费者服务的方式是使用“毒丸(Poison Pill)”对象：毒丸是指一个放在队列中的对象，其含义是“当遇到这个对象时，立即停止”。在 FIFO 队列中，毒丸对象将确保消费者在关闭之前首先完成队列中的所有工作，在提交毒丸对象之前的所有工作都会被处理完毕，而生产者在提交了毒丸之后，将不会再生产任何工作。在程序清单 7-17、7-18、7-19 中给出了一个单生产者单消费者的桌面搜索示例，这个示例中使用了毒丸对象来关闭服务。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>IndexingService</span> <span style=color:#ce5c00;font-weight:700>{</span>
  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>static</span> <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>File</span> <span style=color:#000>POISON</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>File</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#4e9a06>&#34;&#34;</span><span style=color:#ce5c00;font-weight:700>);</span> 
  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>IndexerThread</span> <span style=color:#000>consumer</span> <span style=color:#ce5c00;font-weight:700>=</span> 
    <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>IndexerThread</span><span style=color:#ce5c00;font-weight:700>();</span> 
  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>CrawlerThread</span> <span style=color:#000>producer</span> <span style=color:#ce5c00;font-weight:700>=</span> 
    <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>CrawlerThread</span><span style=color:#ce5c00;font-weight:700>();</span> 
  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>BlockingQueue</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>File</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>queue</span><span style=color:#ce5c00;font-weight:700>;</span> 
  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>FileFilter</span> <span style=color:#000>fileFilter</span><span style=color:#ce5c00;font-weight:700>;</span> 
  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>File</span> <span style=color:#000>root</span><span style=color:#ce5c00;font-weight:700>;</span>

  <span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>CrawlerThread</span> <span style=color:#204a87;font-weight:700>extends</span> <span style=color:#000>Thread</span> <span style=color:#ce5c00;font-weight:700>{</span> <span style=color:#8f5902;font-style:italic>/* Listing 7.18 */</span> <span style=color:#ce5c00;font-weight:700>}</span>
  <span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>IndexerThread</span> <span style=color:#204a87;font-weight:700>extends</span> <span style=color:#000>Thread</span> <span style=color:#ce5c00;font-weight:700>{</span> <span style=color:#8f5902;font-style:italic>/* Listing 7.19 */</span> <span style=color:#ce5c00;font-weight:700>}</span>

  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>start</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span> 
    <span style=color:#000>producer</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>start</span><span style=color:#ce5c00;font-weight:700>();</span> 
    <span style=color:#000>consumer</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>start</span><span style=color:#ce5c00;font-weight:700>();</span> 
  <span style=color:#ce5c00;font-weight:700>}</span>

  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>stop</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span> 
    <span style=color:#000>producer</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>interrupt</span><span style=color:#ce5c00;font-weight:700>();</span> 
  <span style=color:#ce5c00;font-weight:700>}</span>

  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>awaitTermination</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#204a87;font-weight:700>throws</span> <span style=color:#000>InterruptedException</span> <span style=color:#ce5c00;font-weight:700>{</span> 
    <span style=color:#000>consumer</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>join</span><span style=color:#ce5c00;font-weight:700>();</span> 
  <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>CrawlerThread</span> <span style=color:#204a87;font-weight:700>extends</span> <span style=color:#000>Thread</span> <span style=color:#ce5c00;font-weight:700>{</span>
  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>run</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span> 
    <span style=color:#204a87;font-weight:700>try</span><span style=color:#ce5c00;font-weight:700>{</span>
      <span style=color:#000>crawl</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>root</span><span style=color:#ce5c00;font-weight:700>);</span>
    <span style=color:#ce5c00;font-weight:700>}</span> <span style=color:#204a87;font-weight:700>catch</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>InterruptedExcetion</span> <span style=color:#000>e</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span><span style=color:#8f5902;font-style:italic>/* fall through */</span><span style=color:#ce5c00;font-weight:700>}</span>
    <span style=color:#204a87;font-weight:700>finally</span> <span style=color:#ce5c00;font-weight:700>{</span>
      <span style=color:#204a87;font-weight:700>while</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>true</span><span style=color:#ce5c00;font-weight:700>){</span>
        <span style=color:#204a87;font-weight:700>try</span><span style=color:#ce5c00;font-weight:700>{</span>
          <span style=color:#000>queue</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>put</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>POISON</span><span style=color:#ce5c00;font-weight:700>);</span>
          <span style=color:#204a87;font-weight:700>break</span><span style=color:#ce5c00;font-weight:700>;</span>
        <span style=color:#ce5c00;font-weight:700>}</span> <span style=color:#204a87;font-weight:700>catch</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>InterruptedException</span> <span style=color:#000>e1</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span><span style=color:#8f5902;font-style:italic>/* retry */</span><span style=color:#ce5c00;font-weight:700>}</span>
      <span style=color:#ce5c00;font-weight:700>}</span>
    <span style=color:#ce5c00;font-weight:700>}</span>
  <span style=color:#ce5c00;font-weight:700>}</span>
  
  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>cawal</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>File</span> <span style=color:#000>root</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#204a87;font-weight:700>throws</span> <span style=color:#000>InterruptedException</span><span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#8f5902;font-style:italic>// ...
</span><span style=color:#8f5902;font-style:italic></span>  <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>IndexerThread</span> <span style=color:#204a87;font-weight:700>extends</span> <span style=color:#000>Thread</span> <span style=color:#ce5c00;font-weight:700>{</span>
  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>run</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#204a87;font-weight:700>try</span> <span style=color:#ce5c00;font-weight:700>{</span>
      <span style=color:#204a87;font-weight:700>while</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>true</span><span style=color:#ce5c00;font-weight:700>){</span>
        <span style=color:#000>File</span> <span style=color:#000>file</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>queue</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>take</span><span style=color:#ce5c00;font-weight:700>();</span>
        <span style=color:#204a87;font-weight:700>if</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>file</span> <span style=color:#ce5c00;font-weight:700>==</span> <span style=color:#000>POISON</span><span style=color:#ce5c00;font-weight:700>)</span>
          <span style=color:#204a87;font-weight:700>break</span><span style=color:#ce5c00;font-weight:700>;</span>
        <span style=color:#204a87;font-weight:700>else</span>
          <span style=color:#000>indexFile</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>file</span><span style=color:#ce5c00;font-weight:700>);</span>
      <span style=color:#ce5c00;font-weight:700>}</span>
    <span style=color:#ce5c00;font-weight:700>}</span> <span style=color:#204a87;font-weight:700>catch</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>InterruptedException</span> <span style=color:#000>consumed</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{}</span>
  <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>只有生产者和消费者都已知的情况下，才可以使用毒丸对象。在 IndexingService 中采用的解决方案可以扩展到多个生产者：只需要从每个生产者都向队列中放入一个毒丸对象，并且消费者仅当在接收到 N 个毒丸对象时才停止。这种方法也可也扩展到多个消费者的情况，只需生产者将 N 个毒丸对象放入队列。然而，当生产者和消费者的数量较大时，这种方法将变得难以使用。只有在无界队列中，毒丸对象才能可靠的工作。</p>
<h3 id=724-示例只执行一次的服务>7.2.4 示例：只执行一次的服务</h3>
<p>如果某个方法需要处理一批任务，并且当所有任务都处理完成后才返回，那么可以通过一个私有的 Executor 来简化服务的生命周期管理，其中该 Executor 的生命周期是由这个方法来控制的。(在这种情况下，invokeAll 和 invokeAny 等方法通常会起较大的作用)</p>
<p>程序清单 7-20 中的 checkMail 方法能在多台主机上并行的检查新邮件。它创建一个私有的 Executor，并向每台主机提交一个任务。然后，当所有邮件检查任务都执行完成后，关闭 Executor 并等待结束。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#204a87;font-weight:700>boolean</span> <span style=color:#000>checkMail</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>Set</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>String</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>hosts</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#204a87;font-weight:700>long</span> <span style=color:#000>timeout</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>TimeUnit</span> <span style=color:#000>unit</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#204a87;font-weight:700>throws</span> <span style=color:#000>InterruptedException</span> <span style=color:#ce5c00;font-weight:700>{</span>
  <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>AtomicBoolean</span> <span style=color:#000>hasNewMail</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>AtomicBoolean</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>false</span><span style=color:#ce5c00;font-weight:700>);</span>
  <span style=color:#204a87;font-weight:700>try</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#204a87;font-weight:700>for</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>String</span> <span style=color:#000>host</span> <span style=color:#ce5c00;font-weight:700>:</span> <span style=color:#000>hosts</span><span style=color:#ce5c00;font-weight:700>)</span>
      <span style=color:#000>exec</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>ececute</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>Runnable</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span>
        <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>run</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span>
          <span style=color:#204a87;font-weight:700>if</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>checkMail</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>host</span><span style=color:#ce5c00;font-weight:700>))</span>
            <span style=color:#000>hasNewMail</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>set</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>true</span><span style=color:#ce5c00;font-weight:700>);</span>
        <span style=color:#ce5c00;font-weight:700>}</span>
      <span style=color:#ce5c00;font-weight:700>});</span>
  <span style=color:#ce5c00;font-weight:700>}</span> <span style=color:#204a87;font-weight:700>finally</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#000>exec</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>shutdown</span><span style=color:#ce5c00;font-weight:700>();</span>
    <span style=color:#000>exec</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>awaitTermination</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>timeout</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>unit</span><span style=color:#ce5c00;font-weight:700>);</span>
  <span style=color:#ce5c00;font-weight:700>}</span>
  
  <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>hasNewMail</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>get</span><span style=color:#ce5c00;font-weight:700>();</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><h3 id=725-shutdownnow-的局限性>7.2.5 shutdownNow 的局限性</h3>
<p>当通过 shutdownNow 来强行关闭 ExecutorService 时，它会尝试取消正在执行的任务，并返回所有已提交但尚未开始的任务，从而将这些任务写入日志或者保存起来以便之后进行处理。</p>
<p>然而，我们无法通过常规方法来找出哪些任务已经开始但尚未结束。这意味着我们无法在关闭过程中知道正在执行的任务的状态，除非任务本身执行某种检查。要知道哪些任务还没有完成，你不仅需要知道那些任务还没有开始，还需要知道当 Executor 关闭时哪些任务正在执行。</p>
<p>在程序清单 7-21 的 TrackingExecutor 中给出了如何在关闭过程中判断正在执行的任务。通过封装 ExecutorService 并使得 execute (类似的还有 submit 等)记录哪些任务是在关闭后取消的，TackingExecutor 可以找出哪些任务已经开始但还没有正常完成。在 Executor 结束后，getCancelledTasks 返回被取消的任务清单。要使这项技术能发挥作用，任务在返回时必须维持线程的中断状态，在所有设计良好的任务中都会实现这个功能。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>TrackingExecutor</span> <span style=color:#204a87;font-weight:700>extends</span> <span style=color:#000>AbstractExecutorService</span> <span style=color:#ce5c00;font-weight:700>{</span>
  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>ExecutorService</span> <span style=color:#000>exec</span><span style=color:#ce5c00;font-weight:700>;</span>
  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>Set</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>Runnable</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>tasksCancelledAtShutdown</span> <span style=color:#ce5c00;font-weight:700>=</span> 
    <span style=color:#000>Collections</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>synchronizedSer</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>HashSet</span><span style=color:#ce5c00;font-weight:700>&lt;&gt;());</span>
  <span style=color:#ce5c00;font-weight:700>...</span>
  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#000>List</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>Runnable</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>getCancelledTasks</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#204a87;font-weight:700>if</span><span style=color:#ce5c00;font-weight:700>(!</span><span style=color:#000>exec</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>isTerminated</span><span style=color:#ce5c00;font-weight:700>())</span>
      <span style=color:#204a87;font-weight:700>throw</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>IllegalStateException</span><span style=color:#ce5c00;font-weight:700>();</span>
    <span style=color:#204a87;font-weight:700>return</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>ArrayList</span><span style=color:#ce5c00;font-weight:700>&lt;&gt;(</span><span style=color:#000>tasksCancelledAtShutdown</span><span style=color:#ce5c00;font-weight:700>);</span>
  <span style=color:#ce5c00;font-weight:700>}</span>
  
  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>execute</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>Runnable</span> <span style=color:#000>runnable</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#000>exec</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>execute</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>Runnable</span><span style=color:#ce5c00;font-weight:700>(){</span>
      <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>run</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span>
        <span style=color:#204a87;font-weight:700>try</span> <span style=color:#ce5c00;font-weight:700>{</span>
          <span style=color:#000>runnable</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>run</span><span style=color:#ce5c00;font-weight:700>();</span>
        <span style=color:#ce5c00;font-weight:700>}</span> <span style=color:#204a87;font-weight:700>finally</span> <span style=color:#ce5c00;font-weight:700>{</span>
          <span style=color:#204a87;font-weight:700>if</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>isShutdown</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>&amp;&amp;</span> 
          <span style=color:#000>Thread</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>currentThread</span><span style=color:#ce5c00;font-weight:700>().</span><span style=color:#c4a000>isInterrupted</span><span style=color:#ce5c00;font-weight:700>())</span>
            <span style=color:#000>tasksCancelledAtShutdown</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>add</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>runnable</span><span style=color:#ce5c00;font-weight:700>);</span>
        <span style=color:#ce5c00;font-weight:700>}</span>
      <span style=color:#ce5c00;font-weight:700>}</span>
    <span style=color:#ce5c00;font-weight:700>});</span>
  <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>在程序清单 7-22 的 WebCrawler 中给出了 TackingExecutor 的用法。网页爬虫的工作通常是无穷尽的，因此当爬虫程序必须关闭时，我们通常希望保存它的状态，以便稍后重新启动。CrawlerTask 提供了一个 getPage 方法，该方法能找出正在处理的页面。当爬虫程序关闭时，无论是还没有开始的任务，还是那些被取消的任务，多将记录它们的 URL，因此爬虫程序重新启动时，就可以将这些 URL 的页面抓取任务加入到任务队列中。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>abstract</span> <span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>WebCrawler</span> <span style=color:#ce5c00;font-weight:700>{</span>
  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>volatile</span> <span style=color:#000>TrackingExecutor</span> <span style=color:#000>exec</span><span style=color:#ce5c00;font-weight:700>;</span> 
  <span style=color:#5c35cc;font-weight:700>@GuardedBy</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#4e9a06>&#34;this&#34;</span><span style=color:#ce5c00;font-weight:700>)</span> 
  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>Set</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>URL</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>urlsToCrawl</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>HashSet</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>URL</span><span style=color:#ce5c00;font-weight:700>&gt;();</span> 
  <span style=color:#ce5c00;font-weight:700>...</span>

  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>synchronized</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>start</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#000>exec</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>TrackingExecutor</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>Executors</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>newCachedThreadPool</span><span style=color:#ce5c00;font-weight:700>());</span>

    <span style=color:#204a87;font-weight:700>for</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>URL</span> <span style=color:#000>url</span> <span style=color:#ce5c00;font-weight:700>:</span> <span style=color:#000>urlsToCrawl</span><span style=color:#ce5c00;font-weight:700>)</span> 
      <span style=color:#000>submitCrawlTask</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>url</span><span style=color:#ce5c00;font-weight:700>);</span>
      
    <span style=color:#000>urlsToCrawl</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>clear</span><span style=color:#ce5c00;font-weight:700>();</span> 
  <span style=color:#ce5c00;font-weight:700>}</span>

  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>synchronized</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>stop</span><span style=color:#ce5c00;font-weight:700>()</span> 
    <span style=color:#204a87;font-weight:700>throws</span> <span style=color:#000>InterruptedException</span> <span style=color:#ce5c00;font-weight:700>{</span> 
    <span style=color:#204a87;font-weight:700>try</span> <span style=color:#ce5c00;font-weight:700>{</span> 
      <span style=color:#000>saveUncrawled</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>exec</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>shutdownNow</span><span style=color:#ce5c00;font-weight:700>());</span> 
      <span style=color:#204a87;font-weight:700>if</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>exec</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>awaitTermination</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>TIMEOUT</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>UNIT</span><span style=color:#ce5c00;font-weight:700>))</span>
        <span style=color:#000>saveUncrawled</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>exec</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>getCancelledTasks</span><span style=color:#ce5c00;font-weight:700>());</span> 
    <span style=color:#ce5c00;font-weight:700>}</span> <span style=color:#204a87;font-weight:700>finally</span> <span style=color:#ce5c00;font-weight:700>{</span> 
      <span style=color:#000>exec</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>null</span><span style=color:#ce5c00;font-weight:700>;</span> 
    <span style=color:#ce5c00;font-weight:700>}</span> 
  <span style=color:#ce5c00;font-weight:700>}</span>

  <span style=color:#204a87;font-weight:700>protected</span> <span style=color:#204a87;font-weight:700>abstract</span> <span style=color:#000>List</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>URL</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>processPage</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>URL</span> <span style=color:#000>url</span><span style=color:#ce5c00;font-weight:700>);</span>

  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>saveUncrawled</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>List</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>Runnable</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>uncrawled</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span> 
    <span style=color:#204a87;font-weight:700>for</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>Runnable</span> <span style=color:#000>task</span> <span style=color:#ce5c00;font-weight:700>:</span> <span style=color:#000>uncrawled</span><span style=color:#ce5c00;font-weight:700>)</span> 	
      <span style=color:#000>urlsToCrawl</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>add</span><span style=color:#ce5c00;font-weight:700>(((</span><span style=color:#000>CrawlTask</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#000>task</span><span style=color:#ce5c00;font-weight:700>).</span><span style=color:#c4a000>getPage</span><span style=color:#ce5c00;font-weight:700>());</span> 
  <span style=color:#ce5c00;font-weight:700>}</span> 
  
  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>submitCrawlTask</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>URL</span> <span style=color:#000>u</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span> 
    <span style=color:#000>exec</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>execute</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>CrawlTask</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>u</span><span style=color:#ce5c00;font-weight:700>));</span> 
  <span style=color:#ce5c00;font-weight:700>}</span> 
  
  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>CrawlTask</span> <span style=color:#204a87;font-weight:700>implements</span> <span style=color:#000>Runnable</span> <span style=color:#ce5c00;font-weight:700>{</span> 
    <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>URL</span> <span style=color:#000>url</span><span style=color:#ce5c00;font-weight:700>;</span> 
    <span style=color:#ce5c00;font-weight:700>...</span>
    
    <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>run</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span> 
      <span style=color:#204a87;font-weight:700>for</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>URL</span> <span style=color:#000>link</span> <span style=color:#ce5c00;font-weight:700>:</span> <span style=color:#000>processPage</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>url</span><span style=color:#ce5c00;font-weight:700>))</span> <span style=color:#ce5c00;font-weight:700>{</span> 
        <span style=color:#204a87;font-weight:700>if</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>Thread</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>currentThread</span><span style=color:#ce5c00;font-weight:700>().</span><span style=color:#c4a000>isInterrupted</span><span style=color:#ce5c00;font-weight:700>())</span> 
          <span style=color:#204a87;font-weight:700>return</span><span style=color:#ce5c00;font-weight:700>;</span> 
        <span style=color:#000>submitCrawlTask</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>link</span><span style=color:#ce5c00;font-weight:700>);</span> 
      <span style=color:#ce5c00;font-weight:700>}</span> 
    <span style=color:#ce5c00;font-weight:700>}</span> 
    
    <span style=color:#204a87;font-weight:700>public</span> <span style=color:#000>URL</span> <span style=color:#000>getPage</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span> <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>url</span><span style=color:#ce5c00;font-weight:700>;</span> <span style=color:#ce5c00;font-weight:700>}</span>
  <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>在 TrackingExecutor 中存在一个不可避免的竟态条件，从而产生“误报”问题：一些被任务已经取消的任务实际上已经执行完成。这个问题的原因在于，在任务执行最后一条执行以及线程池将任务记录为“结束”的两个时刻之间，线程池可能被关闭。如果任务是幂等的，那么这不会存在问题，在网页爬虫程序中就是这种情况。否则，在应用程序中必须考虑这种风险，并对“误报”问题做好准备。</p>
<h2 id=73-处理非正常的线程终止>7.3 处理非正常的线程终止</h2>
<p>当单线程的控制台程序由于发生了一个未捕获的异常而终止时，程序将停止运行，并产生与程序正常输出非常不同的栈追踪信息，这种情况是很容易理解的。然而，如果并发程序中的某个线程发生故障，那么通常并不会如此明显。在控制台中可能会输出栈追踪信息，但没有人会观察控制台。此外，当线程发生故障时，应用程序可能看起来仍然在工作，所以这个失败很可能被忽略。幸运的是，我们有可以检测并防止在程序中“遗漏”线程的方法。</p>
<p>导致线程提前死亡的最主要原因就是 RuntimeException。由于这些异常表示出现了某种编程错误或者其他不可修复的错误，因此它们通常不会被捕获。它们不会在调用栈中逐层传递，而是默认的在控制台中输出栈追踪信息，并终止线程。</p>
<p>线程非正常退出的后果可能是良性的，也可能是恶性的，这要取决于线程在应用程序中的作用。虽然在线程池中丢失一个线程可能会带来性能上的影响，但如果程序能在包含 50 个线程的线程池上运行良好，那么在包含 49 个线程的线程池上通常也能良好的运行。然而，如果在 GUI 程序中丢失了事件分派线程，那么造成的影响将非常显著——应用程序将停止处理事件并且 GUI 会因此失去响应。在第六章的 OutOfTime 中给出了由于遗留线程而造成的严重后果：Timer 表示的服务将永远无法使用。</p>
<p>任何代码都可能抛出一个 RuntimeException。每当调用另一个方法时，都要对它的行为保持怀疑，不要盲目的任务它一定会正常返回，或者一定会抛出在方法原型中声明的某个受检异常。对调用的代码约不熟悉，就越应该对其代码行为保持怀疑。</p>
<p>在任务处理线程(如线程池中的工作线程或 Swing 的事件派发线程等)的生命周期中，将通过某种抽象机制(如 Runnable)来调用许多未知的代码，我们应该对在这些线程中执行的代码能否表现出正确的行为保持怀疑。像 Swing 事件线程这样的服务可能只是因为某个编写不当的时间处理器抛出 NPE 而失败，这种情况是非常糟糕的。因此，这些线程应该在 try-catch 代码块中调用这些任务，这样就能捕获那些未检异常了，或者也可以使用 try-finally 代码块来确保框架能够知道线程非正常退出的情况，并作出正确的响应。在这种情况下，你或许会考虑捕获 RuntimeException，即当通过 Runnable 这样的抽象机制来调用未知的和不可信的代码时。</p>
<p>在程序清单 7-23 中给出了如何在线程池内部构建一个工作者线程。如果任务抛出了一个未检异常，那么它将终结线程，但首先会通知框架该线程已经终结。然后，框架可能会用新的线程来代替这个工作线程，也可能不会，因为线程池正在关闭，或者当前已有足够多的线程能够满足需要。ThreadPoolExecutor 和 Swing 都通过这项技术来确保行为糟糕的任务不会影响到后续执行的任务。当编写一个向线程池提交任务的工作者线程类时，或者调用不可信的外部代码时(如动态加载的插件)，使用这些方法中的某一种可以避免某个编写的糟糕的任务或插件不会影响调用它的整个线程。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>run</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span>
  <span style=color:#000>Throwable</span> <span style=color:#000>thrown</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>null</span><span style=color:#ce5c00;font-weight:700>;</span>
  <span style=color:#204a87;font-weight:700>try</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#204a87;font-weight:700>while</span><span style=color:#ce5c00;font-weight:700>(!</span><span style=color:#000>isInterrupted</span><span style=color:#ce5c00;font-weight:700>()){</span>
      <span style=color:#000>runTask</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>getTaskFromWorkQueue</span><span style=color:#ce5c00;font-weight:700>());</span>
    <span style=color:#ce5c00;font-weight:700>}</span>
  <span style=color:#ce5c00;font-weight:700>}</span> <span style=color:#204a87;font-weight:700>catch</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>Throwable</span> <span style=color:#000>e</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#000>thrown</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>e</span><span style=color:#ce5c00;font-weight:700>;</span>
  <span style=color:#ce5c00;font-weight:700>}</span> <span style=color:#204a87;font-weight:700>finally</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#000>threadExited</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>this</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>thrown</span><span style=color:#ce5c00;font-weight:700>);</span>
  <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><h3 id=未捕获异常的处理>未捕获异常的处理</h3>
<p>上节介绍了一种主动方法来解决未检异常。在 Thread API 中同样提供了 UncaughtExceptionHandler，它能检测出某个线程由于未捕获异常而终止的情况。这两种方法是互补的，通过将二者结合，就能有效防止线程泄露问题。</p>
<p>当一个线程由于未捕获异常而退出时，JVM 会把这个事件报告给应用程序提供的 UncaughtExceptionHandler 异常处理器。如果没有提供任何异常处理器，那么默认的行为是将栈追踪信息输出到 System.err。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>interface</span> <span style=color:#000>UncaughtExceptionHandler</span> <span style=color:#ce5c00;font-weight:700>{</span>
  <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>uncaughtException</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>Thread</span> <span style=color:#000>t</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>Throwable</span> <span style=color:#000>e</span><span style=color:#ce5c00;font-weight:700>);</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>异常处理器处理未捕获异常的方式，取决于对服务质量的需求。最常见的响应方式是将一个错误信息以及相应的栈追踪信息写入应用程序日志中，如程序清单 7-25 所示。异常处理器还可以采取更直接的响应，例如尝试重新启动线程，关闭应用程序，或者执行其他修复或诊断等操作。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>UEHLogger</span> <span style=color:#204a87;font-weight:700>implements</span> <span style=color:#000>Thread</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>UncaughtExceptionHandler</span> <span style=color:#ce5c00;font-weight:700>{</span>
  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>uncaughtException</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>Thread</span> <span style=color:#000>t</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>Throwable</span> <span style=color:#000>e</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#000>Logger</span> <span style=color:#000>logger</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>Logger</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>getAnonymousLogger</span><span style=color:#ce5c00;font-weight:700>();</span>
    <span style=color:#000>logger</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>log</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>Level</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>SERVER</span><span style=color:#ce5c00;font-weight:700>,</span> 
      <span style=color:#4e9a06>&#34;Thread terminated with exception: &#34;</span> <span style=color:#ce5c00;font-weight:700>+</span> <span style=color:#000>t</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>getname</span><span style=color:#ce5c00;font-weight:700>(),</span> <span style=color:#000>e</span><span style=color:#ce5c00;font-weight:700>);</span>
  <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><blockquote>
<p>在长时间运行的应用程序中，通常会为所有线程的未捕获异常指定同一个异常处理器，并且该处理器至少会将异常信息记录到日志中。</p>
</blockquote>
<p>要为线程池中的所有线程设置一个异常处理器，需要为 ThreadPoolExecutor 的构造函数提供一个 ThreadFactory。(与所有线程操控一样，只有线程的所有者能够改变线程的异常处理器)。标准线程池允许当发生未捕获异常时结束线程，但由于使用了一个 try-finally 代码块来接收通知，因此当线程结束时，将有新的线程来代替它。如果没有提供捕获异常处理器或者其他的故障通知机制，那么任务将会悄悄失败，从而导致大面积的混乱，如果你希望在任务由于发生异常而失败时获得通知，并且执行一些特定于任务的恢复操作，那么可以将任务封装在能捕获异常的 Runnable 或 Callable 中，或者改写 ThreadPoolExecutor 的 afterExecute 方法。</p>
<p>令人困惑的是，只有通过 execute 提交的任务，才能将它抛出的异常交给异常处理器，而通过 submit 提交的任务，无论是抛出未检还是受检异常，都将被认为是任务返回状态的一部分。如果一个由 submit 提交的任务由于抛出了异常而结束，那么这个异常将被 Future.get 封装在 ExecutionException 中。</p>
<h2 id=74-jvm-关闭>7.4 JVM 关闭</h2>
<p>JVM 既可以正常关闭，也可以强行关闭。正常关闭的触发方式有多种，包括：当最后一个“正常(非守护)”线程结束时，或者当调用了 System.exit 时，或者通过其他特定于平台的方法关闭时(例如发送了 SIGINT 信号或键入 Ctrl+C)。虽然可以通过这些标准方法来正常关闭 JVM，但也可以通过调用 Runtime，halt 或者在操作系统中“杀死” JVM 进程(如发送 SIGKILL)来强行关闭 JVM。</p>
<h3 id=关闭钩子>关闭钩子</h3>
<p>在正常关闭中，JVM 首先调用所有已注册的关闭钩子(ShutdownHook)。关闭钩子是通过 Runtime.addShutdownHook 注册的但尚未开始的线程。JVM 并不能保证关闭钩子的调用顺序。在关闭应用程序线程时，如果有(守护或非守护)线程仍在运行，那么这些(钩子)线程接下来将与关闭线程并发运行。当所有的关闭钩子都执行结束时，如果 runFinalizersOnExit 为 true，那么 JVM 将运行终结器，然后再停止。JVM 并不会停止或中断任何在关闭时仍在运行的应用程序线程。当 JVM 最终结束时，这些线程将被强行结束。如果关闭钩子或终结器没有执行完成，那么正常关闭进程“挂起”并且 JVM 必须被强行关闭。当被强行关闭时，只是关闭 JVM，而不会运行关闭钩子。</p>
<p>关闭钩子应该确保线程安全：它们在访问共享数据时必须使用同步机制，并且小心的避免发生死锁，这与其他并发代码的要求相同。而且，关闭钩子不应该对应用程序的状态(如其他服务是否已经关闭、所有的正常线程是否已经执行完成)或 JVM 的关闭原因作出任何假设，因此在编写关闭钩子的代码时必须考虑周全。最后，关闭钩子应该尽快退出，因为它们的运行会延迟 JVM 的结束时间，而用户可能希望尽快关闭 JVM。</p>
<p>关闭钩子可以用于实现服务或应用程序的清理工作，例如删除临时文件、清除无法由操作系统自行清除的资源。在程序清单 7-26 中给出了如何使用程序清单 7-16 中的 LogService 在其 start 方法中注册一个关闭钩子，从而确保在退出时关闭日志文件。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>start</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span>
  <span style=color:#000>Runtime</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>getRuntime</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>addShutdownHook</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>Thread</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>run</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span>
      <span style=color:#204a87;font-weight:700>try</span> <span style=color:#ce5c00;font-weight:700>{</span> <span style=color:#000>LogService</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>this</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>stop</span><span style=color:#ce5c00;font-weight:700>();}</span>
      <span style=color:#204a87;font-weight:700>catch</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>InterruptedException</span> <span style=color:#000>ignored</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{}</span>
    <span style=color:#ce5c00;font-weight:700>}</span>
  <span style=color:#ce5c00;font-weight:700>})</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>由于关闭钩子将并发执行，因此在关闭日志文件时可能导致其他需要日志服务的关闭钩子产生问题。为了避免这种情况，关闭钩子不应该依赖那些可能被应用程序或其他关闭钩子关闭的服务。实现这种功能的一种方式是对所有服务使用同一个关闭钩子(而非为每个服务注册一个不同的关闭钩子)，并且在该关闭钩子中执行一系列的关闭操作。这确保了关闭操作在单个线程中串行执行，从而避免了在关闭操作之间出现竟态条件或死锁。无论是否使用关闭钩子，都可以使用这项技术，通过将各个关闭操作串行执行而非并行执行，可以消除许多潜在的故障。当应用程序需要维护多个服务之间的显式依赖信息时，这项技术可以确保关闭操作按照正确的顺序执行。</p>
<h3 id=742-守护线程>7.4.2 守护线程</h3>
<p>有时候你希望创建一个线程来执行一些辅助工作，但又不希望这个线程阻碍 JVM 的关闭。在这种情况下就需要使用守护线程(Daemon Thread)。</p>
<p>线程可分为两种：普通线程与守护线程。在 JVM 启动时创建的所有线程中，除了主线程以外，其他的线程都是守护线程(如垃圾回收器及其他执行辅助工作的线程)。当创建一个新线程时，新线程将继承创建它的线程的守护状态，因此在默认情况下，主线程创建的所有线程都是普通线程。</p>
<p>普通线程与守护线程的区别仅在于线程退出时发生的操作。当一个线程退出时，JVM 会检查其他正在运行的线程，如果这些线程都是守护线程，那么 JVM 会在正常退出操作。当 JVM 停止时，所有仍然存在的线程都将被抛弃——既不会执行 finally 代码块，也不会执行回卷栈，而是直接退出 JVM。</p>
<p>我们应尽可能少的使用守护线程——很少有操作能够在不进行清理的情况下被安全的抛弃。特别是，如果在守护线程中执行可能包含 IO 操作的任务，那么将是一种危险的行文。守护线程最后用于执行“内部任务”，例如周期性的从内存的缓存中移除逾期数据。</p>
<blockquote>
<p>此外，守护线程不能用来替代应用程序管理程序中各个服务的生命周期。</p>
</blockquote>
<h3 id=743-终结器>7.4.3 终结器</h3>
<p>当不再需要内存资源时，可以通过垃圾回收器来回收他们，但对于其他一些资源，例如文件句柄或套接字句柄，当不再需要它们时，必须显式的交还给操作系统。为了实现这个功能，垃圾回收器对那些定义了 finalize 方法的对象会进行特殊处理：在回收器释放它们后，调用它它们的 finalize 方法，从而保证一些持久化的方法被释放。</p>
<p>由于终结器可以在某个由 JVM 管理的线程中运行，因此终结器访问的任何状态都可能被多个线程访问，这样就必须对其访问操作进行同步。终结器并不能保证它们将在何时运行甚至是否会运行，并且的复杂的终结器通常还会在对象上产生巨大的开销，要编写正确的终结器是非常困难的。在大多数情况下，通过使用 finally 代码块和显式 close 方法，能够比使用终结器更好的管理资源。唯一的例外请求在于：当需要管理对象，并且该对象的资源是通过本地方法获得的。基于这些原因以及其他一些原因，我们要尽量避免编写或使用包含终结器的类(除非是平台类库中的类)。</p>
<blockquote>
<p>避免使用终结器。</p>
</blockquote>
<h2 id=小结>小结</h2>
<p>在任务、线程、服务已经应用程序等模块中的生命周期结束问题，可能会增加它们在设计和实现时的复杂性。Java 并没有提供某种抢占式的机制来取消操作或终结线程。相反，它提供了一种协作式的中断机制来实现取消操作，但这要依赖于如何构建取消操作的协议，以及能否遵循这些协议。通过使用 FutureTask 和 Executor 框架，可以帮助我们构建可以取消的任务和服务。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-6323673bcab4aaf5bae0fd2fb26ec7df>8 - CH08-线程池</h1>
<p>第六种介绍了任务执行框架，他不仅简化任务与线程的生命周期管理，而且还提供一种简单灵活的方式将任务的提交与任务的执行策略解耦开来。第七章介绍了在实际应用程序中使用任务执行框架时出现的一些与服务生命周期管理相关的细节问题。本章将对线程池进行配置与调优的一些高级选项，并分析在使用任务执行框架时需要注意的各种危险，以及一些使用 Executor 的高级示例。</p>
<h2 id=81-在任务与执行策略之间的隐性耦合>8.1 在任务与执行策略之间的隐性耦合</h2>
<p>我们已经知道，Executor 框架可以将任务的提交与任务的执行策略解耦。就像许多对复杂过程的解耦操作那样，这种论断多少有些言过其实了。虽然 Executor 框架为指定和修改执行策略都提供了相当大的灵活性，但并非所有的任务都能适用所有的执行策略。有些类型的任务需要明确的执行策略，包括：</p>
<ul>
<li><strong>依赖性任务</strong>。大多数行为正确的任务都是独立的：它们不依赖于其他任务的执行时序、执行结果或其他效果。当在线程池中执行独立的任务时，可以随意的改变线程池的大小和配置，这些修改只会对执行性能产生影响。然而，如果提交给线程池的任务需要依赖其他的任务，那么久隐含的给执行策略带来的约束，此时必须小心的维持这些执行策略以避免产生活跃性问题。</li>
<li><strong>使用线程封闭机制的任务</strong>。与线程池相比，单线程的 Executor 能够对并发性做出更强的承诺。它们能够确保任务不会并发的执行，使你能够放宽代码对线程安全的要求。对象可以封闭在任务线程中，使得在该线程中的任务在访问该对象时不需要同步，即使这些资源不是线程安全的也没问题。这种情形在任务与执行策略之间形成隐式的耦合——任务要求其执行所在的 Executor 是单线程的。如果将 Executor 从单线程环境改为线程池环境，那么将会失去线程安全性。</li>
<li><strong>对响应时间敏感的任务</strong>。GUI 应用程序对于响应时间是敏感的：如果用户在点击按钮后需要很长延迟才能得到可见的反馈，那么他们会感到不满。如果将一个运行时间较长的任务提交到单线程的 Executor 中，或者将多个运行时间较长的任务提交到一个只包含少量线程的线程池中，那么将降低由该 Executor 管理的所有服务的响应性。</li>
<li><strong>使用 ThreadLocal 的任务</strong>。ThreadLocal 使每个线程都可以拥有某个变量的一个私有“版本”。然而，只要条件允许，Executor 可以自由的重用这些线程。在标准的 Executor 实现中，当执行需求较低时将回收空闲线程，而当需求增加时将添加新的线程，并且如果从任务中抛出了一个未检异常，那么将用一个新的工作者线程来替代抛出异常的线程。只有当线程本地值的声明周期受限于任务的生命周期时，在线程池中使用 ThreadLocal 才有意义，而在线程池的线程中不应该使用 ThreadLocal 在任务之间传递值。</li>
</ul>
<p>只有当任务都是同类型的并且是互相独立时，线程池的性能才能达到最佳。如果将运行时间较长的与运行时间较短的任务混合在一起，那么除非线程池很大，否则将可能造成“拥塞”。如果提交的任务依赖于其他任务，那么除非线程池无限大，否则将可能造成死锁。幸运的是，在基于网络的典型服务器应用程序中——网页服务器、邮件服务器、文件服务器，它们的请求通常都是同类型且相互独立的。</p>
<blockquote>
<p>在一些任务中，需要拥有或排除某种特定的执行策略。如果某些任务依赖于其他的任务，那么会要求线程池足够大，从而确保它们的依赖任务不会被放入到线程池的等待队列中或被拒绝，而采用线程封闭机制的任务需要串行执行。通常将这些需求写入文档，将来的代码维护人员就不会由于使用了某种不合适的执行策略而破坏安全性和活跃性。</p>
</blockquote>
<h3 id=811-线程饥饿死锁>8.1.1 线程饥饿死锁</h3>
<p>在线程池中，如果一个任务依赖于其他任务，则可能会产生死锁。在单线程 Executor 中，如果一个任务将另一个任务提交到同一个 Executor，并且等待这个被提交任务的执行结果，那么通常会引发死锁。第二个任务将停留在任务队列中，并等待第一个任务完成以释放线程，而第一个任务又无法完成，因为它在等待第二个任务的完成。在更大线程池中，如果所有正在执行的任务的线程都由于等待其他仍处于工作队列中的任务二阻塞，那么会发生同样的问题。这种现象被称为线程饥饿死锁，只要在线程池中的任务需要无限期的等待一些必须由线程池中其他任务才能提供的资源或条件，例如某个任务等待另一个任务的返回值或执行结果，那么除非线程池足够大，否则将发生线程饥饿死锁。</p>
<p>在程序清单 8-1 中的 ThreadDeadLock 中给出了线程饥饿死锁的示例。RenderPageTask 向 Executor 提交了两个任务来获取网页的页眉和页脚，绘制页面，等待获取页眉和页脚任务的结果，然后将页眉、页面、页脚组合起来并形成最终的页面。如果使用单线程的 Executor，那么 ThreadDeadLock 会经常发生死锁。同样，如果线程池不够大，那么当多个任务通过栅栏机制来彼此协调时，将导致线程饥饿死锁。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>ThreadDeadLock</span> <span style=color:#ce5c00;font-weight:700>{</span>
  <span style=color:#000>ExecutorService</span> <span style=color:#000>exec</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>Executors</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>newSingleThreadExecutor</span><span style=color:#ce5c00;font-weight:700>();</span>
  
  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>RenderPageTask</span> <span style=color:#204a87;font-weight:700>implements</span> <span style=color:#000>Callable</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>String</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#204a87;font-weight:700>public</span> <span style=color:#000>String</span> <span style=color:#000>call</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#204a87;font-weight:700>throws</span> <span style=color:#000>Exception</span> <span style=color:#ce5c00;font-weight:700>{</span>
      <span style=color:#000>Future</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>String</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>header</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>footer</span><span style=color:#ce5c00;font-weight:700>;</span> 
      <span style=color:#000>header</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>exec</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>submit</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>LoadFileTask</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#4e9a06>&#34;header.html&#34;</span><span style=color:#ce5c00;font-weight:700>));</span> 
      <span style=color:#000>footer</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>exec</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>submit</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>LoadFileTask</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#4e9a06>&#34;footer.html&#34;</span><span style=color:#ce5c00;font-weight:700>));</span> 
      <span style=color:#000>String</span> <span style=color:#000>page</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>renderBody</span><span style=color:#ce5c00;font-weight:700>();</span> 
      <span style=color:#8f5902;font-style:italic>// Will deadlock -- task waiting for result of subtask 
</span><span style=color:#8f5902;font-style:italic></span>      <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>header</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>get</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>+</span> <span style=color:#000>page</span> <span style=color:#ce5c00;font-weight:700>+</span> <span style=color:#000>footer</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>get</span><span style=color:#ce5c00;font-weight:700>();</span>
    <span style=color:#ce5c00;font-weight:700>}</span>
  <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><blockquote>
<p>每当提交了一个有依赖性的 Executor 任务时，要清楚的知道可能会出现线程“饥饿”死锁，因此需要在代码或配置 Executor 的配置文件中记录线程池的大小限制或配置限制。</p>
</blockquote>
<p>除了在线程池大小上的显式限制外，还可能由于其他资源上的约束而存在一些隐式限制。如果应用程序使用一个包含 10 个连接的 JDBC 连接池，并且每个任务需要一个数据库连接，那么线程池就好像只有 10 个线程，因为当超过 10 个任务时，新的任务需要等待其他任务释放连接。</p>
<h3 id=812-运行时间较长的任务>8.1.2 运行时间较长的任务</h3>
<p>如果任务阻塞的时间过长，那么即使不出现死锁，线程池的响应性也会变得糟糕。执行时间较长的任务不仅会造成线程池堵塞，甚至还会增加执行时间较短的任务的服务时间。如果线程池中线程的数量远小于在稳定状态下执行时间较长任务的数量，那么到最后所有的线程都会运行这些执行时间较长的任务，从而影响整体的响应性。</p>
<p>有一项技术可以缓解执行时间较长的任务的影响，即限定任务等待资源的时间，而不要无限制的等待。在平台类库的大多数可阻塞方法中，都同时定义了限时版本和无限时版本，例如 Thread.join、BlockingQueue.put、CountDownLatch.await、Selector.select 等。如果等待超时，那么可以把任务标记为失败，然后终止任务或者将任务重新放回队列以便随后执行。这样，无论任务的最终结果是否成功，这种方法都能确保任务总能执行下去，并将线程释放出来以执行一些能更快执行的任务。如果在线程池中总是充满了被阻塞的任务，那么也可能表明线程池的规模确实过小了。</p>
<h2 id=82-设置线程池的大小>8.2 设置线程池的大小</h2>
<p>线程池的理想大小取决于被提交任务的类型以及所部署系统的特性。在代码中通常不会固定线程池的大小，而应该通过某种配置机制来提供，或者根据 Runtime.availableProcessors 来动态计算。</p>
<p>幸运的是，要设置线程池的大小并不困难，只需要避免过大或过小这两种极端情况。如果线程池过大，那么大量的线程将在相对很少的 CPU 和内存资源上发生竞争，这不仅会导致更高的内存占用，甚至可能会耗尽资源。如果线程池过小，那么将导致许多空闲的处理器无法执行工作，从而降低吞吐率。</p>
<p>要想正确的设置线程池的大小，必须分析计算环境、资源预算和任务的特性。在部署的系统中有多少个 CPU？多大的内存？任务是计算密集型还是 IO 密集型还是二者结合？它们是否需要像 JDBC 连接这样的稀缺资源？如果要执行不同类型的任务，并且它们之间的行为相差很大，那么应该考虑使用不同的线程池，从而使每个线程池可以根据各自的工作负载来调整。</p>
<p>对于计算密集型的任务，在拥有 N 个 CPU 的系统上，当线程池的大小为 N+1 时，通常能实现最优的利用率。(即使当计算密集型的线程偶尔由于缺页故障或其他原因而暂停(阻塞)时，这个“额外”的线程也能确保 CPU 的时钟周期不会被浪费)。对于包含 IO 草作者其他阻塞操作的任务，由于线程并不会一直执行，因此线程池的规模应该更大。要正确的设置线程池的大小，你必须估算出任务的等待时间和时间耗时的比值。这种估算不需要很精确，并且可以通过一些分析或监控工具来获得。你还可以通过另一种方法来调节线程池的带下：在某个基准负载下，分别设置不同大小的线程池来运行应用程序，并观察 CPU 利用率的水平。</p>
<p>给定如下定义：</p>
<div align=center>
<img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20181031233451.png style=display:block;width:70% alt=NAME align=center>
</div>
<p>要使处理器达到期望的使用率，线程池的最优大小等于：</p>
<div align=center>
<img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20181031233508.png style=display:block;width:70% alt=NAME align=center>
</div>
<p>可以通过 Runtime 来获得实际 CPU 数量：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>N_CPUS</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>Runtime</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>getRuntime</span><span style=color:#ce5c00;font-weight:700>().</span><span style=color:#c4a000>availableProcessors</span><span style=color:#ce5c00;font-weight:700>();</span>
</code></pre></div><p>当然，CPU 周期并不是唯一影响线程池大小的资源，还包括内存、文件句柄、套接字句柄和数据库连接等。计算这些资源对线程池的约束条件则更加容易：计算每个任务对该资源的需求量，然后用该资源的可用总量除以每个任务的需求量，所得结果就是线程池大小的上限。</p>
<p>当任务需要某种通过资源池来管理的资源时，例如数据库连接，那么线程池和资源池的大小将会互相影响。如果每个任务都需要一个数据库连接，那么连接池的大小就限制的线程池的大小。同样，当线程池中的任务是数据库连接的唯一使用者时，那么线程池的大小又将限制连接池的大小。</p>
<h2 id=83-配置-threadpoolexecutor>8.3 配置 ThreadPoolExecutor</h2>
<p>ThreadPoolExecutor 为一些 Executor 提供了基本的实现，这些 Executor 是由 Executors 中的 newCachedThreadPool、newFixedThreadPool、newScheduledThreadExecutor 等工厂方法返回的。ThreadPoolExecutor 是一个灵活稳定的线程池，支持进行各种定制。</p>
<p>如果默认的执行策略不能满足需要，那么可以通过 ThreadPoolExecutor 的构造函数来实例化一个对象，并根据自己的需要来定制，并且可以参考 Executors 的源代码来了解默认配置下的执行策略，然后再以这些执行策略为基础进行修改。ThreadPoolExecutor 定义了很多构造函数，在程序清单 8-2 中给出了最常见的形式。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#204a87;font-weight:700>public</span> <span style=color:#000>ThreadPoolExecutor</span><span style=color:#ce5c00;font-weight:700>(</span>
  <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>corePoolSize</span><span style=color:#ce5c00;font-weight:700>,</span>
  <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>maximumPoolSize</span><span style=color:#ce5c00;font-weight:700>,</span>
  <span style=color:#000>TimeUnit</span> <span style=color:#000>unit</span><span style=color:#ce5c00;font-weight:700>,</span>
  <span style=color:#000>BlockingQueue</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>Runnable</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>workQueue</span><span style=color:#ce5c00;font-weight:700>,</span>
  <span style=color:#000>ThreadFactory</span> <span style=color:#000>threadFactory</span><span style=color:#ce5c00;font-weight:700>,</span>
  <span style=color:#000>RejectedExecutionHandler</span> <span style=color:#000>handler</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{...}</span>
<span style=color:#ce5c00;font-weight:700>)</span>
</code></pre></div><h3 id=831-线程的创建与销毁>8.3.1 线程的创建与销毁</h3>
<p>线程池的基本大小、最大大小以及存活时间等因素共同负责线程的创建与销毁。基本大小也就是线程池的目标大小，即在没有任务执行线程池的大小、并且只有在工作队列已满的情况下才会创建超出这个数量的线程。线程池的最大大小表示可同时活动的线程数量的上限。如果某个线程的空闲时间超过了存活时间，那么将被标记为可回收，并且当线程池的当前大小超过了基本大小时，这个线程将被终止。</p>
<p>通过调节线程池的基本大小和存活时间，可以帮助线程池回收空闲线程占优的资源，从而使得这些资源可以用于执行其他工作。(显然，这是一种折中：回收线程会产生额外的延迟，因为当需求增加时，必须创建新的线程来满足需求)</p>
<p>newFixedThreadPool 工厂方法将线程池的基本大小和最大大小设置为参数中指定的值，而且创建的线程池不会超时。newCachedThreadPool 工厂方法将线程池的最大大小设置为 Integer.MAX_VALUE，而将基本大小设置为 0，并将超时设置为 1 分钟，这种方法创建出来的线程池可以被无限扩展，并且当需求降低时会自动收缩。其他形式的线程池可以通过显式的 ThreadPoolExecutor 构造函数来构造。</p>
<h3 id=832-管理队列任务>8.3.2 管理队列任务</h3>
<p>在有限的线程池中会限制可以并发执行的任务数量。(单线程的 Executor 是一种值得注意的特例：它们能确保不会有任务并发执行，因为它们通过线程封闭来实现线程安全性。)</p>
<p>在 6.1.2 节中曾介绍过，如果无限制的创建线程，那么将导致不稳定性降低，并通过采用固定大小的线程池(而不是每收到一个请求就创建一个线程)来解决这个问题。然而，这个防范并不完整。在高负载的情况下，应用程序仍可能耗尽资源，只是出问题的概率比较小。如果新请求的到达速率超过了线程池的处理速率，那么新到来的请求将累积起来。在线程池中，这些请求会在一个由 Executor 管理的 Runnable 队列中等待，而不会线程那样去竞争 CPU 资源。通过一个 Runnable 和一个链表节点来表现一个等待中的任务，当然比使用线程来表示的开销低很多，但如果客户端提交给服务器的请求的速率超过了服务器的处理速率，那么仍可能会耗尽资源。</p>
<p>即使请求的平均到达率很稳定，也仍然会出现请求突增的情况。尽管队列有助于缓解任务的突增问题，但如果任务持续高速抵达，那么最终还是会抑制请求的到达率以避免耗尽内存。甚至在耗尽内存之前，响应性也随着任务队列的增长而变得越来越糟。</p>
<p>ThreadPoolExecutor 和 newSingleThreadExecutor 在默认情况下使用一个无界的 LinkedBlockingQueue。如果所有工作者线程都处于忙碌状态，那么任务将在队列中等候。如果任务持续快速到达，并且超过了线程池处理任务的速度，那么队列将会无限制的增长。</p>
<p>一种更稳妥的资源管理策略是使用有界队列，如 ArrayBlockingQueue、有界的 LinkedBlockingQueue、PriorityBlockingQueue。有界队列 有助于避免资源耗尽的情况发生，但它又带来了新的问题：当队列填满后，新抵达的任务怎么办？(有许多饱和策略可以解决这个问题，见 8.3.3)。在使用有界队列时，队列的大小与线程池的大小必须一起调节。如果线程池较小而队列较大，那么有助于减少内存占用量，降低 CPU 的使用率，同时还可以减少上下文切换，但付出的代价是可能会限制吞吐量。</p>
<p>对于非常大的或者无界的线程池，可以通过使用 SynchronousQueue 来避免任务排队，以及直接将任务从生产者移交给工作者线程。SynchronousQuque 不是一个真正的队列，而是一种在线程之间进行移交的机制。要将一个元素放入 SynchronousQuque 中，必须有一个线程正在等待着接收这个元素。如果没有正在等待的线程，并且线程池的当前大小小于最大值，那么 ThreadPoolExecutor 将创建一个新的线程，否则根据饱和策略，该任务将被拒绝。使用直接移交将更加高效，因为任务会直接移交给执行它的线程，而不是首先被放在队列中，然后由工作者线程从队列中提取该任务。只有当线程池是无界的或者可以拒绝任务时，SynchronousQuque 才有实际价值。在 newCachedThreadPool 工厂方法中使用了 SynchronousQuque。</p>
<p>当使用像 LinkedBlockingQueue 或 ArrayBlockingQueue 这样的 FIFO 队列时，任务的执行顺序与它们的到达顺序一致。如果想进一步控制任务的执行顺序，还可以使用 PriorityBlockingQueue，这个队列将根据优先级来安排任务。任务的优先级是通过自然顺序或 Comparator 来定义的。</p>
<blockquote>
<p>对于 Executor，newCachedThreadPool 工厂方法是一种很好的默认选择，它能提供比固定大小的线程池更好的排队性能。当需要限制当前任务的数量以满足资源管理的需要时，那么可以选择固定大小的线程池，就像在接收网络客户请求的服务器应用程序中，如果不进行限制，那么很容易发生过载问题。</p>
</blockquote>
<p>只有当任务互相独立时，为线程池或工作队列设置界限才是合理的。如果任务之间存在依赖性，那么有界的线程池或队列就可能导致线程饥饿死锁问题。此时应该使用无界的线程池，如 newCachedThreadPool。</p>
<h3 id=833-饱和策略>8.3.3 饱和策略</h3>
<p>当有界队列被填满后，饱和策略将开始发挥作用。ThreadPoolExecutor 的跑和策略可以通过调用 setRejectedExecutionHandler 来修改。(如果某个任务被提交到一个已被关闭的 Executor 时，也会用到饱和策略)。JDK 提供了几种不同的 RejectedExecutionHandler 实现，每种实现都包含有不同的饱和策略：AbortPolicy、CallRunsPolicy、DiscardPolicy、DiscardOldestPolicy。</p>
<p>“中止”策略是默认的饱和策略，该策略将抛出未检查的 RejectedExecutionException。调用者可以捕获这个异常，然后根据需求编写自己的处理代码。当新提交的任务无法被保存到队列中等待执行时，“抛弃”策略会悄悄丢弃该任务。“抛弃最旧的”策略会抛弃下一个尚未执行但将被执行的任务，然后尝试重新提交新的任务。(如果工作队列是一个优先级对垒，那么“抛弃最旧的”将会抛弃当前队列中优先级最高的任务，因此最好不要将“抛弃最旧”策略与优先级队列一起使用)。</p>
<p>“调用者运行”策略实现了一种调节机制，该策略既不会抛弃任务，也不会抛出异常，而是将某感谢任务回退到调用者，从而降低新任务的流量。他不会在线程池的某个线程中执行新提交的任务，而是在一个调用了 execute 的线程中执行任务。我们可以将 WebServer 示例修改为使用有界队列和“调用者运行”饱和策略，当线程池中的所有线程都被占用，并且工作队列被填满后，下一个任务会在调用 execute 时在主线程中执行。由于执行任务需要一定的时间，因此主线程至少在一段时间内都不能提交任何任务，从而使得工作者线程有时间来处理正在执行的任务。在这期间，主线程不会调用 accept，因此到达的请求会被保存在 TCP 层的队列中而不是在应用程序的队列中。如果持续过载，那么 TCP 层将最终会发现它的请求队列被填满，因此同样会开始抛弃请求。当服务器过载时，这种过载请求会逐渐向外蔓延开来——从线程池到工作队列到应用程序再到 TCP 层，最终到达客户端，导致服务器在高负载下实现一种平缓的性能降低。</p>
<p>当创建 Executor 时，可以选择饱和策略或者对执行策略进行修改。程序清单 8-3 给出了如何创建一个固定大小的线程池，同时使用“调用者运行”饱和策略。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#000>ThreadPoolExecutor</span> <span style=color:#000>exeuctor</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>ThreadPoolExecutor</span><span style=color:#ce5c00;font-weight:700>(</span>
  <span style=color:#000>N_THREADS</span><span style=color:#ce5c00;font-weight:700>,</span>
  <span style=color:#000>N_THREADS</span><span style=color:#ce5c00;font-weight:700>,</span>
  <span style=color:#000>0L</span><span style=color:#ce5c00;font-weight:700>,</span>
  <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>LinkedBlockingQueue</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>Runnable</span><span style=color:#ce5c00;font-weight:700>&gt;(</span><span style=color:#000>CAPACITY</span><span style=color:#ce5c00;font-weight:700>)</span>
<span style=color:#ce5c00;font-weight:700>);</span>

<span style=color:#000>exeuctor</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>setRejectedExecutionHandler</span><span style=color:#ce5c00;font-weight:700>(</span>
  <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>ThreadPoolExecutor</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>CallerRunsPolicy</span><span style=color:#ce5c00;font-weight:700>());</span>
</code></pre></div><p>当工作队列被填满时，没有预定义的饱和策略来阻塞 execute。然而，通过使用 Semaphore 来限制任务的到达率，就可以实现这个功能。在程序清单 8-4 中给出了这种方法的实现。该方法使用一个无界对了(因为不能限制队列的大小和任务的到达率)，并设置信号量的上界为线程池的大小加上可排队任务的数量，这是因为信号量需要控制正在执行的和等待执行的任务数量。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#5c35cc;font-weight:700>@ThreadSafe</span>
<span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>BoundedExecutor</span> <span style=color:#ce5c00;font-weight:700>{</span>
  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>Executor</span> <span style=color:#000>exec</span><span style=color:#ce5c00;font-weight:700>;</span>
  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#000>fianl</span> <span style=color:#000>Semaphore</span> <span style=color:#000>semaphore</span><span style=color:#ce5c00;font-weight:700>;</span>
  
  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#000>BoundedExecutor</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>Executor</span> <span style=color:#000>exec</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>bound</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#204a87;font-weight:700>this</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>exec</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>exec</span><span style=color:#ce5c00;font-weight:700>;</span>
    <span style=color:#204a87;font-weight:700>this</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>semaphore</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>Semaphore</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>bound</span><span style=color:#ce5c00;font-weight:700>);</span>
  <span style=color:#ce5c00;font-weight:700>}</span>
  
  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>submitTask</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>Runnable</span> <span style=color:#000>command</span><span style=color:#ce5c00;font-weight:700>)</span> 
    <span style=color:#204a87;font-weight:700>throws</span> <span style=color:#000>InterruptedException</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#000>semaphore</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>acquire</span><span style=color:#ce5c00;font-weight:700>();</span>
    <span style=color:#204a87;font-weight:700>try</span> <span style=color:#ce5c00;font-weight:700>{</span>
      <span style=color:#000>exec</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>execute</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>Runnable</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span>
        <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>run</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span>
          <span style=color:#204a87;font-weight:700>try</span> <span style=color:#ce5c00;font-weight:700>{</span> <span style=color:#000>command</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>run</span><span style=color:#ce5c00;font-weight:700>();</span> <span style=color:#ce5c00;font-weight:700>}</span>
          <span style=color:#204a87;font-weight:700>finally</span> <span style=color:#ce5c00;font-weight:700>{</span>
            <span style=color:#000>semaphore</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>release</span><span style=color:#ce5c00;font-weight:700>();</span>
          <span style=color:#ce5c00;font-weight:700>}</span>
        <span style=color:#ce5c00;font-weight:700>}</span>
      <span style=color:#ce5c00;font-weight:700>});</span>
    <span style=color:#ce5c00;font-weight:700>}</span> <span style=color:#204a87;font-weight:700>catch</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>RejectedExecutonException</span> <span style=color:#000>e</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
      <span style=color:#000>semaphore</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>release</span><span style=color:#ce5c00;font-weight:700>();</span>
    <span style=color:#ce5c00;font-weight:700>}</span>
  <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><h3 id=834-线程工厂>8.3.4 线程工厂</h3>
<p>每当线程池需要创建一个线程时，都是线程工厂方法来完成的。默认的线程工厂方法都将创建一个新的、非守护线程，并且不包含特殊的配置信息。通过指定一个线程工厂方法，可以定制线程池的配置信息。在 ThreadFactory 中只定义了一个方法 newThread，每当线程池需要创建新的线程时都会调用该方法。</p>
<p>然而，在许多情况下都需要使用定制的线程工厂方法。例如，你希望为线程池中的线程指定一个 UncaughtExceptionHandler，或者实例化一个定制的 Thread 类用于执行调试信息的记录。你还可能希望修改线程的优先级(这通常并不是一个好主意)或者守护状态(同样不是一个好主意)。或许你只希望给线程取一个更有意义的名字，用来解释线程的转储信息和错误日志。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>interface</span> <span style=color:#000>ThreadFactory</span> <span style=color:#ce5c00;font-weight:700>{</span>
  <span style=color:#000>Thread</span> <span style=color:#000>newThread</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>Runnable</span> <span style=color:#000>r</span><span style=color:#ce5c00;font-weight:700>);</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>在程序清单 8-6 的 MyThreadFactory 中给出了一个自定义的线程工厂。它创建了一个新的 MyAppThread 实例，并将一个特定于线程池的名字传递给 MyAppThread 的构造函数，从而可以在线程转储和错误日志信息中区分来自不同线程池的线程。在应用程序和其他地方也可以使用 MyAppThread，以便所有线程都能使用它的调试功能。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>MyThreadFactory</span> <span style=color:#204a87;font-weight:700>implements</span> <span style=color:#000>ThreadFactory</span> <span style=color:#ce5c00;font-weight:700>{</span>
  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>String</span> <span style=color:#000>poolName</span><span style=color:#ce5c00;font-weight:700>;</span>
  
  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#000>MyThreadFactory</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>String</span> <span style=color:#000>poolName</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#204a87;font-weight:700>this</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>poolName</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>poolName</span><span style=color:#ce5c00;font-weight:700>;</span>
  <span style=color:#ce5c00;font-weight:700>}</span>
  
  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#000>Thread</span> <span style=color:#000>newThread</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>Runnable</span> <span style=color:#000>runnable</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#204a87;font-weight:700>return</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>MyAppThread</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>runnable</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>poolName</span><span style=color:#ce5c00;font-weight:700>);</span>
  <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>在 MyAppThread 中还可以定制其他行为，如程序清单 8-7 所示，包括：线程名字、设置自定义的 UncaughtExceptionHandler 以向 Logger 写入信息、维护一些统计信息(包括有多少线程被创建和销毁)，以及在线程池被创建和终止时把调试信息写入日志。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>MyAppThread</span> <span style=color:#204a87;font-weight:700>extends</span> <span style=color:#000>Thread</span> <span style=color:#ce5c00;font-weight:700>{</span>
  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>static</span> <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>String</span> <span style=color:#000>DEFAULT_NAME</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#4e9a06>&#34;MyAppThread&#34;</span><span style=color:#ce5c00;font-weight:700>;</span>
  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>static</span> <span style=color:#204a87;font-weight:700>volatile</span> <span style=color:#204a87;font-weight:700>boolean</span> <span style=color:#000>debugLifecycle</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>false</span><span style=color:#ce5c00;font-weight:700>;</span>
  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>static</span> <span style=color:#000>fianl</span> <span style=color:#000>AtomicInteger</span> <span style=color:#000>created</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>AtomicInteger</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>0</span><span style=color:#ce5c00;font-weight:700>);</span>
  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>static</span> <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>AtomicInteger</span> <span style=color:#000>alive</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>AtomicInteger</span><span style=color:#ce5c00;font-weight:700>();</span> 
  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>static</span> <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>Logger</span> <span style=color:#000>log</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>Logger</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>getAnonymousLogger</span><span style=color:#ce5c00;font-weight:700>();</span>
  
  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#000>MyAppThread</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>Runnable</span> <span style=color:#000>r</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span> 
    <span style=color:#204a87;font-weight:700>this</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>r</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>DEFAULT_NAME</span><span style=color:#ce5c00;font-weight:700>);</span> 
  <span style=color:#ce5c00;font-weight:700>}</span>

  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#000>MyAppThread</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>Runnable</span> <span style=color:#000>runnable</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>String</span> <span style=color:#000>name</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#204a87;font-weight:700>super</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>runnable</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>name</span> <span style=color:#ce5c00;font-weight:700>+</span> <span style=color:#4e9a06>&#34;-&#34;</span> <span style=color:#ce5c00;font-weight:700>+</span> <span style=color:#000>created</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>incrementAndGet</span><span style=color:#ce5c00;font-weight:700>());</span> 
    <span style=color:#000>setUncaughtExceptionHandler</span><span style=color:#ce5c00;font-weight:700>(</span>
      <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>Thread</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>UncaughtExceptionHandler</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span>
        <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>uncaughtException</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>Thread</span> <span style=color:#000>t</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>Throwable</span> <span style=color:#000>e</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span> 
        <span style=color:#000>log</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>log</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>Level</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>SEVERE</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#4e9a06>&#34;UNCAUGHT in thread &#34;</span> <span style=color:#ce5c00;font-weight:700>+</span> <span style=color:#000>t</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>getName</span><span style=color:#ce5c00;font-weight:700>(),</span> <span style=color:#000>e</span><span style=color:#ce5c00;font-weight:700>);</span>
        <span style=color:#ce5c00;font-weight:700>}</span>
    <span style=color:#ce5c00;font-weight:700>});</span>
  <span style=color:#ce5c00;font-weight:700>}</span>
  
  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>run</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#8f5902;font-style:italic>// Copy debug flag to ensure consistent value throughout. 
</span><span style=color:#8f5902;font-style:italic></span>    <span style=color:#204a87;font-weight:700>boolean</span> <span style=color:#000>debug</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>debugLifecycle</span><span style=color:#ce5c00;font-weight:700>;</span> 
    <span style=color:#204a87;font-weight:700>if</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>debug</span><span style=color:#ce5c00;font-weight:700>)</span> 
      <span style=color:#000>log</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>log</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>Level</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>FINE</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#4e9a06>&#34;Created &#34;</span><span style=color:#ce5c00;font-weight:700>+</span><span style=color:#000>getName</span><span style=color:#ce5c00;font-weight:700>());</span> 
    <span style=color:#204a87;font-weight:700>try</span> <span style=color:#ce5c00;font-weight:700>{</span>
      <span style=color:#000>alive</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>incrementAndGet</span><span style=color:#ce5c00;font-weight:700>();</span>
      <span style=color:#204a87;font-weight:700>super</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>run</span><span style=color:#ce5c00;font-weight:700>();</span> 
    <span style=color:#ce5c00;font-weight:700>}</span> <span style=color:#204a87;font-weight:700>finally</span> <span style=color:#ce5c00;font-weight:700>{</span>
      <span style=color:#000>alive</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>decrementAndGet</span><span style=color:#ce5c00;font-weight:700>();</span>
      <span style=color:#204a87;font-weight:700>if</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>debug</span><span style=color:#ce5c00;font-weight:700>)</span> 
        <span style=color:#000>log</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>log</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>Level</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>FINE</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#4e9a06>&#34;Exiting &#34;</span><span style=color:#ce5c00;font-weight:700>+</span><span style=color:#000>getName</span><span style=color:#ce5c00;font-weight:700>());</span> 
    <span style=color:#ce5c00;font-weight:700>}</span>
  <span style=color:#ce5c00;font-weight:700>}</span>

  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>static</span> <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>getThreadsCreated</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span> 
    <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>created</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>get</span><span style=color:#ce5c00;font-weight:700>();</span> 
  <span style=color:#ce5c00;font-weight:700>}</span> 
  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>static</span> <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>getThreadsAlive</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span> 
    <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>alive</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>get</span><span style=color:#ce5c00;font-weight:700>();</span> 
  <span style=color:#ce5c00;font-weight:700>}</span> 
  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>static</span> <span style=color:#204a87;font-weight:700>boolean</span> <span style=color:#000>getDebug</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span> 
    <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>debugLifecycle</span><span style=color:#ce5c00;font-weight:700>;</span> 
  <span style=color:#ce5c00;font-weight:700>}</span> 
  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>static</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>setDebug</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>boolean</span> <span style=color:#000>b</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span> 
    <span style=color:#000>debugLifecycle</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>b</span><span style=color:#ce5c00;font-weight:700>;</span> 
  <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>如果在应程序中需要利用安全策略来控制对某些代码库的访问权限，那么可以通过 Executor 中的 privilegedThreadFactory 工厂来定制自己的线程工厂。通过这种方式创建出来的线程，将与创建 privilegedThreadFactory 的线程拥有相同的访问权限、AccessControlContext 和 contextClassLoader。如果不使用 privilegedThreadFactory，线程池创建的线程将从在需要新线程时调用 execute 或 submit 的客户程序中继承权限，从而导致令人困惑的安全性异常。</p>
<h3 id=835-在调用构造函数后再定制-threadpoolexecutor>8.3.5 在调用构造函数后再定制 ThreadPoolExecutor</h3>
<p>在调用完 ThreadPoolExecutor 的构造函数之后，仍然可以通过设置函数来修改大多数传递给构造函数的参数。如果 Executor 是通过 Executors 中的某个工厂方法创建的，那么可以将结果的类型转换为 ThreadPoolExecutor 以访问器设置器，如程序清单 8-8 所示。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#000>ExecutorService</span> <span style=color:#000>exec</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>Executors</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>newCachedThreadPool</span><span style=color:#ce5c00;font-weight:700>();</span> 
<span style=color:#204a87;font-weight:700>if</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>exec</span> <span style=color:#204a87;font-weight:700>instanceof</span> <span style=color:#000>ThreadPoolExecutor</span><span style=color:#ce5c00;font-weight:700>)</span>
  <span style=color:#ce5c00;font-weight:700>((</span><span style=color:#000>ThreadPoolExecutor</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#000>exec</span><span style=color:#ce5c00;font-weight:700>).</span><span style=color:#c4a000>setCorePoolSize</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>10</span><span style=color:#ce5c00;font-weight:700>);</span> 
<span style=color:#204a87;font-weight:700>else</span>
  <span style=color:#204a87;font-weight:700>throw</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>AssertionError</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#4e9a06>&#34;Oops, bad assumption&#34;</span><span style=color:#ce5c00;font-weight:700>);</span>
</code></pre></div><p>哎 Executors 中包含一个 unconfigurableExecutorService 工厂方法，该方法对一个现有的 ExecutorService 进行包装，使其仅暴露出 ExecutorService 方法，因此不能对其进行配置。newSingleThreadExecutor 返回按这种方式封装的 ExecutorService，而不是最初的 ThreadPoolExecutor。虽然单线程的 Executor 实际上被实现为一个仅包含单个线程的线程池，但它同样确保了不会并发的执行任务。如果在代码中增加单线程 Executor 的线程池大小，那么将破坏它的执行策略语义。</p>
<p>你可以在自己的 Executor 中用这项技术来放置执行策略被修改。如果将 ExecutorService 暴露给不信任的代码，又不希望被非法修改，就可以通过 unconfigurableExecutorService 将其包装。</p>
<h2 id=84-扩展-threadpoolexecutor>8.4 扩展 ThreadPoolExecutor</h2>
<p>ThreadPoolExecutor 是可扩展的，它提供了几个可以在子类化中改写的方法：beforeExecute、afterExecute、terminated，这些方法可以用于扩展 ThreadPoolExecutor 的行为。</p>
<p>在执行任务的线程中将调用 beforeExecute 和 afterExecute 等方法，在这些方法中还可以添加日志、计时。监视或统计信息收集等功能。无论任务是从 run 中正常返回，还是抛出一个异常而返回，afterExecute 都会被调用。(让一个一任务在完成后带有一个 Error，那么久不会调用 afterExecute)。如果 beforeExecute 抛出一个 RuntimeException，那么任务将不会被执行，并且 afterExecute 也不会被调用。</p>
<p>在线程池完成关闭操作时调用 termianted，也就是在所有任务都已执行完成并且所有工作者线程都已经关闭后。terminated 可以用来释放 Executor 在其生命周期内分配的各种资源，此外还可以执行发送通知、记录日志或收集 finalize 统计信息等操作。</p>
<h3 id=示例给线程池添加统计信息>示例：给线程池添加统计信息</h3>
<p>在程序清单 8-9 的 TimingThreadPool 中给出了一个自定义的线程池，它通过 beforeExecute、afterExecute 和 terminated 等方法来添加日志记录和统计信息收集。为了测量任务的运行时间，beforeExecute 必须记录开始时间并将其保存到一个 afterExecute 可以访问的地方。因为这些方法将在执行任务的线程中调用，因此 beforeExecute 可以将值保存到一个 ThreadLocal 变量中，然后由 afterExecute 来读取。在 TimingThreadPool 中使用了两个 AtomicLong 变量，分别用于记录已处理的任务数和总的处理时间，并通过 terminated 来输出包含平均时间的日志消息。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>TimingThreadPool</span> <span style=color:#204a87;font-weight:700>extends</span> <span style=color:#000>ThreadPoolExecutor</span> <span style=color:#ce5c00;font-weight:700>{</span>
  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>ThreadLocal</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>Long</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>startTime</span>
    <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>ThreadLocal</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>Long</span><span style=color:#ce5c00;font-weight:700>&gt;();</span>
  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>Logger</span> <span style=color:#000>log</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>Logger</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>getLogger</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#4e9a06>&#34;TimingThreadPool&#34;</span><span style=color:#ce5c00;font-weight:700>);</span>
  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>AtomicLong</span> <span style=color:#000>numTasks</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>AtomicLong</span><span style=color:#ce5c00;font-weight:700>();</span>
  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>AtomicLong</span> <span style=color:#000>totalTime</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>AtomicLong</span><span style=color:#ce5c00;font-weight:700>();</span>
  
  <span style=color:#204a87;font-weight:700>protected</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>beforeExecute</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>Thread</span> <span style=color:#000>t</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>Runnable</span> <span style=color:#000>r</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#204a87;font-weight:700>super</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>beforeExecute</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>t</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>r</span><span style=color:#ce5c00;font-weight:700>);</span>
    <span style=color:#000>log</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>fine</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>String</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>format</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#4e9a06>&#34;Thread %s: start %s&#34;</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>t</span><span style=color:#ce5c00;font-weight:700>,</span><span style=color:#000>r</span><span style=color:#ce5c00;font-weight:700>));</span>
    <span style=color:#000>startTime</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>set</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>System</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>nanoTime</span><span style=color:#ce5c00;font-weight:700>());</span>
  <span style=color:#ce5c00;font-weight:700>}</span>
  
  <span style=color:#204a87;font-weight:700>protected</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>afterExecute</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>Runnable</span> <span style=color:#000>r</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>Throwable</span> <span style=color:#000>t</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#204a87;font-weight:700>try</span> <span style=color:#ce5c00;font-weight:700>{</span>
      <span style=color:#204a87;font-weight:700>long</span> <span style=color:#000>endTime</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>System</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>nanoTime</span><span style=color:#ce5c00;font-weight:700>();</span>
      <span style=color:#204a87;font-weight:700>long</span> <span style=color:#000>taskTime</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>endTime</span> <span style=color:#ce5c00;font-weight:700>-</span> <span style=color:#000>startTime</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>get</span><span style=color:#ce5c00;font-weight:700>();</span>
      <span style=color:#000>numTasks</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>incrementAndGet</span><span style=color:#ce5c00;font-weight:700>();</span>
      <span style=color:#000>totalTime</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>addAndGet</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>taskTime</span><span style=color:#ce5c00;font-weight:700>);</span>
      <span style=color:#000>log</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>fine</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>String</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>format</span><span style=color:#ce5c00;font-weight:700>(</span>
        <span style=color:#4e9a06>&#34;Thread %s: end %s, time=%dns&#34;</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>t</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>r</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>taskTime</span><span style=color:#ce5c00;font-weight:700>));</span>
    <span style=color:#ce5c00;font-weight:700>}</span> <span style=color:#204a87;font-weight:700>finally</span> <span style=color:#ce5c00;font-weight:700>{</span>
      <span style=color:#204a87;font-weight:700>super</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>afterExecute</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>r</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>t</span><span style=color:#ce5c00;font-weight:700>);</span>
    <span style=color:#ce5c00;font-weight:700>}</span>
  <span style=color:#ce5c00;font-weight:700>}</span>
  
  <span style=color:#204a87;font-weight:700>protected</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>terminated</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#204a87;font-weight:700>try</span> <span style=color:#ce5c00;font-weight:700>{</span>
      <span style=color:#000>log</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>info</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>String</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>format</span><span style=color:#ce5c00;font-weight:700>(</span>
        <span style=color:#4e9a06>&#34;Terminated: avg time=%dns&#34;</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>totalTime</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>get</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>/</span> <span style=color:#000>numTasks</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>get</span><span style=color:#ce5c00;font-weight:700>()));</span>
    <span style=color:#ce5c00;font-weight:700>}</span> <span style=color:#204a87;font-weight:700>finally</span> <span style=color:#ce5c00;font-weight:700>{</span>
      <span style=color:#204a87;font-weight:700>super</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>terminated</span><span style=color:#ce5c00;font-weight:700>();</span>
    <span style=color:#ce5c00;font-weight:700>}</span>
  <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><h2 id=85-递归算法的并行化>8.5 递归算法的并行化</h2>
<p>我们对 6.3 节描绘绘制程序进行了一系列的改进以便不断发掘可利用的并行性。第一次是使程序完全串行执行，第二次虽然使用了两个线程，但仍然是串行的现在所有图像：在最后一次实现中将每个图像的下载操作视作一个独立任务，从而实现了更高的并发性。如果在循环体中包含了一些密集计算，或者需要执行可阻塞的 IO 操作，那么只要每次迭代是独立的，都可以对其进行并行化。</p>
<p>如果循环中的迭代操作都是独立的，并且不需要等待所有的迭代操作都完成再继续执行，那么就可以使用 Executor 将串行循环转化为并行循环，在程序清单 8-10 的 processSequentially 和 processInParallel 中给出了这种方法。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>processSequentially</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>List</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>Element</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>elements</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
  <span style=color:#204a87;font-weight:700>for</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>Element</span> <span style=color:#000>e</span> <span style=color:#ce5c00;font-weight:700>:</span> <span style=color:#000>elements</span><span style=color:#ce5c00;font-weight:700>)</span>
    <span style=color:#000>process</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>e</span><span style=color:#ce5c00;font-weight:700>);</span>
<span style=color:#ce5c00;font-weight:700>}</span>

<span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>processInParallel</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>Executor</span> <span style=color:#000>exec</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>List</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>Element</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>elements</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
  <span style=color:#204a87;font-weight:700>for</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>Element</span> <span style=color:#000>e</span> <span style=color:#ce5c00;font-weight:700>:</span> <span style=color:#000>elements</span><span style=color:#ce5c00;font-weight:700>){</span>
    <span style=color:#000>exec</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>execute</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>Runnable</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span>
      <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>run</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span> <span style=color:#000>process</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>e</span><span style=color:#ce5c00;font-weight:700>);</span> <span style=color:#ce5c00;font-weight:700>}</span>
    <span style=color:#ce5c00;font-weight:700>});</span>
  <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>调用 processInParallel 比调用 processSequentially 能能快的返回，因为 processInParallel 会在所有任务都进入了 Executor 的队列后就立即返回，而不会等待任务全部完成。如果需要提交一个任务集并等待它们完成，那么可以使用 ExecutorService.invokeAll，并且在所有任务都执行完成后调用 CompletionService 来获得结果，如第六章的 Render 所示。</p>
<p>当串行循环中的各个迭代操作之间彼此独立，并且每个迭代操作执行的工作量比管理一个新任务时带来的开销更多，那么这个串行循环就适合并行化。</p>
<p>在一些递归设计中同样可以采用循环并行化的方法。在递归算法中通常都会存在串行循环，而且这些循环可以按照程序清单 8-10 的方式进行并行化。一种简单的情况是：在每个迭代操作中都不需要来自后续递归迭代的结果。例如，程序清单 8-11 的 sequentialRecursive 用深度优先算法遍历一棵树，在每个节点上执行计算并将结果放入一个集合，而是为每个节点提交一个任务来完成计算。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#204a87;font-weight:700>public</span> <span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>T</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>sequentialRecursive</span><span style=color:#ce5c00;font-weight:700>(</span>
  <span style=color:#000>List</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>Node</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>T</span><span style=color:#ce5c00;font-weight:700>&gt;&gt;</span> <span style=color:#000>nodes</span><span style=color:#ce5c00;font-weight:700>,</span> 
  <span style=color:#000>Collection</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>T</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>results</span>
<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
  <span style=color:#204a87;font-weight:700>for</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>Node</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>T</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>n</span><span style=color:#ce5c00;font-weight:700>:</span> <span style=color:#000>nodes</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#000>results</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>add</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>n</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>compute</span><span style=color:#ce5c00;font-weight:700>());</span>
    <span style=color:#000>sequentialRecursive</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>n</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>getChildren</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>results</span><span style=color:#ce5c00;font-weight:700>);</span>
  <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#ce5c00;font-weight:700>}</span>

<span style=color:#204a87;font-weight:700>public</span> <span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>T</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>parallelRecursive</span><span style=color:#ce5c00;font-weight:700>(</span>
  <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>Executor</span> <span style=color:#000>exec</span><span style=color:#ce5c00;font-weight:700>,</span>
  <span style=color:#000>List</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>Node</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>T</span><span style=color:#ce5c00;font-weight:700>&gt;&gt;</span> <span style=color:#000>nodes</span><span style=color:#ce5c00;font-weight:700>,</span>
  <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>Collection</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>T</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>results</span>
<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
  <span style=color:#204a87;font-weight:700>for</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>Node</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>T</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>n</span> <span style=color:#ce5c00;font-weight:700>:</span> <span style=color:#000>nodes</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#000>exec</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>execute</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>Runnable</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span>
      <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>run</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span>
        <span style=color:#000>results</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>add</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>n</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>compute</span><span style=color:#ce5c00;font-weight:700>());</span>
      <span style=color:#ce5c00;font-weight:700>}</span>
    <span style=color:#ce5c00;font-weight:700>});</span>
    <span style=color:#000>parallelRecusive</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>exec</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>n</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>getChildren</span><span style=color:#ce5c00;font-weight:700>(),</span> <span style=color:#000>results</span><span style=color:#ce5c00;font-weight:700>);</span>
  <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>当 parallelRecursive 返回时，树中的各个节点都已经访问过了(但是遍历过程仍然是串行的，只有 compute 调用才是并行执行的)，并且每个节点的计算任务任务也已经放入 Executor 的工作队列。parallelRecursive 的调用者可以通过以下方式等待所有的结果：创建一个特定于遍历过过程的 Executor，并使用 shutdown 和 awaitTermination 等方法，如程序清单 8-12 所示。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#204a87;font-weight:700>public</span> <span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>T</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>Colleciton</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>T</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>getParallelResults</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>List</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>Node</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>T</span><span style=color:#ce5c00;font-weight:700>&gt;&gt;</span> <span style=color:#000>nodes</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#204a87;font-weight:700>throws</span> <span style=color:#000>InterruptedException</span> <span style=color:#ce5c00;font-weight:700>{</span>
  <span style=color:#000>ExecutorService</span> <span style=color:#000>exec</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>Executors</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>newCachedThreadPool</span><span style=color:#ce5c00;font-weight:700>();</span>
  <span style=color:#000>Queue</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>T</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>resultQueue</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>ConcuurentLinkedQueue</span><span style=color:#ce5c00;font-weight:700>&lt;&gt;();</span>
  <span style=color:#000>parallelRecursive</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>exec</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>nodes</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>resultQueue</span><span style=color:#ce5c00;font-weight:700>);</span>
  <span style=color:#000>exec</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>shutdown</span><span style=color:#ce5c00;font-weight:700>();</span>
  <span style=color:#000>exec</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>awaitTermination</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>Long</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>MAX_VALUE</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>TimeUnit</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>SECONDS</span><span style=color:#ce5c00;font-weight:700>);</span>
  <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>resultQueue</span><span style=color:#ce5c00;font-weight:700>;</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><h3 id=示例谜题框架>示例：谜题框架</h3>
<p>这项技术的一种强大应用就是解决一些谜题，这些谜题都需要找出一系列的操作从初始化状态转换到目标状态，例如类似于“搬箱子”、“Hi-Q”、“四色方柱”和其他的棋牌谜题。</p>
<p>我们将“谜题”定义为：包含了一个初始位置，一个目标位置，以及用于判断是否是有效移动的规则集。规则集包含两个部分：计算从指定位置开始的所有合法移动，以及每次移动的结果位置。在程序清单 8-13 给出了表示谜题的抽象类，其中的类型参数 P 和 M 表示位置类和移动类。根据这个接口，我们可以写一个简单的串行求解程序，该程序子在谜题空间(Puzzle Space)中查找，直到找到一个解答或者找遍了整个空间都没有发现答案。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>interface</span> <span style=color:#000>Puzzle</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>P</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>M</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#ce5c00;font-weight:700>{</span>
  <span style=color:#000>P</span> <span style=color:#000>initialPosition</span><span style=color:#ce5c00;font-weight:700>();</span>
  <span style=color:#204a87;font-weight:700>boolean</span> <span style=color:#000>isGoal</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>P</span> <span style=color:#000>position</span><span style=color:#ce5c00;font-weight:700>);</span>
  <span style=color:#000>Set</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>M</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>legalMoves</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>P</span> <span style=color:#000>position</span><span style=color:#ce5c00;font-weight:700>);</span>
  <span style=color:#000>P</span> <span style=color:#000>move</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>P</span> <span style=color:#000>position</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>M</span> <span style=color:#000>move</span><span style=color:#ce5c00;font-weight:700>);</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>程序清单 8-14 中的 Node 代表通过一系列的移动到达的一个位置，其中保存了到达该位置的移动以及前一个 Node。只要沿着 Node 链接逐步回溯，就可以重新构建出到达当前位置的移动序列。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#5c35cc;font-weight:700>@Immutable</span>
<span style=color:#204a87;font-weight:700>static</span> <span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>Node</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>P</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>M</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#ce5c00;font-weight:700>{</span>
  <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>P</span> <span style=color:#000>pos</span><span style=color:#ce5c00;font-weight:700>;</span>
  <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>M</span> <span style=color:#000>move</span><span style=color:#ce5c00;font-weight:700>;</span>
  <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>Node</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>P</span><span style=color:#ce5c00;font-weight:700>,</span><span style=color:#000>M</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>prev</span><span style=color:#ce5c00;font-weight:700>;</span>
  
  <span style=color:#000>Node</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>P</span> <span style=color:#000>pos</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>M</span> <span style=color:#000>move</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>Node</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>P</span><span style=color:#ce5c00;font-weight:700>,</span><span style=color:#000>M</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>prev</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{...}</span>
  
  <span style=color:#000>List</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>M</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>asMoveList</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#000>List</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>M</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>solution</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>LinkedList</span><span style=color:#ce5c00;font-weight:700>&lt;&gt;();</span>
    <span style=color:#204a87;font-weight:700>for</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>Node</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>P</span><span style=color:#ce5c00;font-weight:700>,</span><span style=color:#000>M</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>n</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>this</span><span style=color:#ce5c00;font-weight:700>;</span> <span style=color:#000>n</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>move</span> <span style=color:#ce5c00;font-weight:700>!=</span> <span style=color:#204a87;font-weight:700>null</span><span style=color:#ce5c00;font-weight:700>;</span> <span style=color:#000>n</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>n</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>prev</span><span style=color:#ce5c00;font-weight:700>)</span>
      <span style=color:#000>solution</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>add</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>0</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>n</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>move</span><span style=color:#ce5c00;font-weight:700>);</span>
    <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>solution</span><span style=color:#ce5c00;font-weight:700>;</span>
  <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>在程序清单 8-15 的 SequentialPuzzleSolver 中给出了谜题框架的串行解决方法，它在谜题空间中执行一个深度优先搜索，当找到解答方案(不一定是最短的解决方案)后结束搜索。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>SequentialPuzzleSolver</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>P</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>M</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#ce5c00;font-weight:700>{</span>
  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>Puzzle</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>P</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>M</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>puzzle</span><span style=color:#ce5c00;font-weight:700>;</span> 
  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>Set</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>P</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>seen</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>HashSet</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>P</span><span style=color:#ce5c00;font-weight:700>&gt;();</span>

  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#000>SequentialPuzzleSolver</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>Puzzle</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>P</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>M</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>puzzle</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span> 
    <span style=color:#204a87;font-weight:700>this</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>puzzle</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>puzzle</span><span style=color:#ce5c00;font-weight:700>;</span> 
  <span style=color:#ce5c00;font-weight:700>}</span>

  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#000>List</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>M</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>solve</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span> 
    <span style=color:#000>P</span> <span style=color:#000>pos</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>puzzle</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>initialPosition</span><span style=color:#ce5c00;font-weight:700>();</span> 
    <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>search</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>Node</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>P</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>M</span><span style=color:#ce5c00;font-weight:700>&gt;(</span><span style=color:#000>pos</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#204a87;font-weight:700>null</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#204a87;font-weight:700>null</span><span style=color:#ce5c00;font-weight:700>));</span> 
  <span style=color:#ce5c00;font-weight:700>}</span>

  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#000>List</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>M</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>search</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>Node</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>P</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>M</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>node</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#204a87;font-weight:700>if</span> <span style=color:#ce5c00;font-weight:700>(!</span><span style=color:#000>seen</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>contains</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>node</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>pos</span><span style=color:#ce5c00;font-weight:700>))</span> <span style=color:#ce5c00;font-weight:700>{</span> 
      <span style=color:#000>seen</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>add</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>node</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>pos</span><span style=color:#ce5c00;font-weight:700>);</span> 
      <span style=color:#204a87;font-weight:700>if</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>puzzle</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>isGoal</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>node</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>pos</span><span style=color:#ce5c00;font-weight:700>))</span> 
        <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>node</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>asMoveList</span><span style=color:#ce5c00;font-weight:700>();</span> 
      <span style=color:#204a87;font-weight:700>for</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>M</span> <span style=color:#000>move</span> <span style=color:#ce5c00;font-weight:700>:</span> <span style=color:#000>puzzle</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>legalMoves</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>node</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>pos</span><span style=color:#ce5c00;font-weight:700>))</span> <span style=color:#ce5c00;font-weight:700>{</span> 
        <span style=color:#000>P</span> <span style=color:#000>pos</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>puzzle</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>move</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>node</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>pos</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>move</span><span style=color:#ce5c00;font-weight:700>);</span> 
        <span style=color:#000>Node</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>P</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>M</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>child</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>Node</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>P</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>M</span><span style=color:#ce5c00;font-weight:700>&gt;(</span><span style=color:#000>pos</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>move</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>node</span><span style=color:#ce5c00;font-weight:700>);</span> 
        <span style=color:#000>List</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>M</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>result</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>search</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>child</span><span style=color:#ce5c00;font-weight:700>);</span> 
        <span style=color:#204a87;font-weight:700>if</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>result</span> <span style=color:#ce5c00;font-weight:700>!=</span> <span style=color:#204a87;font-weight:700>null</span><span style=color:#ce5c00;font-weight:700>)</span> 
          <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>result</span><span style=color:#ce5c00;font-weight:700>;</span> 
      <span style=color:#ce5c00;font-weight:700>}</span>
    <span style=color:#ce5c00;font-weight:700>}</span> 
    <span style=color:#204a87;font-weight:700>return</span> <span style=color:#204a87;font-weight:700>null</span><span style=color:#ce5c00;font-weight:700>;</span>
  <span style=color:#ce5c00;font-weight:700>}</span>
  <span style=color:#204a87;font-weight:700>static</span> <span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>Node</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>P</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>M</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#ce5c00;font-weight:700>{</span> <span style=color:#8f5902;font-style:italic>/* Listing 8.14 */</span> <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>通过修改解决方案以利用并发性，可以以并发方式来计算下一步移动以及目标条件，因为计算某次移动的过程在很大程度上与计算其他移动的过程是相互独立的。(之所以说“在很大的程度上”，是因为在各个任务之间会共享一些可变状态，例如已遍历位置的集合)。如果有多个处理器可用，那么这将减少寻找解决方案所花费的时间。</p>
<p>在程序清单 8-16 的 ConcurrentPuzzleSolver 中使用了一个内部类 SolverTask，这个类扩展了 Node 并实现了 Runnable。大多数工作都是在 run 方法中完成的：首先计算出下一步可能到达的所有位置，并去掉已经到达的位置，然后判断(这个任务或其他某个任务)是否已经成功完成，最后将尚未搜索过的位置交给 Executor。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>ConcurrentPuzzleSolver</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>P</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>M</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#ce5c00;font-weight:700>{</span>
  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>Puzzle</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>P</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>M</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>puzzle</span><span style=color:#ce5c00;font-weight:700>;</span> 
  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>ExecutorService</span> <span style=color:#000>exec</span><span style=color:#ce5c00;font-weight:700>;</span> 
  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>ConcurrentMap</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>P</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>Boolean</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>seen</span><span style=color:#ce5c00;font-weight:700>;</span> 
  <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>ValueLatch</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>Node</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>P</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>M</span><span style=color:#ce5c00;font-weight:700>&gt;&gt;</span> <span style=color:#000>solution</span> <span style=color:#ce5c00;font-weight:700>=</span> 
    <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>ValueLatch</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>Node</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>P</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>M</span><span style=color:#ce5c00;font-weight:700>&gt;&gt;();</span> 
  <span style=color:#ce5c00;font-weight:700>...</span>

  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#000>List</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>M</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>solve</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#204a87;font-weight:700>throws</span> <span style=color:#000>InterruptedException</span> <span style=color:#ce5c00;font-weight:700>{</span> 
    <span style=color:#204a87;font-weight:700>try</span> <span style=color:#ce5c00;font-weight:700>{</span> 
      <span style=color:#000>P</span> <span style=color:#000>p</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>puzzle</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>initialPosition</span><span style=color:#ce5c00;font-weight:700>();</span> 
      <span style=color:#000>exec</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>execute</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>newTask</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>p</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#204a87;font-weight:700>null</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#204a87;font-weight:700>null</span><span style=color:#ce5c00;font-weight:700>));</span> 
      <span style=color:#8f5902;font-style:italic>// block until solution found 
</span><span style=color:#8f5902;font-style:italic></span>      <span style=color:#000>Node</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>P</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>M</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>solnNode</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>solution</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>getValue</span><span style=color:#ce5c00;font-weight:700>();</span> 
      <span style=color:#204a87;font-weight:700>return</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>solnNode</span> <span style=color:#ce5c00;font-weight:700>==</span> <span style=color:#204a87;font-weight:700>null</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>?</span> <span style=color:#204a87;font-weight:700>null</span> <span style=color:#ce5c00;font-weight:700>:</span> <span style=color:#000>solnNode</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>asMoveList</span><span style=color:#ce5c00;font-weight:700>();</span> 
    <span style=color:#ce5c00;font-weight:700>}</span> <span style=color:#204a87;font-weight:700>finally</span> <span style=color:#ce5c00;font-weight:700>{</span> <span style=color:#000>exec</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>shutdown</span><span style=color:#ce5c00;font-weight:700>();</span> <span style=color:#ce5c00;font-weight:700>}</span>
  <span style=color:#ce5c00;font-weight:700>}</span>

  <span style=color:#204a87;font-weight:700>protected</span> <span style=color:#000>Runnable</span> <span style=color:#000>newTask</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>P</span> <span style=color:#000>p</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>M</span> <span style=color:#000>m</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>Node</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>P</span><span style=color:#ce5c00;font-weight:700>,</span><span style=color:#000>M</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>n</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span> 
    <span style=color:#204a87;font-weight:700>return</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>SolverTask</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>p</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>m</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>n</span><span style=color:#ce5c00;font-weight:700>);</span> 
  <span style=color:#ce5c00;font-weight:700>}</span>

  <span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>SolverTask</span> <span style=color:#204a87;font-weight:700>extends</span> <span style=color:#000>Node</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>P</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>M</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#204a87;font-weight:700>implements</span> <span style=color:#000>Runnable</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#ce5c00;font-weight:700>...</span>

    <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>run</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span> 
      <span style=color:#204a87;font-weight:700>if</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>solution</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>isSet</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>||</span> 
        <span style=color:#000>seen</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>putIfAbsent</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>pos</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#204a87;font-weight:700>true</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>!=</span> <span style=color:#204a87;font-weight:700>null</span><span style=color:#ce5c00;font-weight:700>)</span> 
        <span style=color:#204a87;font-weight:700>return</span><span style=color:#ce5c00;font-weight:700>;</span>  <span style=color:#8f5902;font-style:italic>// already solved or seen this position 
</span><span style=color:#8f5902;font-style:italic></span>      <span style=color:#204a87;font-weight:700>if</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>puzzle</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>isGoal</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>pos</span><span style=color:#ce5c00;font-weight:700>))</span> 
        <span style=color:#000>solution</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>setValue</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>this</span><span style=color:#ce5c00;font-weight:700>);</span> 
      <span style=color:#204a87;font-weight:700>else</span> <span style=color:#204a87;font-weight:700>for</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>M</span> <span style=color:#000>m</span> <span style=color:#ce5c00;font-weight:700>:</span> <span style=color:#000>puzzle</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>legalMoves</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>pos</span><span style=color:#ce5c00;font-weight:700>))</span> 
        <span style=color:#000>exec</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>execute</span><span style=color:#ce5c00;font-weight:700>(</span> <span style=color:#000>newTask</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>puzzle</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>move</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>pos</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>m</span><span style=color:#ce5c00;font-weight:700>),</span> <span style=color:#000>m</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#204a87;font-weight:700>this</span><span style=color:#ce5c00;font-weight:700>));</span>

    <span style=color:#ce5c00;font-weight:700>}</span>
  <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>为了避免无限循环，在串行版本中引入了一个 Set 对象，其中保存了之前已经搜索过的所有位置。在 ConcurrentPuzzleSovler 中使用了 ConcurrentHashMap 来实现相同的功能。这种做法不仅提供了线程安全性，还避免了在更新共享集合时存在的竟态条件，因为 putIfAbsent 只有在之前没有遍历过的某个位置才会通过原子方式添加到集合中。ConcurrentPuzzleSolver 使用线程池内部工作队列而不是调用栈来保存搜索的状态。</p>
<p>这种并发方法引入了一种新形式的限制去掉了一种原有的限制，新的限制在这个问题域中更合适。串行版本的程序执行深度优先搜索，因此搜索过程将受限于栈的大小。并发版本的程序执行广度优先搜索，因此不会受到栈大小的限制(但如果待搜索的或则已搜索的位置集合大小超过了可用的内存总量，那么仍可能耗尽内存)。</p>
<p>为了在找到某个解答后停止搜索，需要通过某种方法来检查是否有线程已经找到了一个解答。如果需要第一个找到的解答，那么嗨需要在其他任务都没有找到解答时更新答案。这些需求买哦是的是一种闭锁机制，具体的说，是一种包含结果的闭锁。通过使用第 14 章中的技术，可以很容易的构造出一个阻塞的并且可携带结果的闭锁，但更简单且更不容易出错的方式是使用现有库中的类，而不是使用底层的语言机制。在程序清单 8-17 的 ValueLatch 中使用 CountDownLatch 来实现所需的闭锁行为，并且使用多订机制来确保解答只会被设置一次。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#5c35cc;font-weight:700>@ThreadSafe</span> <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>ValueLatch</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>T</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#ce5c00;font-weight:700>{</span>

  <span style=color:#5c35cc;font-weight:700>@GuardedBy</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#4e9a06>&#34;this&#34;</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#204a87;font-weight:700>private</span> <span style=color:#000>T</span> <span style=color:#000>value</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>null</span><span style=color:#ce5c00;font-weight:700>;</span> 
  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>CountDownLatch</span> <span style=color:#000>done</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>CountDownLatch</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>1</span><span style=color:#ce5c00;font-weight:700>);</span>

  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>boolean</span> <span style=color:#000>isSet</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span> <span style=color:#204a87;font-weight:700>return</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>done</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>getCount</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>==</span> <span style=color:#000>0</span><span style=color:#ce5c00;font-weight:700>);</span> <span style=color:#ce5c00;font-weight:700>}</span> 
  
  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>synchronized</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>setValue</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>T</span> <span style=color:#000>newValue</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span> 
    <span style=color:#204a87;font-weight:700>if</span> <span style=color:#ce5c00;font-weight:700>(!</span><span style=color:#000>isSet</span><span style=color:#ce5c00;font-weight:700>())</span> <span style=color:#ce5c00;font-weight:700>{</span> 
      <span style=color:#000>value</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>newValue</span><span style=color:#ce5c00;font-weight:700>;</span> 
      <span style=color:#000>done</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>countDown</span><span style=color:#ce5c00;font-weight:700>();</span> 
    <span style=color:#ce5c00;font-weight:700>}</span> 
  <span style=color:#ce5c00;font-weight:700>}</span>

  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#000>T</span> <span style=color:#000>getValue</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#204a87;font-weight:700>throws</span> <span style=color:#000>InterruptedException</span> <span style=color:#ce5c00;font-weight:700>{</span> 
    <span style=color:#000>done</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>await</span><span style=color:#ce5c00;font-weight:700>();</span> 
    <span style=color:#204a87;font-weight:700>synchronized</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>this</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span> <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>value</span><span style=color:#ce5c00;font-weight:700>;</span> <span style=color:#ce5c00;font-weight:700>}</span> 
  <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>每个任务首先查询 solution 闭锁，找到一个解答就停止。而在此之前，主线程需要等待，ValueLatch 中的 getValue 将一直阻塞，直到有线程设置了这个值。ValueLatch 提供了一种方式来保存这个值，只有第一次调用才会设置它。调用者能够判断这个值是否已经被设置，以及阻塞并等待后它被设置。在第一次调用 setValue 时，将更新解答方案，并且 CountDownLatch 会递减，从 getValue 中释放主线程。</p>
<p>第一个找到解答的线程还会关闭 Executor，从而阻止接受新的任务。要避免处理 RejectedExecutionException，需要将拒绝执行处理器设置为“抛弃已提交的任务”。然后，所有未完成的任务最终将执行完成，并且在执行任何新任务时都会失败，从而使 Executor 结束。(如果任务运行时间过长，那么可以中断它们而不是等待它们完成)</p>
<p>如果不存在解答，那么 ConcurrentPuzzleSolver 就不能很好的处理这种情况：如果已经遍历的所有移动和位置都没有找到解答，那么在 getSolution 调用中将永远等待下去。当遍历了真个搜索空间时，串行版本的程序将结束，但要结束并发程序会更将困难。其中一个方法是：记录活动任务的数量，当该值为零时将解答设置为 null，如程序清单 8-18 所示。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>PuzzleSolver</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>P</span><span style=color:#ce5c00;font-weight:700>,</span><span style=color:#000>M</span><span style=color:#ce5c00;font-weight:700>&gt;</span> 
  <span style=color:#204a87;font-weight:700>extends</span> <span style=color:#000>ConcurrentPuzzleSolver</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>P</span><span style=color:#ce5c00;font-weight:700>,</span><span style=color:#000>M</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#ce5c00;font-weight:700>{</span> 
  <span style=color:#ce5c00;font-weight:700>...</span> 
  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>AtomicInteger</span> <span style=color:#000>taskCount</span> <span style=color:#ce5c00;font-weight:700>=</span> 
    <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>AtomicInteger</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>0</span><span style=color:#ce5c00;font-weight:700>);</span>

  <span style=color:#204a87;font-weight:700>protected</span> <span style=color:#000>Runnable</span> <span style=color:#000>newTask</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>P</span> <span style=color:#000>p</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>M</span> <span style=color:#000>m</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>Node</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>P</span><span style=color:#ce5c00;font-weight:700>,</span><span style=color:#000>M</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>n</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span> 
    <span style=color:#204a87;font-weight:700>return</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>CountingSolverTask</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>p</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>m</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>n</span><span style=color:#ce5c00;font-weight:700>);</span> 
  <span style=color:#ce5c00;font-weight:700>}</span>

  <span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>CountingSolverTask</span> <span style=color:#204a87;font-weight:700>extends</span> <span style=color:#000>SolverTask</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#000>CountingSolverTask</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>P</span> <span style=color:#000>pos</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>M</span> <span style=color:#000>move</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>Node</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>P</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>M</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>prev</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
      <span style=color:#204a87;font-weight:700>super</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>pos</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>move</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>prev</span><span style=color:#ce5c00;font-weight:700>);</span> 
      <span style=color:#000>taskCount</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>incrementAndGet</span><span style=color:#ce5c00;font-weight:700>();</span> 
    <span style=color:#ce5c00;font-weight:700>}</span> 
    
    <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>run</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span> 
      <span style=color:#204a87;font-weight:700>try</span> <span style=color:#ce5c00;font-weight:700>{</span> <span style=color:#204a87;font-weight:700>super</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>run</span><span style=color:#ce5c00;font-weight:700>();</span> <span style=color:#ce5c00;font-weight:700>}</span> 
      <span style=color:#204a87;font-weight:700>finally</span> <span style=color:#ce5c00;font-weight:700>{</span> 
        <span style=color:#204a87;font-weight:700>if</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>taskCount</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>decrementAndGet</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>==</span> <span style=color:#000>0</span><span style=color:#ce5c00;font-weight:700>)</span> 	
          <span style=color:#000>solution</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>setValue</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>null</span><span style=color:#ce5c00;font-weight:700>);</span> 
      <span style=color:#ce5c00;font-weight:700>}</span> 
    <span style=color:#ce5c00;font-weight:700>}</span>
  <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>找到解答的时间可能比等待的时间更长，因此在解决器中需要包含几个结束条件。其中一个结束条件是时间限制，这很容易实现：在 ValueLatch 中实现一个限时的 getValue(其中将使用限时版本的 await)，如果 getValue 超时，那么关闭 Executor 并声明一个失败。另一个结束条件是某种特定于谜题的标准，例如仅搜索特定数量的位置。此外，还可以提供一种取消机制，由用户来决定何时停止搜索。</p>
<h2 id=总结>总结</h2>
<p>对于并发执行任务，Executor 框架是一种强大且灵活的框架。它提供了大量可调节的选项，例如创建线程和关闭线程的策略，处理队列任务的策略，处理过多任务的策略，并且提供了几个钩子方法来扩展它的行为。然而，与大多数功能强大的框架一样，其中有些设置参数并不能很好的工作，某些类型的任务需要特定的执行策略，而一些参数组合则可能产生奇怪的结果。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-ee31a489e60b7eb53487aea1f8b19250>9 - CH09-GUI应用</h1>
<p>如果用 Swing 编写过简单的图形用户界面应用程序，那么就应该知道 GUI 应用程序有其奇特的线程问题。为了维护安全性，一些特定的任务必须运行在 Swing 的事件线程中。然而，在事件线程中不应该执行时间较长的操作，以免用户界面失去响应。而且，由于 Swing 的数据结构不是线程安全的，因此必须将它们限制在事件线程中。</p>
<p>几乎所有的 GUI 工具包都被实现为单线程子系统，这意味着所有的 GUI 操作都被限制在单个线程中。如果你不打算编写一个单线程程序，那么就会有部分操作在一个应用程序线程中执行，而其他操作则在事件线程中执行。与其他线程错误一样，即使在这种操作分解中出现了错误，也会导致应用程序立即崩溃，而且程序将在一个难以确定的条件下表现出奇怪的行为。虽然 GUI 框架本身是单线程子系统，但应用程序可能不是单线程的，因此在编写 GUI 代码时仍然需要谨慎的考虑线程问题。</p>
<h2 id=91-为什么-gui-是单线程的>9.1 为什么 GUI 是单线程的</h2>
<p>早期的 GUI 程序都是单线程的，并且 GUI 事件在“主事件循环”进行处理。当前的 GUI 框架则使用了一种略有不同的模型：在该模型中创建一个专门事件分发线程(EDT)来处理 GUI 事件。</p>
<p>单线程的 GUI 框架并不仅限于在 Java 中，在 Qt、NexiStep、MaxOS Cocoa、X Windows 以及其他环境中的 GUI 框架都是单线程的。许多人曾经尝试过编写多线程的 GUI 框架，但最终都由于竟态条件和死锁导致的稳定性问题而又重新回到单线程的事件队列模型：采用一个专门的线程从队列中抽取事件，并将它们转发到应用程序定义的事件处理器。(AWT 最初尝试在更大程度上支持多线程访问，而正是基于在 AWT 中得到的经验和教训，Swing 在实现时决定采用单线程模型)。</p>
<p>在多线程的 GUI 框架中更容易发生死锁问题，其部分原因在于，在输入事件的处理过程与 GUI 组件的面向对象模型之间会存在错误的交互。用户引发的动过将通过一种类似于“气泡上升”的方式从操作系统传递给应用程序——操作系统首先检测到一个鼠标点击，然后通过工具包将其转换为“鼠标点击”事件，该事件最终被转换为一个更高层事件(如“鼠标键被按下”事件)转发给应用程序的监听器。另一个方面，应用程序引发的工作有会以“气泡下沉”的方式从应用程序返回到操作系统。例如，在应用程序中引发修改某个组件背景色的请求，该请求将被转发给某个特定的组件类，并最终转发给操作系统进行绘制。因此，一方面这组操作将以完全相反的顺序来访问相同的 GUI 对象；另一方面，又要确保对象都是线程安全的，从而导致不一致的锁定顺序，并引发死锁。这种问题几乎在每次开发 GUI 包时都会重现。</p>
<p>另一个在多线程 GUI 框架中导致死锁的原因就是“模型——视图——控制(MVC)”这种设计模式的广泛应用。通过将用户的交互分解到模型、视图和控制等模块中，能极大的简化 GUI 应用程序的实现，但这却进一步增加了出现不一致锁定顺序的风险。“控制”模块将调用“模型”模块，而“模型”模块将发生的变化通知给“视图”模块。“控制”模块同样可以调用“视图”模块，并调用“模型”模块来查询模型的状态。这将再次导致不一致的锁定顺序并出现死锁。</p>
<p>Sun 公司的前副总裁 Graham Hamilton 在其博客中总结了这些问题，详细阐述了为什么多线程的 GUI 工具包会成为计算机科学史上的又一个“失败的梦想”。</p>
<blockquote>
<p>不过，我相信你还是可以成功的编写出多线程的 GUI 工具包，只要做到：非常晋升的设计多线程 GUI 工具包，详尽无遗的公开工具包的锁定方法，以及你非常聪明，非常仔细，并且对工具包的整体结构有着全局理解。然而，如果在上述某个方面稍有偏差，那么即使程序在大多数时候都能正确运行，但在偶尔情况下仍会出现(死锁引起的)挂起或(竞争引起的)运行故障。只有那些深入参与工具包设计的人们才能够正确的使用这种多线程的 GUI 框架。</p>
<p>然而，我并不认为这些特性能够在商业产品中得到广泛应用。可能出现的情况是：大多数普通的开发者发现应用程序无法可靠的运行，而又找不到其中的原因。于是，这些开发者会感到非常不满，并诅咒这些无辜的工具包。</p>
</blockquote>
<p>单线程的 GUI 框架通过线程封闭机制来实现线程安全性。所有 GUI 对象，包括可视化组件和数据模型等，都只能在事件线程中访问。当然，这只是将确保线程安全性的一部分工作交给应用程序的开发人员来负责，他们必须确保这些对象被正确的封闭在事件线程中。</p>
<h3 id=911-串行事件处理>9.1.1 串行事件处理</h3>
<p>GUI 应用程序需要处理一些细粒度的事件，例如点击鼠标、按下键盘或定时器超时等。事件是另一种类型的任务，而 AWT 和 Swing 提供的事件处理机制在结构上也类似于 Executor。</p>
<p>因为只有单个线程来处理所有的 GUI 任务，因此会采用依次处理的方式——处理完一个任务后再开始下一个任务，在两个任务的处理之间不会重叠。清除了这一点，就可以更容易的编写任务代码，而无需担心其他任务会产生干扰。</p>
<p>串行任务处理的不利之处在于，如果某个任务的处理时间很长，那么其他任务必须等到该任务执行结束。如果这些任务的工作是响应用户输入或者提供可视化界面反馈，那么应该程序看似会失去响应。如果在事件线程中执行时间较长的任务，那么用户甚至无法点击“取消”按钮，因为在该任务完成之前，将无法调用“取消”按钮的监听器。因此，在事件线程中执行的任务必须尽快的把控制权交换给事件线程。要启动一些执行耗时较长的任务，例如对某个大型文档执行拼写检查，在文件系统中执行搜索，或者通过网络获取资源等，必须在另一个线程中执行这些任务，从而尽快的将控制权交还给事件线程。如果要在执行某个事件较长的任务时更新进度标识，或者在任务完成后提高一个可视化的反馈，那么需要再次执行事件线程中的代码。这会很快使程序变得更加复杂。</p>
<h3 id=912-swing-中的线程封闭机制>9.1.2 Swing 中的线程封闭机制</h3>
<p>所有 Swing 组件和数据模型对象都被封闭在事件线程中，因此任何访问它们的代码都必须在事件线程中运行。GUI 对象并非通过同步来确保一致性，而是通过线程封闭机制。这种方法的好处在于，当访问表现对象时在事件线程中运行的任务无需担心同步问题，而坏处在于，无法从事件线程之外的线程中访问表现对象。</p>
<blockquote>
<p>Swing 的单线程规则是：Swing 中的组件以及模型只能在这个事件分发线程中进行创建、修改、查询。</p>
</blockquote>
<p>与所有的规则不同，这个规则也存在一些例外情况。Swing 中只有少数方法可以安全的从其他线程中调用，而在 Javadoc 中已经很清楚的说明了这些方法的线程安全性。单线程规则的其他一些例外情况包括：</p>
<ul>
<li>SwingUtilities.isEventDispatchThread，用于判断当前线程是否是事件线程。</li>
<li>SwingUtilities.invokeLater，该方法可以将一个 Runnable 任务调度到事件线程中执行(可以从任意线程中调用)。</li>
<li>SwingUtilities.invokeAndWait，该方法可以将一个 Runnable 任务调度到事件线程中执行，并阻塞当前线程直到任务完成(只能从非 GUI 线程中调用)。</li>
<li>所有将重绘请求或重生效请求插入队列的方法(可以从任意线程调用)。</li>
<li>所有添加或移除监听器的方法(这些方法可以在任意线程中调用，但监听器本身一定要在事件线程中调用)。</li>
</ul>
<p>invokeLater 和 invokeAndWait 两个方法的作用酷似 Executor。事实上，用单线程的 Executor 来实现 SwingUtilities 中与线程相关的方法是很容易的，如程序清单 9-1 所示。这并非是 SwingUtilities 中的真实实现，因为 Swing 的出现时间要早于 Executor 框架，但如果现在来实现 Swing，或许应该采用这种实现方式。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>SwingUtilities</span> <span style=color:#ce5c00;font-weight:700>{</span>

  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>static</span> <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>ExecutorService</span> <span style=color:#000>exec</span> <span style=color:#ce5c00;font-weight:700>=</span> 
    <span style=color:#000>Executors</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>newSingleThreadExecutor</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>SwingThreadFactory</span><span style=color:#ce5c00;font-weight:700>());</span> 
  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>static</span> <span style=color:#204a87;font-weight:700>volatile</span> <span style=color:#000>Thread</span> <span style=color:#000>swingThread</span><span style=color:#ce5c00;font-weight:700>;</span>

  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>static</span> <span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>SwingThreadFactory</span> <span style=color:#204a87;font-weight:700>implements</span> <span style=color:#000>ThreadFactory</span> <span style=color:#ce5c00;font-weight:700>{</span> 
    <span style=color:#204a87;font-weight:700>public</span> <span style=color:#000>Thread</span> <span style=color:#000>newThread</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>Runnable</span> <span style=color:#000>r</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span> 
      <span style=color:#000>swingThread</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>Thread</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>r</span><span style=color:#ce5c00;font-weight:700>);</span> 
      <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>swingThread</span><span style=color:#ce5c00;font-weight:700>;</span> 
    <span style=color:#ce5c00;font-weight:700>}</span> 
  <span style=color:#ce5c00;font-weight:700>}</span>

  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>static</span> <span style=color:#204a87;font-weight:700>boolean</span> <span style=color:#000>isEventDispatchThread</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span> 
    <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>Thread</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>currentThread</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>==</span> <span style=color:#000>swingThread</span><span style=color:#ce5c00;font-weight:700>;</span> 
  <span style=color:#ce5c00;font-weight:700>}</span>

  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>static</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>invokeLater</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>Runnable</span> <span style=color:#000>task</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span> 
    <span style=color:#000>exec</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>execute</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>task</span><span style=color:#ce5c00;font-weight:700>);</span> 
  <span style=color:#ce5c00;font-weight:700>}</span>

  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>static</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>invokeAndWait</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>Runnable</span> <span style=color:#000>task</span><span style=color:#ce5c00;font-weight:700>)</span> 
    <span style=color:#204a87;font-weight:700>throws</span> <span style=color:#000>InterruptedException</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>InvocationTargetException</span> <span style=color:#ce5c00;font-weight:700>{</span> 
    <span style=color:#000>Future</span> <span style=color:#000>f</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>exec</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>submit</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>task</span><span style=color:#ce5c00;font-weight:700>);</span> 
    <span style=color:#204a87;font-weight:700>try</span> <span style=color:#ce5c00;font-weight:700>{</span> <span style=color:#000>f</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>get</span><span style=color:#ce5c00;font-weight:700>();</span> <span style=color:#ce5c00;font-weight:700>}</span> 
    <span style=color:#204a87;font-weight:700>catch</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>ExecutionException</span> <span style=color:#000>e</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span> 
      <span style=color:#204a87;font-weight:700>throw</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>InvocationTargetException</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>e</span><span style=color:#ce5c00;font-weight:700>);</span> 
    <span style=color:#ce5c00;font-weight:700>}</span> 
  <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>可以将 Swing 的事件线程视为一个单线程的 Executor，它处理来自事件队列的任务。与线程池一样，有时候工作者线程会死亡并由另一个新线程来替代，但这一切要对任务透明。如果所有任务的执行时间都很短，或者任务调度的可预见性并不重要，又或者任务不能被并发执行，那么应该采用串行的和单线程的执行策略。</p>
<p>程序清单 9-2 中的 GuiExecutor 是一个 Executor，它将任务委托给 SwingUtilities 来执行。也可以使用其他的 GUI 框架来实现它，例如 SWT 提供的 Display.asyncExec 方法，它类似于 Swing 中的 invokeLater。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>GuiExecutor</span> <span style=color:#204a87;font-weight:700>extends</span> <span style=color:#000>AbstractExecutorService</span> <span style=color:#ce5c00;font-weight:700>{</span>

  <span style=color:#8f5902;font-style:italic>// Singletons have a private constructor and a public factory 
</span><span style=color:#8f5902;font-style:italic></span>  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>static</span> <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>GuiExecutor</span> <span style=color:#000>instance</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>GuiExecutor</span><span style=color:#ce5c00;font-weight:700>();</span>

  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#000>GuiExecutor</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span> <span style=color:#ce5c00;font-weight:700>}</span>

  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>static</span> <span style=color:#000>GuiExecutor</span> <span style=color:#000>instance</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span> <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>instance</span><span style=color:#ce5c00;font-weight:700>;</span> <span style=color:#ce5c00;font-weight:700>}</span>

  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>execute</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>Runnable</span> <span style=color:#000>r</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span> 
    <span style=color:#204a87;font-weight:700>if</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>SwingUtilities</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>isEventDispatchThread</span><span style=color:#ce5c00;font-weight:700>())</span> 
      <span style=color:#000>r</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>run</span><span style=color:#ce5c00;font-weight:700>();</span> 
    <span style=color:#204a87;font-weight:700>else</span> <span style=color:#000>SwingUtilities</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>invokeLater</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>r</span><span style=color:#ce5c00;font-weight:700>);</span> 
  <span style=color:#ce5c00;font-weight:700>}</span>

  <span style=color:#8f5902;font-style:italic>// Plus trivial implementations of lifecycle methods
</span><span style=color:#8f5902;font-style:italic></span><span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><h2 id=92-短时间的-gui-任务>9.2 短时间的 GUI 任务</h2>
<p>在 GUI 应用中，事件在事件线程中产生，并通过“气泡上升”的方式来传递给应用程序提供的监听器，而监听器则根据收到的事件执行一些计算来修改表现对象。为了简便，短时间的任务可以把整个操作都放在事件线程中执行，而对于长时间的任务，则应该讲某些操作放到另一个线程中执行。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>Random</span> <span style=color:#000>random</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>Random</span><span style=color:#ce5c00;font-weight:700>();</span>
<span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>JButton</span> <span style=color:#000>button</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>JButton</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#4e9a06>&#34;change color&#34;</span><span style=color:#ce5c00;font-weight:700>);</span>
<span style=color:#ce5c00;font-weight:700>...</span>
<span style=color:#000>button</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>addActionListener</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>ActionListener</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span>
  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>actionPerformed</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>ActionEvent</span> <span style=color:#000>e</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#000>button</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>setBackground</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>Color</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>random</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>nexInt</span><span style=color:#ce5c00;font-weight:700>()));</span>
  <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#ce5c00;font-weight:700>})</span>
</code></pre></div><p>在这种情况下，表现对象封闭在事件线程中。程序清单 9-3 创建了一个按钮，它的颜色在被按下时会随机的变化。当用户点击按钮时，工具包将事件线程中的一个 ActionEvent 投递给所有已注册的 ActionListener，作为响应，ActionListener 将选择一个新的颜色，并将按钮的背景颜色设置为新颜色。这样，在 GUI 工具包中产生事件，然后发送到应用程序，而应用程序通过修改 GUI 来响应用户的动作。在这期间，执行控制始终不会离开事件线程，如图 9-1所示。</p>
<div align=center>
<img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20181118174040.png style=display:block;width:70% alt=9-1 align=center>
</div>
<p>这个示例揭示了 GUI 应用程序和 GUI 工具包之间的主要交互。只要任务是短期的，并且只访问 GUI 对象(或者其他线程封闭的或线程安全的应用程序对象)，那么就可以忽略与线程相关的问题，而在时间线程中可以执行任何操作都不会出问题。</p>
<p>图 9-2 给出了一个略微复杂的版本，其中使用了正式的数据模型，例如 TableModel 或 TreeModel。Swing 将大多数可视化组件都分为两个对象，即模型对象和视图对象。在模型对象中保存的是将被显示的数据，而在视图对象中则保存了控制显示方式的规则。模型对象可以通过引发事件来表示模型数据发生了变化，而视图对象则通过“订阅”来接收这些事件。当视图对象收到表示模型数据已经发生变化的事件，将向模型对象查询新的数据，并更新界面显示。因此，在一个修改表格内容的按钮监听器中，事件监听器将更新模型并调用其中一个 fireXxx 方法，这个方法会依次调用视图对象中表格模型监听器，从而更新视图的显示。同样，执行控制权仍然不会离开事件线程。(Swing 数据模型的 fireXxx 方法通常会直接调用模型监听器，而不会向线程队列中提交新的事件，因此 fireXxx 方法只能从事件线程中调用。)</p>
<div align=center>
<img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20181118174102.png style=display:block;width:70% alt=9-2 align=center>
</div>
<h2 id=93-长时间的-gui-任务>9.3 长时间的 GUI 任务</h2>
<p>如果所有任务的执行时间都较短(并且应用中不包含执行时间较长的非 GUI 部分)，那么整个应用程序都可以在事件线程内部运行，并且完全不用关心线程。然而，在复杂的 GUI 应用中可能包含一些执行时间较长的任务，并且可能超过了用户可以等待的时间，例如拼写检查、后台编辑或者远程资源获取等。这些任务必须在另一个线程中运行，才能使得 GUI 在运行时保持高响应性。</p>
<p>Swing 使得在事件线程中运行任务很容易，但(在 Java 6 之前)并没有提供任何机制来帮助 GUI 任务执行其他线程中的代码。然而在这里并不需要借助 Swing：可以创建自己的 Executor 来执行长时间的任务。对于长时间的任务，可以使用缓存线程池。只要 GUI 应用程序很少会发起大量的长时间任务，因此即使线程池可以无限制的增长也不会有太大风险。</p>
<p>首先我们来看一个简单的任务，该任务不支持取消操作和进度指示，也不会在完成后更新 GUI，我们之后再将这些功能依次添加进来。在程序清单 9-4 中给出了一个与某个可视化组件绑定的监听器，它将一个长时间的任务提交给一个 Executor。尽管有两个层次的内部类，但通过这种方式使某个 GUI 任务启动另一个任务还是很简单的：在事件线程中调用 UI 动作监听器，然后将一个 Runnable 提交到线程池中执行。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#000>ExecutorService</span> <span style=color:#000>backgroundExec</span> <span style=color:#ce5c00;font-weight:700>=</span> 
  <span style=color:#000>Executors</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>newCachedThreadPool</span><span style=color:#ce5c00;font-weight:700>();</span> 
<span style=color:#ce5c00;font-weight:700>...</span>

<span style=color:#000>button</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>addActionListener</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>ActionListener</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span>
  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>actionPerformed</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>ActionEvent</span> <span style=color:#000>e</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#000>backgroundExec</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>execute</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>Runnable</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span> 
      <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>run</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span> <span style=color:#000>doBigComputation</span><span style=color:#ce5c00;font-weight:700>();</span> <span style=color:#ce5c00;font-weight:700>}</span>
  <span style=color:#ce5c00;font-weight:700>});</span> 
<span style=color:#ce5c00;font-weight:700>}});</span>
</code></pre></div><p>这个示例通过 “Fire and Forget” 方式将长时间运行的任务从事件线程中分类出来，这种方式可能不是非常有用。在执行完一个产时间的任务后，通常会产生某种可视化的反馈给用户。但你并不能从后台线程中访问这些表现对象，因此任务在完成时必须向事件线程提交另一个任务来更新用户界面。</p>
<p>程序清单 9-5 给出了如何实现这个功能的方式，但此时已经开始变得复杂了，即已经有了三层内部类。动作监听器首先使按钮无效，并设置一个标签表示正在进行某个计算，然后将一个任务提交给后台的 Executor。当任务完成时，它会在事件下滑才能中增加另一个任务，该任务将重新激活按钮并恢复文本标签文本。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#000>button</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>addActionListener</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>ActionListener</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span>
  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>actionPerformed</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>ActionEvent</span> <span style=color:#000>e</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span> 	
    <span style=color:#000>button</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>setEnabled</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>false</span><span style=color:#ce5c00;font-weight:700>);</span> 
    <span style=color:#000>label</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>setText</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#4e9a06>&#34;busy&#34;</span><span style=color:#ce5c00;font-weight:700>);</span> 
    <span style=color:#000>backgroundExec</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>execute</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>Runnable</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span> 
      <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>run</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span> 
        <span style=color:#204a87;font-weight:700>try</span> <span style=color:#ce5c00;font-weight:700>{</span> <span style=color:#000>doBigComputation</span><span style=color:#ce5c00;font-weight:700>();</span> <span style=color:#ce5c00;font-weight:700>}</span> 
        <span style=color:#204a87;font-weight:700>finally</span> <span style=color:#ce5c00;font-weight:700>{</span> 
          <span style=color:#000>GuiExecutor</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>instance</span><span style=color:#ce5c00;font-weight:700>().</span><span style=color:#c4a000>execute</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>Runnable</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span> 
            <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>run</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span> 
              <span style=color:#000>button</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>setEnabled</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>true</span><span style=color:#ce5c00;font-weight:700>);</span> 
              <span style=color:#000>label</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>setText</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#4e9a06>&#34;idle&#34;</span><span style=color:#ce5c00;font-weight:700>);</span> 
            <span style=color:#ce5c00;font-weight:700>}</span> 
          <span style=color:#ce5c00;font-weight:700>});</span> 
        <span style=color:#ce5c00;font-weight:700>}</span>
      <span style=color:#ce5c00;font-weight:700>}</span>
    <span style=color:#ce5c00;font-weight:700>});</span>
  <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#ce5c00;font-weight:700>});</span>
</code></pre></div><p>在按下按钮时触发的任务中包含 3 个连续的子任务，它们将在事件线程与后台线程之间交替运行。第一个子任务更新用户界面，表示一个长时间的操作已经开始，然后在后台线程中启动第二个子任务。当第二个子任务完成时，它把第三个子任务再次提交到事件线程中运行，第三个子任务也会更新用户界面来表示操作已经完成。在 GUI 应程序中，这种“线程接力”是处理长时间任务的典型用法。</p>
<h3 id=931-取消>9.3.1 取消</h3>
<p>当某个任务在线程中运行了过长时间没有结束，用户可能希望取消它。你可以直接通过线程中断来实现取消操作，但是一种更简单的方式是使用 Future，专门用来管理可取消的任务。</p>
<p>如果调用 Future 的 cancel 方法，并将参数 mayInterruptIfRunning 设置为 true，那么这个 Future 可以中断正在执行任务的线程。如果你编写的任务能够正确响应中断，那么当它被取消时就可以提前返回。在程序清单 9-6 给出的任务中，将轮询线程的中断状态，并且在返现中断时提前返回。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#000>Future</span><span style=color:#ce5c00;font-weight:700>&lt;?&gt;</span> <span style=color:#000>runningTask</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>null</span><span style=color:#ce5c00;font-weight:700>;</span> 
<span style=color:#8f5902;font-style:italic>// thread-confined ...
</span><span style=color:#8f5902;font-style:italic></span><span style=color:#000>startButton</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>addActionListener</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>ActionListener</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span>
  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>actionPerformed</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>ActionEvent</span> <span style=color:#000>e</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span> 
    <span style=color:#204a87;font-weight:700>if</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>runningTask</span> <span style=color:#ce5c00;font-weight:700>!=</span> <span style=color:#204a87;font-weight:700>null</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span> 
      <span style=color:#000>runningTask</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>backgroundExec</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>submit</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>Runnable</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span> 
        <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>run</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span> 
          <span style=color:#204a87;font-weight:700>while</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>moreWork</span><span style=color:#ce5c00;font-weight:700>())</span> <span style=color:#ce5c00;font-weight:700>{</span> 
            <span style=color:#204a87;font-weight:700>if</span>  <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>Thread</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>currentThread</span><span style=color:#ce5c00;font-weight:700>().</span><span style=color:#c4a000>isInterrupted</span><span style=color:#ce5c00;font-weight:700>())</span> <span style=color:#ce5c00;font-weight:700>{</span> 	
              <span style=color:#000>cleanUpPartialWork</span><span style=color:#ce5c00;font-weight:700>();</span> 
              <span style=color:#204a87;font-weight:700>break</span><span style=color:#ce5c00;font-weight:700>;</span> 
            <span style=color:#ce5c00;font-weight:700>}</span> 
          <span style=color:#000>doSomeWork</span><span style=color:#ce5c00;font-weight:700>();</span> 
          <span style=color:#ce5c00;font-weight:700>}</span> 
        <span style=color:#ce5c00;font-weight:700>}</span>
      <span style=color:#ce5c00;font-weight:700>});</span>	
    <span style=color:#ce5c00;font-weight:700>}</span>
  <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#ce5c00;font-weight:700>}});</span>

<span style=color:#000>cancelButton</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>addActionListener</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>ActionListener</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span> 
  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>actionPerformed</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>ActionEvent</span> <span style=color:#000>event</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span> 
    <span style=color:#204a87;font-weight:700>if</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>runningTask</span> <span style=color:#ce5c00;font-weight:700>!=</span> <span style=color:#204a87;font-weight:700>null</span><span style=color:#ce5c00;font-weight:700>)</span> 
    <span style=color:#000>runningTask</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>cancel</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>true</span><span style=color:#ce5c00;font-weight:700>);</span> 
<span style=color:#ce5c00;font-weight:700>}});</span>
</code></pre></div><p>由于 runningTask 被封闭在事件线程中，因此在对它进行设置会检查时不需要同步，并且“开始”按钮的监听器可以确保每次只有一个后台任务在运行。然而，当任务完成时最好能通知按钮监听器，例如说可以禁用“取消”按钮。我们将在下一节解决这个问题。</p>
<h3 id=932-进度标识和完成标识>9.3.2 进度标识和完成标识</h3>
<p>通过 Future 来表示一个长时间的任务，可以极大的简化取消操作的实现。在 FutureTask 中也有一个 done 方法同样有助于实现完成通知。当后台的 Callable 完成后，将调用 done。通过 done 方法在事件线程中触发一个完成任务，我们能够构造一个 BackgroundTask 类，这个类将提供一个在事件线程中调用 onCompletion 方法，如程序清单 9-7 所示。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#204a87;font-weight:700>abstract</span> <span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>BackgroundTask</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>V</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#204a87;font-weight:700>implements</span> <span style=color:#000>Runnable</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>Future</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>V</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#ce5c00;font-weight:700>{</span> 
  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>FutureTask</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>V</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>computation</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>Computation</span><span style=color:#ce5c00;font-weight:700>();</span>

  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>Computation</span> <span style=color:#204a87;font-weight:700>extends</span> <span style=color:#000>FutureTask</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>V</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#204a87;font-weight:700>public</span> <span style=color:#000>Computation</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span> 
      <span style=color:#204a87;font-weight:700>super</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>Callable</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>V</span><span style=color:#ce5c00;font-weight:700>&gt;()</span> <span style=color:#ce5c00;font-weight:700>{</span> 
        <span style=color:#204a87;font-weight:700>public</span> <span style=color:#000>V</span> <span style=color:#000>call</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#204a87;font-weight:700>throws</span> <span style=color:#000>Exception</span> <span style=color:#ce5c00;font-weight:700>{</span> 
          <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>BackgroundTask</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>this</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>compute</span><span style=color:#ce5c00;font-weight:700>();</span>
        <span style=color:#ce5c00;font-weight:700>}</span>
      <span style=color:#ce5c00;font-weight:700>});</span> 
    <span style=color:#ce5c00;font-weight:700>}</span> 
    <span style=color:#204a87;font-weight:700>protected</span> <span style=color:#204a87;font-weight:700>final</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>done</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span>
      <span style=color:#000>GuiExecutor</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>instance</span><span style=color:#ce5c00;font-weight:700>().</span><span style=color:#c4a000>execute</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>Runnable</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span>
        <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>run</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span> 
          <span style=color:#000>V</span> <span style=color:#000>value</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>null</span><span style=color:#ce5c00;font-weight:700>;</span> 
          <span style=color:#000>Throwable</span> <span style=color:#000>thrown</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>null</span><span style=color:#ce5c00;font-weight:700>;</span> 
          <span style=color:#204a87;font-weight:700>boolean</span> <span style=color:#000>cancelled</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>false</span><span style=color:#ce5c00;font-weight:700>;</span> 
          <span style=color:#204a87;font-weight:700>try</span> <span style=color:#ce5c00;font-weight:700>{</span> <span style=color:#000>value</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>get</span><span style=color:#ce5c00;font-weight:700>();</span> <span style=color:#ce5c00;font-weight:700>}</span> 
          <span style=color:#204a87;font-weight:700>catch</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>ExecutionException</span> <span style=color:#000>e</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span> 
            <span style=color:#000>thrown</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>e</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>getCause</span><span style=color:#ce5c00;font-weight:700>();</span> 
          <span style=color:#ce5c00;font-weight:700>}</span> <span style=color:#204a87;font-weight:700>catch</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>CancellationException</span> <span style=color:#000>e</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span> 
            <span style=color:#000>cancelled</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>true</span><span style=color:#ce5c00;font-weight:700>;</span> 
          <span style=color:#ce5c00;font-weight:700>}</span> <span style=color:#204a87;font-weight:700>catch</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>InterruptedException</span> <span style=color:#000>consumed</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span> 
          <span style=color:#ce5c00;font-weight:700>}</span> <span style=color:#204a87;font-weight:700>finally</span> <span style=color:#ce5c00;font-weight:700>{</span> 
            <span style=color:#000>onCompletion</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>value</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>thrown</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>cancelled</span><span style=color:#ce5c00;font-weight:700>);</span> 
          <span style=color:#ce5c00;font-weight:700>}</span>
        <span style=color:#ce5c00;font-weight:700>};</span>
      <span style=color:#ce5c00;font-weight:700>});</span>
    <span style=color:#ce5c00;font-weight:700>}</span>
  <span style=color:#ce5c00;font-weight:700>}</span> 
  
  <span style=color:#204a87;font-weight:700>protected</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>setProgress</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>final</span> <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>current</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#204a87;font-weight:700>final</span> <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>max</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#000>GuiExecutor</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>instance</span><span style=color:#ce5c00;font-weight:700>().</span><span style=color:#c4a000>execute</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>Runnable</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span>
      <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>run</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span> 
        <span style=color:#000>onProgress</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>current</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>max</span><span style=color:#ce5c00;font-weight:700>);</span> 
      <span style=color:#ce5c00;font-weight:700>}</span>
    <span style=color:#ce5c00;font-weight:700>});</span> 
  <span style=color:#ce5c00;font-weight:700>}</span> 
  
  <span style=color:#8f5902;font-style:italic>// Called in the background 
</span><span style=color:#8f5902;font-style:italic></span>  <span style=color:#000>thread</span> <span style=color:#204a87;font-weight:700>protected</span> <span style=color:#204a87;font-weight:700>abstract</span> <span style=color:#000>V</span> <span style=color:#000>compute</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#204a87;font-weight:700>throws</span> <span style=color:#000>Exception</span><span style=color:#ce5c00;font-weight:700>;</span> 
  <span style=color:#8f5902;font-style:italic>// Called in the event thread 
</span><span style=color:#8f5902;font-style:italic></span>  <span style=color:#204a87;font-weight:700>protected</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>onCompletion</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>V</span> <span style=color:#000>result</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>Throwable</span> <span style=color:#000>exception</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#204a87;font-weight:700>boolean</span> <span style=color:#000>cancelled</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span> <span style=color:#ce5c00;font-weight:700>}</span> 
  <span style=color:#204a87;font-weight:700>protected</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>onProgress</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>current</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>max</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span> <span style=color:#ce5c00;font-weight:700>}</span> 
  <span style=color:#8f5902;font-style:italic>// Other Future methods forwarded to computation
</span><span style=color:#8f5902;font-style:italic></span><span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>BackgroundTask 还支持进度标识。conpute 方法可以调用 setProgress 方法以数字形式来指示进度。因而在事件线程中调用 onProgress，从而更新用户界面以显示可视化的进度信息。</p>
<p>要想实现 BackgroundTask，只需要实现 compute 方法，该方法将在后台线程中调用。也可以改写 onCompletion 和 onProgress，这两个方法会在事件线程中调用。</p>
<p>基于 FutureTask 构造的 BackgroundTask 还能简化取消操作。Compute 不会检查线程的中断状态，而是调用 Future.isCancelled。程序清单 9-8 通过 BackgroundTask 重新实现了程序清单 9-6 中的示例程序。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>runInBackground</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>Runnable</span> <span style=color:#000>task</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
  <span style=color:#000>startButton</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>addActionListener</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>ActionListener</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span> 
    <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>actionPerformed</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>ActionEvent</span> <span style=color:#000>e</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span> 
      <span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>CancelListener</span> <span style=color:#204a87;font-weight:700>implements</span> <span style=color:#000>ActionListener</span> <span style=color:#ce5c00;font-weight:700>{</span> 
        <span style=color:#000>BackgroundTask</span><span style=color:#ce5c00;font-weight:700>&lt;?&gt;</span> <span style=color:#000>task</span><span style=color:#ce5c00;font-weight:700>;</span> 
        <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>actionPerformed</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>ActionEvent</span> <span style=color:#000>event</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span> 
          <span style=color:#204a87;font-weight:700>if</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>task</span> <span style=color:#ce5c00;font-weight:700>!=</span> <span style=color:#204a87;font-weight:700>null</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#000>task</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>cancel</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>true</span><span style=color:#ce5c00;font-weight:700>);</span> 
        <span style=color:#ce5c00;font-weight:700>}</span>
      <span style=color:#ce5c00;font-weight:700>}</span>

      <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>CancelListener</span> <span style=color:#000>listener</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>CancelListener</span><span style=color:#ce5c00;font-weight:700>();</span>

      <span style=color:#000>listener</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>task</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>BackgroundTask</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>Void</span><span style=color:#ce5c00;font-weight:700>&gt;()</span> <span style=color:#ce5c00;font-weight:700>{</span> 	
        <span style=color:#204a87;font-weight:700>public</span> <span style=color:#000>Void</span> <span style=color:#000>compute</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span> 
          <span style=color:#204a87;font-weight:700>while</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>moreWork</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>&amp;&amp;</span> <span style=color:#ce5c00;font-weight:700>!</span><span style=color:#000>isCancelled</span><span style=color:#ce5c00;font-weight:700>())</span> 
            <span style=color:#000>doSomeWork</span><span style=color:#ce5c00;font-weight:700>();</span> 
            <span style=color:#204a87;font-weight:700>return</span> <span style=color:#204a87;font-weight:700>null</span><span style=color:#ce5c00;font-weight:700>;</span> 
        <span style=color:#ce5c00;font-weight:700>}</span> 
        <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>onCompletion</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>boolean</span> <span style=color:#000>cancelled</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>String</span> <span style=color:#000>s</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>Throwable</span> <span style=color:#000>exception</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span> 
            <span style=color:#000>cancelButton</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>removeActionListener</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>listener</span><span style=color:#ce5c00;font-weight:700>);</span> 
            <span style=color:#000>label</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>setText</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#4e9a06>&#34;done&#34;</span><span style=color:#ce5c00;font-weight:700>);</span> 
        <span style=color:#ce5c00;font-weight:700>}</span>
      <span style=color:#ce5c00;font-weight:700>};</span> 
      <span style=color:#000>cancelButton</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>addActionListener</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>listener</span><span style=color:#ce5c00;font-weight:700>);</span> 
      <span style=color:#000>backgroundExec</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>execute</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>task</span><span style=color:#ce5c00;font-weight:700>);</span>
    <span style=color:#ce5c00;font-weight:700>}</span>
  <span style=color:#ce5c00;font-weight:700>});</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><h3 id=933-swingworker>9.3.3 SwingWorker</h3>
<p>我们已经通过 FutureTask 和 Executor 构建了一个简单的框架，它会在后台线程中执行较长耗时的任务，因此不会影响 GUI 的响应性。在任何单线程的 GUI 框架中都可以使用这些技术，而不仅局限于 Swing。在 Swing 中，这类给出的许多特性是由 SwingWorker 类提供的，包括取消、完成通知、进度指示灯。在 “Swing Connection” 和 “The Java Tutorial” 等资料中介绍了不同版本的 SwingWorker，并在 Java 6 中包含了一个更新好的版本。</p>
<h2 id=94-共享数据模型>9.4 共享数据模型</h2>
<p>Swing 的表现对象都被封装在事件线程中。在加单的 GUI 程序中，所有的可变状态都被保存在表现对象中，并且除了事件线程之外，唯一的线程就是主线程。要在这些程序中强制实施单线程规则是很容易的：不要从主线程中访问数据模型或表现组件。在一些更复杂的程序中，可能会使用其他线程对持久化的存储进行读写操作以免降低系统的响应性。</p>
<p>最简单的情况是，数据模型中的数据由用户来输入或由应用程序在启动时静态的从文件或其他数据源加载。在这种情况下，除了事件线程之外的任何线程都不可能访问到数据。但在某些情况下，表现模型对象只是一个数据源的视图对象。这时，当数据在应用程序中进出时，有多个线程可以访问这些数据。</p>
<p>例如，你可以使用一个树形空间来显示远程文件系统的内容。在显示树形控件之前，并不需要枚举真个文件系统——那样做会消耗大量的时间和内存。正确的做法是，当树节点被展开时才读取相应的内容。即使只枚举远程卷上的单个目录也可能花费很长的时间，因此你可以考虑在后台线程中执行枚举操作。当后台任务完成后，必须通过某种方式将数据填充到树形模型中。可以使用线程安全的树形模型来实现这个功能：通过 invokeLater 提交一个任务，将数据从后台任务中“推入”事件线程，或者让事件线程通过轮询来查看是否有数据可用。</p>
<h3 id=941-线程安全的数据模型>9.4.1 线程安全的数据模型</h3>
<p>只要阻塞操作不会过度影响响应性，那么多个线程操作同一份数据的问题都可以通过线程安全的数据模型来解决。如果数据模型支持细粒度的开发，那么事件线程和后台线程就能共享该数据模型，而不会发生响应性问题。例如，第五章的 DelegatingVehicleTracker 在底层使用了一个 ConcurrentHashMap 来提供高度并发的读写操作。这种方法的缺点在于，ConcurrentHashMap 无法提供一致的数据快照，而这可能是需求的一部分。线程安全的数据模型必须在更新模板时产生事件，这样视图才能在数据发生变化后进行更新。</p>
<p>有时候，在使用版本化数据模型时，例如 CopyOnWriteArrayList，可能要同时获得线程安全性，一致性以及良好的响应性。当获取一个“写实复制”容器的迭代时，这个迭代器将遍历真个容器。然而，只有在遍历操作远远多于修改操作时，“写时复制”容器才能提供更好的性能，例如在车辆追踪应用程序中就不适合采用这种方法。一些特定的数据结构或许可以避免这种限制，但要构建一个既能提供高效并发访问又能在旧数据无效后不再维护它们的数据结构却并不容易，因此只有其他方法都行不通后才应该考虑使用它。</p>
<h3 id=942-分解数据模型>9.4.2 分解数据模型</h3>
<p>从 GUI 的角度看，Swing 的表格模型类，例如 TableModel 和 TreeModel，都是保存将要显示的数据的正式方法。然而，这些模型对象本身通常都是应用程序中其他对象的视图。如果在程序中既包含用于表示的数据模型，又包含应用程序特定的数据模型，那么这种应该程序就被称为一种分解模型设计。</p>
<p>在分解模型设计时，表现模型被封闭在事件线程汇总，而其他模型，即共享模型，是线程安全的，因此既可以由事件线程方法，也可以由应用程序线程访问。表现模型会注册共享模型的监听器，从而在更新时得到通知。然后，表示模型可以在共享模型中得到更新：通过将相关状态的快照嵌入到更新消息中，或者由表现模型在收到更新事件时直接从共享模型中获取数据。</p>
<p>快照这种方法虽然简单，但却存在着一些局限。当数据模型很小，更新频率不高，并且这两个模型的结构相似时，他可以工作良好。如果数据模型很大，或者更新频率极高，在分解模型包含的信息中有一方或者双方对另一方不可见，那么更高效的方式是发送增量更新信息而不是发送完整的快照。这种方法将共享模型上的更新操作序列化，并在事件线程中重现。增量更新的另一个好处是，细粒度的变化信息可以提高显示的视觉效果——如果只有一辆车移动，那么只需要更新发生变化的区域，而不用重绘整个显示图形。</p>
<blockquote>
<p>如果一个数据模型必须被多个线程共享，而且由于阻塞、一致性或复杂度等原因而无法实现一个线程安全的模型时，可以考虑使用分解模型设计。</p>
</blockquote>
<h2 id=95-其他形式的单线程子系统>9.5 其他形式的单线程子系统</h2>
<p>线程封闭不仅仅可以在 GUI 中使用，每当某个工具需要被实现为单线程子系统时，都可以使用这项技术。有时候，当程序员无法避免同步或死锁等问题时，也将不得不使用线程封闭。例如，一些原生库要求：所有对库的访问，甚至通过 System.loadLibiary 来加载库时，都必须在同一个线程中执行。</p>
<p>借鉴 GUI 框架中采用的方法，可以很容易创建一个专门的线程或一个单线程的 Executor 来访问那些库，并提供一个代理对象来拦截所有对线程封闭对象的调用，并将这些调用作为一个任务来提交给专门的线程。将 Future 和 newSingleThreadExecutor 一起使用，可以简化这项工作。在代理方法中可以调用 submit 方法提交任务，然后立即调用 Future.get 来等待结果。(如果在封闭线程的类中实现了一个接口，那么每次可以自动的让方法将一个 Callable 提交给后台线程并通过动态的代理来等待结果。)</p>
<h2 id=小结>小结</h2>
<p>所有 GUI 框架基本上都实现为单线程的子系统，其中所有与表现相关的代码都作为任务在事件线程中运行。由于只有一个事件线程，因此运行时间较长的任务会降低 GUI 程序的响应性，所以应该放在后台线程中运行。在一些辅助类(例如 SwingWorker 以及在本章中构建的 BackgroundTask) 中提供了对取消、进度指示以及完成指示的支持，因此对于执行时间较长的任务来说，无论在任务中包含了 GUI 组件还是非 GUI 组件，在开发时都可以的到简化。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-c7824454c2c5b68a1a276860c2a3d769>10 - CH10-活跃性危险</h1>
<p>在安全性和活跃性之间通常存在着某种制衡。我们使用加锁机制来确保线程安全，但如果过度的使用锁，则可能导致锁顺序死锁(Lock-Ordering Deadlock)。同样，我们使用线程池和信号量来限制对资源的使用，但这些被限制的行为可能导致资源死锁。Java 应用程序无法从死锁中恢复过来，因此在设计时一定要排除那些可能导致死锁出现的因素。本章将介绍一些导致活跃性故障的原因，以及如何避免它们。</p>
<h2 id=101-死锁>10.1 死锁</h2>
<p>经典的“哲学家就餐”问题很好的描述了死锁问题。5 个哲学家去吃中餐，坐在一张圆桌旁。他们有 5 根筷子(而不是 5 双)，并且每两个人之间放着一根筷子。哲学家们时而思考、时而进餐。每个人都需要一双筷子才能吃东东，并在吃完后将筷子放回原处继续思考。有些筷子管理算法能够使每个人都能相对及时的吃到东西(例如一个饥饿的哲学家会尝试获取两根临近的筷子，但如果其中一跟正在被他人使用，那么他将放弃已经得到的那根筷子，并等待几分钟之后再次尝试)，但有些算法却可能导致一些或者所有哲学家都“饿死”(每个人都立即抓住自己左手边的筷子，然后等待右手边的筷子空出来，但同时又不放下已经拿到的筷子)。后一种情况将产生死锁：每个人都拥有其他人需要的资源，同时又等待其他人已经拥有的资源，并且每个人在获得所有需要的资源之前都不会放弃已经拥有的资源。</p>
<p>当一个线程永远的持有一把锁，并且其他线程都尝试获得这个锁时，那么他们将永远被阻塞。在线程 A 持有锁 L 并想获得锁 M 的同时，线程 B 持有锁 M 并尝试获得锁 L，那么这两个线程将永远的等待下去。这是最简单的死锁形式(即抱死)，其中多个线程由于存在环路的锁依赖关系而永远等待下去。(把每个线程假想为有向图中的一个节点，图中每条边表示的关系是：“线程 A 等待线程 B 所占有的资源”。如果在图中形成了一条环路，那么久存在一个死锁)。</p>
<p>在数据库系统的设计中考虑了检测死锁以及从死锁恢复。在执行一个事务时可能需要同时获得多个锁，并一直持有这些锁直到事务提交。因此在两个事务之间很可能发生死锁，但事实上这种情况并不常见。如果没有外部干涉，这些事务将永远等待下去(在某个事务中持有的锁可能在其他事务中也需要)。但数据库服务器不会让这种情况发生。当他检测到一组事务发生了死锁时(通过在表示等待关系的有向图中搜索依赖循环)，将选择牺牲者并放弃该事务。作为牺牲者的事务会释放它所只有的资源，从而使其他事务继续运行。应用程序可以重新执行被强制终止的事务，而这个事务现在可以成功完成，因为所有跟它存在资源竞争的事务都已经完成了。</p>
<p>JVM 在解决死锁问题方面并没有数据库服务那样强大。当一组 Java 线程发生死锁时，“游戏”将到此结束——这些线程将永远无法再使用了。根据线程完成工作的不同，可能造成应用程序完全停止，或者某个特定的子系统停止，或者是性能降低。恢复应用程序的唯一方式就是中止并重启，并希望不要再发生同样的事情。</p>
<p>与所有其他的并发危险一样，死锁造成的影响很少会立即显现出来。如果一个类可能发生死锁，那么并不意味着每次都会发生死锁，而只是表示有可能。当死锁出现时，往往是最糟糕的时候——在高负载情况下。</p>
<h3 id=1011-锁顺序死锁>10.1.1 锁顺序死锁</h3>
<p>程序清单 10-1 中过的 LeftRightDeadlock 存在死锁风险。leftRight 和 rightLeft 这两个方法分别获得 left 锁和 right 锁。如果一个线程调用了 leftRight，而另一个线程调用了 rightLeft，并且这两个线程的操作是交错执行的，如图 10-1 所示，那么将发生死锁。</p>
<div align=center>
<img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20181118174433.png style=display:block;width:70% alt=10-1 align=center>
</div>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>LeftRightDeadlock</span> <span style=color:#ce5c00;font-weight:700>{</span>
  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#000>fianl</span> <span style=color:#000>Object</span> <span style=color:#000>left</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>Object</span><span style=color:#ce5c00;font-weight:700>();</span>
  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>Object</span> <span style=color:#000>right</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>Object</span><span style=color:#ce5c00;font-weight:700>();</span>
  
  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>leftRight</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#204a87;font-weight:700>synchronized</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>left</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
      <span style=color:#204a87;font-weight:700>synchronized</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>right</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
        <span style=color:#000>doSomething</span><span style=color:#ce5c00;font-weight:700>();</span>
      <span style=color:#ce5c00;font-weight:700>}</span>
    <span style=color:#ce5c00;font-weight:700>}</span>
  <span style=color:#ce5c00;font-weight:700>}</span>
  
  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>rightLeft</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#204a87;font-weight:700>synchronized</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>right</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
      <span style=color:#204a87;font-weight:700>synchronized</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>left</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
        <span style=color:#000>doSomething</span><span style=color:#ce5c00;font-weight:700>();</span>
      <span style=color:#ce5c00;font-weight:700>}</span>
    <span style=color:#ce5c00;font-weight:700>}</span>
  <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>在 LeftRightDeadlock 中发生死锁的原因是：两个线程试图以不同的顺序来获得相同的锁。如果按照相同的顺序来请求锁，那么就不会出现循环加锁依赖性，因此也就不会产生死锁。如果每个需要锁 L 和锁 M 的线程都以相同的顺序来获得两个锁，那么就不会发生死锁了。</p>
<blockquote>
<p>如果所有线程以固定的顺序来获得锁，那么在程序中就不会出现锁顺序死锁问题。</p>
</blockquote>
<p>要想验证锁顺序的一致性，需要对程序中的加锁顺序进行全局分析。如果只是单独的分析每条获取多个锁的代码路径，那是不够的：leftRight 和 rightLeft 都采用了“合理的”方式来获得锁，它们只是不能互相兼容。当需要加锁时，它们需要知道彼此正在执行什么操作。</p>
<h3 id=1012-动态的锁顺序死锁>10.1.2 动态的锁顺序死锁</h3>
<p>有时候，并不能清楚地知道是否在锁顺序上有足够的控制权来避免死锁的发生。考虑程序清单 10-2 中看似无害的代码，它将资金从一个账户转入另一个账户。在开始转账之前，首先要获得这两个 Account 对象的锁，以确保通过原子方式来更新两个账户中的余额，同时又不破坏一些不变性条件，例如“账户的余额不能为负数”。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>transferMoney</span><span style=color:#ce5c00;font-weight:700>(</span>
  <span style=color:#000>Account</span> <span style=color:#000>fromAccount</span><span style=color:#ce5c00;font-weight:700>,</span>
  <span style=color:#000>Account</span> <span style=color:#000>toAccount</span><span style=color:#ce5c00;font-weight:700>,</span>
  <span style=color:#000>DollarAmount</span> <span style=color:#000>amount</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#204a87;font-weight:700>throws</span> <span style=color:#000>InsufficientFundsException</span><span style=color:#ce5c00;font-weight:700>{</span>
  <span style=color:#204a87;font-weight:700>synchronized</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>fromAccount</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#204a87;font-weight:700>synchronized</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>toAccount</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
      <span style=color:#204a87;font-weight:700>if</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>fromAccount</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>getBalance</span><span style=color:#ce5c00;font-weight:700>().</span><span style=color:#c4a000>compareTo</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>amount</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>0</span><span style=color:#ce5c00;font-weight:700>)</span>
        <span style=color:#000>thorw</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>InsufficientFundsException</span><span style=color:#ce5c00;font-weight:700>();</span>
      <span style=color:#204a87;font-weight:700>else</span> <span style=color:#ce5c00;font-weight:700>{</span>
        <span style=color:#000>fromAccount</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>debit</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>amount</span><span style=color:#ce5c00;font-weight:700>);</span>
        <span style=color:#000>toAccount</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>credit</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>amount</span><span style=color:#ce5c00;font-weight:700>);</span>
      <span style=color:#ce5c00;font-weight:700>}</span>
    <span style=color:#ce5c00;font-weight:700>}</span>
  <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>在 transferMoney 中如何发生死锁？所有的线程似乎都是按照相同的顺序来获得锁，但事实上锁的顺序取决于传递给 transferMoney 的参数顺序，而这些参数顺序又取决于外部输入。如果两个线程同时调用 transferMoney，其中一个线程从 X 向 Y 转账，另一个线程从 Y 向 X 转账，那么就会发生死锁：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#f57900>A:</span> <span style=color:#000>transferMoney</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>myAccount</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>yourAccount</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>10</span><span style=color:#ce5c00;font-weight:700>);</span>
<span style=color:#f57900>B:</span> <span style=color:#000>transferMoney</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>yourAccount</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>myAccount</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>20</span><span style=color:#ce5c00;font-weight:700>);</span>
</code></pre></div><p>如果执行时序不当，那么 A 可能获得 myAccount 的锁并等待 yourAccount 的锁，然后 B 此时持有 yourAccount 的锁，并正在等待 myAccount 的锁。</p>
<p>这种死锁可以采用程序清单 10-1 中的方法来检查——查看是否存在嵌套的锁获取操作。由于我们无法控制参数的顺序，因此要解决该问题，必须定义锁的顺序，并在整个应用程序中都按照这个顺讯来获得锁。</p>
<p>在制定锁的顺序时，可以使用 System.identityHashCode 方法，该方法将返回由 Object.hashCode 返回的值。程序清单 10-3 给出了一另一个版本的 transferMoney，在该版本中使用了 System.identityHashCode 来定义锁的顺序。虽然增加了一些新的代码，但却消除了发生死锁的可能性。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>static</span> <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>Object</span> <span style=color:#000>tieLock</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>Object</span><span style=color:#ce5c00;font-weight:700>();</span>

<span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>transferMoney</span><span style=color:#ce5c00;font-weight:700>(</span>
  <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>Account</span> <span style=color:#000>fromAcct</span><span style=color:#ce5c00;font-weight:700>,</span>
  <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>Account</span> <span style=color:#000>toAcct</span><span style=color:#ce5c00;font-weight:700>,</span> 
  <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>DollarAmount</span> <span style=color:#000>amount</span>
<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#204a87;font-weight:700>throws</span> <span style=color:#000>InsufficientFundsException</span> <span style=color:#ce5c00;font-weight:700>{</span> 
  <span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>Helper</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>transfer</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#204a87;font-weight:700>throws</span> <span style=color:#000>InsufficientFundsException</span> <span style=color:#ce5c00;font-weight:700>{</span>
      <span style=color:#204a87;font-weight:700>if</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>fromAcct</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>getBalance</span><span style=color:#ce5c00;font-weight:700>().</span><span style=color:#c4a000>compareTo</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>amount</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>&lt;</span> <span style=color:#000>0</span><span style=color:#ce5c00;font-weight:700>)</span> 
        <span style=color:#204a87;font-weight:700>throw</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>InsufficientFundsException</span><span style=color:#ce5c00;font-weight:700>();</span>
      <span style=color:#204a87;font-weight:700>else</span> <span style=color:#ce5c00;font-weight:700>{</span> 
        <span style=color:#000>fromAcct</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>debit</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>amount</span><span style=color:#ce5c00;font-weight:700>);</span> 
        <span style=color:#000>toAcct</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>credit</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>amount</span><span style=color:#ce5c00;font-weight:700>);</span>
      <span style=color:#ce5c00;font-weight:700>}</span>
    <span style=color:#ce5c00;font-weight:700>}</span> 
  <span style=color:#ce5c00;font-weight:700>}</span> 
  
  <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>fromHash</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>System</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>identityHashCode</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>fromAcct</span><span style=color:#ce5c00;font-weight:700>);</span> 
  <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>toHash</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>System</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>identityHashCode</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>toAcct</span><span style=color:#ce5c00;font-weight:700>);</span>

  <span style=color:#204a87;font-weight:700>if</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>fromHash</span> <span style=color:#ce5c00;font-weight:700>&lt;</span> <span style=color:#000>toHash</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span> 
    <span style=color:#204a87;font-weight:700>synchronized</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>fromAcct</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span> 
      <span style=color:#204a87;font-weight:700>synchronized</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>toAcct</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span> 
        <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>Helper</span><span style=color:#ce5c00;font-weight:700>().</span><span style=color:#c4a000>transfer</span><span style=color:#ce5c00;font-weight:700>();</span> 
      <span style=color:#ce5c00;font-weight:700>}</span> 
    <span style=color:#ce5c00;font-weight:700>}</span> 
  <span style=color:#ce5c00;font-weight:700>}</span> <span style=color:#204a87;font-weight:700>else</span> <span style=color:#204a87;font-weight:700>if</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>fromHash</span> <span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>toHash</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span> 
    <span style=color:#204a87;font-weight:700>synchronized</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>toAcct</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span> 
      <span style=color:#204a87;font-weight:700>synchronized</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>fromAcct</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span> 
        <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>Helper</span><span style=color:#ce5c00;font-weight:700>().</span><span style=color:#c4a000>transfer</span><span style=color:#ce5c00;font-weight:700>();</span> 
      <span style=color:#ce5c00;font-weight:700>}</span> 
    <span style=color:#ce5c00;font-weight:700>}</span> 
  <span style=color:#ce5c00;font-weight:700>}</span> <span style=color:#204a87;font-weight:700>else</span> <span style=color:#ce5c00;font-weight:700>{</span> 
    <span style=color:#204a87;font-weight:700>synchronized</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>tieLock</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span> 
      <span style=color:#204a87;font-weight:700>synchronized</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>fromAcct</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span> 
        <span style=color:#204a87;font-weight:700>synchronized</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>toAcct</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span> 
          <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>Helper</span><span style=color:#ce5c00;font-weight:700>().</span><span style=color:#c4a000>transfer</span><span style=color:#ce5c00;font-weight:700>();</span> 
        <span style=color:#ce5c00;font-weight:700>}</span> 
      <span style=color:#ce5c00;font-weight:700>}</span> 
    <span style=color:#ce5c00;font-weight:700>}</span>
  <span style=color:#ce5c00;font-weight:700>}</span> 
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>在极少情况下，两个对象可能拥有相同的散列值，此时必须通过某种任意的方法来决定锁的顺序，而这可能又会重新引入死锁。为了避免这种情况，可以使用“加时赛”锁。在获得两个 Account 锁之前，首先获得这个“加时赛”锁，从而每次保证只有一个线程以未知的顺序获得这两个锁，从而消除了死锁发生的可能性(只要一致的使用这种机制)。如果经常会出现散列冲突的情况，那么这种技术可能会成为并发性的一个瓶颈(这类似于在整个程序中只有一个锁的情况)，但由于 System.identityHashCode 中出现散列冲突的频率非常低，因此这项技术以最小的代价，换来的最大的安全性。</p>
<p>如果在 Account 中包含一个唯一的、不可变的，并具备可比性的键值，比如账号，那么要指定锁的顺序就更加容易了：通过键值将对象排序，因而不再需要使用“加时赛”锁了。</p>
<p>你或许认为我夸大了死锁的风险，因为所被持有的时间通常很短暂，然而在真实系统中，死锁往往都是很严重的问题。作为商业产品的应用程序每天肯可能要处理数十亿次获取锁——释放锁的操作。只要在这数十亿次操作中出现一次错误，就可能导致程序发生死锁，并且即使使应用程序通过了压力测试也不可能找出所有潜在的死锁。在程序清单 10-4 中的 DemonstrateDeadlock 在大多数系统下都会很快发生死锁。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>DemonstrateDeadlock</span> <span style=color:#ce5c00;font-weight:700>{</span>
  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>static</span> <span style=color:#204a87;font-weight:700>final</span> <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>NUM_THREADS</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>20</span><span style=color:#ce5c00;font-weight:700>;</span> 
  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>static</span> <span style=color:#204a87;font-weight:700>final</span> <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>NUM_ACCOUNTS</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>5</span><span style=color:#ce5c00;font-weight:700>;</span> 
  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>static</span> <span style=color:#204a87;font-weight:700>final</span> <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>NUM_ITERATIONS</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>1000000</span><span style=color:#ce5c00;font-weight:700>;</span>

  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>static</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>main</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>String</span><span style=color:#ce5c00;font-weight:700>[]</span> <span style=color:#000>args</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>Random</span> <span style=color:#000>rnd</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>Random</span><span style=color:#ce5c00;font-weight:700>();</span> 
    <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>Account</span><span style=color:#ce5c00;font-weight:700>[]</span> <span style=color:#000>accounts</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>Account</span><span style=color:#ce5c00;font-weight:700>[</span><span style=color:#000>NUM_ACCOUNTS</span><span style=color:#ce5c00;font-weight:700>];</span>
    
    <span style=color:#204a87;font-weight:700>for</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>i</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>0</span><span style=color:#ce5c00;font-weight:700>;</span> <span style=color:#000>i</span> <span style=color:#ce5c00;font-weight:700>&lt;</span> <span style=color:#000>accounts</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>length</span><span style=color:#ce5c00;font-weight:700>;</span> <span style=color:#000>i</span><span style=color:#ce5c00;font-weight:700>++)</span> 
      <span style=color:#000>accounts</span><span style=color:#ce5c00;font-weight:700>[</span><span style=color:#000>i</span><span style=color:#ce5c00;font-weight:700>]</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>Account</span><span style=color:#ce5c00;font-weight:700>();</span>

    <span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>TransferThread</span> <span style=color:#204a87;font-weight:700>extends</span> <span style=color:#000>Thread</span> <span style=color:#ce5c00;font-weight:700>{</span>
      <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>run</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span> 
        <span style=color:#204a87;font-weight:700>for</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>i</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#000>0</span><span style=color:#ce5c00;font-weight:700>;</span> <span style=color:#000>i</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>NUM_ITERATIONS</span><span style=color:#ce5c00;font-weight:700>;</span> <span style=color:#000>i</span><span style=color:#ce5c00;font-weight:700>++)</span> <span style=color:#ce5c00;font-weight:700>{</span> 
          <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>fromAcct</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>rnd</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>nextInt</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>NUM_ACCOUNTS</span><span style=color:#ce5c00;font-weight:700>);</span> 
          <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>toAcct</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>rnd</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>nextInt</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>NUM_ACCOUNTS</span><span style=color:#ce5c00;font-weight:700>);</span> 
          <span style=color:#000>DollarAmount</span> <span style=color:#000>amount</span> <span style=color:#ce5c00;font-weight:700>=</span> 
            <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>DollarAmount</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>rnd</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>nextInt</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>1000</span><span style=color:#ce5c00;font-weight:700>));</span> 
          <span style=color:#000>transferMoney</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>accounts</span><span style=color:#ce5c00;font-weight:700>[</span><span style=color:#000>fromAcct</span><span style=color:#ce5c00;font-weight:700>],</span> <span style=color:#000>accounts</span><span style=color:#ce5c00;font-weight:700>[</span><span style=color:#000>toAcct</span><span style=color:#ce5c00;font-weight:700>],</span> <span style=color:#000>amount</span><span style=color:#ce5c00;font-weight:700>);</span> 
        <span style=color:#ce5c00;font-weight:700>}</span> 
      <span style=color:#ce5c00;font-weight:700>}</span>
    <span style=color:#ce5c00;font-weight:700>}</span> 
    
    <span style=color:#204a87;font-weight:700>for</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>i</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>0</span><span style=color:#ce5c00;font-weight:700>;</span> <span style=color:#000>i</span> <span style=color:#ce5c00;font-weight:700>&lt;</span> <span style=color:#000>NUM_THREADS</span><span style=color:#ce5c00;font-weight:700>;</span> <span style=color:#000>i</span><span style=color:#ce5c00;font-weight:700>++)</span> 
      <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>TransferThread</span><span style=color:#ce5c00;font-weight:700>().</span><span style=color:#c4a000>start</span><span style=color:#ce5c00;font-weight:700>();</span>
  <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><h3 id=1013-在协作对象之间发生死锁>10.1.3 在协作对象之间发生死锁</h3>
<p>某些获取多个锁的操作并不像在 LeftRightDeadlock 或 transferMoney 中那么明显，这两个锁并不一定必须在同一个方法中获取。考虑程序清单 10-5 中两个互相协作的类，在出租车调度系统中可能会用到它们。Taxi 代表一个出租车对象，包含位置和目的地两个属性，Dispatcher 代表一个出租车车队。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#8f5902;font-style:italic>// Warning: deadlock-prone! 
</span><span style=color:#8f5902;font-style:italic></span><span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>Taxi</span> <span style=color:#ce5c00;font-weight:700>{</span>
  <span style=color:#5c35cc;font-weight:700>@GuardedBy</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#4e9a06>&#34;this&#34;</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#204a87;font-weight:700>private</span> <span style=color:#000>Point</span> <span style=color:#000>location</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>destination</span><span style=color:#ce5c00;font-weight:700>;</span> 	<span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>Dispatcher</span> <span style=color:#000>dispatcher</span><span style=color:#ce5c00;font-weight:700>;</span>

  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#000>Taxi</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>Dispatcher</span> <span style=color:#000>dispatcher</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span> 
    <span style=color:#204a87;font-weight:700>this</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>dispatcher</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>dispatcher</span><span style=color:#ce5c00;font-weight:700>;</span> 
  <span style=color:#ce5c00;font-weight:700>}</span>

  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>synchronized</span> <span style=color:#000>Point</span> <span style=color:#000>getLocation</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span> 
    <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>location</span><span style=color:#ce5c00;font-weight:700>;</span> 
  <span style=color:#ce5c00;font-weight:700>}</span>

  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>synchronized</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>setLocation</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>Point</span> <span style=color:#000>location</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span> 	
    <span style=color:#204a87;font-weight:700>this</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>location</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>location</span><span style=color:#ce5c00;font-weight:700>;</span> 
    <span style=color:#204a87;font-weight:700>if</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>location</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>equals</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>destination</span><span style=color:#ce5c00;font-weight:700>))</span> 
      <span style=color:#000>dispatcher</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>notifyAvailable</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>this</span><span style=color:#ce5c00;font-weight:700>);</span> 
  <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#ce5c00;font-weight:700>}</span>

<span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>Dispatcher</span> <span style=color:#ce5c00;font-weight:700>{</span>
  <span style=color:#5c35cc;font-weight:700>@GuardedBy</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#4e9a06>&#34;this&#34;</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>Set</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>Taxi</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>taxis</span><span style=color:#ce5c00;font-weight:700>;</span> 	
  <span style=color:#5c35cc;font-weight:700>@GuardedBy</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#4e9a06>&#34;this&#34;</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>Set</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>Taxi</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>availableTaxis</span><span style=color:#ce5c00;font-weight:700>;</span>

  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#000>Dispatcher</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span> 
    <span style=color:#000>taxis</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>HashSet</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>Taxi</span><span style=color:#ce5c00;font-weight:700>&gt;();</span> 
    <span style=color:#000>availableTaxis</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>HashSet</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>Taxi</span><span style=color:#ce5c00;font-weight:700>&gt;();</span> 
  <span style=color:#ce5c00;font-weight:700>}</span>

  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>synchronized</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>notifyAvailable</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>Taxi</span> <span style=color:#000>taxi</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span> 	
    <span style=color:#000>availableTaxis</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>add</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>taxi</span><span style=color:#ce5c00;font-weight:700>);</span> 
  <span style=color:#ce5c00;font-weight:700>}</span>

  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>synchronized</span> <span style=color:#000>Image</span> <span style=color:#000>getImage</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span> 
    <span style=color:#000>Image</span> <span style=color:#000>image</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>Image</span><span style=color:#ce5c00;font-weight:700>();</span> 
    <span style=color:#204a87;font-weight:700>for</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>Taxi</span> <span style=color:#000>t</span> <span style=color:#ce5c00;font-weight:700>:</span> <span style=color:#000>taxis</span><span style=color:#ce5c00;font-weight:700>)</span> 
      <span style=color:#000>image</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>drawMarker</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>t</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>getLocation</span><span style=color:#ce5c00;font-weight:700>());</span> 
    <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>image</span><span style=color:#ce5c00;font-weight:700>;</span> 
  <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>尽管没有任何方法会显式的获取连个锁，但 setLocation 和 getImage 等方法的调用者都会获得两个锁。如果一个线程在收到 GPS 接收器的更新事件时调用 setLocation，那么它将首先更新出租车的位置，然后判断它是否到达了目的地。如果已经到达，它会通知 Dispatcher：它需要一个新的目的地。因为 setLocation 和 notifyAvailable 都是同步方法，因此调用 setLocation 的线程将首先获取 Taxi 的锁，然后获取 Dispatcher 的锁。同样，调用 getImage 的线程将首先获取 Dispatcher 锁，然后在获取一个 Taxi 锁(每次获取一个)。这与 LeftRightDeadlock 中的情况相同，两个线程按照不同的顺序来获取两个锁，因此就可能产生死锁。</p>
<p>在 LeftRightDeadlock 或 transferMoney 中，要查找死锁是比较简单的，只需要找出那些需要获取两个锁的方法即可。然而要在 Taxi 和 Dispatcher 中查找死锁则比较困难：如果在持有锁的情况中调用某个外部方法，那么就需要警惕死锁。</p>
<blockquote>
<p>如果在持有锁调用某个外部方法，那么将出现活跃性问题。在这个外部方法中可能或获取其他锁(从而可能产生死锁)，或者阻塞时间过长，导致其他线程无法及时获得当前被持有的锁。</p>
</blockquote>
<h3 id=1014-开放调用>10.1.4 开放调用</h3>
<p>当然，Taxi 和 Dispatcher 并不知道它们将要陷入死锁，况且它们本来就不应该知道。方法调用相当于一种抽象屏障，因而你无需了解在被调方法内执行的操作。但也正是由于不知道在被调方法内部执行的操作，因此在持有锁的时候对调用某个外部方法将难以进行分析，从而可能出现死锁。</p>
<p>如果在调用某个方法时不需要持有锁，那么这种调用被称为开放调用。依赖于开放调用的类通常表现出更好的行为，并且与那些在调用方法时需要持有锁的类相比，也更容易编写。这种通过开放调用来避免死锁的方法，类似于采用封装机制来提供线程安全的方法：虽然在没有封装的情况下也能确保构建线程安全的程序，但对一个使用了封装的程序进行线程安全分析，要比分析那些没有使用封装的程序容易的多。同理，分析一个完全依赖于开放调用的程序的活跃性，要比分析那些不依赖开放调用的程序的活跃性简单。通过尽可能的使用开放调用，将更易于找出那些需要获取多个锁的代码路径，因此也就更容易确保采用一致的顺序来获取锁。</p>
<p>可以很容易的将程序清单 10-5 中的 Taxi 和 Dispatcher 修改为使用开放调用，从而消除发生死锁的风险。这需要使同步代码块仅被用于保护那些涉及共享状态的操作，如程序清单 10-6 所示。通常，如果只是为了语法紧凑或简单性(而不是因为整个方法必须通过一个锁来保护)而使用同步方法(而不是同步代码块)，那么就会导致程序清单 10-5 中的问题。(此外，收缩同步代码块的保护范围还可以提高伸缩性，在 11.4.1 节中给出了如何确定同步代码块大小的方法。)</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#5c35cc;font-weight:700>@ThreadSafe</span> <span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>Taxi</span> <span style=color:#ce5c00;font-weight:700>{</span>
  <span style=color:#5c35cc;font-weight:700>@GuardedBy</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#4e9a06>&#34;this&#34;</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#204a87;font-weight:700>private</span> <span style=color:#000>Point</span> <span style=color:#000>location</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>destination</span><span style=color:#ce5c00;font-weight:700>;</span> 	<span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>Dispatcher</span> <span style=color:#000>dispatcher</span><span style=color:#ce5c00;font-weight:700>;</span> 
  <span style=color:#ce5c00;font-weight:700>...</span>

  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>synchronized</span> <span style=color:#000>Point</span> <span style=color:#000>getLocation</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span> 
    <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>location</span><span style=color:#ce5c00;font-weight:700>;</span> 
  <span style=color:#ce5c00;font-weight:700>}</span>

  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>synchronized</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>setLocation</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>Point</span> <span style=color:#000>location</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span> 			<span style=color:#204a87;font-weight:700>boolean</span> <span style=color:#000>reachedDestination</span><span style=color:#ce5c00;font-weight:700>;</span> <span style=color:#204a87;font-weight:700>synchronized</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>this</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span> 				<span style=color:#204a87;font-weight:700>this</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>location</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>location</span><span style=color:#ce5c00;font-weight:700>;</span> 
      <span style=color:#000>reachedDestination</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>location</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>equals</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>destination</span><span style=color:#ce5c00;font-weight:700>);</span> 
    <span style=color:#ce5c00;font-weight:700>}</span> 
    
    <span style=color:#204a87;font-weight:700>if</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>reachedDestination</span><span style=color:#ce5c00;font-weight:700>)</span> 	
      <span style=color:#000>dispatcher</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>notifyAvailable</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>this</span><span style=color:#ce5c00;font-weight:700>);</span> 
    <span style=color:#ce5c00;font-weight:700>}</span>
  <span style=color:#ce5c00;font-weight:700>}</span>

<span style=color:#5c35cc;font-weight:700>@ThreadSafe</span> 
<span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>Dispatcher</span> <span style=color:#ce5c00;font-weight:700>{</span>
  <span style=color:#5c35cc;font-weight:700>@GuardedBy</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#4e9a06>&#34;this&#34;</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>Set</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>Taxi</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>taxis</span><span style=color:#ce5c00;font-weight:700>;</span> 			<span style=color:#5c35cc;font-weight:700>@GuardedBy</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#4e9a06>&#34;this&#34;</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>Set</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>Taxi</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>availableTaxis</span><span style=color:#ce5c00;font-weight:700>;</span> 
  <span style=color:#ce5c00;font-weight:700>...</span>

  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>synchronized</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>notifyAvailable</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>Taxi</span> <span style=color:#000>taxi</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#000>availableTaxis</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>add</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>taxi</span><span style=color:#ce5c00;font-weight:700>);</span> 
  <span style=color:#ce5c00;font-weight:700>}</span>

  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#000>Image</span> <span style=color:#000>getImage</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span> 
    <span style=color:#000>Set</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>Taxi</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>copy</span><span style=color:#ce5c00;font-weight:700>;</span> 
    <span style=color:#204a87;font-weight:700>synchronized</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>this</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span> 
      <span style=color:#000>copy</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>HashSet</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>Taxi</span><span style=color:#ce5c00;font-weight:700>&gt;(</span><span style=color:#000>taxis</span><span style=color:#ce5c00;font-weight:700>);</span> 
    <span style=color:#ce5c00;font-weight:700>}</span> 
    <span style=color:#000>Image</span> <span style=color:#000>image</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>Image</span><span style=color:#ce5c00;font-weight:700>();</span> 
    <span style=color:#204a87;font-weight:700>for</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>Taxi</span> <span style=color:#000>t</span> <span style=color:#ce5c00;font-weight:700>:</span> <span style=color:#000>copy</span><span style=color:#ce5c00;font-weight:700>)</span> 
      <span style=color:#000>image</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>drawMarker</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>t</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>getLocation</span><span style=color:#ce5c00;font-weight:700>());</span> 
    <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>image</span><span style=color:#ce5c00;font-weight:700>;</span> 
  <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><blockquote>
<p>在程序中应尽量使用开放调用。与那些在持有锁时调用外部方法的程序相比，更易于对依赖于开放调用的程序进行死锁分析。</p>
</blockquote>
<p>有时候，再重新编写同步代码块以使用开放调用时会产生意想不到的结果，因为这会使得某个原子操作变得不再原子。在许多情况下，是某个操作时区原子性是可以接受的。例如，对于两个操作：更新出租车位置以及通知调用程序这两出租车已经准备好出发去一个新的目的地，这两个操作并不需要实现为一个原子操作。在其他情况中，虽然去掉原子性可能会出现一些值得注意的结果，但这种语义变化让然是可以接受的。在容易产生死锁的版本中，getImage 会生成某个时刻下的整个车队位置的完整快照，而在重新改写的版本中，getImage 将获得每辆出租车不同时刻的位置。</p>
<p>然而，在某些情况下，丢失原子性会引发错误，此时需要通过另一种技术来实现原子性。例如，在构造一个并发对象时，使得每次只有单个线程执行使用了开放调用的代码路径。例如，在关闭某个服务时，你可能希望所有正在运行的操作执行完成以后，再释放这些服务占用的资源。如果在等待操作完成的同时持有该服务的锁，那么将很容易导致死锁，但如果在服务关闭之前就释放服务的锁，则可能导致其他线程开始新的操作。这个问题的解决方法是，在将服务的状态更新为“关闭”之前一直持有锁，这样其他想要开始操作的线程，包括想关闭该服务的其他线程，会发现服务已经不可用，因此也就不会视图开始新的操作。然后，你可以等待关闭操作结束，并且知道当开放调用完成后，只有执行关闭操作的线程才能访问服务的状态，因此，这项技术依赖于构造一些协议(而不是通过加锁)来防止其他线程进入代码的临界区。</p>
<h3 id=1015-资源死锁>10.1.5 资源死锁</h3>
<p>正如当多个线程相互持有彼此正在等待的锁而又不释放自己已持有的锁时会发生死锁，当它们在相同的资源集合上等待时，也会发生死锁。</p>
<p>假设有两个资源池，例如两个不同数据库的连接池。资源池通常采用信号量来实现当资源为空时的阻塞行为。如果一个任务需要同时连接两个数据库，并且在请求这两个资源时不会始终遵循相同的顺序，那么线程 A 可能与持有数据库 D1 的连接、并等待与数据库 D2 的连接，而线程 B 则持有与 D2 的连接并等待与 D1 的连接。(资源池越大，出现这种情况的可能性也就越小。如果每个资源池都有 N 个连接，那么发生死锁时不仅需要 N 个循环等待的线程，而且还需要大量不恰当的执行顺序)。</p>
<p>另一种基于资源的死锁形式是线程饥饿死锁。8.1.1 节给出了这种危害的一个示例：一个任务提交另一个任务，并等待被提交的任务在单线程的 Executor 中执行完成。这种情况下，第一个任务将永远等待下去，并使得另一个任务以及在这个 Executor 中执行的所有其他任务都停止执行。如果某些任务需要等待其他任务的结果，那么这些任务往往是产生线程饥饿死锁的主要来源，有界线程池/资源池与相互依赖的任务不能结合使用。</p>
<h2 id=102-死锁的避免与诊断>10.2 死锁的避免与诊断</h2>
<p>如果一个程序每次至多只能获得一个锁，那么就不会产生锁顺序死锁。当然，这种情况通常并不现实，但如果能够避免这种情况，那么就能省去很多工作。如果必须获得多个锁，那么在设计的时候必须考虑锁的顺序：尽量减少潜在的加锁交互次数，将获取锁时需要遵循的协议写入正式的文档并始终遵循这些协议。</p>
<p>在使用细粒度锁的程序中，可以通过使用一种两阶段策略来检查代码中的死锁：首先，找出在什么地方将会获取多个锁(使这个集合尽量小)，然后对所有这些实例进行全局分析，从而确保它们在整个程序中获取锁的顺序都保持一致。尽可能的使用开放调用，这能极大的简化分析过程。如果所有的调用都是开放调用，那么要发现获取多个锁的实例是非常简单的，可以通过代码审查，或者借助自动化的源代码分析工具。</p>
<h3 id=1021-支持定时的锁>10.2.1 支持定时的锁</h3>
<p>还有一项技术用于检测死锁和从死锁中恢复，即显式使用 Lock 类中的定时 tryLock 功能来代替内置锁机制。当使用内置锁时，只要没有获得锁，就会永远等待下去，而显式锁可以指定一个超时时限，在等待超过该时限后 tryLock 会返回一个失败信息。如果超时时限比获取锁的时间要长很多，那么就可以在发生某个意外情况后重新获得控制权，(在程序清单 13-3 中给出了 transferMoney 的另一种实现，其中使用了一种轮询的 tryLock 消除了死锁发生的可能性)</p>
<p>当定时锁失败时，你并不需要知道失败的原因。或许是因为发生了死锁，或许某个线程在持有锁时错误的进入了无限循环，还可能是某个操作的执行时间远远超过了你的预期。然而，至少你能记录所发生的失败，以及关于这次操作的其他有用信息，并通过一种更平缓的方式来重新启动计算，而不是关闭整个进程。</p>
<p>即使在整个系统中没有始终使用定时锁，使用定时锁来获取多个锁也能有效的应对死锁问题。如果获取锁时超时，那可可以释放该锁，然后后退并在一段时间后再次尝试，从而消除了死锁发生的条件，使程序恢复过来。(这项技术只有在同时获取两个锁时才有效，如果在嵌套的方法调用中请求多个锁，那么即使你知道已经持有了外层的锁，也无法将其释放)。</p>
<h3 id=1022-通过线程转储信息来分析死锁>10.2.2 通过线程转储信息来分析死锁</h3>
<p>虽然防止死锁的主要责任在于你自己，但 JVM 仍然通过线程转储来帮助识别死锁的发生。线程转储包括各个运行中的线程的栈追踪信息，这类似于发生异常时的栈追踪信息。线程转储还包含加锁信息，例如每隔线程持有了哪些锁，在哪些栈帧中获得这些所，以及被阻塞的线程正在等待哪个锁。在生成线程转储之前，JVM 将在等待关系图中通过搜索循环来找出死锁。如果发现了一个死锁，则获取相应的死锁信息，例如在死锁中设计哪些锁和线程，以及这个锁的获取操作位于程序的哪些位置。</p>
<p>要在 UNIX 平台上触发线程转储操作，可以通过向 JVM 的进程发送 SIGQUIT 信号(<code>kill -3</code>)，或者在 UNIX 平台中按下 <code>Ctrl-\</code>，在 Windows 平台中按下 <code>Ctrl-Break</code> 键。在许多 IDE 中都可以请求线程转储。</p>
<p>如果使用显式的 Lock 类而不是内部锁，那么 Java 5 并不支持与 Lock 相关的转储信息，在线程转储中不会出现显式的 Lock。虽然 Java 6 中包含对显式 Lock 的线程转储和死锁检测等支持，但在这些锁上获得的信息比在内置锁上获得的信息精确度低。内置锁与获得它们所在的线程栈帧是相关联的，而显式的 Lock 只与获得它的线程相关联。</p>
<p>程序清单 10-7 给出了一个 J2EE 应用中获取的部分线程转储信息。在导致死锁的故障中包括 3 个组件：一个 J2EE 应用程序、一个 J2EE 容器、一个 JDBC 驱动程序，分别由不同的生产商提供。这三个组件都是商业产品，并经过了大量的测试，但每个组件都存在一个错误，并且这个错误只有当他们进行交互时才会显现出来，并导致服务器出现一个严重的故障。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback>Found one Java-level deadlock: 
============================= 
&#34;ApplicationServerThread&#34;:
  waiting to lock monitor 0x080f0cdc (a MumbleDBConnection),
  which is held by &#34;ApplicationServerThread&#34; &#34;ApplicationServerThread&#34;:
  waiting to lock monitor 0x080f0ed4 (a 	
  MumbleDBCallableStatement),
  which is held by &#34;ApplicationServerThread&#34;

Java stack information for the threads listed above: 	
  &#34;ApplicationServerThread&#34;:
  at MumbleDBConnection.remove_statement
  - waiting to lock &lt;0x650f7f30&gt; (a MumbleDBConnection) 
  at MumbleDBStatement.close
  - locked &lt;0x6024ffb0&gt; (a MumbleDBCallableStatement) 
  ...

&#34;ApplicationServerThread&#34;:
  at MumbleDBCallableStatement.sendBatch
  - waiting to lock &lt;0x6024ffb0&gt; (a MumbleDBCallableStatement) 
  at MumbleDBConnection.commit
  - locked &lt;0x650f7f30&gt; (a MumbleDBConnection) 
  ...
</code></pre></div><p>我们只给出了与查找死锁相关的部分线程转储信息。当诊断死锁时，JVM 可以帮我们做许多工作——哪些死锁导致了这个问题，涉及哪些线程，它们持有哪些其他的锁，以及是否间接地给其他下城带来了不利的影响。其中一个线程持有 MumbleDBConnection 上的锁，并等待获得 MumbleDBCallableStatement 上的锁，而另一个线程则持有 MumbleDBCallableStatement 上的锁，并等待 MumbleDBConnection 上的锁。</p>
<p>在这里使用的 JDBC 驱动程序中明显存在一个锁顺序问题：不同的调用链通过 JDBC 驱动程序以不同的顺序获得多个锁。如果不是由于另一个错误，这个问题永远不会显现出来：多个线程视图同时使用同一个 JDBC 连接。这并不是应用程序的设计初衷——开发任务惊讶的发现同一个 Connection 被两个线程并发使用。在 JDBC 规范中并没有要求 Connection 必须是线程安全的，以及 Connection 通常被封装在单个线程中使用，而在这里就采用了这种假设。这个生产商视图提供一个线程安全的 JDBC 驱动，因此在驱动程序代码内部对多个 JDBC 对象施加了同步机制。然而，生产商却没有考虑锁的顺序，因而驱动程序很容易发生死锁，而正是由于这个存在死锁风险的驱动程序与错误共享 Connection 的应用程序发生了交互，才使得这个问题暴露出来。因为单个错误并不会产生死锁，只有这两个错误同时发生时才会出现，即使它们分别进行了大量测试。</p>
<h2 id=103-其他活跃性危险>10.3 其他活跃性危险</h2>
<p>尽管死锁是最常见的活跃性危险，但在并发程序中还存在一些其他的活跃性危险，包括：饥饿、丢失信号、活锁等。</p>
<h3 id=1031-饥饿>10.3.1 饥饿</h3>
<p>当线程无法访问它所需要的资源而不能继续执行时，就发生了饥饿。引发饥饿的崔常见资源就是 CPU 时钟周期。如果在 Java 应用程序中对线程的优先级使用不当，或者在持有锁时执行一些无法结束的结构(如无限训话、无限制的等待某个资源)，那么也可能导致饥饿，因为其他需要这个锁的线程将无法得到它。</p>
<p>在 Thread API 中定义的线程优先级只是作为线程调度的参考。在 Thread API 中定义了 10 个优先级，JVM 根据需要将他们映射到操作系统的调度优先级。这种映射是与特定平台相关的，因此在某个操作系统中两个不同的 Java 优先级可能被映射到同一个优先级上，而在另一个操作系统中则可能被映射到另一个不同的优先级上。在某些操作系统中，如果优先级的数量少于 10 个，那么有多个 Java 优先级会被映射到同一个优先级上。</p>
<p>操作系统的线程调度器会尽力提供公平的、活跃性良好的调度，甚至超出 Java 语言规范的需求范围。在大多数 Java 程序中，所有线程都具有相同的优先级 Thread.NORMA_PRIORITY。线程优先级并不是一种直观的机制，而通过修改线程优先级所带来的效果通常也不明显。当提高某个线程的优先级时，可能不会起到任何作用，或者也可能使得某个线程的调度优先级高于其他线程，从而导致饥饿。</p>
<p>通常，我们尽量不要改变线程的优先级。只要改变了线程的优先级，程序的行为就将于平台相关，并且会导致发生饥饿问题的风险。你经常能发现某个程序会在一些奇怪的地方抵用 Thread.sleep 或 Thread.yield，这是因为该程序视图克服优先级调整问题或响应性问题，并试图让低优先级的线程执行更多的时间。</p>
<blockquote>
<p>Thread.yied (以及 Thread.sleep) 的语义都是未定义的。JVM 既可以将它们实现为空操作，也可以将它们视为线程调度的参考。尤其是，在 UNIX 系统中并不要求它们拥有 sleep 的语义——将当前线程放在与该优先级对应的运行队列的末尾，并将执行权交给拥有相同优先级的其他线程，尽管有些 JVM 是按照这种方式实现 Thread.yied 方法的。</p>
</blockquote>
<blockquote>
<p>要避免使用线程优先级，因为这会增加平台依赖性，并可能导致活跃性问题。在大多数应用程序中，都可以使用默认的线程优先级。</p>
</blockquote>
<h3 id=1032-糟糕的响应性>10.3.2 糟糕的响应性</h3>
<p>除饥饿意外的另一个问题是糟糕的响应性，如果在 GUI 应用程序中使用了后台线程，那么这种问题是很常见的。在第九章中开发了一个框架，并发运行时间较长的任务放到后台线程中运行，从而不会使用户界面失去响应。但 CPU 密集型的后台任务仍然可能对响应性造成影响，因为它们会与事件线程共同竞争 CPU 时钟周期。在这种情况下就可以发挥线程优先级的作用，此时计算密集型的后台任务将对响应性造成影响。如果由其他线程完成的工作都是后台任务，那么应该降低它们的优先级，从而提高前台程序的响应性。</p>
<p>不良的锁管理也可能导致糟糕的响应性。如果某个线程长时间占有一个锁(或许正在对一个大容器进行迭代，并且对每个元素进行计算密集的处理)，而其他想要访问这个容器的线程就必须等待很长时间。</p>
<h3 id=1033-活锁>10.3.3 活锁</h3>
<p>活锁是另一种形式的活跃性问题，该问题尽管不会阻塞线程，但也不能继续执行，因为线程将不断的重复执行相同的操作，而且总是会失败。活锁通常发生在处理事务消息的应用程序中：如果不能成功的处理某个消息，那么消息处理机制将回滚整个事务，并将它重新放到队列的开头。如果消息处理器在处理某个特定类型的消息时存在错误并导致它失败，那么每当这个消息从队列中取出并传递给存在错误的处理器时，都会发生事务回滚。由于这条消息又被放回到队列的开头，因此处理器将被反复调用，并返回相同的结果。(有时候也被称为毒药消息，Poison Message)。虽然处理消息的贤臣并没有阻塞，但也无法继续执行下去。这种形式的活锁通常是由过度的错误恢复代码造成的，因为它错误的将不可修复的错误作为可修复的错误。</p>
<p>当多个相互协作的线程都对彼此进行响应而修改各自的状态，并使得任何一个线程都无法继续执行，就发生了活锁。这就像两个过于礼貌的人在半路上面对面的相遇：他们彼此都让出对方的路，然后又在另一条路上相遇了。因此它们就这样反复的避让下去。</p>
<p>要解决这种活锁问题，需要在重试机制中引入随机性。例如，在网络上，如果两台机器都尝试使用相同的载波来发送数据包，那么这些数据包将会冲突。这两台机器都检查到了冲突，并都在稍后再次发送。如果二者都选择了在 1 秒钟之后重试，那么它们会再次冲突，如此往复，因而即使有大量闲置的带宽，也无法发出数据包。为了避免这种情况发生，需要让他们分别等待一段随机的时间。(以太网定义了在重复发生冲突时采用指数方式回退机制，从而降低在多台存在冲突的机器之间发生拥堵而反复失败的风险)。在并发应用中，通过等待随机长度的时间和回退可以有效的避免活锁的发生。</p>
<h2 id=小结>小结</h2>
<p>活跃性故障是一个非常严重的问题，因为当出现活跃性故障时，除了终止应用之外没有其他任何机制可以帮助从这种故障中恢复。最常见的活跃性故障就是锁顺序死锁。在设计时应避免产生锁顺序死锁：确保线程在获取多个锁时采用一致的顺序。最好的解决方法是在程序中始终使用开放调用。这将大大减少需要同时持有多个锁的代码路径，也更容易发现有问题的代码路径。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-af9981d14338576c7a49dd8987440644>11 - CH11-性能与伸缩</h1>
<p>线程主要的目的是提高程序的运行性能。线程可以使程序更加充分的发挥系统的可处理能力，从而提高系统的资源利用率。此外，线程还可以使程序在运行现有任务的情况下立即开始处理新的任务，从而提高系统的响应性。</p>
<p>本章将开始介绍各种分析、监测以及提升并发程序性能的技术。然而，许多提升性能的技术同样会增加复杂性，因此也就增加了在安全性和活跃性上发生失败的风险。更糟糕的是，虽然某些技术的初衷是提升性能，但事实上却与最初的目标背道而驰，或者又带来了其他新的性能问题。虽然我们希望获得更好的性能——提升性能总会令人满意，但始终要把安全性放在第一位。首先要保证程序能正确运行，然后仅当程序的性能需求和测试结果要求程序执行的更快时，才应该设法提高它的运行速度。在设计并发的应用程序时，最重要的考虑因素通常并不是将程序的性能提升至极限。</p>
<h2 id=111-对性能的思考>11.1 对性能的思考</h2>
<p>提升性能意味着用更少的资源做更多的事。“资源”的含义很广。对于一个给定的操作，通常会缺乏某种特定的资源，例如 CPU 时钟周期、内存、网络带宽、IO 带宽、数据库请求、磁盘空间等其他资源。当操作性能由于某种特定的资源而受到限制时，我们通常将该操作称为资源密集型的操作，例如，CPU 密集型、数据库密集型等。</p>
<p>尽管使用线程的目标是提升整体性能，但与单线程的方法相比，使用多个线程总会引入一些额外的性能开销。造成这些开销的操作包括：线程之间的协调(例如加锁、触发信号以及内存同步等)，增加的上下文切换，线程的创建和销毁，以及线程的调度等。如果过度的使用线程，那么这些开销甚至会超过由于提升吞吐量、响应性或计算能力带来的性能提升。另一方面，一个并发设计很糟糕的应用程序，其性能甚至比实现相同功能的串行程序的性能还要差。</p>
<p>要想通过并发来获得更好的性能，需要努力做好两件事情：更有效的利用现有处理资源，以及在出现新的处理资源时使程序尽可能的利用这些新资源。从性能监视的视角来看，CPU 需要尽可能保持忙碌状态。(当然，这并不意味着将 CPU 时钟周期浪费在一些无用的计算上，而是执行一些有用的工作)。如果程序是计算密集型的，那么可以通过增加处理器来提升性能。因为如果程序无法使现有的处理器处于忙碌的状态，那么增加再多的处理器也无济于事。通过将应用程序分解到多个线程上执行，使得每个处理器都执行一些工作，从而使所有 CPU 都保持忙碌状态。</p>
<h3 id=1111-性能与可伸缩性>11.1.1 性能与可伸缩性</h3>
<p>应用的性能可以通过多个指标来衡量，例如服务时间、延迟时间、吞吐率、效率、可伸缩性以及容量等。其中一些指标(服务时间、等待时间)用于衡量程序的“运行速度”，即某个指定的任务单元需要“多快”才能处理完成。另一些指标(生产量、吞吐量)用于程序的“处理能力”，即在计算资源一定的情况下，能完成多少工作。</p>
<blockquote>
<p>可伸缩性指的是：当增加计算资源时(如 CPU、内存、存储容量或 IO 带宽)，程序的吞吐量或者处理能力能获得相应的提升。</p>
</blockquote>
<p>在并发应用程序中针对可伸缩性进行设计和调整时所采用的方法与传统的性能调优方法截然不同。当进行性能调优时，其目的通常是用更小的代价完成相同的工作，例如通过缓存来重用之前计算的结果，或者采用事件复杂度 O(n^2) 算法来代替复杂度为 O(n log n) 的算法。在进行可伸缩性调优时，其目的是设法将问题进行并行化，从而能利用更多的计算资源来完成更多的任务。</p>
<p>我们熟悉的三层程序模型，即在模型中的表现层、业务逻辑层、持久化层都是彼此独立的，并且可能由不同的系统来处理，这很好的说明了提高可伸缩性通常会造成性能损失的原因。如果把表现层、业务逻辑层和持久化层都融合到单个应用程序汇总，那么在处理第一个工作单元时，其性能肯定要高出将应用分为多个层次并将不同层次划分到多个系统时的性能。这种单一的应用程序避免了在不同层次之间传递任务时存在的网络延迟，同时也不需要将计算过程分解到不同的抽象层次，因此能减少很多开销(如任务排队、线程协调、数据复制)。</p>
<p>然而，当这种单一的系统到达自身处理能力的极限时，会遇到一个严重的问题：要进一步提升它的处理能力将非常困难。因此，我们通常会接受每个工作单元执行更长的时间或消耗更多的计算资源，以换取应用程序在增加更多资源的情况下处理更高的负载。</p>
<p>对于服务器应用程序来说，“多少”这个方面——可伸缩性、吞吐量、生产量，往往比“多快”这个方面更受重视。(在交互式应用程序中，延迟或许更加重要，这样用户就不用等待进度条，并奇怪程序究竟在执行哪些操作)。本章将重点介绍可伸缩性而不是单线程程序的性能。</p>
<h3 id=1112-评估各种性能权衡因素>11.1.2 评估各种性能权衡因素</h3>
<p>在几乎所有的工程决策中都会涉及某些形式的权衡。在建设桥梁时，使用更粗的钢筋可以提高桥的负载能力和安全性，但同时也会提高建造成本。尽管在软件工程的决策中通常不会涉及资金以及人身安全，但在做出正确的权衡时通常会缺少相应的信息。例如，“快速排序”算法在大规模数据集上的执行效率非常高，但对于小规模的数据集来说，“冒泡排序”实际上更搞笑。如果要实现一个高效的排序算法，那么就需要知道被处理的数据集的大小，还有衡量优化的指标，包括：平均计算时间、最差时间、可预知性。然而，编写某个库中的排序算法的开发人员通常无法知道这些需求信息。这就是大多数优化措施都不成熟的原因之一：它们通常无法获得一组明确的需求。</p>
<blockquote>
<p>避免不成熟的优化。首先使程序正确，然后再提高运行速度——如果它运行的还不够快。</p>
</blockquote>
<p>当进行决策时，有时候会通过增加某种形式的成本来降低另一种形式的开销(例如，增加内存使用量以降低服务时间)，也会通过增加开销来换取安全性。安全性并不一定就是指对人身安全的威胁，例如桥梁设计的示例。很多性能优化措施都是以牺牲可读性或可维护性为代价——代码越聪明越晦涩，它们又会带来更高的错误风险，因为通常越快的算法就越复杂。(如果你无法找出其中的代价或风险，那么或许还没有对这些优化措施进行彻底的思考和分析)。</p>
<p>在大多数性能决策中都包含多个变量，并且非常依赖于运行环境。在使某个方案比其他方案更快之前，首先问自己一些问题：</p>
<ul>
<li>“更快”的含义是什么？</li>
<li>该方法在什么条件写运行的更快？在低负载还是高负载的情况下？多数据集还是小数据集？能否通过测试结果来验证你的答案？</li>
<li>这些条件在运行环境中的发生概率？能否通过测试结果来验证你的答案？</li>
<li>在其他不同条件的环境中是否能使用这里的代码？</li>
<li>在实现这种性能提升时需要付出哪些隐含的代价，例如增加开发风险或维护开销？这种权衡是否合适？</li>
</ul>
<p>在进行任何与性能相关的决策时，都应该考虑哪些问题，本书只介绍并发性方面的内容。我们为什么要推荐这种保守的方法？对性能的提升可能是并发错误的最大来源。有人认为同步机制太慢，因而采用一些看似聪明实则危险的方法来减少同步的使用(比如 16.2.4 节中讨论的双重检查锁)，这也通常作为不遵守同步规则的一个常见借口。然而，由于并发错误是最难追踪和消除的错误，因此对于任何可能会引入这类错误的措施，都需要谨慎实施。</p>
<p>更糟糕的是，虽然你的初衷可能是用安全性来换取性能，但最终可能什么也得不到。特别是，当提到并发时，许多开发人员对于哪些地方存在性能问题，哪种方法的运行速度更快，以及哪种方法的可伸缩性更好，往往会存在错误的直觉。因此，在对性能进行调优时，一定要有明确的性能需求(这样才能知道什么时候需要调优，以及什么时候应该停止)，此外还需要一个测试程序以及真实的配置和负载均衡等环境。在对性能调优后，你需要再次测量以验证是否达到了预期的性能提升目标。在许多优化措施中带来的安全性和可维护性等风险非常高。如果不是必须的话，你通常不想付出这样的代价，如果无法从这些措施中获得性能提升，那么你肯定不希望付出这种代价。</p>
<blockquote>
<p>以测试为基准，不要猜测。</p>
</blockquote>
<p>市场上有一些成熟的分析工具可以用于评估性能以及找出性能瓶颈，但你不需要花费太多的资金来找出程序的功能。比如免费的 perfbar 应用可以给出 CPU 的忙碌程度信息，而我们通常的目标是使 CPU 保持忙碌状态，因此这个功能可以有效的评估是否需要进行性能调优或者已经实现的调优效果如何。</p>
<h2 id=112-amdahl-定律>11.2 Amdahl 定律</h2>
<p>在有些问题中，如果可用资源越多，那么问题的解决速度就越快。例如，如果参与收割庄稼工人越多，那么就能越快的完成收割工作。而有些任务本质上是串行的，例如，即使增加再多的工人也无法增加作物的生长速度。如果使用线程主要是为了发挥多个处理器的处理能力，那么就必须对问题进行合理的并行分解，并使得程序能有效的使用这种潜在的并行能力。</p>
<p>大多数并发程序都与农业耕作有着形似之处，它们都是由一系列的并行工作和串行工作组成的。Amdahl 定律描述的是：在增加计算资源的情况下，程序在理论上就能够实现最高加速比，这个取值取决于程序中可并行组件与串行组件所占的比重。假定 F 是必须被串行的部分，那么根据 Amdahl 定律，在包含 N 个处理器的机器中，最高的加速比为：</p>
<div align=center>
<img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20181106220640.png style=display:block;width:40% alt=NAME align=center>
</div>
<p>当 N 趋近于无穷大时，最大的加速比趋近于 1/F。因此，如果程序有 50% 的计算需要串行执行，那么最高的加速比只能是 2(而无论有多少个线程可用)；如果程序中有 10% 的计算需要串行执行，那么最高的加速比接近于 10。Amdahl 定律还量化了串行化的效率开销。在拥有 10 个处理器的系统中，如果程序中有 10% 的部分需要串行执行，那么最高加速比为 5.3(53%的使用率)，在拥有 100 个处理器的系统中，加速比可以达到 9.2(9%的使用率)。即使拥有无限多个 CPU，加速比也不可能为 10。</p>
<p>图 11-1 给出了处理器利用率在不同串行比例以及处理器数量的情况下的变化曲率。(利用率定义为：加速比除以处理器的数量)。随着处理器数量的增加，可以明显的看到，即使串行部分所占的比例很小，也会极大的限制当增加计算资源时能够提升的吞吐率。</p>
<div align=center>
<img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20181118174600.png style=display:block;width:70% alt=11-1 align=center>
</div>
<p>第六章介绍了如何识别任务的逻辑边界并将应用程序分解为多个子任务。然而，要预测应用程序在某个多处理器系统中将实现多大的加速比，还需要找出任务的串行部分。</p>
<p>假设应用程序中 N 个线程正在执行程序清单 11-1 中的 doWork，这些线程从一个共享的工作队列中取出任务并进行处理，而且这里的任务都不依赖于任何其他的执行结果或影响。暂时先不考虑任务是如何进入这个队列的，如果增加处理器，那么应用程序的性能是否会相应的发生变化？初看上去，这个程序似乎能完全并行化：各个任务之间不会互相等待，因此处理器越多，能够并发处理的任务也就越多。然而，在这个过程中包含了一个串行的部分——从队列中获取任务。所有工作者线程都共享同一个工作队列，因此在对该队列进行并发访问时需要采用某种同步机制来维持队列的完整性。如果通过加锁来保护队列的状态，那么当一个线程从队列中取出一个任务时，其他需要获取下一个任务的线程就必须等待，这就是任务处理过程中的串行部分。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>WorkerThread</span> <span style=color:#204a87;font-weight:700>extends</span> <span style=color:#000>Thread</span> <span style=color:#ce5c00;font-weight:700>{</span> 
  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>BlockingQueue</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>Runnable</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>queue</span><span style=color:#ce5c00;font-weight:700>;</span>

  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#000>WorkerThread</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>BlockingQueue</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>Runnable</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>queue</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span> 			<span style=color:#204a87;font-weight:700>this</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>queue</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>queue</span><span style=color:#ce5c00;font-weight:700>;</span> 
  <span style=color:#ce5c00;font-weight:700>}</span>

  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>run</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span> 
    <span style=color:#204a87;font-weight:700>while</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>true</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span> 
      <span style=color:#204a87;font-weight:700>try</span> <span style=color:#ce5c00;font-weight:700>{</span> 
        <span style=color:#000>Runnable</span> <span style=color:#000>task</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>queue</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>take</span><span style=color:#ce5c00;font-weight:700>();</span> 
        <span style=color:#000>task</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>run</span><span style=color:#ce5c00;font-weight:700>();</span>
      <span style=color:#ce5c00;font-weight:700>}</span> <span style=color:#204a87;font-weight:700>catch</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>InterruptedException</span> <span style=color:#000>e</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span> 
        <span style=color:#204a87;font-weight:700>break</span><span style=color:#ce5c00;font-weight:700>;</span> <span style=color:#8f5902;font-style:italic>/* Allow thread to exit */</span>
      <span style=color:#ce5c00;font-weight:700>}</span>
    <span style=color:#ce5c00;font-weight:700>}</span> 
  <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>单个任务的处理时间不仅包括执行任务 Runnable 的时间，还包括从共享队列中取出任务的时间。如果使用 LinkedBlockingQueue 作为工作队列，那么出列操作被阻塞的可能性将小于使用同步 LinkedList 发生阻塞的可能性，因为 BlockingQueue 使用了一种可伸缩性更高的算法。然而，无论访问何种共享数据结构，基本上都会为程序引入一个串行的部分。</p>
<p>这个示例还忽略了另一种常见的串行操作：对结果进行处理。所有有用的计算都会生成某种结果或产生某种副作用——如果不会，那么可以将它们作为无用代码删除掉。由于 Runnable 没有提供明确的结果处理过程，因此这些任务一定会产生某种副作用，例如将它们的结果写入日志或保存到某个数据结构。通常，日志文件和结果容器都会由多个工作者线程共享，因此这也是串行的一部分。如果所有线程都将各自的计算结果保存到自行维护的数据结构中，并且在所有任务都执行完成后在合并所有结果，那么这种合并操作也是一个串行部分。</p>
<blockquote>
<p>在所有并发程序中都包含一些串行部分。</p>
</blockquote>
<h3 id=1121-示例在各种框架中隐藏的串行部分>11.2.1 示例：在各种框架中隐藏的串行部分</h3>
<p>要想知道串行部分是如何隐藏在应用程序的框架中的，可以比较当增加线程时吞吐量的变化，并根据观察到的可伸缩线变化来推断串行部分中的差异。图 11-2 给出了一个简单的应用程序，其中多个线程反复从一个共享 Queue 中取出元素进行处理，这与程序清单 11-1 很相似。处理步骤只需执行线程本地的计算。如果某个线程发现队列为空，那么他将一个新元素放入队列，因而其他线程在下一次访问时不会出现没有元素可供处理。在访问共享队列的过程中显然存在着一定程度的串行操作，但处理步骤完全可以并行执行，因为它不会访问共享数据。</p>
<div align=center>
<img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20181118174617.png style=display:block;width:70% alt=11-2 align=center>
</div>
<p>图 11-2 的曲线对两个线程安全的 Queue 的吞吐率进行了对比：其中一个是采用 synchronizedList 封装的 LinkedList，另一个是 ConcurrentLinkedQueue。这些测试在 8 路 Sparc V880 系统上运行，操作系统为 Solaris。尽管每次运行都表示相同的“工作量”，但我们可以看到，只需要改变队列的实现方式，就能对伸缩性产生明显的影响。</p>
<p>ConcurrentLinkedQueue 的吞吐量不断提升，直到达到处理器的数量上限，之后将基本保持不变。另一方面，当线程数量小于 3 时，同步 LinkedList 的吞吐量也会有某种程度的提升，但是之后会由于同步开销而骤然下跌。当线程数量达到 4 个或 5 个时，竞争将非常激烈，甚至每次访问队列都会在锁上发生竞争，此时的吞吐量主要受到上下文切换的限制。</p>
<p>吞吐量的差异主要来源于两个队列中不同比例的串行部分。同步 LinkedList 采用单个锁来保护整个队列的状态，并且在 offer 和 remover 等方法的调用期间都将持有该锁。ConcurrentLinkedQueue 使用了一种更加复杂的非阻塞队列算法，该算法使用原子引用来更新各个链接指针。在第一个队列中，整个的插入和删除操作都将串行执行，而在第二个队列中，只有对指针的更新操作才需要串行执行。</p>
<h3 id=1122-amdahl-定律的应用>11.2.2 Amdahl 定律的应用</h3>
<p>如果能准确估算出串行部分所占的比例，那么 Amdahl 定律就能量化增加计算资源时的加锁比。虽然要直接测量串行部分的比例非常困难，但即使在不进行测试的情况下该定律仍然是有用的。</p>
<p>因为我们的思维通常会受周围环境的影响，因此很多人都习惯的认为在多处理器系统中会包含 2 个或 4 个处理器，甚至更多，因为这种技术在近年来被广泛使用。但随着多个 CPU 逐渐成为主流，系统可能拥有数百个或者数千个处理器。一些在 4 路系统中看似具有可伸缩性的算法，却可能含有一个隐藏的可伸缩性瓶颈，只是还没有遇到而已。</p>
<p>在评估一个算法时，要考虑算法在数百个或数千个处理器的情况下的性能表现，从而对可能出现的可伸缩性局限有一定程度的认识。例如，在 11.4.2 节或 11.4.3 节中介绍了两种降低所粒度的技术：锁分解(将一个锁分解为两个锁)和锁分段(将一个锁分解为多个锁)。当通过 Amdahl 定律来分析这两项技术时，我们会发现，如果将一个锁分解为两个锁，似乎并不能充分利用多处理器的能力。锁分段技术似乎更有前途，因为分段的数量可随着处理器数量的增加而增加。(当然，性能优化应该考虑实际的性能需求，在某些情况下，应用锁分解就够了)。</p>
<h2 id=113-线程引入的开销>11.3 线程引入的开销</h2>
<p>单线程程序即不存在线程调度、也不存在同步开销、而且也不需要使用锁来保证数据结构的一致性。在多个线程的调度和协调过程中都需要一定的性能开销：对于为了提升性能而引入的线程来说，并行带来的性能提升必须超过引入线程的开销。</p>
<h3 id=1131-上下文切换>11.3.1 上下文切换</h3>
<p>如果主线程是唯一的线程，那么它基本上不会被调度出去。另一方面，如果可运行的线程数大于 CPU 的数量，那么操作系统最终会将某个正在运行的线程调度出来，从而使得其他线程能够使用 CPU。这将导致一次上下文切换，在这个过程中将保存当前运行线程的执行上下文，并将新调度进来的线程的上下文设置为当前上下文。</p>
<p>切换上下文需要一定的开销，而在线程调度过程中需要访问由操作系统和 JVM 共享的数据结构。应用程序、操作系统以及 JVM 都使用一组相同的 CPU。在 JVM 和操作系统的代码中消耗越多的 CPU 时钟周期，应用程序的可用 CPU 时钟周期就越少。但上下文切换的开销并不只是包含 JVM 和操作系统的开销。当一个新的线程被切换进来时，它所需要的数据可能不再当前处理器的本地缓存中，因此上下文切换将导致一些缓存缺失，因而线程在首次调度运行时会更加缓慢。这就是为什么调度器会为每个可运行的线程分配一个最小执行时间，即使有许多其他的线程正在等待执行：它将上下文切换的开销分摊到更多不会中断的执行时间上，从而提高整体的吞吐量(以损失响应性为代价)。</p>
<p>当线程由于等待某个发生竞争的锁而被阻塞时，JVM 通常会将这个线程挂起，并允许它被交换出去。如果线程频繁发生阻塞，那么它们将无法使用完整的调度时间片。在程序中发生越多的阻塞(包括阻塞 IO、等待获取发生竞争的锁、在条件变量上等待)，与 CPU 密集型的程序就会发生越多的上下文切换，从而增加调度开销，并因此而降低吞吐量。(无阻塞算法同样有助于减少上下文切换，详见第 15 章)。</p>
<p>上下文切换的开销会随着平台的不同而变化，然而按照经验来看：在大多数同样的处理器中，上下文切换的开销相当于 5000~10000 个时钟周期，也就是几微秒。</p>
<p>UNIX 系统中的 vmstat 命令和 Windows 系统的 perfmon 工具都能包括上下文切换的次数以及在内核中执行时间所占比例等信息。如果内核占用率较高(超过 10%)，那么通常表示调度活动发生得很频繁，这很可能是由 IO 或竞争锁导致的阻塞引起的。</p>
<h3 id=1132-内存同步>11.3.2 内存同步</h3>
<p>同步操作的性能开销包括多个方面。在 synchronized 和 volatile 提供的可见性保证中可能会使用一些特殊指令，即内存屏障。内存屏障可以刷新缓存，使缓存无效，刷新硬件的写缓冲，以及停止执行管道。内存屏障可能同样会对性能带来间接的影响，因为它们将抑制一些编译器优化操作。在内存屏障中，大多数操作都不能被重排序。</p>
<p>在评估同步操作带来的性能影响时，区分有竞争的同步和无竞争的同步非常重要。synchronized 机制针对无竞争的同步进行了优化(volatile 通常是非竞争的)，而在编写本书时，一个快速通道(Fast-Path)的非竞争同步将消耗 20~250 个时钟周期。虽然非竞争同步的开销不为零，但它对应用程序整体性能的影响微乎其微，而另一种方法不仅会破坏安全性，而且会使你(或后续开发人员)经历非常痛苦的除错过程。</p>
<p>现代的 JVM 能通过优化来去掉一些不会发生竞争的锁，从而减少不必要的同步开销。如果一个锁的对象只能由当前线程访问，那么 JVM 就可以通过优化来去掉这个加锁操作，因为另一个线程无法与当前线程在这个锁上发生同步。比如，JVM 通常都会去掉程序清单 11-2 中的加锁操作。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#204a87;font-weight:700>synchronized</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>Object</span><span style=color:#ce5c00;font-weight:700>())</span> <span style=color:#ce5c00;font-weight:700>{</span>
  <span style=color:#8f5902;font-style:italic>// some operations
</span><span style=color:#8f5902;font-style:italic></span><span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>一些更加完备的 JVM 会通过逃逸分析来找出不会被发布到堆的对象引用(因此这个对象是线程本地的)。在程序清单 11-3 的 getStoogeNames 中，对 List 的唯一引用就是局部变量 stooges，并且所有封闭在栈中的变量都会自动称为线程本地变量。在 getStoogeNames 的执行过程中，至少会将 Vector 上的锁获取、释放 4 次，每次调用 add 或 toString 时都会执行一次。然而，一个智能的运行时编译器通常会分析这些调用，从而使 stooges 及其内部状态不会益处，因此可以去掉这 4 次对锁的获取操作。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#204a87;font-weight:700>public</span> <span style=color:#000>String</span> <span style=color:#000>getStoogeNames</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span> 
  <span style=color:#000>List</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>String</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>stooges</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>Vector</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>String</span><span style=color:#ce5c00;font-weight:700>&gt;();</span> 
  <span style=color:#000>stooges</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>add</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#4e9a06>&#34;Moe&#34;</span><span style=color:#ce5c00;font-weight:700>);</span> 
  <span style=color:#000>stooges</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>add</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#4e9a06>&#34;Larry&#34;</span><span style=color:#ce5c00;font-weight:700>);</span> 
  <span style=color:#000>stooges</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>add</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#4e9a06>&#34;Curly&#34;</span><span style=color:#ce5c00;font-weight:700>);</span> 
  <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>stooges</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>toString</span><span style=color:#ce5c00;font-weight:700>();</span> 
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>即使不进行逃逸分析，编译器也可以执行锁粒度粗化操作，即将临近的同步代码块用同一个锁合并起来。在 getStoogeNames 中，如果 JVM 进行锁粗粒度化，那么可能会把 3 个 add 操作和 1 个 toString 调用合并为单个加解锁操作，并采用启发式方法来评估同步代码块中采用同步操作以及指令之间的相对开销。这不仅减少了同步的开销，同时还能使优化器处理更大的代码块，从而实现更进一步的优化。</p>
<blockquote>
<p>不要过度担心非竞争同步带来的开销。这个基本的机制已经非常快了，并且 JVM 还能进行额外的优化进一步降低或消除开销。因此，我们应该将优化重点放到那些发生锁竞争的地方。</p>
</blockquote>
<p>某个线程中的同步可能会影响其他线程的性能。同步会增加共享内存总线上的通信量，总线的带宽是有限的，并且所有的处理器都将共享这条总线。如果有多个线程竞争同步带宽，那么所有使用了同步的线程都会受到影响。</p>
<h3 id=1133-阻塞>11.3.3 阻塞</h3>
<p>非竞争同步可以完全在 JVM 中进行处理(而不涉及操作系统)，而竞争的同步可能需要操作系统的介入，从而增加开销。当在锁上发生竞争时，竞争失败的线程肯定会阻塞。JVM 在实现阻塞的行为时，可以采用自旋等待(Spin-Waiting，指通过循环不断的尝试获取锁，直到成功)或者通过操作系统挂起被阻塞的线程。这两种方式的效率高低，要取决于上下文切换的开销以及在成功获取锁之前需要等待的时间。如果等待的时间很短，则适合采用自旋等待的方式，而如果等待时间很长，则适合采用线程挂起的方式。有些 JVM 将根据对历史等待时间的分析数据在这两者之间进行选择，但是大多数 JVM 在等待锁时都只是将线程挂起。</p>
<p>当线程无法获取某个锁或者由于在某个条件等待或在 IO 操作上阻塞时，需要被挂起，在这个过程中将包含两次额外的上下文切换，以及所有必要的操作系统操作和缓存操作：被阻塞的线程在其执行时间片还未用完之前就被交换出去，而在随后当要获取的锁或者其他资源可用时，又再次被切换回来。(由于锁竞争而导致锁阻塞时，线程在持有锁时将存在一定的开销：当它释放锁时，必须告诉操作系统恢复运行阻塞的线程)。</p>
<h2 id=114-减少锁的竞争>11.4 减少锁的竞争</h2>
<p>我们已经看到，串行操作会降低可伸缩线，并且上下文切换也会降低性能。在锁上发生竞争时将同时导致这两种问题，因此减少锁的竞争能够提高性能和可伸缩性。</p>
<p>在对由某个独占锁保护的资源进行访问时，将采用串行方式——每次只有一个线程能访问它。当然，我们有很好的理由来使用锁，例如避免数据被破坏，但获得这种安全性是需要付出代价的。如果在锁上持续发生竞争，那么将限制代码的可伸缩性。</p>
<blockquote>
<p>在并发程序中，对可伸缩性的最主要威胁就是独占方式的资源锁。</p>
</blockquote>
<p>有两个因素将影响在锁上发生竞争的可能性：锁的请求频率，以及每次持有该锁的时间。如果二者的乘积很小，那么大多数获取锁的操作都不会发生竞争，因此在该锁上的竞争不会对可伸缩性造成严重影响。然而，如果在锁上的请求量很高，那么需要获取该锁的线程将被阻塞并等待。在极端情况下，即使仍有大量工作等待完成，处理器也会被闲置。</p>
<blockquote>
<p>有三种方式可以降低锁的竞争程度：</p>
<ol>
<li>减少持有锁的时间。</li>
<li>降低对锁的请求频率。</li>
<li>使用带有协调机制的独占锁，这些机制支持更高的并发性。</li>
</ol>
</blockquote>
<h3 id=1141-缩小锁的范围快进快出>11.4.1 缩小锁的范围——“快进快出”</h3>
<p>降低发生竞争可能性的一种有效方式就是尽可能缩短锁的持有时间。例如，可以将一些与锁无关的代码移出同步代码块，尤其是那些开销较大的操作，以及可能被阻塞的操作，例如 IO 操作。</p>
<p>我们都知道，如果将一个“高度竞争”的锁持有过长的时间，那么会限制可伸缩性，例如在第二章中介绍的 SynchronizedFactorizer 的示例。如果某个操作持有锁的时间超过 2 毫秒并且所有操作都需要这个锁，那么无论拥有多个个空闲的处理器，吞吐量也不会超过每秒 500 个操作。如果将这个锁的持有时间降低为 1 毫秒，那么能够将这个锁对应的吞吐量提高到每秒 1000 个操作。</p>
<p>程序清单 11-4 给出了一个示例，其中锁被持有过长的时间。userLocationMatches 方法在一个 Map 对象中查找用户的位置，并使用正则表达式进行匹配以判断结果值是否匹配所提供的模式。整个 userLocationMatches 方法都是用了 synchronized 来修饰，但只有 Map.get 这个调用才真正需要锁。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#5c35cc;font-weight:700>@ThreadSafe</span> <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>AttributeStore</span> <span style=color:#ce5c00;font-weight:700>{</span>

  <span style=color:#5c35cc;font-weight:700>@GuardedBy</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#4e9a06>&#34;this&#34;</span><span style=color:#ce5c00;font-weight:700>)</span> 
  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>Map</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>String</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>String</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>attributes</span> <span style=color:#ce5c00;font-weight:700>=</span> 
    <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>HashMap</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>String</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>String</span><span style=color:#ce5c00;font-weight:700>&gt;();</span>

  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>synchronized</span> <span style=color:#204a87;font-weight:700>boolean</span> <span style=color:#000>userLocationMatches</span><span style=color:#ce5c00;font-weight:700>(</span>
    <span style=color:#000>String</span> <span style=color:#000>name</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>String</span> <span style=color:#000>regexp</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span> 
    <span style=color:#000>String</span> <span style=color:#000>key</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#4e9a06>&#34;users.&#34;</span> <span style=color:#ce5c00;font-weight:700>+</span> <span style=color:#000>name</span> <span style=color:#ce5c00;font-weight:700>+</span> <span style=color:#4e9a06>&#34;.location&#34;</span><span style=color:#ce5c00;font-weight:700>;</span> 
    <span style=color:#000>String</span> <span style=color:#000>location</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>attributes</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>get</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>key</span><span style=color:#ce5c00;font-weight:700>);</span> 
    <span style=color:#204a87;font-weight:700>if</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>location</span> <span style=color:#ce5c00;font-weight:700>==</span> <span style=color:#204a87;font-weight:700>null</span><span style=color:#ce5c00;font-weight:700>)</span>
      <span style=color:#204a87;font-weight:700>return</span> <span style=color:#204a87;font-weight:700>false</span><span style=color:#ce5c00;font-weight:700>;</span> 
    <span style=color:#204a87;font-weight:700>else</span>
      <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>Pattern</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>matches</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>regexp</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>location</span><span style=color:#ce5c00;font-weight:700>);</span>
  <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>在程序清单 11-5 的 BetterAttributeStore 中重新编写了 AttributeStore，从而大大降低了锁的持有时间。第一个步骤是构建 Map 中与用户位置相关联的键值，这是一个字符串，形式为 user.name.location。这个步骤还包括实例化一个 StringBuilder 对象，向其添加几个字符串，并将结果转化为一个 String 对象。在获得了位置之后，就可以将正则表达式与位置字符串进行匹配。由于在构建键值字符串以及处理正则表达式等过程中不需要访问共享状态，因此在执行时不需要持有锁。通过 BetterAttributeStore 中将这些步骤提取出来并放到同步代码块之外，从而减少了锁被持有的时间。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#5c35cc;font-weight:700>@ThreadSafe</span> <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>BetterAttributeStore</span> <span style=color:#ce5c00;font-weight:700>{</span>

  <span style=color:#5c35cc;font-weight:700>@GuardedBy</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#4e9a06>&#34;this&#34;</span><span style=color:#ce5c00;font-weight:700>)</span> 
  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>Map</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>String</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>String</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>attributes</span> <span style=color:#ce5c00;font-weight:700>=</span> 
    <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>HashMap</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>String</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>String</span><span style=color:#ce5c00;font-weight:700>&gt;();</span>

  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>boolean</span> <span style=color:#000>userLocationMatches</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>String</span> <span style=color:#000>name</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>String</span> <span style=color:#000>regexp</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span> 
    <span style=color:#000>String</span> <span style=color:#000>key</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#4e9a06>&#34;users.&#34;</span> <span style=color:#ce5c00;font-weight:700>+</span> <span style=color:#000>name</span> <span style=color:#ce5c00;font-weight:700>+</span> <span style=color:#4e9a06>&#34;.location&#34;</span><span style=color:#ce5c00;font-weight:700>;</span>
    <span style=color:#000>String</span> <span style=color:#000>location</span><span style=color:#ce5c00;font-weight:700>;</span> <span style=color:#204a87;font-weight:700>synchronized</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>this</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span> 
      <span style=color:#000>location</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>attributes</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>get</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>key</span><span style=color:#ce5c00;font-weight:700>);</span> 
    <span style=color:#ce5c00;font-weight:700>}</span> 
    <span style=color:#204a87;font-weight:700>if</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>location</span> <span style=color:#ce5c00;font-weight:700>==</span> <span style=color:#204a87;font-weight:700>null</span><span style=color:#ce5c00;font-weight:700>)</span> 
      <span style=color:#204a87;font-weight:700>return</span> <span style=color:#204a87;font-weight:700>false</span><span style=color:#ce5c00;font-weight:700>;</span> 
    <span style=color:#204a87;font-weight:700>else</span> 
      <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>Pattern</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>matches</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>regexp</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>location</span><span style=color:#ce5c00;font-weight:700>);</span>
  <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>通过缩小 userLocationMatches 方法中所的作用范围，能极大的减少在持有锁时需要执行的指令数量。根据 Amdahl 定律，这样消除了限制可伸缩性的一个因素，因为串行代码的总量减少了。</p>
<p>由于 AttributeStore 中只有一个状态变量 attributes，因此可以通过将线程安全性委托给其他的类来进一步提升它的性能。通过使用线程安全的 Map 来代替 attributes，AttributeStore 可以将确保线程安全性为任务委托给顶层的线程安全容器来实现，这样就无需在 AttributeStore 中采用显式锁的同步，缩小在访问 Map 期间锁的范围，并降低了将来的代码维护者无意破坏线程安全性的风险(比如在访问 attributes 之前忘记获得对应的锁)。</p>
<p>尽管缩小同步代码块能够提高可伸缩性，但同步代码块也不能过小——一些采用原子方式执行的操作(如对某个不变性条件中的多个变量进行更新)必须包含在一个同步块中。此外，同步需要获得一定的开销，当把一个同步块分解为多个同步块代码块时(在确保正确性的情况下)，反而会对性能提升产生负面的影响。在分解同步代码时，理想的平衡点将与平台相关，但在实际情况中，仅当可以将一些“大量”的计算或阻塞操作作为同步代码块中移出时，才应该考虑同步代码块的大小。</p>
<h3 id=1142-减小锁的粒度>11.4.2 减小锁的粒度</h3>
<p>另一种减少锁持有时间的方式是降低线程请求锁的频率(从而减少发生竞争的可能性)。这可以通过锁分解和锁分段技术来实现，在这些技术中将采用多个互相独立的锁来保护独立的状态变量，从而改变这些变量在之前由单个变量来保护的情况。这些技术能减少锁操作的粒度，并能实现更高的可伸缩性，然而，使用的锁越多，发生死锁的风险也越高。</p>
<p>设想一下，如果在整个应用中只有一个锁，而不是为每个对象分配一个独立的锁，那么，所有同步代码块的执行就会变成串行化执行，而不考虑各个同步块中的锁。由于很多线程将竞争同一个全局锁，因此两个线程同时请求这个锁的概率将剧增，从而导致更严重的竞争。所以如果将这些锁请求分布到更多的锁上，那么能有效的降低竞争程度。由于等待锁而被阻塞的线程将更少，因此可伸缩性将提高。</p>
<p>如果一个锁需要保护多个相互独立的状态变量，那么可以将这个锁分解为多个锁，并且每个锁仅保护一个变量，从而提高可伸缩性，并最终降低每个锁被请求的频率。</p>
<p>在程序清单 11-6 的 ServerStatus 中给出了某个数据库服务器的部分监视接口，该数据库维护了当前已登录的用户以及正在执行的请求。当一个用户登录、注销、开始查询或结束查询时，都会调用对应的 add 和 remove 方法来更新 ServerStatus 对象。这两种类型的信息是完全独立的，ServerStatus 甚至可以被分解为两个类，同时确保不会丢失功能。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#5c35cc;font-weight:700>@ThreadSafe</span> <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>ServerStatus</span> <span style=color:#ce5c00;font-weight:700>{</span>

  <span style=color:#5c35cc;font-weight:700>@GuardedBy</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#4e9a06>&#34;this&#34;</span><span style=color:#ce5c00;font-weight:700>)</span> 
  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>Set</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>String</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>users</span><span style=color:#ce5c00;font-weight:700>;</span> 
  <span style=color:#5c35cc;font-weight:700>@GuardedBy</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#4e9a06>&#34;this&#34;</span><span style=color:#ce5c00;font-weight:700>)</span> 
  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>Set</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>String</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>queries</span><span style=color:#ce5c00;font-weight:700>;</span> 
  <span style=color:#ce5c00;font-weight:700>...</span>

  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>synchronized</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>addUser</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>String</span> <span style=color:#000>u</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span> 
    <span style=color:#000>users</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>add</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>u</span><span style=color:#ce5c00;font-weight:700>);</span> 
  <span style=color:#ce5c00;font-weight:700>}</span> 
  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>synchronized</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>addQuery</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>String</span> <span style=color:#000>q</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span> 
    <span style=color:#000>queries</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>add</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>q</span><span style=color:#ce5c00;font-weight:700>);</span> 
  <span style=color:#ce5c00;font-weight:700>}</span> 
  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>synchronized</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>removeUser</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>String</span> <span style=color:#000>u</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#000>users</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>remove</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>u</span><span style=color:#ce5c00;font-weight:700>);</span> 
  <span style=color:#ce5c00;font-weight:700>}</span> 
  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>synchronized</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>removeQuery</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>String</span> <span style=color:#000>q</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#000>queries</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>remove</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>q</span><span style=color:#ce5c00;font-weight:700>);</span> 
  <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>在代码中不是用 ServerStatus 锁来保护用户状态和查询状态，而是每个状态都通过一个锁来保护，如程序清单 11-7 所示。在对锁进行分解后，每个新的粒度锁上的访问量将比最初的访问量少。(通过将用户状态和查询状态委托给一个线程安全的 Set，而不是使用显式的同步，能隐含的对锁进行分解，因为每个 Set 都会使用一个不同的锁来保护其状态。)</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#5c35cc;font-weight:700>@ThreadSafe</span> <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>ServerStatus</span> <span style=color:#ce5c00;font-weight:700>{</span>
  <span style=color:#5c35cc;font-weight:700>@GuardedBy</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#4e9a06>&#34;users&#34;</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>Set</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>String</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>users</span><span style=color:#ce5c00;font-weight:700>;</span> 	
  <span style=color:#5c35cc;font-weight:700>@GuardedBy</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#4e9a06>&#34;queries&#34;</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>Set</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>String</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>queries</span><span style=color:#ce5c00;font-weight:700>;</span> 
  <span style=color:#ce5c00;font-weight:700>...</span>

  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>addUser</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>String</span> <span style=color:#000>u</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#204a87;font-weight:700>synchronized</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>users</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
      <span style=color:#000>users</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>add</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>u</span><span style=color:#ce5c00;font-weight:700>);</span>
    <span style=color:#ce5c00;font-weight:700>}</span>
  <span style=color:#ce5c00;font-weight:700>}</span>

  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>addQuery</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>String</span> <span style=color:#000>q</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span> 
    <span style=color:#204a87;font-weight:700>synchronized</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>queries</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span> 
      <span style=color:#000>queries</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>add</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>q</span><span style=color:#ce5c00;font-weight:700>);</span> 
    <span style=color:#ce5c00;font-weight:700>}</span> 
  <span style=color:#ce5c00;font-weight:700>}</span> 
  
  <span style=color:#8f5902;font-style:italic>// remove methods similarly refactored to use split locks
</span><span style=color:#8f5902;font-style:italic></span><span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>如果在锁上存在适中而非激烈的竞争时，通过将一个锁分解为两个锁，能最大限度的提升性能。如果对竞争并不激烈的锁进行分解，那么在性能和吞吐量等方面带来的提升将非常有限，但是也会提高性能随着竞争提高而下降的拐点。对竞争适中的锁进行分解时，实际上是把这些锁转变为非竞争的锁，从而有效的提高性能和可伸缩性。</p>
<h3 id=1143-锁分段>11.4.3 锁分段</h3>
<p>把一个竞争激烈的锁分解为两个锁时，这两个锁可能都存在激烈的竞争。虽然采用两个线程并发执行能提高一部分性能，但是在一个拥有多个处理器的系统中，仍然无法给可伸缩性带来极大的提高。在 ServerStatus 类的锁分解实例中，并不能进一步多锁进行分解。</p>
<p>在某些情况下，可以将锁分解技术进一步扩展为对一组独立对象上的锁进行分解，这种情况被称为锁分段。例如，在 ConcurrentHashMap 的实现中使用了一个包含 16 的锁的数组，每个锁保护所有散列通的 1/16，其中第 N 个散列桶由第 (N mod 16) 个锁来保护。假设散列函数具有合理的分布性，并且关键字能够实现均匀分布，那么这大约能把对于锁的请求减少到原来的 1/16。这是这项技术使得 ConcurrentHashMap 能够支持多达 16 个并发的写入器。(要使得拥有大量处理器的系统在高访问量的情况下实现更高的并发性，还可以进一步增加锁的数量，但仅当你能证明并发写入线程的竞争足够激烈并需要突破这个限制时，才能将锁分段的数量超过默认的 16 个。)</p>
<p>锁分段的一个劣势在于：与采用单个锁来实现的独占性相比，要获取多个锁来实现独占访问将更加困难并且开销更高。通常，在执行一个操作时最多只需获取一个锁，但在某些情况下需要对整个容器加锁，例如当 ConcurrentHashMap 需要扩展容器映射范围时，以及重新计算键值的散列值要分布到更大的桶集合中时，就需要获取分段分段锁集合中所有的锁。</p>
<p>在程序清单 11-8 的 StripedMap 中给出了基于散列的 Map 实现，其中使用了锁分段技术。它拥有 N_LOCKS 个锁，并且每个锁保护散列桶的一个子集。大多数方法，例如 get，都只需要获得一个锁，而有些方法则需要获得所有的锁，但并不要求同时获得，例如 clear 方法的实现。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#5c35cc;font-weight:700>@ThreadSafe</span> <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>StripedMap</span> <span style=color:#ce5c00;font-weight:700>{</span>

  <span style=color:#8f5902;font-style:italic>// Synchronization policy: buckets[n] guarded by locks[n%N_LOCKS] 
</span><span style=color:#8f5902;font-style:italic></span>  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>static</span> <span style=color:#204a87;font-weight:700>final</span> <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>N_LOCKS</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>16</span><span style=color:#ce5c00;font-weight:700>;</span> 
  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>Node</span><span style=color:#ce5c00;font-weight:700>[]</span> <span style=color:#000>buckets</span><span style=color:#ce5c00;font-weight:700>;</span> 
  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>Object</span><span style=color:#ce5c00;font-weight:700>[]</span> <span style=color:#000>locks</span><span style=color:#ce5c00;font-weight:700>;</span>

  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>static</span> <span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>Node</span> <span style=color:#ce5c00;font-weight:700>{</span> <span style=color:#ce5c00;font-weight:700>...</span> <span style=color:#ce5c00;font-weight:700>}</span>

  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#000>StripedMap</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>numBuckets</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span> 
    <span style=color:#000>buckets</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>Node</span><span style=color:#ce5c00;font-weight:700>[</span><span style=color:#000>numBuckets</span><span style=color:#ce5c00;font-weight:700>];</span> 
    <span style=color:#000>locks</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>Object</span><span style=color:#ce5c00;font-weight:700>[</span><span style=color:#000>N_LOCKS</span><span style=color:#ce5c00;font-weight:700>];</span> 
    <span style=color:#204a87;font-weight:700>for</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>i</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>0</span><span style=color:#ce5c00;font-weight:700>;</span> <span style=color:#000>i</span> <span style=color:#ce5c00;font-weight:700>&lt;</span> <span style=color:#000>N_LOCKS</span><span style=color:#ce5c00;font-weight:700>;</span> <span style=color:#000>i</span><span style=color:#ce5c00;font-weight:700>++)</span> 
      <span style=color:#000>locks</span><span style=color:#ce5c00;font-weight:700>[</span><span style=color:#000>i</span><span style=color:#ce5c00;font-weight:700>]</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>Object</span><span style=color:#ce5c00;font-weight:700>();</span> 
  <span style=color:#ce5c00;font-weight:700>}</span>

  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>final</span> <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>hash</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>Object</span> <span style=color:#000>key</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span> 
    <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>Math</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>abs</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>key</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>hashCode</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>%</span> <span style=color:#000>buckets</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>length</span><span style=color:#ce5c00;font-weight:700>);</span> 
  <span style=color:#ce5c00;font-weight:700>}</span>

  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#000>Object</span> <span style=color:#000>get</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>Object</span> <span style=color:#000>key</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span> 
    <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>hash</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>hash</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>key</span><span style=color:#ce5c00;font-weight:700>);</span> 
    <span style=color:#204a87;font-weight:700>synchronized</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>locks</span><span style=color:#ce5c00;font-weight:700>[</span><span style=color:#000>hash</span> <span style=color:#ce5c00;font-weight:700>%</span> <span style=color:#000>N_LOCKS</span><span style=color:#ce5c00;font-weight:700>])</span> <span style=color:#ce5c00;font-weight:700>{</span> 
      <span style=color:#204a87;font-weight:700>for</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>Node</span> <span style=color:#000>m</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>buckets</span><span style=color:#ce5c00;font-weight:700>[</span><span style=color:#000>hash</span><span style=color:#ce5c00;font-weight:700>];</span> <span style=color:#000>m</span> <span style=color:#ce5c00;font-weight:700>!=</span> <span style=color:#204a87;font-weight:700>null</span><span style=color:#ce5c00;font-weight:700>;</span> <span style=color:#000>m</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>m</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>next</span><span style=color:#ce5c00;font-weight:700>)</span> 
        <span style=color:#204a87;font-weight:700>if</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>m</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>key</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>equals</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>key</span><span style=color:#ce5c00;font-weight:700>))</span> 
          <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>m</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>value</span><span style=color:#ce5c00;font-weight:700>;</span> 
    <span style=color:#ce5c00;font-weight:700>}</span> 
    <span style=color:#204a87;font-weight:700>return</span> <span style=color:#204a87;font-weight:700>null</span><span style=color:#ce5c00;font-weight:700>;</span> 
  <span style=color:#ce5c00;font-weight:700>}</span>

  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>clear</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span> 
    <span style=color:#204a87;font-weight:700>for</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>i</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>0</span><span style=color:#ce5c00;font-weight:700>;</span> <span style=color:#000>i</span> <span style=color:#ce5c00;font-weight:700>&lt;</span> <span style=color:#000>buckets</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>length</span><span style=color:#ce5c00;font-weight:700>;</span> <span style=color:#000>i</span><span style=color:#ce5c00;font-weight:700>++)</span> <span style=color:#ce5c00;font-weight:700>{</span> 
      <span style=color:#204a87;font-weight:700>synchronized</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>locks</span><span style=color:#ce5c00;font-weight:700>[</span><span style=color:#000>i</span> <span style=color:#ce5c00;font-weight:700>%</span> <span style=color:#000>N_LOCKS</span><span style=color:#ce5c00;font-weight:700>])</span> <span style=color:#ce5c00;font-weight:700>{</span> 
        <span style=color:#000>buckets</span><span style=color:#ce5c00;font-weight:700>[</span><span style=color:#000>i</span><span style=color:#ce5c00;font-weight:700>]</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>null</span><span style=color:#ce5c00;font-weight:700>;</span>
      <span style=color:#ce5c00;font-weight:700>}</span>
    <span style=color:#ce5c00;font-weight:700>}</span> 
  <span style=color:#ce5c00;font-weight:700>}</span> 
  <span style=color:#ce5c00;font-weight:700>...</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><h3 id=1144-避免热点域>11.4.4 避免热点域</h3>
<p>锁分解和锁分段技术都能提高可伸缩性，因为它们都能使不同的线程在不同的数据(或者同一个数据的不同部分)上操作，而不会互相干扰。如果程序采用锁分段技术，那么一定要表现出在锁上的竞争频率高于在锁保护的数据上发生竞争的频率。如果一个锁保护两个独立变量 X 和 Y，并且线程 A 想要访问 X，而线程 B 想要访问 Y(这类似于在 ServerStatus 中，一个线程调用 addUser，而另一个线程调用 addQuery)，那么这两个线程不会在任何数据上发生竞争，即使它们会在同一个锁上发生竞争。</p>
<p>当每个操作都访问多个变量时，锁的粒度将很难降低。这是在性能和可伸缩性之间相互制衡的另一个方面，一些常见的优化措施，例如将一些反复计算的结果缓存起来，都会引入一些“热点域(Hot Field)”，而这些热点域往往会限制可伸缩性。</p>
<p>当实现 HashMap 时，你需要考虑如何在 size 方法中计算 Map 中的元素数量。最简单的方法就是，在每次调用时都统计一次元素的数量。一种常见的优化措施是，在插入和移除元素时更新一个计数器，虽然这在 put 和 remove 等方法中略微增加了一些开销，以确保计数器是最新的值，但这将 size 方法的开销从 O(n) 降低到了 O(1)。</p>
<p>在单线程或采用完全同步的实现中，使用一个独立的就计数能很好的提高类似 size 和 isEmpty 这些方法的执行速度，但却导致更加难以提升实现的可伸缩性，因为每个修改 Map 的操作都需要跟新这个计数器。即使使用锁分段即使来实现散列链，那么在对计数器的访问进行同步时，也会重新导致在使用独占锁时存在的可伸缩性问题。一个看似性能优化的措施——缓存 size 操作的结果，已经变成了一个可伸缩性问题。在这种情况下，计数器也被称为热点域，因为每个导致元素数量发生变化的操作都需要访问它。</p>
<p>为了避免该问题，ConcurrentHashMap 中的 size 将对每个分段进行枚举并将每个分段中的元素数量增加，而不是维护一个全局计数。为了避免枚举每个元素，ConcurrentHashMap 为每个分段都维护了一个独立的计数，并通过每个分段的锁来维护这个值。</p>
<h3 id=1145-一些替代独占锁的方法>11.4.5 一些替代独占锁的方法</h3>
<p>第三种降低竞争锁的影响的技术就是放弃独占所，从而有助于使用一种友好并发的方式来管理共享状态。例如，使用并发容器、读-写锁、不可变对象以及原子变量。</p>
<p>ReadWriteLock 实现了一种在多个读取操作以及单个写入操作情况下的加锁规则：如果有多个读取操作都不会修改共享资源，那么这些读操作可以同时访问该共享资源，但在执行写入操作时必须以独占的方式来获取锁，对于读取操作占多数的数据结构，ReadWriteLock 能够提供比独占锁更高的并发性。而对于只读的数据结构，其中包含的不可变性可以完全不需要加锁操作。</p>
<p>源自变量提供了一种方式来降低更新“热点域”时的开销，例如静态计数器、序列生成器、或者对链表数据结构中头节点的引用。原子变量类提供了在整数或对象引用上的细粒度原子操作(因此可伸缩性更高)，并使用了现代处理器中提供的底层并发原语(比如 CAS)。如果在类中只包含少量的热点域，并且这些域不会与其他变量参与到不变性条件中，那么用原子变量来代替它们提高可伸缩性。(通过减少算法中的热点域，可以提高可伸缩性——虽然原子变量能降低热点域的更新开销，但并不能完全消除。)</p>
<h3 id=1146-检测-cpu-的利用率>11.4.6 检测 CPU 的利用率</h3>
<p>当测试可伸缩性时，通常要确保处理器得到充分利用。一些工具，例如 UNIX 系统上的 vastat 和 mpstat，或者 Windows 系统的 perfmon，都能给出处理器的忙碌状态。</p>
<p>如果所有 CPU 的利用率并不均匀(有些 CPU 在忙碌的运行，而其他 CPU 却并非如此)。那么你的首要目标就是进一步找出程序中的并行性。不均匀的利用率表名大多数计算都是由一小组线程完成的，并且应用程序没有利用上其他的处理器。</p>
<p>如果 CPU 没有得到充分的利用，那么需要找出其中的原因，通常有以下几种原因：</p>
<p><strong>负载不充足</strong>。测试的程序中可能没有足够的负载，因而可以在测试时增加负载，并检查利用率、响应时间和服务时间等指标的变化。如果产生足够多的负载使应用程序达到饱和，那么可能需要大量的计算机能耗，并且问题可能在于客户端系统是否具有足够的能力，而不是被测试的系统。</p>
<p><strong>IO 密集</strong>。可以通过 iostat 或 perfmon 来判断某个应用程序是否是磁盘 IO 密集型的，或者通过监控网络的通信流量级别来判断它是否需要高带宽。</p>
<p><strong>外部限制</strong>。如果应用程序依赖于外部服务，例如数据库或者 Web 服务，那么性能瓶颈可能并不在你自己的代码中。可以使用某个分析工具或数据库管理工具来判断在等待外部的结果时需要的时间。</p>
<p><strong>锁竞争</strong>。使用分析工具可以知道在程序中存在何种程度的锁竞争，以及在哪些锁上存在“激烈的竞争”。然而，也可以通过其他一些方式来获得相同的信息，例如随机取样，触发一些线程转储并在其中查找在锁上发生竞争的线程。如果线程由于等待某个锁而被阻塞，那么在线程转储信息中将存在相应的栈帧，其中包含的信息形如“waiting to lock monitor&mldr;”。非竞争的锁很少会出现在线程转储中，而对于竞争激烈的锁，通常至少会有一个线程正在等待获取它，因此将在线程转储中频繁的出现。</p>
<p>如果应用程序正在使 CPU 保持忙碌的状态，那么可以使用检测工具来判断是否能通过增加额外的 CPU 来提升程序的性能。如果一个程序只有 4 个线程，那么可以充分利用一个 4 路系统的计算能力，但当移植到 8 路系统上时，却未必能获得性能提升，因为可能需要更多的线程才会有效利用剩余的处理器。(可以通过重新配置程序将负载分配给更多的线程，例如调整线程池的大小)。在 vmstat 命令的输出中，有一栏信息是当前处于可运行状态但并没有运行(由于没有足够的 CPU)的线程数量。如果 CPU 的利用率很高，并且总会有可运行的线程在等待 CPU，那么当增加更多的处理器时，程序的性能可能会得到提升。</p>
<h3 id=1147-向对象池说不>11.4.7 向对象池说“不”</h3>
<p>在 JVM 早期的版本中，对象分配和垃圾回收等操作的执行速度非常慢，但在后续的版本中，这些操作的性能得到了很大的提升。事实上，现在 Java 的分配操作已经比 C 语言的 malloc 调用更快：在 HotSpot 1.4.x 和 5.0 中，“new Object”的代码大约包含 10 条机器指令。</p>
<p>为了解决“缓慢的”对象生命周期问题，许多开发人员都选择使用对象池技术，在对象池中，对象能够被循环使用，而不是由垃圾收集器回收并在需要时再重新分配。在单线程程序中，尽管对象池技术能降低垃圾收集器的开销，但对于高开销对象以外的其他对象来说，仍然存在性能缺失(对于轻量级和中量级的对象来说，这种损失更为严重)。</p>
<p>在并发应用程序中，对象池的表现更加糟糕。当线程分配新的对象时，基本上不需要在线程之间进行协调，因为对象分配器通常会使用线程本地的内存块，所以不需要在堆数据结构上进行同步。然而，如果这些线程从对象池中请求一个对象，那么久需要通过某种同步来协调对对象池数据结构的访问，从而可能使某个线程被阻塞。如果某个线程由于锁竞争而被阻塞，那么这种阻塞的开销将是内存分配操作开销的数百倍，因此即使对象池带来的竞争很小，也可能形成一个可伸缩的性能瓶颈。(即使是一个非竞争同步，所导致的开销也会被分配一个对象的开销大)。虽然这看上去是一种性能优化技术，但实际上却会导致可伸缩性问题。对象池有其特定的用途，但对于性能优化来说，用途是有限的。</p>
<blockquote>
<p>通常，对象分配操作的开销比同步的开销更低。</p>
</blockquote>
<h2 id=115-示例比较-map-的性能>11.5 示例：比较 Map 的性能</h2>
<p>在单线程环境下，ConcurrentHashMap 的性能比同步的 HashMap 的性能略好一些，但在并发环境中则要好的多。在 ConcurrentHashMap 的实现中假设，大多数常用的操作都是获取某个已经存在的值，因此它对各种 get 操作进行了优化从而提高性能和并发性。</p>
<p>在同步 Map 的实现中，可伸缩性的最主要阻碍在于整个 Map 中只有一个锁，因此每次只有一个线程能能够访问这个 Map。不同的是，ConcurrentHashMap 对于大多数读操作都不会加锁，并且在写入操作以及其他一些需要锁的读操作中使用了锁分段技术。因此，多个线程能并发的访问这个 Map 而不会发生阻塞。</p>
<p>图 11-3 给出了几种 Map 实现在可伸缩性上的差异：ConcurrentHashMap、ConcurrentSkipListMap，以及通过 synchronizedMap 来包装的 HashMap 和 TreeMap。前两种 Map 是线程安全的，而后两个 Map 则通过同步封装器来确保线程安全性。每次运行时，将有 N 个线程并发的执行一个紧凑的循环：选择一个随机的键值，并尝试获取与这个键值相对应的值。如果不存在相应的值，那么将这个值增加到 Map 的概率为 p=0.6，如果存在相应的值，那么删除这个值的概率为 p=0.02。这个测试在 8路 Sparc V880 系统上运行，基于 Java 6 环境，并且在图中给出了将 ConcurrentHashMap 归一化为单个线程时的吞吐量。(并发容器与同步容器在可伸缩性上的差异比在 Java 5.0 中更明显)。</p>
<div align=center>
<img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20181118174659.png style=display:block;width:70% alt=11-3 align=center>
</div>
<p>ConcurrentHashMap 和 ConcurrentSkipListMap 的数据显示，它们在线程数量增加时能表现出更好的可伸缩性，并且吞吐量会随着线程的增加而增加。虽然图 11-3 中的线程数量并不大，但与普通的应用程序相比，这个测试程序在每个线程上生成更多的竞争，因为它除了向 Map 施加压力以外几乎没有执行任何其他操作，而实际的应用程序通常会在每次迭代中进行一些线程本地工作。</p>
<p>同步容器的数量并非越多越好。单线程情况下的性能与 ConcurrentHashMap 的性能基本相当，但当负载情况由于非竞争性转变为竞争性时——这里是两个线程，同步容器的性能将变得非常糟糕。在伸缩性收到锁竞争限制的代码中，这种情况很常见。只要竞争程度不高，那么每个操作消耗的时间基本上即使实执行工作的时间，并且吞吐量会因为线程数的增加而增加。当竞争变得激烈时，每个操作消耗的时间大部分都用于上下文切换和调度延迟，而再加入更多的线程也不会提高太多的吞吐量。</p>
<h2 id=116-减少上下文切换的开销>11.6 减少上下文切换的开销</h2>
<p>在许多人物中都包含一些可能被阻塞的操作。当任务在运行和阻塞这连个状态之间转换时，就相当于一次上下文切换。在服务器应用中，发生阻塞的原因之一就是在处理请求时产生各种日志消息。为了说明如何通过减少上下文切换的次数来提高吞吐量，我们将对两种日志方法的调度行为进行分析。</p>
<p>在大多数日志框架中都是简单的对 println 进行包装，但需要记录某个消息时，只需要将其写入日志文件。在第七章中的 LogWriter 中给出了另一种方法：记录日志的工作由一个专门的后台线程完成，而不是由发出请求的线程。从开发人员的角度来看，这两种方法基本上是相同的。但二者在性能上可能存在一些差异，这取决于日志操作的工作量，即有多少线程正在记录日志，以及其他一些因素，例如上下文切换的开销等。</p>
<p>日志操作的服务时间包括与 IO 流类相关的计算时间，如果 IO 操作被阻塞，那么还会包括线程被阻塞的时间。操作系统将这个被阻塞的线程从调度队列中移出并直到 IO 操作结束，这将比实际阻塞的时间更长。当 IO 操作结束时，可能有其他线程正在执行它们的带哦度时间片，并且在调度队列中有些线程位于被阻塞线程之前，从而进一步增加服务时间。如果有多个线程在同时记录日志，那么还可能在输出流上的锁上发生竞争，这种情况的结果与阻塞 IO 的情况一样——线程被阻塞并等待锁，然后被线程调度器调度出去。在这种日志操作中包含了 IO 操作和加锁操作，从而导致上下文切换次数的增多，以及服务时间的增加。</p>
<p>请求服务的时间不应该过长，主要有以下原因。首先，服务时间将影响服务质量：服务时间越长，就意味着有程序在获得结果时需要等待更多的时间。但更重要的是，服务是将越长，也就意味着存在越多的锁竞争。11.4.1 节中的“快进快出”原则告诉我们，锁被持有的时间应该尽可能的短，因为锁的持有时间越长，那么在这个锁上发生竞争的可能性就越大。如果一个线程由于等待 IO 操作完成而被阻塞，同时它还持有一个锁，那么在这期间很可能会有另一个线程想要获得这个锁。如果在大多数的锁获取操作上不存在竞争，那么并发系统就能执行得更好，因为在锁获取操作上发生竞争时将导致更多的上下文切换。在代码中造成的上下文切换次数越多，吞吐量就越低。</p>
<p>通过将 IO 操作从处理请求的线程分离出来，可以缩短处理请求的平均服务时间。调用 log 方法的线程将不会再因为等待输出流的锁或者 IO 完成而被阻塞，它们只需要将消息放入队列，然后就返回到各自的任务中。另一方面，虽然在消息队列上可能发生竞争，但 put 操作相对于记录日志的 IO 操作(可能需要执行系统调用)是一种更为轻量级的操作，因此在实际使用中发生阻塞的概率更小(只要队列未满)。由于发出日志请求的线程现在被阻塞的概率降低，因此该线程在处理请求时被交换出去的概率也会降低。我们所做的工作就是把一条包含 IO 操作和锁竞争的复杂且不确定的代码路径变成一条简单的代码路径。</p>
<p>从某种意义上讲，我们只是将工作分散开来，并将 IO 操作移到了另一个用户感知不到开销的线程上(这本身就已经获得了成功)。通过把所有记录日志的 IO 转移到一个线程，还消除了输出流上的竞争，因去掉了一个竞争来源。这将提升整体的吞吐量，因为在调度中消耗的资源更少，上下文切换次数更少，并且锁的管理也更简单。</p>
<p>通过把 IO 操作从处理请求的线程转移到一个专门的线程，类似于两种不同救火方案之间的差异：第一种方案是所有人排成一队，通过传递水桶来救火；第二种方案是每个人都拿着一个水桶去救火。在第二种方案中，每个人都可能在水源点和着火点上存在很大的竞争(结果导致了只能将更少的水传递到着火点)，此外救火的效率也更低，因为每个人都在不停的切换模式(装水、跑步、倒水、跑步&mldr;)。在第一种方案中，水不断的从水源传递到燃烧的建筑物，人么付出更少的体力却传递了更多的水，并且每个人从头到尾只需要做一项工作。正如中断会干扰人们的工作并降低效率一样，阻塞和上下文切换同样会干扰线程的正常执行。</p>
<h2 id=小结>小结</h2>
<p>由于使用线程常常是为了充分利用多个处理器的计算能力，因此在并发程序性能的讨论中，通常更多的将侧重点放在吞吐量和可伸缩性上，而不是服务时间。Amdahl 定律告诉我们，程序的可伸缩性取决于在所有代码中必须被串行执行的代码的比例。因为 Java 程序中串行执行的主要来源是独占方式的资源锁，因此通常可以通过以下方式来提升伸缩性：减少锁的持有时间、降低锁的粒度、以及采用非独占的锁或者非阻塞锁来代替独占锁。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-6feac954c9d43e334e5b483468c245c4>12 - CH12-测试</h1>
<p>在编写并发程序时，可以采用与串行程序相同的设计原则和设计模式。二者的差异在于，并发程序存在一定程度的不确定性，而在串行程序中不存在这个问题。这种不确定性将增加不同交互模式及故障模式的数量，因此在设计并发程序时必须对这些模式进行分析。</p>
<p>同样，在测试开发程序时，将会使用并扩展很多在测试串行程序时用到的方法。在测试串行程序正确性与性能方面所采用的技术，同样可以用于测试并发程序，但对于并发程序而言，可能出错的地方要远比串行程序多。要在测试中将这些故障暴露出来，就需要比普通的串行程序测试覆盖更广的范围并且执行更长的时间。</p>
<p>并发测试大致分为两类，即安全性测试与活跃性测试。在第一章，我们将安全性定义为“不发生任何错误的行为”，而降活跃性定义为“某个良好的行为终究会发生”。</p>
<p>在进行安全性测试时，通常会采用测试不变性条件的形式，即判断某个类的行为是否与其规范保持一致。例如，假设有一个链表，在它每次被修改时将其大小缓存下来，那其中一项安全性测试就是比较在缓存中保存的大小值与链表中实际元素的数目是否相等。这种测试在单线程程序中很简单，因为在测试时链表的内容不会发生变化。但在并发程序中，这种测试将可能由于竞争而失败，除非能将访问计数器的操作和统计元素数据的操作合并为单个原子操作。要实现这一点，可以对链表加锁以实现独占访问，然后采用链表中提供的某种“原子快照”功能，或者在某些“测试点”上采用原子方式来判断不变性条件或者执行测试代码。</p>
<p>在本书中，我们曾通过执行时序图来说明“错误的”交互操作，这些操作将在未被正确构造的类中导致各种故障，而测试程序将努力在足够大的状态空间中查找这些地方。然而，测试代码同样会对执行时序或同步操作带来影响，这些影响可能会掩盖一些本可以暴露的错误。</p>
<p>测试活跃性本身也存在问题。活跃性测试包括进展测试和无进展测试两个方面，这些都是很难量化的——如何验证某个方法是被阻塞了。而不是运行缓慢？同样，如何测试某个算法不会发生死锁？要等待多久才能宣告发生了故障？</p>
<p>与活跃性测试相关的是性能测试。性能可以通过多个方面来衡量，包括：</p>
<ul>
<li>吞吐量。指一组并发任务中已经成任务所占的比例。</li>
<li>响应性。指请求从发出到完成之间的时间，也称延迟。</li>
<li>可伸缩性。指在增加更多资源的情况下(如 CPU)，吞吐量(或者缓解短缺)的提升情况。</li>
</ul>
<h2 id=121-正确性测试>12.1 正确性测试</h2>
<p>在为某个并发类设计单元测试时，首先需要执行与测试串行代码类时相同的分析——找出需要检查的不变性条件和后验条件，而在剩下的时间里，当编写测试时将不断发现新的规范。</p>
<p>为了进一步说明，接下来我们将构建一组测试用例来测试一个有界缓存。程序清单 12-1 给出了 BoundedBuffer 的实现，其中使用 Semaphore 来实现缓存的有界属性和阻塞行文。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#5c35cc;font-weight:700>@ThreadSafe</span> <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>BoundedBuffer</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>E</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#ce5c00;font-weight:700>{</span>

  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>Semaphore</span> <span style=color:#000>availableItems</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>availableSpaces</span><span style=color:#ce5c00;font-weight:700>;</span> 	
  <span style=color:#5c35cc;font-weight:700>@GuardedBy</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#4e9a06>&#34;this&#34;</span><span style=color:#ce5c00;font-weight:700>)</span> 
  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>E</span><span style=color:#ce5c00;font-weight:700>[]</span> <span style=color:#000>items</span><span style=color:#ce5c00;font-weight:700>;</span> 	
  <span style=color:#5c35cc;font-weight:700>@GuardedBy</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#4e9a06>&#34;this&#34;</span><span style=color:#ce5c00;font-weight:700>)</span> 
  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>putPosition</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>0</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>takePosition</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>0</span><span style=color:#ce5c00;font-weight:700>;</span>

  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#000>BoundedBuffer</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>capacity</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span> 
    <span style=color:#000>availableItems</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>Semaphore</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>0</span><span style=color:#ce5c00;font-weight:700>);</span> 
    <span style=color:#000>availableSpaces</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>Semaphore</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>capacity</span><span style=color:#ce5c00;font-weight:700>);</span> 
    <span style=color:#000>items</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>E</span><span style=color:#ce5c00;font-weight:700>[])</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>Object</span><span style=color:#ce5c00;font-weight:700>[</span><span style=color:#000>capacity</span><span style=color:#ce5c00;font-weight:700>];</span> 
  <span style=color:#ce5c00;font-weight:700>}</span> 
  
  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>boolean</span> <span style=color:#000>isEmpty</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>availableItems</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>availablePermits</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>==</span> <span style=color:#000>0</span><span style=color:#ce5c00;font-weight:700>;</span> 
  <span style=color:#ce5c00;font-weight:700>}</span> 
  
  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>boolean</span> <span style=color:#000>isFull</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>availableSpaces</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>availablePermits</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>==</span> <span style=color:#000>0</span><span style=color:#ce5c00;font-weight:700>;</span> 
  <span style=color:#ce5c00;font-weight:700>}</span>
  
  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>put</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>E</span> <span style=color:#000>x</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#204a87;font-weight:700>throws</span> <span style=color:#000>InterruptedException</span> <span style=color:#ce5c00;font-weight:700>{</span> 
    <span style=color:#000>availableSpaces</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>acquire</span><span style=color:#ce5c00;font-weight:700>();</span> 
    <span style=color:#000>doInsert</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>x</span><span style=color:#ce5c00;font-weight:700>);</span> 
    <span style=color:#000>availableItems</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>release</span><span style=color:#ce5c00;font-weight:700>();</span> 
  <span style=color:#ce5c00;font-weight:700>}</span> 
  
  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#000>E</span> <span style=color:#000>take</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#204a87;font-weight:700>throws</span> <span style=color:#000>InterruptedException</span> <span style=color:#ce5c00;font-weight:700>{</span> 	
    <span style=color:#000>availableItems</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>acquire</span><span style=color:#ce5c00;font-weight:700>();</span> 
    <span style=color:#000>E</span> <span style=color:#000>item</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>doExtract</span><span style=color:#ce5c00;font-weight:700>();</span> 
    <span style=color:#000>availableSpaces</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>release</span><span style=color:#ce5c00;font-weight:700>();</span> 
    <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>item</span><span style=color:#ce5c00;font-weight:700>;</span> 
  <span style=color:#ce5c00;font-weight:700>}</span>

  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>synchronized</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>doInsert</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>E</span> <span style=color:#000>x</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span> 
    <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>i</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>putPosition</span><span style=color:#ce5c00;font-weight:700>;</span> 
    <span style=color:#000>items</span><span style=color:#ce5c00;font-weight:700>[</span><span style=color:#000>i</span><span style=color:#ce5c00;font-weight:700>]</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>x</span><span style=color:#ce5c00;font-weight:700>;</span> 
    <span style=color:#000>putPosition</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#ce5c00;font-weight:700>(++</span><span style=color:#000>i</span> <span style=color:#ce5c00;font-weight:700>==</span> <span style=color:#000>items</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>length</span><span style=color:#ce5c00;font-weight:700>)?</span> <span style=color:#000>0</span> <span style=color:#ce5c00;font-weight:700>:</span> <span style=color:#000>i</span><span style=color:#ce5c00;font-weight:700>;</span> 
  <span style=color:#ce5c00;font-weight:700>}</span> 
  
  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>synchronized</span> <span style=color:#000>E</span> <span style=color:#000>doExtract</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span> 
    <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>i</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>takePosition</span><span style=color:#ce5c00;font-weight:700>;</span> 
    <span style=color:#000>E</span> <span style=color:#000>x</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>items</span><span style=color:#ce5c00;font-weight:700>[</span><span style=color:#000>i</span><span style=color:#ce5c00;font-weight:700>];</span> 
    <span style=color:#000>items</span><span style=color:#ce5c00;font-weight:700>[</span><span style=color:#000>i</span><span style=color:#ce5c00;font-weight:700>]</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>null</span><span style=color:#ce5c00;font-weight:700>;</span> 
    <span style=color:#000>takePosition</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#ce5c00;font-weight:700>(++</span><span style=color:#000>i</span> <span style=color:#ce5c00;font-weight:700>==</span> <span style=color:#000>items</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>length</span><span style=color:#ce5c00;font-weight:700>)?</span> <span style=color:#000>0</span> <span style=color:#ce5c00;font-weight:700>:</span> <span style=color:#000>i</span><span style=color:#ce5c00;font-weight:700>;</span> 
    <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>x</span><span style=color:#ce5c00;font-weight:700>;</span> 
  <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>BoundedBuffer 实现了一个固定长度的队列，其中定义了可阻塞的 put 和 take 方法，并通过两个计数信号量进行控制。信号量 availableItems 表示可以从缓存中删除的元素个数，它的初始值为 0(因为缓存的初始状态为空)。同样，信号量 availableSpaces 表示可以插入到缓存的元素个数，它的初始值等于缓存的大小。</p>
<p>take 操作首先请求从 availableItems 中获得一个许可(Permit)。如果缓存不为空，那么这个请求会立即成功，否则请求将被阻塞直到缓存不再为空。在获得一个许可后，take 方法将删除缓存中的下一个元素，并返回一个许可到 availableSpaces 信号量。put 方法的执行属顺序则刚好相反，因此无论是从 put 方法还是从 take 方法中退出，这两个信号量计数值的和都会等于缓存的大小。(在实际情况中，如果需要一个有界缓存，应该直接使用 ArrayBlockingQueue 或 LinkedBlockingQueue，而不是自己编写，但这里用于说明如何对添加和删除等方法进行控制的技术，在其他数据结构中也同样适用。)</p>
<h3 id=1211-基本的单元测试>12.1.1 基本的单元测试</h3>
<p>BoundedBuffer 的最基本单元测试类似于在串行上下文中执行的测试。首先创建一个有界缓存，然后调用它的各个方法，并验证它的后验条件和不变性条件。我们很快会想到一些不变性条件：新建立的缓存应该是空的，而不是满的。另一个略显复杂的安全测试是，将 N 个元素插入到容量为 N 的缓存中(整个过程应该可以成功且不会阻塞)，然后测试缓存是否已经填满(不为空)。程序清单 12-2 给出了这些属性的 JUnit 测试方法。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>BoundedBufferTest</span> <span style=color:#204a87;font-weight:700>extends</span> <span style=color:#000>TestCase</span> <span style=color:#ce5c00;font-weight:700>{</span>

  <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>testIsEmptyWhenConstructed</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span> 
    <span style=color:#000>BoundedBuffer</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>Integer</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>bb</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>BoundedBuffer</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>Integer</span><span style=color:#ce5c00;font-weight:700>&gt;(</span><span style=color:#000>10</span><span style=color:#ce5c00;font-weight:700>);</span> 
    <span style=color:#000>assertTrue</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>bb</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>isEmpty</span><span style=color:#ce5c00;font-weight:700>());</span> 
    <span style=color:#000>assertFalse</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>bb</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>isFull</span><span style=color:#ce5c00;font-weight:700>());</span> 
  <span style=color:#ce5c00;font-weight:700>}</span>

  <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>testIsFullAfterPuts</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#204a87;font-weight:700>throws</span> <span style=color:#000>InterruptedException</span> <span style=color:#ce5c00;font-weight:700>{</span> 
    <span style=color:#000>BoundedBuffer</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>Integer</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>bb</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>BoundedBuffer</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>Integer</span><span style=color:#ce5c00;font-weight:700>&gt;(</span><span style=color:#000>10</span><span style=color:#ce5c00;font-weight:700>);</span> 
    <span style=color:#204a87;font-weight:700>for</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>i</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>0</span><span style=color:#ce5c00;font-weight:700>;</span> <span style=color:#000>i</span> <span style=color:#ce5c00;font-weight:700>&lt;</span> <span style=color:#000>10</span><span style=color:#ce5c00;font-weight:700>;</span> <span style=color:#000>i</span><span style=color:#ce5c00;font-weight:700>++)</span> 
      <span style=color:#000>bb</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>put</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>i</span><span style=color:#ce5c00;font-weight:700>);</span> 
    <span style=color:#000>assertTrue</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>bb</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>isFull</span><span style=color:#ce5c00;font-weight:700>());</span> 
    <span style=color:#000>assertFalse</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>bb</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>isEmpty</span><span style=color:#ce5c00;font-weight:700>());</span> 
  <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>这些简单的测试方法都是串行的。在测试集中包含一组串行测试通常是有益的，因为他们有助于在开始分析竞争之前就找出与并发性无关的问题。</p>
<h3 id=1212-测试阻塞操作>12.1.2 测试阻塞操作</h3>
<p>在测试并发的基本属性时，需要引入多线程。大多数测试框架并不能很好的支持并发性测试：它们很少会包含相应的工具来创建线程或监视线程，以确保它们不会意外结束。如果在某个测试用例创建的辅助线程中发现了一个错误，那么框架通常无法得知与这个线程相关的是哪一个测试，所以需要通过一些工作将成功或失败信息传递会主测试线程，从而能够将对应的信息报告出来。</p>
<p>在 JUC 的一致性测试中，一定要将故障与特定的测试明确的关联起来。因此 JSR 166 转件组创建了一个基类，其中定义了一些方法可以将 tearDown 期间传递或报告失败信息，并遵循一个约定：每个测试必须等待它所创建的全部线程结束后才能完成。你不需要考虑这么深入，关键的需求在于，能否通过这些测试，以及是否在某个地方报告了失败信息以便于诊断问题。</p>
<p>如果某方法需要在某些特定条件下阻塞，那么当测试这种行为时，只有当线程不再继续执行时，测试才是成功的。要测试一个方法的阻塞行为，类似于测试一个抛出异常的方法：如果这个方法可以正常返回，那么就意味着测试失败。</p>
<p>在测试方法的阻塞行为时，将引入额外的复杂性：当方法被成功的阻塞后，还必须使方法解除阻塞。实现这个功能的一种简单方式是使用中断——在一个单独的线程中启动一个阻塞操作，等到线程阻塞后再中断它，然后宣告阻塞操作成功。当然，这要求阻塞方法通过提前返回或者抛出中断异常来响应中断。</p>
<p>“等待并直到线程阻塞后”这句话说起来简单，做起来难。实际上，你必须估计执行这些指令可能需要多长时间，并且等待的时间会更长。如果估计的时间不准确(在这种情况下，你会看到伪测试失败)，那么应该增大这个值。</p>
<p>程序清单 12-3 给出了一种测试阻塞操作的方法。这种方法会创建一个“获取线程”，该线程将尝试从缓存中获取一个元素。如果 take 方法成功，那么表示测试失败。执行测试的线程启动“获取”线程，等待一段时间，然后中断该线程。如果“获取”线程正确的在 take 方法中阻塞，那么将抛出中断异常，而捕获到该异常的 catch 块将把这个异常视为测试成功，并让线程退出。然后，主测线程会尝试与“获取”线程合并，通过调用 Thread.isAlive 来验证 join 方法是否返回成功，如果“获取”线程可以响应中断，那么 join 能很快完成。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>testTakeBlocksWhenEmpty</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span>
  <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>BoundedBuffer</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>Integer</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>bb</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>BoundedBuffer</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>Integer</span><span style=color:#ce5c00;font-weight:700>&gt;(</span><span style=color:#000>10</span><span style=color:#ce5c00;font-weight:700>);</span> 
  <span style=color:#000>Thread</span> <span style=color:#000>taker</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>Thread</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span> 
    <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>run</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span> 
      <span style=color:#204a87;font-weight:700>try</span> <span style=color:#ce5c00;font-weight:700>{</span> 
        <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>unused</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>bb</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>take</span><span style=color:#ce5c00;font-weight:700>();</span> 
        <span style=color:#000>fail</span><span style=color:#ce5c00;font-weight:700>();</span> <span style=color:#8f5902;font-style:italic>// if we get here, it&#39;s an error 
</span><span style=color:#8f5902;font-style:italic></span>      <span style=color:#ce5c00;font-weight:700>}</span> <span style=color:#204a87;font-weight:700>catch</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>InterruptedException</span> <span style=color:#000>success</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span> <span style=color:#ce5c00;font-weight:700>}</span> 
    <span style=color:#ce5c00;font-weight:700>}</span>
  <span style=color:#ce5c00;font-weight:700>};</span> 
  
  <span style=color:#204a87;font-weight:700>try</span> <span style=color:#ce5c00;font-weight:700>{</span> 
    <span style=color:#000>taker</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>start</span><span style=color:#ce5c00;font-weight:700>();</span> 
    <span style=color:#000>Thread</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>sleep</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>LOCKUP_DETECT_TIMEOUT</span><span style=color:#ce5c00;font-weight:700>);</span> 
    <span style=color:#000>taker</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>interrupt</span><span style=color:#ce5c00;font-weight:700>();</span> 
    <span style=color:#000>taker</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>join</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>LOCKUP_DETECT_TIMEOUT</span><span style=color:#ce5c00;font-weight:700>);</span> 
    <span style=color:#000>assertFalse</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>taker</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>isAlive</span><span style=color:#ce5c00;font-weight:700>());</span> 
  <span style=color:#ce5c00;font-weight:700>}</span> <span style=color:#204a87;font-weight:700>catch</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>Exception</span> <span style=color:#000>unexpected</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span> 
    <span style=color:#000>fail</span><span style=color:#ce5c00;font-weight:700>();</span> 
  <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>如果 take 操作由于某种意料之外的原因停滞了，那么支持限时的 join 方法能确保测试最终完成。该测试验证了 take 方法的多种属性——不仅能阻塞，而且在中断后还能抛出中断异常。在这种情况下，最好是对 Thread 进行子类化而不是使用线程池中的 Runnable，即通过 join 来正确的结束测试。当主线程将一个元素放入队列后，“获取”线程应该解除阻塞状态，要测试这种行为，可以使用相同的方法。</p>
<p>开发人员会尝试使用 Thread.getState 来验证线程能否在一个条件等待上阻塞，但这种方法并不可靠。被阻塞线程并不需要进入 WAITING 或 TIMED_WAITING 等状态，因此 JVM 可以选择通过自旋锁等待来实现阻塞。类似的，由于在 Object.wait 或 Condition.await 等方法上存在伪唤醒，因此，即使一个线程等待的条件尚未成真，也可能从 WAITING 或 TIMED_WAITING 等待状态临时性的转换到 RUNNABLE 状态。即使忽略这些不同实现之间的差异，目标线程在进入阻塞状态时也会消耗一定的时间。Thread.getState 的返回结果不能用于并发控制，它将限制测试的有效性——其主要的作用要是作为调试信息。</p>
<h3 id=1213-安全性测试>12.1.3 安全性测试</h3>
<p>程序清单 12-2、12-3 的测试用例验证了有界缓存的一些重要属性，但它们却无法发现由于数据竞争而引发的错误。要想测试一个并发类在不可预测的并发访问情况下能否正确执行，需要创建多个线程来分别执行 put 和 take 操作，并在执行一段时间后判断在测试中是否会出现问题。</p>
<p>如果要构造一些测试来发现并发类中的安全性错误，那么这实际上是一个“先有蛋还是先有鸡”的问题：测试程序自身就是并发程序。要开发一个良好的并发测试程序，或许比开发这些要被测试的类更加困难。</p>
<blockquote>
<p>在构建对并发类的安全性测试中，需要解决的关键问题在于，要找出那些容易检查的属性，这些属性在发生错误的情况下极有可能失败，同时又不会使得错误检查代码认为的限制并发性。理想的情况是，在测试属性中不需要任何同步机制。</p>
</blockquote>
<p>要测试在生产消费模式中使用的类，一种有效的方法就是检查被放入队列中的、和从队列中取出的各个元素。这种方法的一种简单实现是，当元素被插入到队列时，同时将其插入到一个“影子”列表，当从队列中删除该元素时，同时也从“影子”列表中删除，然后在测试程序运行完成以后判断“影子”列表是否为空。然而，这种方法可能会干扰测试线程的调度，因为在修改“影子”列表时需要同步，并可能会阻塞。</p>
<p>一种更好的方法是，通过一个对顺序敏感的校验和计算函数来计算所有入列元素以及出列元素的校验和，并进行比较。如果二者相等，那么测试就是成功的。如果只有一个生产者将元素放入缓存，同时也只有一个消费者从中取出元素，那么这种方法能发挥最大的作用，因为它不仅能测试出是否取出了正确的元素，而且还能测试出元素被取出的顺序是否正确。</p>
<p>如果要将这种方法扩展到多生产者——多消费者的情况，就需要一个对元素的入列、出列顺序不敏感的校验和函数，从而在测试程序运行完成以后，可以将多个校验和以不同的顺序组合起来。如果不是这样，多个线程就需要访问同一个共享的校验和变量，因此就需要同步，这将成为一个并发瓶颈或者破坏被测代码的执行时序。(任何具备可交换性的操作，例如加法或 XOR，都符合这些需求)。</p>
<p>要确保测试程序正确的测试所有要点，就一定不能让编译器可以预先猜到校验和的值。使用连续的整数作为测试数据并不是一个好办法，因为得到的结果是相同的，而一个智能的编译器通常可以预先计算出这个结果。</p>
<p>要避免这种问题，应该采用随机方式生成的测试数据，但如果选择了一种不合适的随机数生成器，那么会对许多其他的测试造成影响。由于大多数随机数生成器都是线程安全的，并且会代码额外的同步开销，因此在随机数生成过程中，可能会在这些类与执行时序之间产生耦合关系。如果每个线程都拥有各自的生成器，那么生成器就无需在意线程安全性。</p>
<p>与其使用一个通用的随机数生成器，还不如使用一些简单的伪随机函数。你并不需要某种高质量的随机性，而只需要确保在不同的测试运行中都有不同的数字。在程序清单 12-4 的 xorShift 函数是最符合这个需求的随机函数之一。该函数基于 hashCode 和 nanoTime 来生成随机数，所得的结果是不可预测的，而且基本上每次运行都会不同。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#204a87;font-weight:700>static</span> <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>xorShift</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>y</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span> 
  <span style=color:#000>y</span> <span style=color:#ce5c00;font-weight:700>^=</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>y</span> <span style=color:#ce5c00;font-weight:700>&lt;&lt;</span> <span style=color:#000>6</span><span style=color:#ce5c00;font-weight:700>);</span> 
  <span style=color:#000>y</span> <span style=color:#ce5c00;font-weight:700>^=</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>y</span> <span style=color:#ce5c00;font-weight:700>&gt;&gt;&gt;</span> <span style=color:#000>21</span><span style=color:#ce5c00;font-weight:700>);</span> 
  <span style=color:#000>y</span> <span style=color:#ce5c00;font-weight:700>^=</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>y</span> <span style=color:#ce5c00;font-weight:700>&lt;&lt;</span> <span style=color:#000>7</span><span style=color:#ce5c00;font-weight:700>);</span> 
  <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>y</span><span style=color:#ce5c00;font-weight:700>;</span> 
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>在程序清单 12-5 和程序清单 12-6 的 PutTakeTest 中启动了 N 个生产者线程来生成元素并把它们插入到队列，同时还启动了 N 个消费者线程从队列中取出元素。当元素进出队列时，每个线程都会更新对这些元素计算得到的校验和，每个线程都拥有一个校验和，并在测试结束后将它们合并，从而在测试缓存时就不会引入过多的同步或竞争。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>PutTakeTest</span> <span style=color:#ce5c00;font-weight:700>{</span>

  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>static</span> <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>ExecutorService</span> <span style=color:#000>pool</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>Executors</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>newCachedThreadPool</span><span style=color:#ce5c00;font-weight:700>();</span> 
  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>AtomicInteger</span> <span style=color:#000>putSum</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>AtomicInteger</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>0</span><span style=color:#ce5c00;font-weight:700>);</span> 	
  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>AtomicInteger</span> <span style=color:#000>takeSum</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>AtomicInteger</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>0</span><span style=color:#ce5c00;font-weight:700>);</span> 
  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>CyclicBarrier</span> <span style=color:#000>barrier</span><span style=color:#ce5c00;font-weight:700>;</span> 
  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>BoundedBuffer</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>Integer</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>bb</span><span style=color:#ce5c00;font-weight:700>;</span> 
  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>final</span> <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>nTrials</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>nPairs</span><span style=color:#ce5c00;font-weight:700>;</span>

  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>static</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>main</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>String</span><span style=color:#ce5c00;font-weight:700>[]</span> <span style=color:#000>args</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span> 
    <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>PutTakeTest</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>10</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>10</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>100000</span><span style=color:#ce5c00;font-weight:700>).</span><span style=color:#c4a000>test</span><span style=color:#ce5c00;font-weight:700>();</span> <span style=color:#8f5902;font-style:italic>// sample parameters 
</span><span style=color:#8f5902;font-style:italic></span>    <span style=color:#000>pool</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>shutdown</span><span style=color:#ce5c00;font-weight:700>();</span> 
  <span style=color:#ce5c00;font-weight:700>}</span>

  <span style=color:#000>PutTakeTest</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>capacity</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>npairs</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>ntrials</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span> 
    <span style=color:#204a87;font-weight:700>this</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>bb</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>BoundedBuffer</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>Integer</span><span style=color:#ce5c00;font-weight:700>&gt;(</span><span style=color:#000>capacity</span><span style=color:#ce5c00;font-weight:700>);</span> 
    <span style=color:#204a87;font-weight:700>this</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>nTrials</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>ntrials</span><span style=color:#ce5c00;font-weight:700>;</span> <span style=color:#204a87;font-weight:700>this</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>nPairs</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>npairs</span><span style=color:#ce5c00;font-weight:700>;</span> 
    <span style=color:#204a87;font-weight:700>this</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>barrier</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>CyclicBarrier</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>npairs</span><span style=color:#ce5c00;font-weight:700>*</span> <span style=color:#000>2</span> <span style=color:#ce5c00;font-weight:700>+</span> <span style=color:#000>1</span><span style=color:#ce5c00;font-weight:700>);</span> 
  <span style=color:#ce5c00;font-weight:700>}</span>

  <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>test</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#204a87;font-weight:700>try</span> <span style=color:#ce5c00;font-weight:700>{</span> 
      <span style=color:#204a87;font-weight:700>for</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>i</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>0</span><span style=color:#ce5c00;font-weight:700>;</span> <span style=color:#000>i</span> <span style=color:#ce5c00;font-weight:700>&lt;</span> <span style=color:#000>nPairs</span><span style=color:#ce5c00;font-weight:700>;</span> <span style=color:#000>i</span><span style=color:#ce5c00;font-weight:700>++)</span> <span style=color:#ce5c00;font-weight:700>{</span> 
        <span style=color:#000>pool</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>execute</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>Producer</span><span style=color:#ce5c00;font-weight:700>());</span> 
        <span style=color:#000>pool</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>execute</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>Consumer</span><span style=color:#ce5c00;font-weight:700>());</span> 
      <span style=color:#ce5c00;font-weight:700>}</span> 
      <span style=color:#000>barrier</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>await</span><span style=color:#ce5c00;font-weight:700>();</span> <span style=color:#8f5902;font-style:italic>// wait for all threads to be ready 
</span><span style=color:#8f5902;font-style:italic></span>      <span style=color:#000>barrier</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>await</span><span style=color:#ce5c00;font-weight:700>();</span> <span style=color:#8f5902;font-style:italic>// wait for all threads to finish 
</span><span style=color:#8f5902;font-style:italic></span>      <span style=color:#000>assertEquals</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>putSum</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>get</span><span style=color:#ce5c00;font-weight:700>(),</span> <span style=color:#000>takeSum</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>get</span><span style=color:#ce5c00;font-weight:700>());</span> 
    <span style=color:#ce5c00;font-weight:700>}</span> <span style=color:#204a87;font-weight:700>catch</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>Exception</span> <span style=color:#000>e</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span> 
      <span style=color:#204a87;font-weight:700>throw</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>RuntimeException</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>e</span><span style=color:#ce5c00;font-weight:700>);</span> 
    <span style=color:#ce5c00;font-weight:700>}</span>
  <span style=color:#ce5c00;font-weight:700>}</span>

  <span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>Producer</span> <span style=color:#204a87;font-weight:700>implements</span> <span style=color:#000>Runnable</span> <span style=color:#ce5c00;font-weight:700>{</span> <span style=color:#8f5902;font-style:italic>/* Listing 12.6*/</span> <span style=color:#ce5c00;font-weight:700>}</span>

  <span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>Consumer</span> <span style=color:#204a87;font-weight:700>implements</span> <span style=color:#000>Runnable</span> <span style=color:#ce5c00;font-weight:700>{</span> <span style=color:#8f5902;font-style:italic>/* Listing 12.6 */</span> <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#8f5902;font-style:italic>/* inner classes of PutTakeTest (Listing 12.5) */</span>
<span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>Producer</span> <span style=color:#204a87;font-weight:700>implements</span> <span style=color:#000>Runnable</span> <span style=color:#ce5c00;font-weight:700>{</span>

  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>run</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span> 
    <span style=color:#204a87;font-weight:700>try</span> <span style=color:#ce5c00;font-weight:700>{</span> 
      <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>seed</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>this</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>hashCode</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>^</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>int</span><span style=color:#ce5c00;font-weight:700>)</span><span style=color:#000>System</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>nanoTime</span><span style=color:#ce5c00;font-weight:700>());</span> 
      <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>sum</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>0</span><span style=color:#ce5c00;font-weight:700>;</span> 
      <span style=color:#000>barrier</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>await</span><span style=color:#ce5c00;font-weight:700>();</span> 
      <span style=color:#204a87;font-weight:700>for</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>i</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>nTrials</span><span style=color:#ce5c00;font-weight:700>;</span> <span style=color:#000>i</span> <span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>0</span><span style=color:#ce5c00;font-weight:700>;</span> <span style=color:#ce5c00;font-weight:700>--</span><span style=color:#000>i</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span> 
        <span style=color:#000>bb</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>put</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>seed</span><span style=color:#ce5c00;font-weight:700>);</span> 
        <span style=color:#000>sum</span> <span style=color:#ce5c00;font-weight:700>+=</span> <span style=color:#000>seed</span><span style=color:#ce5c00;font-weight:700>;</span> 
        <span style=color:#000>seed</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>xorShift</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>seed</span><span style=color:#ce5c00;font-weight:700>);</span> 
      <span style=color:#ce5c00;font-weight:700>}</span> 
      <span style=color:#000>putSum</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>getAndAdd</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>sum</span><span style=color:#ce5c00;font-weight:700>);</span> 
      <span style=color:#000>barrier</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>await</span><span style=color:#ce5c00;font-weight:700>();</span> 
    <span style=color:#ce5c00;font-weight:700>}</span> <span style=color:#204a87;font-weight:700>catch</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>Exception</span> <span style=color:#000>e</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span> 
      <span style=color:#204a87;font-weight:700>throw</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>RuntimeException</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>e</span><span style=color:#ce5c00;font-weight:700>);</span> 
    <span style=color:#ce5c00;font-weight:700>}</span>
  <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#ce5c00;font-weight:700>}</span>

<span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>Consumer</span> <span style=color:#204a87;font-weight:700>implements</span> <span style=color:#000>Runnable</span> <span style=color:#ce5c00;font-weight:700>{</span>

  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>run</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span> 
    <span style=color:#204a87;font-weight:700>try</span> <span style=color:#ce5c00;font-weight:700>{</span> 
      <span style=color:#000>barrier</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>await</span><span style=color:#ce5c00;font-weight:700>();</span> 
      <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>sum</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>0</span><span style=color:#ce5c00;font-weight:700>;</span> 
      <span style=color:#204a87;font-weight:700>for</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>i</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>nTrials</span><span style=color:#ce5c00;font-weight:700>;</span> <span style=color:#000>i</span> <span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>0</span><span style=color:#ce5c00;font-weight:700>;</span> <span style=color:#ce5c00;font-weight:700>--</span><span style=color:#000>i</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span> 
        <span style=color:#000>sum</span> <span style=color:#ce5c00;font-weight:700>+=</span> <span style=color:#000>bb</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>take</span><span style=color:#ce5c00;font-weight:700>();</span> 
      <span style=color:#ce5c00;font-weight:700>}</span> 
      <span style=color:#000>takeSum</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>getAndAdd</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>sum</span><span style=color:#ce5c00;font-weight:700>);</span> 
      <span style=color:#000>barrier</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>await</span><span style=color:#ce5c00;font-weight:700>();</span> 
    <span style=color:#ce5c00;font-weight:700>}</span> <span style=color:#204a87;font-weight:700>catch</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>Exception</span> <span style=color:#000>e</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span> 
      <span style=color:#204a87;font-weight:700>throw</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>RuntimeException</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>e</span><span style=color:#ce5c00;font-weight:700>);</span> 
    <span style=color:#ce5c00;font-weight:700>}</span>
  <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>根据系统平台的不同，创建线程与启动线程等操作可能需要较大的开销。如果线程的执行时间很短，并且在循环中启动了大量的这种线程，那么最坏的情况就是，这些线程将会串行执行而不是并发执行。即使在一些不太糟糕的情况下，第一个线程仍然比其他线程具有“领先优势”。因此这可能无法获得预想预想中的交替执行：第一个线程先运行一段时间，然后前两个线程会并发的执行一段时间，只有到了最后，所有线程才会一起并发执行。(在线程结束运行时也存在同样的问题：首先启动的线程将提前完成)。</p>
<p>在 5.5.1 中接收了一项可以缓解该问题的技术，即使用两个 CountDownLatch，一个作为开始阀门，一个作为结束阀门。使用 CyclicBarrier 也可以获得同样的效果：在初始化 CyclicBarrier 时将计数值指定为工作者线程的数量再加 1，并在运行开始和结束时，使工作者线程和测试线程都在这个栅栏处等待。这能确保所有线程在开始执行任何工作之前，都首先执行到同一个位置。PutTakeTest 使用这项技术来协调工作者现货出呢个的启动和停止，从而产生更多的并发交替操作。我们仍然无法确保调度器不会采用串行方式来执行每个线程，但只要这些线程的执行时间足够长，就能降低调度机制对结果的不利影响。</p>
<p>PutTakeTest 使用了一个确定性的结束条件，从而在判断测试何时完成时就不需要在线程之间执行额外的协调。test 方法将启动相同数量的生产者和消费者线程，它们将分别插入和取出相同数量的元素，因此添加和删除的总数相同。</p>
<p>想 PutTakeTest 这种测试能很好的发现安全性问题。例如，在实现由限号量控制的缓存时，一个常见的错误就是在执行插入和取出的代码中忘记实现互斥行为(可以使用 synchronized 或 ReentrantLock)。如果在 PutTakeTest 使用的 BoundedBuffer 中忘记将 doInsert 和 doExtract 声明为 synchronized，那么在运行 PutTakeTest 时就会立即失败。通过多个线程来运行 PutTakeTest，并且使这些线程在不同系统上的不同容量的缓存上迭代数百万次，是我们能进一步确定在 put 和 take 方法中不存在数据破坏问题。</p>
<blockquote>
<p>这些测试应该放在多处理器系统上运行，从而进一步测试更多形式的交替运行。然而，CPU 的数量越多并不一定会使测试更加高效。要最大程度的检测出一些对执行时序敏感的数据竞争，那么测试中的线程数量应该多于 CPU 数量，这样在任意时刻都会有一些线程在运行，而另一些被交换出去，从而可以检查线程间交替行为的可测试性。</p>
</blockquote>
<p>有一些测试中通常要求执行完一定数量的操作后才能停止运行，如果在测试代码中出现了一个错误并抛出了一个异常，那么这个测试将永远不会停止。最常见的解决方法是：让测试框架放弃那个没有在规定时间内完成的测试，具体要等待多长时间，则要凭借经验来确定，并且要对故障进行分析以确保所出现的问题并不是由于没有等待足够的时长而造成的。(这个问题并不仅限于对并发类的测试，在串行测试中也必须区分长时间的运行和死循环)。</p>
<h3 id=1214-资源管理测试>12.1.4 资源管理测试</h3>
<p>到目前为止，所有的测试都侧重于类与其设计规范的一致程度——在类中应该实现规范中定义的功能。测试的另一个方面就是要判断类中是否没有做它应该做的事情，例如资源泄露。对于任何持有或管理其他对象的对象，都应该在不需要这些对象时销毁对它们的引用。这种存储资源泄露不仅会妨碍垃圾回收期回收内存(或者线程、文件句柄、套接字、数据库连接或其他有限资源)，而且还会导致资源耗尽甚至应用程序失败。</p>
<p>对于像 BoundedBuffer 这样的类来说，资源管理的问题尤为重要。之所以有限制缓存的带下，其原因就是要防止由于资源耗尽而导致应用程序发生故障，例如生产者的速度远远高于消费者的处理速度。通过对缓存进行限制，将使得生产力过剩的生产者被阻塞，因为它们就不会继续创建更多的工作来消耗越来越多的内存以及其他资源。</p>
<p>通过一些测量应用程序中内存使用情况的堆检查工具，可以很容易的测试出对内存的不合理占用，许多商业和开源的堆分析工具都支持这种功能。在程序清单 12-7 的 testLeak 方法中包含了一些堆分析工具用于抓取堆的快照，这将强制执行一次垃圾回收，然后记录堆大小和内存用量的信息。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>Big</span> <span style=color:#ce5c00;font-weight:700>{</span> 
  <span style=color:#204a87;font-weight:700>double</span><span style=color:#ce5c00;font-weight:700>[]</span> <span style=color:#000>data</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#204a87;font-weight:700>double</span><span style=color:#ce5c00;font-weight:700>[</span><span style=color:#000>100000</span><span style=color:#ce5c00;font-weight:700>];</span> 
<span style=color:#ce5c00;font-weight:700>}</span>

<span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>testLeak</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#204a87;font-weight:700>throws</span> <span style=color:#000>InterruptedException</span> <span style=color:#ce5c00;font-weight:700>{</span> 
  <span style=color:#000>BoundedBuffer</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>Big</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>bb</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>BoundedBuffer</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>Big</span><span style=color:#ce5c00;font-weight:700>&gt;(</span><span style=color:#000>CAPACITY</span><span style=color:#ce5c00;font-weight:700>);</span> 
  <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>heapSize1</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#8f5902;font-style:italic>/* snapshot heap */</span> <span style=color:#ce5c00;font-weight:700>;</span> 
  <span style=color:#204a87;font-weight:700>for</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>i</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>0</span><span style=color:#ce5c00;font-weight:700>;</span> <span style=color:#000>i</span> <span style=color:#ce5c00;font-weight:700>&lt;</span> <span style=color:#000>CAPACITY</span><span style=color:#ce5c00;font-weight:700>;</span> <span style=color:#000>i</span><span style=color:#ce5c00;font-weight:700>++)</span> 
    <span style=color:#000>bb</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>put</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>Big</span><span style=color:#ce5c00;font-weight:700>());</span> 
  <span style=color:#204a87;font-weight:700>for</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>i</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>0</span><span style=color:#ce5c00;font-weight:700>;</span> <span style=color:#000>i</span> <span style=color:#ce5c00;font-weight:700>&lt;</span> <span style=color:#000>CAPACITY</span><span style=color:#ce5c00;font-weight:700>;</span> <span style=color:#000>i</span><span style=color:#ce5c00;font-weight:700>++)</span> 
    <span style=color:#000>bb</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>take</span><span style=color:#ce5c00;font-weight:700>();</span> 
  <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>heapSize2</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#8f5902;font-style:italic>/* snapshot heap */</span> <span style=color:#ce5c00;font-weight:700>;</span> 
  <span style=color:#000>assertTrue</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>Math</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>abs</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>heapSize1</span><span style=color:#ce5c00;font-weight:700>-</span><span style=color:#000>heapSize2</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>&lt;</span> <span style=color:#000>THRESHOLD</span><span style=color:#ce5c00;font-weight:700>);</span> 
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>testLeak 方法将多个大型对象插入到一个有界缓存中，然后再将他们移除。第二个堆快照中的内存用量应该与第一个堆快照中的内存用量基本相同。然而，doExtract 如果忘记将返回元素的引用置为空(<code>intems[i]=null</code>)，那么在两次快中中报告的内存用量将明显不同。(这是为数不多的集中需要显式的将变量置空的情况之一。在大多数情况下，这种做法不仅不会带来帮助，甚至还会带来负面作用)。</p>
<h3 id=1215-使用回调>12.1.5 使用回调</h3>
<p>在构造测试案例时，对客户提供的代码进行回调是非常有帮助的。回调函数的执行通常是在对象生命周期的一些已知位置上，并且在这些位置上非常适合判断不变性条件是否被破坏。例如，在 ThreadPoolExecutor 中将调用任务的 Runnable 和 ThreadFactory。</p>
<p>在测试线程池时，需要测试执行策略的多个方面：在需要更多的线程时创建新线程，在不需要时不创建，以及当需要回收空闲线程时执行回收操作等。要构造一个全面的测试方案是很困难的，但其中许多方面的测试都可以单独进行。</p>
<p>通过使用自定义的线程工厂，可以对线程的创建过程进行控制。在程序清单 12-8 的 TestingThreadFactory 中将记录已创建的线程数量。这样，在测试过程中，测试方案可以验证已创建线程的数量。我们还可以对 TestingThreadFactory 进行扩展，使其返回一个自定义的 Thread，并且该对象可以记录自己在何时结束，从而在测试方案中验证线程在被回收时是否与执行策略一致。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>TestingThreadFactory</span> <span style=color:#204a87;font-weight:700>implements</span> <span style=color:#000>ThreadFactory</span> <span style=color:#ce5c00;font-weight:700>{</span>

  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>AtomicInteger</span> <span style=color:#000>numCreated</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>AtomicInteger</span><span style=color:#ce5c00;font-weight:700>();</span>
  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>ThreadFactory</span> <span style=color:#000>factory</span> <span style=color:#ce5c00;font-weight:700>=</span> 
    <span style=color:#000>Executors</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>defaultThreadFactory</span><span style=color:#ce5c00;font-weight:700>();</span>

  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#000>Thread</span> <span style=color:#000>newThread</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>Runnable</span> <span style=color:#000>r</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span> 	
    <span style=color:#000>numCreated</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>incrementAndGet</span><span style=color:#ce5c00;font-weight:700>();</span> 
    <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>factory</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>newThread</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>r</span><span style=color:#ce5c00;font-weight:700>);</span> 
  <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>如果线程池的基本大小小于最大值，那么线程池会根据执行需求做对应的增长。当把一些运行时间较长的任务提交给线程池时，线程池中的任务数量在长时间内都不会变化，这就可以进行一些判断，例如测试线程池是否能按照预期的方式扩展，如程序清单 12-9 所示。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>testPoolExpansion</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#204a87;font-weight:700>throws</span> <span style=color:#000>InterruptedException</span> <span style=color:#ce5c00;font-weight:700>{</span>

  <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>MAX_SIZE</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>10</span><span style=color:#ce5c00;font-weight:700>;</span> 
  <span style=color:#000>ExecutorService</span> <span style=color:#000>exec</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>Executors</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>newFixedThreadPool</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>MAX_SIZE</span><span style=color:#ce5c00;font-weight:700>);</span>

  <span style=color:#204a87;font-weight:700>for</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>i</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>0</span><span style=color:#ce5c00;font-weight:700>;</span> <span style=color:#000>i</span> <span style=color:#ce5c00;font-weight:700>&lt;</span> <span style=color:#000>10</span><span style=color:#ce5c00;font-weight:700>*</span> <span style=color:#000>MAX_SIZE</span><span style=color:#ce5c00;font-weight:700>;</span> <span style=color:#000>i</span><span style=color:#ce5c00;font-weight:700>++)</span> 
    <span style=color:#000>exec</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>execute</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>Runnable</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span> 
      <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>run</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span> 
        <span style=color:#204a87;font-weight:700>try</span> <span style=color:#ce5c00;font-weight:700>{</span> 
          <span style=color:#000>Thread</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>sleep</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>Long</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>MAX_VALUE</span><span style=color:#ce5c00;font-weight:700>);</span> 
        <span style=color:#ce5c00;font-weight:700>}</span> <span style=color:#204a87;font-weight:700>catch</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>InterruptedException</span> <span style=color:#000>e</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span> 
          <span style=color:#000>Thread</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>currentThread</span><span style=color:#ce5c00;font-weight:700>().</span><span style=color:#c4a000>interrupt</span><span style=color:#ce5c00;font-weight:700>();</span> 
        <span style=color:#ce5c00;font-weight:700>}</span>
      <span style=color:#ce5c00;font-weight:700>}</span>
    <span style=color:#ce5c00;font-weight:700>});</span> 
    
  <span style=color:#204a87;font-weight:700>for</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>i</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>0</span><span style=color:#ce5c00;font-weight:700>;</span><span style=color:#000>i</span> <span style=color:#ce5c00;font-weight:700>&lt;</span> <span style=color:#000>20</span> <span style=color:#ce5c00;font-weight:700>&amp;&amp;</span> <span style=color:#000>threadFactory</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>numCreated</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>get</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>&lt;</span> <span style=color:#000>MAX_SIZE</span><span style=color:#ce5c00;font-weight:700>;</span><span style=color:#000>i</span><span style=color:#ce5c00;font-weight:700>++)</span>
    <span style=color:#000>Thread</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>sleep</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>100</span><span style=color:#ce5c00;font-weight:700>);</span> 
    
  <span style=color:#000>assertEquals</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>threadFactory</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>numCreated</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>get</span><span style=color:#ce5c00;font-weight:700>(),</span> <span style=color:#000>MAX_SIZE</span><span style=color:#ce5c00;font-weight:700>);</span> 
  <span style=color:#000>exec</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>shutdownNow</span><span style=color:#ce5c00;font-weight:700>();</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><h3 id=1216-产生更多的交替操作>12.1.6 产生更多的交替操作</h3>
<p>由于并发代码中的大多数错误都是一些低概率事件，因此在测试并发错误时需要反复的执行多次，但有些方法可以提高发现这些错误的概率。在前面提高过，在多处理器系统上，如果处理器数量少于活动线程的数量，那么与单处理器系统或者包含多处理器的系统相比，将能产生更多的交替行为。同样，如果在不同的处理器数量、操作系统以及处理器架构的系统上进行测试，就可以发现那些在特定运行环境中才会出现的问题。</p>
<p>有一种有用的方法可以提高交替操作的数量，以便能够更有效的探索程序的状态空间：在访问共享状态的操作中，使用 Thread.yield 将产生更多的上下文切换。(该方法的有效性与具体的平台有关，因为 JVM 可以将 Thread.yield 实现为一个空操作。如果使用一个睡眠时间较短的 sleep，那么虽然更慢，但却更可靠)。程序清单 12-10 中的方法在两个账户之间执行转账操作，在两次更新操作之间，像“所有账户的总和应等于零”这样的一些不变性条件可能会被破坏。当代码在访问状态时没有使用足够的同步，将存在一些对执行时序敏感的错误，通过在某个操作的执行过程中调用 yield 方法，可以将这些错误暴露出来。这种方法需要在测试中添加一些调用并且在正式产品中删除这些调用，这将给开发人员带来不便，通过使用面向切面编程(AOP)工具，可以降低这种不便性。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>synchronized</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>transferCredits</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>Account</span> <span style=color:#000>from</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>Account</span> <span style=color:#000>to</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>amount</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
  <span style=color:#000>from</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>setBalance</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>from</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>getBalance</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>-</span> <span style=color:#000>amount</span><span style=color:#ce5c00;font-weight:700>);</span>
  <span style=color:#204a87;font-weight:700>if</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>random</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>nextInt</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>1000</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>THRESHOLD</span><span style=color:#ce5c00;font-weight:700>)</span>
    <span style=color:#000>Thread</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>yield</span><span style=color:#ce5c00;font-weight:700>();</span>
  <span style=color:#000>to</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>setBalance</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>to</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>getBalance</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>+</span> <span style=color:#000>amount</span><span style=color:#ce5c00;font-weight:700>);</span> 
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><h2 id=122-性能测试>12.2 性能测试</h2>
<p>性能测试通常是功能测试的延伸。事实上，在性能测试中应该包含一些基本的功能测试，从而确保不会对错误代码进行性能测试。</p>
<p>虽然在性能测试与功能测试之间肯定会存在重叠之处，但它们的目标是不同的。性能测试将衡量典型测试用例中的端到端性能。通常，要活的一组合理的使用场景并不容易，理想情况下，在测试中应该反映出被测试对象在应用程序中的实际用法。</p>
<p>在某些情况下，也存在某种显而易见的测试场景。在生产者-消费者设计中通常都会用到有界缓存，因此显然需要测试生产者向消费者提供数据时的吞吐量。对 PutTakeTest 进行扩展，使其成对针对该应用场景的性能测试。</p>
<p>性能测试的第二个目标是根据经验值来调整各个不同的限值，比如线程数量、缓存容量等。这些限值可能依赖具体平台的特性(如处理器类型、处理器的步进级别、CPU 数量、内存大小等)，因此需要进行动态的配置，而我们通常需要合理的选择这些值，从而使程序能够在更多的系统上良好的运行。</p>
<h3 id=1221-在-puttaketest-中增加计时功能>12.2.1 在 PutTakeTest 中增加计时功能</h3>
<p>之前对 PutTakeTest 的主要扩展计时测量运行一次需要的时间。现在，我们不测量单个操作的时间，而是实现一种更精确的测量方式：记录整个运行过程的时间，然后除以总操作的次数，从而得到每次操作的运行时间。之前使用了 CyclicBarrier 来启动和结束工作者线程，因此可以对其进行扩展：使用一个栅栏动作来测量启动和技术时间，如程序清单 12-11 所示。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#204a87;font-weight:700>this</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>timer</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>BarrierTimer</span><span style=color:#ce5c00;font-weight:700>();</span> 
<span style=color:#204a87;font-weight:700>this</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>barrier</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>CyclicBarrier</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>npairs</span> <span style=color:#ce5c00;font-weight:700>*</span> <span style=color:#000>2</span> <span style=color:#ce5c00;font-weight:700>+</span> <span style=color:#000>1</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>timer</span><span style=color:#ce5c00;font-weight:700>);</span> 

<span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>BarrierTimer</span> <span style=color:#204a87;font-weight:700>implements</span> <span style=color:#000>Runnable</span> <span style=color:#ce5c00;font-weight:700>{</span>
  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>boolean</span> <span style=color:#000>started</span><span style=color:#ce5c00;font-weight:700>;</span> <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>long</span> <span style=color:#000>startTime</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>endTime</span><span style=color:#ce5c00;font-weight:700>;</span>

  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>synchronized</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>run</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span> 
    <span style=color:#204a87;font-weight:700>long</span> <span style=color:#000>t</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>System</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>nanoTime</span><span style=color:#ce5c00;font-weight:700>();</span> 
    <span style=color:#204a87;font-weight:700>if</span> <span style=color:#ce5c00;font-weight:700>(!</span><span style=color:#000>started</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span> 
      <span style=color:#000>started</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>true</span><span style=color:#ce5c00;font-weight:700>;</span> 
      <span style=color:#000>startTime</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>t</span><span style=color:#ce5c00;font-weight:700>;</span> 
    <span style=color:#ce5c00;font-weight:700>}</span> 
    <span style=color:#204a87;font-weight:700>else</span> <span style=color:#000>endTime</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>t</span><span style=color:#ce5c00;font-weight:700>;</span> 
  <span style=color:#ce5c00;font-weight:700>}</span> 
  
  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>synchronized</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>clear</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span> 
    <span style=color:#000>started</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>false</span><span style=color:#ce5c00;font-weight:700>;</span> 
  <span style=color:#ce5c00;font-weight:700>}</span> 
  
  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>synchronized</span> <span style=color:#204a87;font-weight:700>long</span> <span style=color:#000>getTime</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span> 
    <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>endTime</span> <span style=color:#ce5c00;font-weight:700>-</span> <span style=color:#000>startTime</span><span style=color:#ce5c00;font-weight:700>;</span> 
  <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>我们可以将栅栏的初始化过程修改为使用这种栅栏动作，即使用能接收栅栏动作的 CyclicBarrier 构造函数。</p>
<p>在修改后的 test 方法中使用了基于栅栏的计时器，如程序清单 12-12 所示。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>test</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span>
  <span style=color:#204a87;font-weight:700>try</span> <span style=color:#ce5c00;font-weight:700>{</span> 
    <span style=color:#000>timer</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>clear</span><span style=color:#ce5c00;font-weight:700>();</span> 
    <span style=color:#204a87;font-weight:700>for</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>i</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>0</span><span style=color:#ce5c00;font-weight:700>;</span> <span style=color:#000>i</span> <span style=color:#ce5c00;font-weight:700>&lt;</span> <span style=color:#000>nPairs</span><span style=color:#ce5c00;font-weight:700>;</span> <span style=color:#000>i</span><span style=color:#ce5c00;font-weight:700>++)</span> <span style=color:#ce5c00;font-weight:700>{</span> 
      <span style=color:#000>pool</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>execute</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>Producer</span><span style=color:#ce5c00;font-weight:700>());</span> 
      <span style=color:#000>pool</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>execute</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>Consumer</span><span style=color:#ce5c00;font-weight:700>());</span> 
    <span style=color:#ce5c00;font-weight:700>}</span> 
    <span style=color:#000>barrier</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>await</span><span style=color:#ce5c00;font-weight:700>();</span> 
    <span style=color:#000>barrier</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>await</span><span style=color:#ce5c00;font-weight:700>();</span> 
    <span style=color:#204a87;font-weight:700>long</span> <span style=color:#000>nsPerItem</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>timer</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>getTime</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>/</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>nPairs</span><span style=color:#ce5c00;font-weight:700>*</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>long</span><span style=color:#ce5c00;font-weight:700>)</span><span style=color:#000>nTrials</span><span style=color:#ce5c00;font-weight:700>);</span> 
    <span style=color:#000>System</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>out</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>print</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#4e9a06>&#34;Throughput: &#34;</span> <span style=color:#ce5c00;font-weight:700>+</span> <span style=color:#000>nsPerItem</span> <span style=color:#ce5c00;font-weight:700>+</span> <span style=color:#4e9a06>&#34; ns/item&#34;</span><span style=color:#ce5c00;font-weight:700>);</span> 
    <span style=color:#000>assertEquals</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>putSum</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>get</span><span style=color:#ce5c00;font-weight:700>(),</span> <span style=color:#000>takeSum</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>get</span><span style=color:#ce5c00;font-weight:700>());</span> 
  <span style=color:#ce5c00;font-weight:700>}</span> <span style=color:#204a87;font-weight:700>catch</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>Exception</span> <span style=color:#000>e</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span> 
    <span style=color:#204a87;font-weight:700>throw</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>RuntimeException</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>e</span><span style=color:#ce5c00;font-weight:700>);</span> 
  <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>我们可以从 TimedPutTakeTest 的运行中学到一些东西。第一，生产者-消费者模式在不同参数组合下的吞吐率。第二，有界缓存在不同线程数量下的可伸缩性。第三，如果选择缓存的大小。要回答这些问题，需要对不同的参数组合以进行测试，因此我们需要一个主测试程序，如程序清单 12-13 所示。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>static</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>main</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>String</span><span style=color:#ce5c00;font-weight:700>[]</span> <span style=color:#000>args</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#204a87;font-weight:700>throws</span> <span style=color:#000>Exception</span> <span style=color:#ce5c00;font-weight:700>{</span> 
  <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>tpt</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>100000</span><span style=color:#ce5c00;font-weight:700>;</span> <span style=color:#8f5902;font-style:italic>// trials per thread 
</span><span style=color:#8f5902;font-style:italic></span>  <span style=color:#204a87;font-weight:700>for</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>cap</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>1</span><span style=color:#ce5c00;font-weight:700>;</span> <span style=color:#000>cap</span> <span style=color:#ce5c00;font-weight:700>&lt;=</span> <span style=color:#000>1000</span><span style=color:#ce5c00;font-weight:700>;</span> <span style=color:#000>cap</span><span style=color:#ce5c00;font-weight:700>*=</span> <span style=color:#000>10</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span> 
    <span style=color:#000>System</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>out</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>println</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#4e9a06>&#34;Capacity: &#34;</span> <span style=color:#ce5c00;font-weight:700>+</span> <span style=color:#000>cap</span><span style=color:#ce5c00;font-weight:700>);</span> 
    <span style=color:#204a87;font-weight:700>for</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>pairs</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>1</span><span style=color:#ce5c00;font-weight:700>;</span> <span style=color:#000>pairs</span> <span style=color:#ce5c00;font-weight:700>&lt;=</span> <span style=color:#000>128</span><span style=color:#ce5c00;font-weight:700>;</span> <span style=color:#000>pairs</span><span style=color:#ce5c00;font-weight:700>*=</span> <span style=color:#000>2</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span> 
      <span style=color:#000>TimedPutTakeTest</span> <span style=color:#000>t</span> <span style=color:#ce5c00;font-weight:700>=</span> 
        <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>TimedPutTakeTest</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>cap</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>pairs</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>tpt</span><span style=color:#ce5c00;font-weight:700>);</span> 
      <span style=color:#000>System</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>out</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>print</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#4e9a06>&#34;Pairs: &#34;</span> <span style=color:#ce5c00;font-weight:700>+</span> <span style=color:#000>pairs</span> <span style=color:#ce5c00;font-weight:700>+</span> <span style=color:#4e9a06>&#34;\t&#34;</span><span style=color:#ce5c00;font-weight:700>);</span> 
      <span style=color:#000>t</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>test</span><span style=color:#ce5c00;font-weight:700>();</span> 
      <span style=color:#000>System</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>out</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>print</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#4e9a06>&#34;\t&#34;</span><span style=color:#ce5c00;font-weight:700>);</span> 
      <span style=color:#000>Thread</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>sleep</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>1000</span><span style=color:#ce5c00;font-weight:700>);</span> 
      <span style=color:#000>t</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>test</span><span style=color:#ce5c00;font-weight:700>();</span> 
      <span style=color:#000>System</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>out</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>println</span><span style=color:#ce5c00;font-weight:700>();</span> 
      <span style=color:#000>Thread</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>sleep</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>1000</span><span style=color:#ce5c00;font-weight:700>);</span>
    <span style=color:#ce5c00;font-weight:700>}</span>
  <span style=color:#ce5c00;font-weight:700>}</span> 
  <span style=color:#000>pool</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>shutdown</span><span style=color:#ce5c00;font-weight:700>();</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>图 12-1 给出在 4 路机器上的一些测试结果，缓存容量分别为 1、10、100、1000。我们可以看到，当缓存大小为 1 时，吞吐率非常糟糕，这是因为每个线程在阻塞并等待另一个线程之前，所取得的进展是非常有限的。当把缓存大小提高到 10 时，吞吐率得到了几大提高：但在超过 10 之后，所得到的收益又开始降低。</p>
<div align=center>
<img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20181118174906.png style=display:block;width:70% alt=12-1 align=center>
</div>
<p>初看起来可能会感到困惑：当增加更多的贤臣时，性能却略有下降。其中的原因很难中数据中看出来，但可以在运行测试时使用 CPU 性能工具：虽然有许多的线程，但却没有足够的计算量，并且大部分时间都消耗在线程的阻塞和解除阻塞等操作上。线程有足够多的 CPU 空闲时钟周期来做相同的事情，因此不会过多的降低性能。</p>
<p>然而，要谨慎对待从上面的数据中得出的结论，即在使用有界缓存的生产消费程序中总是可以添加更多的线程。这个测试在模拟应该程序时忽略了许多实际的因素，例如生产者几乎不需要任何工作就可以生成一个元素并将其放入队列，如果工作者线程需要通过执行一些复杂的操作来生产和获取各个元素条目(通常就是这种情况)，那么之前那种 CPU 空闲状态将消失，并且由于线程过多而导致的影响将变得非常明显。这个测试的主要目的是，测量生产者和消费者在通过有界缓存传递数据时，哪些约束条件将对整体吞吐量产生影响。</p>
<h3 id=1222-多种算法的比较>12.2.2 多种算法的比较</h3>
<p>虽然 BoundedBuffer 是一种非常合理的实现，并且他的性能还不错，但还是没有 ArrayBlockingQueue 或 LinkedBlockingQueue 那样好(这也解释了为什么这种缓存算法没有被选入标准库)。JUC 中的算法已经通过类似的测试进行了调优，其性能也已经达到了我们已知的最佳状态。此外，这些算法还能提供更多的功能。BoundedBuffer 运行效率不高的主要原因是：在 put 和 get 方法中都包含多个可能发生竞争的操作，比如获取一个信号量、获取一个锁、释放信号量等。而在其他实现中，可能发生竞争的位置将少很多。</p>
<p>图 12-2 给出了一个在双核超线程机器上对这三个类的吞吐量的测试结果，在测试中使用了一个包含 256 个元素的缓存，以及相应版本的 TimedPutTakeTest。测试结果表明，LinkedBlockingQueue 的可伸缩性要高于 ArrayBlockingQueue。初看起来，这个结果有些奇怪：链表队列在每次插入元素时，都必须分配一个链表节点对象，这似乎比基于数组的队列执行了更多的工作。然而，虽然它拥有更好的内存分配和 GC 等开销，但与基于数组的队列相比，链表队列的 put 和 take 等方法支持并发性更高的访问，因为一些优化后的链表队列算法能够将队列头结点的更新操作与尾节点的更新操作分离开来。由于内存分配操作通常是线程本地的，因此如果算法能够通过多执行一些内存分配操作来降低竞争程度，那么这种算法通常具有更高的可伸缩性。(这种情况再次证明了，基于传统性能调优的直觉与提升可伸缩性的实际需求是背道而驰的)。</p>
<div align=center>
<img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20181118174922.png style=display:block;width:70% alt=12-2 align=center>
</div>
<h3 id=响应性衡量>响应性衡量</h3>
<p>到目前为止，我们的重点是对吞吐量的测试，这通常是并发程序中最重要的性能指标。但有时候，我们还需要知道某个动作经过长时间才能执行完成，这时就好测量服务时间的变化情况。而且，如果能获得更小的服务时间变动性，那么更长的平均服务时间是有意义的，“可预测性”同样是一个非常有价值的性能特征。通过测量变动性，使我们能回答一些关于服务质量的问题，如“操作在 100 毫秒内成功执行的百分比是多少？”</p>
<p>通过表示任务完成时间的直方图，最能看出服务时间的变动。服务时间变动的测量比平均值的测量要略困难一些——除了总共完成时间外，还要记录每个任务的完成时间。因为计数器的粒度通常是测量任务时间的一个主要因素(任务的执行时间可能小于或接近于最小“定时器计时单位”，这将影响测量结果的精确性)，为了避免测量过程中的认为影响，我们可以测量一组 put 和 take 方法的运行时间。</p>
<p>图 12-3 给出在不同 TimedPutTakeTest 中每个任务的完成时间，其中使用了一个大小为 1000 的缓存，有 256 个并发任务，并且每个任务都将使用非公平的信号量(隐蔽栅栏，Shaded Bars)和公平信号量(开发栅栏，Open Bars)来迭代这 1000 个元素。非公平信号量完成时间的变动范围为 104 到 8714 毫秒，相差超过 80 倍。通过在同步控制中实现为更高的公平性，可以缩小这种变动范围，通过在 BoundedBuffer 中将信号量初始化为公平模式，可以很容易实现这个功能。如图 12-3 所示，这种方法能成功的降低变动性(现在的变动范围为 38194 到 38207 毫秒)，然而，该方法会极大的降低吞吐量。(如果在运行时间较长的测试中执行更多种任务，那么吞吐量的下降程度可能更大。)</p>
<div align=center>
<img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20181118175023.png style=display:block;width:70% alt=12-3 align=center>
</div>
<p>前面讨论过，如果缓存过小，那么将导致非常多的上下文切换次数，这即使是在非公平模式中也会导致很低的吞吐量，因此在几乎每个操作上都会执行上下文切换。为了说明非公平性开销主要是由于线程阻塞而造成的，我们可以将缓存大小设置为 1，然后重新运行这个测试，从而可以看出此时非公平信号量与公平信号量的执行性能基本相当。如图 12-4 所示，这种情况下公平性并不会使平均完成时间变长，或者使变动性变小。</p>
<div align=center>
<img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20181118175037.png style=display:block;width:70% alt=12-4 align=center>
</div>
<p>因此，除非线程由于密集的同步需求而被持续的阻塞，否则非公平的信号量通常能实现更好的吞吐量，而公平的信号量则实现更低的变动性。因为这些结果之间的差异非常大，所以 Semaphore 要求客户选择针对哪一个特性进行优化。</p>
<h2 id=123-避免性能测试的陷阱>12.3 避免性能测试的陷阱</h2>
<p>理论上，编写性能测试程序是很容易的——找出一个典型应用场景，比那些一段程序并多次执行这种场景，同时统计程序的运行时间。但在实际情况中，你必须提防多种编码陷阱，它们会使性能测试变得毫无意义。</p>
<h3 id=1231-垃圾回收>12.3.1 垃圾回收</h3>
<p>垃圾回收的执行时机是无法预测的，因此在执行测试时，垃圾回收器可能在任何时刻运行。如果测试程序执行了 N 次迭代都没有触发垃圾回收操作，但在第 N+1 次迭代时触发了垃圾回收操作，那么即使运行次数相差不大，仍可能在最终测试的每次迭代时间上带来很大的(却是虚假的)影响。</p>
<p>有两种策略可以防止垃圾回收操作对测试结果产生偏差。第一种策略是，确保垃圾回收操作在测试运行的整个期间都不会执行(可以在启动 JVM 时指定 <code>-vervose:gc</code> 来判断是否执行了垃圾回收操作)。第二种策略是，确保垃圾回收操作在测试期间执行多次，这样测试程序就能充分反映出运行期间的内存分配与垃圾回收等开销。通常第二种策略更好，它要求更长的测试时间，斌跟那个更有可能反映实际环境下的性能。</p>
<p>在大多数采用生产者消费者设计的应用程序中，都会执行一定数量的内存分配与垃圾回收等操作——生产者分配新对象，然后被消费者使用并丢弃。如果将有界缓存测试运行足够长的时间，那么将引发多次垃圾回收，从而得到更精确的结果。</p>
<h3 id=1232-动态编译>12.3.2 动态编译</h3>
<p>与静态编译语言(如 C/C++)相比，编写动态编译语言(如 Java)的性能基准测试要困难的多。在 HotSpot JVM (以及其他现代 JVM)中将字节码的解释与动态编辑结合起来使用。当某个类第一次没加载时，JVM 会通过解释字节码的方式来执行它。在某个时刻，如果一个方法被运行的次数足够多，那么动态编译器会将它编译为机器代码，当编译完成之后，代码的执行方式将从即使执行变成直接执行。</p>
<p>这种编译的执行时机是无法预测的。只有在所有代码都编译完成以后，才应该统计测试的运行时间。测量采用解释执行的速度是没有意义的，因为大多数程序在运行足够长时间后，所有频繁执行的代码路径都会被编译。如果编译器可以在测试期间运行，那么将在两个方面对测试结果带来偏差：在编译过程中将消耗 CPU 资源，并且，如果在测量的代码中包含解释执行的代码，又包含编译执行的代码，那么通过测试这种混合代码得到的性能指标没有太大意义。图 12-5 给出了动态编译在测试结果上带来的偏差。这 3 条时间线表示执行了相同次数的迭代：时间线 A 表示所有代码都采用解释执行，时间线 B 表示在运行过程中间开始转向编译执行，而时间线 C 表示从较早时刻就尅是采用编译执行。编译执行的开始时刻会对每次操作的运行时间产生极大的影响。</p>
<div align=center>
<img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20181118175057.png style=display:block;width:70% alt=12-5 align=center>
</div>
<p>基于各种原因，代码还可能被反编译(退回到解释执行)以及重新编译，比如加载了一个会使编译假设无效的类，或者在收集了足够的分析信息后，决定采用不同的优化措施来重新编译某条代码路径。</p>
<p>有种方式可以放置动态编译对测试结果产生偏差，即使使程序运行足够长的时间(至少数分钟)，这样编译过程以及解释执行都只是总运行时间的很小一部分。另一种方法是使代码预先运行一段时间并且不测试这段时间内的代码性能，这样在开始计时前代码就已经被完全编译了。在 HotSpot 中，如果在运行时使用命令行选项 <code>-xx:+PrintCompilation</code>，那么当动态编译运行时将输出一条信息，你可以通过这条信息来验证动态编译是在测试运行前将机执行，而不是在运行过程中执行。</p>
<p>通过在同一个 JVM 中将相同的测试运行多次，可以验证测试方法的有效性。第一组结果应该作为“预先执行”的结果而丢弃，如果在剩下的结果中仍然存在不一致的地方，那么就需要进一步对测试进行分析，从而找出结果不可重复的原因。</p>
<p>JVM 会使用不同的后台线程来执行辅助任务。当在单次运行中测试多个不相关的计算密集型操作时，一种好的做法是在不同操作的测试之间插入显式的暂停，从而使 JVM 能够与后台任务保持步调一致，同时将被测试任务的干扰将至最低。(然而，当测量多个相关操作时，例如将相同测试运行多次，如果按照这种方式来排除 JVM 后台任务，那么可能会得出不真实的结果)。</p>
<h3 id=1233-对代码路径不真实采样>12.3.3 对代码路径不真实采样</h3>
<p>运行时编译器根据收集到的信息对已编译的代码进行优化。JVM 可以与执行过程特定的信息来生成更优的代码，这意味着在编译某个程序的方法 M 时生成的代码，将可能与编译另一个不同程序中的方法 M 时生成的代码不同。在某些情况下，JVM 可能会基于一些只是临时有效的假设进行优化，并在这些假设失效时丢弃已编译的代码。</p>
<p>因此，测试程序不仅要大致判断某个典型应用程序的使用模式，还需要尽量覆盖在该应用程序中将要指定的代码路劲的集合。否则，动态编译器可能会针对一个单线程测试程序进行一些专门优化，但只要在真实的应用程序中略微包含一些并行，都是使这些优化不复存在。因此，即使你只是想测试单线程的性能，也应该将单线程的性能与多线程的性能测试结合在一起。(在 TimedPutTakeTest 中不会出现这个问题，因为即使在最小的测试用例中都使用了两个线程。)</p>
<h3 id=1234-不真实的竞争程度>12.3.4 不真实的竞争程度</h3>
<p>并发的应用程序可以交替执行两种不同类型的工作：访问共享数据(例如从共享工作对垒中取出下一个任务)以及执行线程本地的计算(如，执行任务，并假设任务本身不会访问共享数据)。根据两种不同类型工作的相关程度，在应用程序中出现不同程度的竞争，并发现出不同的性能与可伸缩性。</p>
<p>如果有 N 个线程从共享对垒中获取任务并执行，并且这些任务都是计算密集型的且运行时间较长(但不会频繁的访问共享数据)，那么在这种情况下几乎不存在竞争，吞吐量仅受限于 CPU 资源的可用性。然而，如果任务的生命周期很短，俺么在工作队列上将会存在验证的竞争，此时的吞吐量将受限于同步的开销。</p>
<p>要获得有实际意义的结果，在并发测试中应该尽量模拟典型应用程序中的线程本地计算量以及并发协调开销。如果在真实应用程序的各个任务中执行的工作，与测试程序中执行的工作截然不同，那么测试出的性能瓶颈位置将是不准确的。在 11.5 节看到过，对于基于锁的类，比如同步 Map 实现，在访问锁时是否存在高度的竞争将会对吞吐量产生巨大的影响。本节的测试除了不断访问 Map 之外没有执行其他操作，因此，虽然又两个线程，但在所有对 Map 的访问操作中都存在竞争。然而，如果应用程序在每次访问共享数据结构时执行大量的线程本地计算，那么可以极大的降低竞争程度并提供更好的性能。</p>
<p>从这个角度来看，TimedPutTakeTest 对于某些应用程序来说不是一种好模式。由于工作者线程没有执行太多的工作，因此吞吐量将主要受限于线程之间的协调开销，并且对所有通过有界缓存的生产者和消费者之间交换数据的应用程序来说，并不都是这种情况。</p>
<h3 id=1235-无用代码的消除>12.3.5 无用代码的消除</h3>
<p>在编写优秀的基准测试程序时，一个需要面对的挑战是：优化编译器能找出并消除那些不会对输出结果产生任何影响的无用代码。由于基准测试通常不会执行任何计算，因此它们很容易在编译器的优化过程中被消除。在大多数情况下，编译器从程序中删除无用代码都是一种优化措施，但对于基准测试程序来说却是一个大问题，因为这将使得被测试的内容变得更少。如果幸运的话，编译器将删除整个程序中无用的代码，从而得到一份明显虚假的测试数据。但如果不幸运的话，编译器在消除无用代码后将提高程序的执行速度，从而是你做出错误的结论。</p>
<p>对于静态编译语言中的基准测试，编译器在消除无用代码时也存在问题，但要检测出编译器是否消除了测试基准是很容易的，因为可以通过机器码来发现是否缺失了部分程序。但在动态编译语言中，要获得这种信息则更加困难。</p>
<p>在 HotSpot 中，许多基准测试在 “-server” 模式下都能比在 “-client” 模式下运行的更好，这不仅是因为 “-server” 模式下的编译器能产生更有效的代码，而且这种模式更易于通过优化消除无用代码。然而，对于将执行一定操作的代码来说，无用代码消除优化却不会去掉它们。在多处理器系统上，无论在正式产品还是测试版本中，都应该选择 “-server” 模式而不是 “-client” 模式——只是在测试程序时必须保证它们不会受到无用代码消除带来的影响。</p>
<blockquote>
<p>要编写有效的性能测试程序，就需要告诉编译器不要将基准测试当做无用代码优化掉，这就要求在程序中对每个计算结果都要通过某种方式使用，这种方式不需要同步或者大量的计算。</p>
</blockquote>
<p>在 PutTakeTest 中，我们计算了在队列中被添加和删除的所有元素的校验和，但如果在程序中没有用到这个校验和，那么计算校验和的操作仍有可能被优化掉。幸好我们需要通过校验和来验证算法的正确性，然而你也可以通过输出这个值来确保它被用到。但是，你需要避免在运行测试时执行 IO 操作，以避免运行时间的测试结果产生偏差。</p>
<p>有一个简单的技巧可以避免运算被优化掉而又不引入过高的开销：即计算某个派生对象中域的散列值，并将它与一个任意值进行比较，比如 System.nanoTime 的当前值，如果二者碰巧相等，那么就输出一个无用且可以被忽略的消息：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#204a87;font-weight:700>if</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>foo</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>x</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>hashCode</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>==</span> <span style=color:#000>System</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>nanoTime</span><span style=color:#ce5c00;font-weight:700>())</span>
  <span style=color:#000>System</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>out</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>print</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#4e9a06>&#34; &#34;</span><span style=color:#ce5c00;font-weight:700>);</span>
</code></pre></div><p>这个比较操作很少很成功，即使成功了，它的唯一作用就是在输出中插入一个无害的空字符。(在 print 方法中把输出结果缓存起来，并直到调用 println 才真正执行输出操作，因此即使 hashCode 和 System.nanoTime 的返回值碰巧相等，也不会真正的执行 IO 操作)。</p>
<p>不仅每个计算结果都应该被使用，而且还应该是不可预测的。否则，一个智能的动态优化编译器将用预先计算的结果来代替计算过程。虽然在 PutTakeTest 的构造过程中解决了这个问题，但如果测试程序的输入参数为静态数据，那么都会受到这种优化措施的影响。</p>
<h2 id=124-其他的测试方法>12.4 其他的测试方法</h2>
<p>虽然我们希望一个测试程序能够“找出所有的错误”，但这是一个不切实际的目标。NASA 在测试中投入的资源比任何商业集团投入的都要多，但他们生产的代码仍然是存在缺陷的。在一些复杂的程序中，即使再多的测试也无法找出所有的错误。</p>
<p>测试的目标不是更多的发现错误，而是提高代码能按照预期方式工作的可信度。由于找出所有的错误是不现实的，所以质量保证(QA)目标应该是在给定的测试资源下实现最高的可信度。到目前为止，我们介绍了如何构造有限的单元测试和性能测试。在构建并发类能否表现出正确行为的可信度时，测试是一种非常重要的首选，但并不是唯一可用的 QA 方法。</p>
<p>还有其他一些 QA 方法，他们在找出某些类型的错误时非常有效，而在找出其他类型的错误时则相对低效。通过使用一些补充的测试方法，比如代码审查和静态分析等，可以获得比在使用任何单一方法更多的可信度。</p>
<h3 id=1241-代码审查>12.4.1 代码审查</h3>
<p>正如单元测试和压力测试在查找并发错误时是非常有效和重要的手段，多人参与的代码审查通常是不可替代的。虽然你可以在设计测试方法时使其能最大限度的发现安全性错误，以及反复的运行这些测试，但同样应该需要有代码编写者之外的其他人来仔细的审查并发代码。即使并发专家也有犯错的时候，花一定的时间由其他人来审查代码总是物有所值的。并发专家能够比大多数测试程序更有效的发现一些微秒的竞争问题。(此外，一些平台问题，比如 JVM 的实现细节或处理器的内存模型等，都会屏蔽一些只有在特定硬件或软件配置下才会出现的错误)。代码审查还有其他的好处，它不仅能发现错误，通常还能提高描述实现细节的注释质量，因此可以降低后期维护的成本和风险。</p>
<h3 id=1242-静态分析工具>12.4.2 静态分析工具</h3>
<p>在编写本书时，一些静态分析工具正在迅速的称为正式测试和代码审查的有效补充。静态代码分析是指在进行分析时不需要运行代码，而代码审查工具可以分类类中是否存在一些常见错误模式。在一些静态分析工具(如 FindBugs)中包含了许多错误模式检查器，能检查出多种常见的编码错误，其中许多错误都很容易在测试或代码审查中遗漏。</p>
<p>静态分析工具能生成一个告警列表，其中包含的警告信息必须通过手工方式进行检查，从而确定这些警告是否表示真正的错误。曾经有一些工具(如 lint)会产生很多伪警告信息，使得开发人员望而却步，但现在的一些工具已经在这方面有所改进，并且产生的伪警告很少。虽然静态分析工具仍然显得有些原始(尤其在它们与开发工具和开发生命周期的集成过程中)，但却足以成为对测试过程的一种有效补充。</p>
<p>在编写本书时，FindBugs 包含的检查器中可以发现以下与并发相关的错误模式，而且一直在不断的增加新的检查器：</p>
<p><strong>不一致的同步</strong>。许多对象遵循的同步策略是，使用对象的内置锁来保护所有的变量。如果某个域被频繁的访问，但并不是在每次访问时都持有相同的锁，那么这就可能表示没有一致的遵循这个策略。</p>
<p>分析工具必须对同步策略进行猜测，因为在 Java 类中并没有正式的同步规范。将来，如果 <code>@GuardedBy</code> 注解可以被标准化，那么核查工具就能解析这些注解，而无需猜测变量与锁之间的关系，从而提高分析质量。</p>
<p><strong>调用 Thread.run</strong>。在 Thread 中实现了 Runnable，因此包含了一个 run 方法。然而，如果直接调用 Thread.run，那么通常是错误的，而应该调用 Thread.start。</p>
<p><strong>未被释放的锁</strong>。与内置锁不同的是，执行控制流在退出显式锁的作用域时，通常不会自动释放它们。标准的做法是在一个 finally 块中释放显式锁，否则，当发生 Execution 事件时，锁仍然处于未被释放的状态。</p>
<p><strong>空的同步块</strong>。虽然在 Java 内存模型中，空同步块具有一定的语义，但它们总是被不正确的使用，无论开发人员尝试通过空同步块来解决哪种问题，通常都存在一些更好的替代方案。</p>
<p><strong>双重检查锁</strong>。双检锁所是一种错误的习惯用法，其初衷是为了降低延迟初始化过程中的同步开销，该用法在读取一个共享的可变域时缺少正确的同步。</p>
<p><strong>在构造函数中启动线程</strong>。如果在构造函数中启动线程，那么将可能带来子类化问题，同时还会导致 this 引用从构造函数中溢出。</p>
<p><strong>通知错误</strong>。notify 和 notifyAll 方法都表示，某个对象的可变状态可能以某个方式发生了变化，并且这种方式将在相关条件队列上被阻塞的线程恢复执行。只有在与条件队列相关的状态发生改变后，才应该调用这些方法。如果在一个同步块中条用了 notify 或 notifyAll，但没有修改任何状态，那么就可能出错。</p>
<p><strong>条件等待中的错误</strong>。当在一个条件队列上等待时，Object.wait 和 Condition.await 方法应该在检查了状态谓词之后，在某个循环中调用，同时需要持有正确的锁。如果在调用 Object.wait 和 Condition.await 方法时没有持有锁，或者不在某个循环中，或者没有检查某些状态谓词，那么通常都是一个错误。</p>
<p><strong>对 Lock 和 Condition 的无用</strong>。将 Lock 作为同步块来使用通常是一种错误的用法，正如调用 Condition.wait 而不是调用 await(后者能够通过测试被发现，因此在第一次调用它的将抛出 IllegalMonitorStateException)。</p>
<p><strong>在休眠或等待的同时持有一个锁</strong>。如果在调用 Thread.sleep 时持有一个锁，那么将导致其他线程在很长一段时间内无法执行，因此可能导致严重的活跃性问题。如果在调用 Object.wait 或 Condition.await 时持有两个锁，那么也可能导致同样的问题。</p>
<p><strong>自旋循环</strong>。如果在代码中除了通过自旋(忙于等待)来检查某个域的值以外不做任何事情，那么将浪费 CPU 时钟周期，并且如果这个域不是 volatile 类型，那么将无法保证这种自旋过程能结束。当等待某个状态转换发生时，闭锁或条件等待通常是一种更好的技术。</p>
<h3 id=1243-面向方面的测试技术>12.4.3 面向方面的测试技术</h3>
<p>在编写本书时，面向方面编程(AOP)技术在并发领域的应用是非常有限的，因为大多数主流的 AOP 工具还不能支持在同步位置处的“切入点”。然而，AOP 还可以用来确保不变型条件不被破坏，获取与同步策略的某些方面保持一致。例如，在(Laddad, 2003)中给出了一个示例，其中使用了一个切面将所有对非线程安全的 Swing 方法调用都封装在一个断言中，该断言确保这个调用是在事件线程中执行的。由于不需要修改代码，因此该技术很容易使用，并且可以发现一些复杂的发布错误和线程封闭错误。</p>
<h3 id=1244-分析与检测工具>12.4.4 分析与检测工具</h3>
<p>大多数商业分析工具都支持线程。这些工具在功能与执行效率上存在差异，但通常都能给出队程序内部的详细信息(虽然分析工具通常采用侵入式实现，因此可能对程序的执行时序和行为产生极大的影响)。大多数分析工作通常还为每个线程提供了一个时间线显示，并且用颜色来区分不同的线程状态(可运行、由于等待某个锁而阻塞、由于等待 IO 操作而阻塞等等)。从这些显示信息中可以看出程序对可用 CPU 资源的利用率，以及当程序表现糟糕时，该从何处查找原因。(许多分析工具还生成能够找出哪些锁导致了竞争，但在实际情况中，这些功能与人们期望的加锁行为分析能力之间存在一定的差距)。</p>
<p>内置的 JMX 代理同样提供了一些有限的功能来监测线程的行为。在 ThreadInfo 类中包含了线程的当前状态，并且当线程被阻塞时，它还会包含发生阻塞所在的锁或者条件对了。如果启动了“线程竞争监测”功能(在默认情况下为了不影响性能会被关闭)，那么在 ThreadInfo 中还会包括线程由于等待一个锁或者通知而被阻塞的次数，以及等待的累积时间。</p>
<h2 id=小结>小结</h2>
<p>要测试并发程序的正确性可能非常困难，因为并发程序的许多故障模式都是一些低概率事件，它们对于执行时序、负载情况以及其他难以重现的条件都非常敏感。而且，在测试程序中还会引入额外的同步或执行时序限制，这些因素都将掩盖被测试代码中的一些并发问题。要测试并发程序的性能同样非常困难，与使用静态编译语言(C/C++)编写的程序相比，用 Java 编写的的程序在测试起来会更加困难，因为动态编译、垃圾回收以及自动优化等操作都会影响与时间相关的测试结果。</p>
<p>要想尽可能的发现潜在的错误以及避免它们在正式正式产品中暴露出来，我们需要将传统的测试技术与代码审查和自动化分析工具结合起来，每项技术都可以找出其他方式忽略的问题。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-5362a9725228190e36f82efd5628981c>13 - CH13-显式锁</h1>
<p>在 Java 5.0 之前，在协调对共享对象访问时仅能使用 synchronized 和 volatile 机制。Java 5.0 增加了一种新的机制：ReentrantLock。与之前提到的机制相反，ReentrantLock 并非一种替代内置锁的方法，而是当内置锁机制不适用时，作为一种可供选择的高级功能。</p>
<h2 id=131-lock-与-reentrantlock>13.1 Lock 与 ReentrantLock</h2>
<p>在程序清单 13-1 给出的 Lock 接口中定义了一组抽象的加锁操作。有内置加锁机制不同的是，Lock 提供了一种无条件的、可轮询的、定时的、可中断的加锁操作，所有加锁和解锁的方法都是显式的。在 Lock 的实现中必须提供与内置锁相同的内存可见性语义，但在加锁语义、调度算法、顺序保证以及性能特性等方面可以有所不同。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>interface</span> <span style=color:#000>Lock</span> <span style=color:#ce5c00;font-weight:700>{</span> 
  <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>lock</span><span style=color:#ce5c00;font-weight:700>();</span> 
  <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>lockInterruptibly</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#204a87;font-weight:700>throws</span> <span style=color:#000>InterruptedException</span><span style=color:#ce5c00;font-weight:700>;</span> 
  <span style=color:#204a87;font-weight:700>boolean</span> <span style=color:#000>tryLock</span><span style=color:#ce5c00;font-weight:700>();</span> 
  <span style=color:#204a87;font-weight:700>boolean</span> <span style=color:#000>tryLock</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>long</span> <span style=color:#000>timeout</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>TimeUnit</span> <span style=color:#000>unit</span><span style=color:#ce5c00;font-weight:700>)</span> 
    <span style=color:#204a87;font-weight:700>throws</span> <span style=color:#000>InterruptedException</span><span style=color:#ce5c00;font-weight:700>;</span> 
  <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>unlock</span><span style=color:#ce5c00;font-weight:700>();</span> 
  <span style=color:#000>Condition</span> <span style=color:#000>newCondition</span><span style=color:#ce5c00;font-weight:700>();</span> 
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>ReentrantLock 实现了 Lock 接口，并提供了与 synchronized 相同的互斥性和内存可见性。在获取 ReentrantLock 时，有着与进入同步代码块相同的内存语义，在释放 ReentrantLock 时，有着与退出同步代码块相同的内存语义。此外，与 synchronized 一样，ReentrantLock 还提供了可重入的加锁语义。ReentrantLock 支持在 Lock 接口中定义的所有加锁模式，并且与 synchronized 相比，它还为处理锁的不可用性问题提供更高的灵活性。</p>
<p>为什么要创造一种与内置锁如此类似的新加锁机制？在大多数情况下，内置锁能很好的工作，但在功能上存在一些局限性，例如，无法中断一个正在等待获取锁的线程，或者无法在请求获取一个锁时无限的等待下去。内置锁必须在获取该锁的代码块中释放，这就简化了编码工作，并且与异常处理操作实现了很好的交互，但却无法实现非阻塞结构的加锁规则。这些都是使用 synchronized 的原因，但在某些情况下，一种更灵活的加锁机制通常能提供更好的活跃性或性能。</p>
<p>程序清单 13-2 给出了 Lock 接口的标准使用形式。这种形式比使用内置锁复杂一些：必须在 finally 块中释放锁。否则，如果在被保护的代码中抛出了异常，那么这个锁永远都无法释放。当使用加锁时，还必须考虑更多的 try-catch 或 try-finally 代码块。(当使用某种形式的加锁时，包括内置锁，都应该考虑在出现异常时的情况。)</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#000>Lock</span> <span style=color:#000>lock</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>ReentrantLock</span><span style=color:#ce5c00;font-weight:700>();</span> 
<span style=color:#ce5c00;font-weight:700>...</span>
<span style=color:#000>lock</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>lock</span><span style=color:#ce5c00;font-weight:700>();</span> 
<span style=color:#204a87;font-weight:700>try</span> <span style=color:#ce5c00;font-weight:700>{</span>
  <span style=color:#8f5902;font-style:italic>// update object state
</span><span style=color:#8f5902;font-style:italic></span>  <span style=color:#8f5902;font-style:italic>// catch exceptions and restore invariants if necessary 
</span><span style=color:#8f5902;font-style:italic></span><span style=color:#ce5c00;font-weight:700>}</span> <span style=color:#204a87;font-weight:700>finally</span> <span style=color:#ce5c00;font-weight:700>{</span>
  <span style=color:#000>lock</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>unlock</span><span style=color:#ce5c00;font-weight:700>();</span> 
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>如果没有使用 finally 块来释放 Lock，那么就相当于启动了一个定时炸弹。当“炸弹爆炸”时，将会很难追踪到最初发生错误的位置，因为没有记录应该释放锁的位置和时间。这就是 ReentrantLock 无法完全替代 synchronized 的原因：它更加危险，因为当程序的执行控制离开被保护的代码时，不会自动清除锁。虽然在 finally 块中释放锁并不困难，但可能会被忘记。</p>
<h3 id=1311-轮询锁与定时锁>13.1.1 轮询锁与定时锁</h3>
<p>可定时的与可轮询的加锁模式是由 tryLock 方法实现的，与无条件的加锁模式相比，它具有更完善的错误恢复机制。在内置锁中，死锁是一个严重的问题，恢复程序的唯一方法是重新启动程序，而放置死锁的唯一方法就是在构造程序时避免出现不一致的锁顺序。可定时的与可轮询的锁提供了另一种选择：避免死锁的发生。</p>
<p>如果不能获得所有需要的锁，那么可以使用可定时的或可轮询的加锁方式，从而使你重新获得控制权，这会释放已经获得的锁，然后尝试重新获取所有锁(或者至少会将这次失败记录到日志，并采取其他措施)。程序清单 13-3 给出了另一种方法来解决 10.1.2 节中动态顺序死锁的问题：使用 tryLock 来获取两个锁，如果不能同时获得，那么就会退并重新尝试。在休眠时间中包括固定部分和随机部分，从而降低发生活锁的可能性。如果在指定时间内不能获得所有需要的锁，那么 transferMoney 将返回一个失败状态，从而使该操作平缓的失败。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>boolean</span> <span style=color:#000>transferMoney</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>Account</span> <span style=color:#000>fromAcct</span><span style=color:#ce5c00;font-weight:700>,</span>
               <span style=color:#000>Account</span> <span style=color:#000>toAcct</span><span style=color:#ce5c00;font-weight:700>,</span> 
               <span style=color:#000>DollarAmount</span> <span style=color:#000>amount</span><span style=color:#ce5c00;font-weight:700>,</span> 
               <span style=color:#204a87;font-weight:700>long</span> <span style=color:#000>timeout</span><span style=color:#ce5c00;font-weight:700>,</span> 
               <span style=color:#000>TimeUnit</span> <span style=color:#000>unit</span><span style=color:#ce5c00;font-weight:700>)</span> 
  <span style=color:#204a87;font-weight:700>throws</span> <span style=color:#000>InsufficientFundsException</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>InterruptedException</span> <span style=color:#ce5c00;font-weight:700>{</span> 	
  <span style=color:#204a87;font-weight:700>long</span> <span style=color:#000>fixedDelay</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>getFixedDelayComponentNanos</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>timeout</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>unit</span><span style=color:#ce5c00;font-weight:700>);</span> 
  <span style=color:#204a87;font-weight:700>long</span> <span style=color:#000>randMod</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>getRandomDelayModulusNanos</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>timeout</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>unit</span><span style=color:#ce5c00;font-weight:700>);</span> 
  <span style=color:#204a87;font-weight:700>long</span> <span style=color:#000>stopTime</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>System</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>nanoTime</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>+</span> <span style=color:#000>unit</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>toNanos</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>timeout</span><span style=color:#ce5c00;font-weight:700>);</span>

  <span style=color:#204a87;font-weight:700>while</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>true</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#204a87;font-weight:700>if</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>fromAcct</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>lock</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>tryLock</span><span style=color:#ce5c00;font-weight:700>())</span> <span style=color:#ce5c00;font-weight:700>{</span> 
      <span style=color:#204a87;font-weight:700>try</span> <span style=color:#ce5c00;font-weight:700>{</span> 
        <span style=color:#204a87;font-weight:700>if</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>toAcct</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>lock</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>tryLock</span><span style=color:#ce5c00;font-weight:700>())</span> <span style=color:#ce5c00;font-weight:700>{</span> 
          <span style=color:#204a87;font-weight:700>try</span> <span style=color:#ce5c00;font-weight:700>{</span> 
            <span style=color:#204a87;font-weight:700>if</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>fromAcct</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>getBalance</span><span style=color:#ce5c00;font-weight:700>().</span><span style=color:#c4a000>compareTo</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>amount</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>&lt;</span> <span style=color:#000>0</span><span style=color:#ce5c00;font-weight:700>)</span> 
              <span style=color:#204a87;font-weight:700>throw</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>InsufficientFundsException</span><span style=color:#ce5c00;font-weight:700>();</span> 
            <span style=color:#204a87;font-weight:700>else</span> <span style=color:#ce5c00;font-weight:700>{</span> 
              <span style=color:#000>fromAcct</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>debit</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>amount</span><span style=color:#ce5c00;font-weight:700>);</span> 
              <span style=color:#000>toAcct</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>credit</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>amount</span><span style=color:#ce5c00;font-weight:700>);</span> 
              <span style=color:#204a87;font-weight:700>return</span> <span style=color:#204a87;font-weight:700>true</span><span style=color:#ce5c00;font-weight:700>;</span> 
            <span style=color:#ce5c00;font-weight:700>}</span> 
          <span style=color:#ce5c00;font-weight:700>}</span> <span style=color:#204a87;font-weight:700>finally</span> <span style=color:#ce5c00;font-weight:700>{</span> 
            <span style=color:#000>toAcct</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>lock</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>unlock</span><span style=color:#ce5c00;font-weight:700>();</span> 
          <span style=color:#ce5c00;font-weight:700>}</span>
        <span style=color:#ce5c00;font-weight:700>}</span> 
      <span style=color:#ce5c00;font-weight:700>}</span> <span style=color:#204a87;font-weight:700>finally</span> <span style=color:#ce5c00;font-weight:700>{</span>
        <span style=color:#000>fromAcct</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>lock</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>unlock</span><span style=color:#ce5c00;font-weight:700>();</span> 
      <span style=color:#ce5c00;font-weight:700>}</span>
    <span style=color:#ce5c00;font-weight:700>}</span> 
    
    <span style=color:#204a87;font-weight:700>if</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>System</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>nanoTime</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>&lt;</span> <span style=color:#000>stopTime</span><span style=color:#ce5c00;font-weight:700>)</span>
      <span style=color:#204a87;font-weight:700>return</span> <span style=color:#204a87;font-weight:700>false</span><span style=color:#ce5c00;font-weight:700>;</span> 
    
    <span style=color:#000>NANOSECONDS</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>sleep</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>fixedDelay</span> <span style=color:#ce5c00;font-weight:700>+</span> <span style=color:#000>rnd</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>nextLong</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>%</span> <span style=color:#000>randMod</span><span style=color:#ce5c00;font-weight:700>);</span>
  <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>在实现具有时间限制的操作时，定时锁同样非常有用。挡在带有时间限制的操作中调用了一个阻塞方法时，它能根据剩余时间来提供一个时限。如果操作不能在指定的时间内给出结果，那么就会使程序提前结束。当使用内置锁时，在开始请求锁后，这个操作将无法取消，因此内置锁很难实现带有时间限制的操作。</p>
<p>在程序清单 6-17 的旅游门户网站示例中，为询价的每个汽车租赁公司都创建了一个独立的任务。询价操作包含某种基于网络的请求机制，例如 Web 服务请求。但在询价操作中同样可能需要实现对紧缺资源的独占访问，例如通过向公司的直连通信线路。</p>
<p>9.5 节中介绍了确保对资源进行串行访问的方法：一个单线程的 Executor。另一种方法是使用一个独占锁来保护对资源的访问。程序清单 13-4 视图在 Lock 保护的共享通信线路上发送一条消息，如果不能在指定时间内完成，代码就会失败。定时的 tryLock 能够在这种带有时间限制的操作中实现独占加锁行为。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>boolean</span> <span style=color:#000>trySendOnSharedLine</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>String</span> <span style=color:#000>message</span><span style=color:#ce5c00;font-weight:700>,</span>
                   <span style=color:#204a87;font-weight:700>long</span> <span style=color:#000>timeout</span><span style=color:#ce5c00;font-weight:700>,</span> 
                   <span style=color:#000>TimeUnit</span> <span style=color:#000>unit</span><span style=color:#ce5c00;font-weight:700>)</span> 
                   <span style=color:#204a87;font-weight:700>throws</span> <span style=color:#000>InterruptedException</span> <span style=color:#ce5c00;font-weight:700>{</span> 	<span style=color:#204a87;font-weight:700>long</span> <span style=color:#000>nanosToLock</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>unit</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>toNanos</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>timeout</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>-</span> <span style=color:#000>estimatedNanosToSend</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>message</span><span style=color:#ce5c00;font-weight:700>);</span> 
  <span style=color:#204a87;font-weight:700>if</span> <span style=color:#ce5c00;font-weight:700>(!</span><span style=color:#000>lock</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>tryLock</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>nanosToLock</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>NANOSECONDS</span><span style=color:#ce5c00;font-weight:700>))</span>
    <span style=color:#204a87;font-weight:700>return</span> <span style=color:#204a87;font-weight:700>false</span><span style=color:#ce5c00;font-weight:700>;</span> 
    
  <span style=color:#204a87;font-weight:700>try</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>sendOnSharedLine</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>message</span><span style=color:#ce5c00;font-weight:700>);</span> 
  <span style=color:#ce5c00;font-weight:700>}</span> <span style=color:#204a87;font-weight:700>finally</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#000>lock</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>unlock</span><span style=color:#ce5c00;font-weight:700>();</span> 
  <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><h3 id=1312-可中断的加锁操作>13.1.2 可中断的加锁操作</h3>
<p>正如定时加锁操作能在带有时间限制的操作中使用独占锁，可中断的锁获取操作同样能在可取消的操作中使用加锁。7.1.6 节给出了集中不能响应中断的机制，例如请求内置锁。这些不可中断的阻塞机制将使得实现可取消的任务变得复杂。lockInterruptibly 方法能够在获得锁的同时保持对中断的响应，并且由于它包含在 Lock 中，因此无需创建其他类型的不可中断阻塞机制。</p>
<p>可中断的锁获取操作的标准结构比普通的锁线程获取操作略微复杂一些，因为需要两个 try 块。(如果在可中断的锁获取操作中抛出了 InterruptedException，那么可以使用标准的 try-finally 加锁模式。)在程序清单 13-5 中使用了 lockInterruptily 来实现程序清单 13-4 中的 sendOnSharedLine，以便在一个可取消的任务中调用它。定时的 tryLock 同样能响应中断，因此当需要实现一个定时的和可中断的锁获取操作时，可以使用 tryLock 方法。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>boolean</span> <span style=color:#000>sendOnSharedLine</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>String</span> <span style=color:#000>message</span><span style=color:#ce5c00;font-weight:700>)</span> 
  <span style=color:#204a87;font-weight:700>throws</span> <span style=color:#000>InterruptedException</span> <span style=color:#ce5c00;font-weight:700>{</span> 
  <span style=color:#000>lock</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>lockInterruptibly</span><span style=color:#ce5c00;font-weight:700>();</span> 
  
  <span style=color:#204a87;font-weight:700>try</span> <span style=color:#ce5c00;font-weight:700>{</span> 
    <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>cancellableSendOnSharedLine</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>message</span><span style=color:#ce5c00;font-weight:700>);</span> 
  <span style=color:#ce5c00;font-weight:700>}</span> <span style=color:#204a87;font-weight:700>finally</span> <span style=color:#ce5c00;font-weight:700>{</span> 
    <span style=color:#000>lock</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>unlock</span><span style=color:#ce5c00;font-weight:700>();</span> 
  <span style=color:#ce5c00;font-weight:700>}</span> 
<span style=color:#ce5c00;font-weight:700>}</span>

<span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>boolean</span> <span style=color:#000>cancellableSendOnSharedLine</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>String</span> <span style=color:#000>message</span><span style=color:#ce5c00;font-weight:700>)</span> 		<span style=color:#204a87;font-weight:700>throws</span> <span style=color:#000>InterruptedException</span> <span style=color:#ce5c00;font-weight:700>{</span> <span style=color:#ce5c00;font-weight:700>...</span> <span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><h3 id=1313-非块结构的加锁>13.1.3 非块结构的加锁</h3>
<p>在内置锁中，锁的获取和释放等操作都是基于代码块的——释放锁的操作总是与获取锁的操作处于同一个代码块，而不考虑控制权如何退出该代码块。自动的锁释放操作简化了对程序的分析，避免了可能的编码错误，但有时候需要更灵活的加锁规则。</p>
<p>在第 11 章中，我们看到了通过降低锁的粒度可以提供代码的可伸缩性。锁分段技术在基于散列的容器中实现了不同的散列链，以便使用不同的锁。我们可以通过采用类似的原则来降低链表中所的粒度，即为每个链表节点使用一个独立的锁，使不同的线程能独立的对链表的不同部分进行操作。每个节点的锁将保护链接指针以及在该节点中存储的数据，因此当遍历或修改链表时，我们必须持有该节点上的这个锁，直到获得了下一个节点的锁，只有这样，才能是方法前一个节点上的锁。在 <code>CPJ 2.5.1.4</code> 中介绍了使用这项技术的一个示例，并称之为连锁式加锁(Hand-Over-Hand Locking)或者耦合锁(Lock Coupling)。</p>
<h2 id=132-性能考虑因素>13.2 性能考虑因素</h2>
<p>当把 ReentrantLock 添加到 Java 5.0 时，它能比内置锁提供更好的竞争性能。对于同步原语来说，竞争性是可伸缩性的关键要素：如果有越多的资源被耗费在锁的管理和调度上，那么应用程序得到的资源就越少。锁的实现方式越好，将需要越少的系统调用和上下文切换，并且在共享内存总线上的内存同步通信量也越少，而一些耗时的操作将占用应用程序的计算资源。</p>
<p>Java 6 使用了改进后的算法来管理内置锁，与在 ReentrantLock 中使用的算法类似，该算法有效的提供了可伸缩性。图 13-1 给出了在 Java 5 和 Java 6 版本中，内置锁与 ReentrantLock 之间的性能差异，测试程序的运行环境是 4 路的 Opteron 系统，操作系统为 Solaris。图中的曲线表示在某个 JVM 版本中 ReentrantLock 相对于内置锁的“加速比”。在 Java 5 中，ReentrantLock 能提供更高的吞吐量，但在 Java 6 中，二者非常接近。这里使用了与 11.5 节相同的测试程序，这次比较的是通过一个 HashMap 在由内置锁保护以及由 ReentrantLock 保护的情况下的吞吐量。</p>
<div align=center>
<img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20181118175259.png style=display:block;width:70% alt=13-1 align=center>
</div>
<p>在 Java 5.0 中，当从单线程(无竞争)变化到多线程时，内置锁的性能急剧下降，而 ReentrantLock 的性能下降则更为平缓，因为它具有更好的可伸缩性。但在 Java 6 中，情况就完全不同了，内置锁的性能不会犹豫竞争而急剧下降，并且两者的可伸缩性也基本相当。</p>
<p>图 13-1 的曲线图告诉我们，像 “X 比 Y 更快”这样的表述大多是短暂的。性能和可伸缩性对于具体平台等因素较为敏感，例如 CPU、处理器数量、缓存带下以及 JVM 特性等，所有这些因素都可能会随着时间而发生变化。</p>
<blockquote>
<p>性能是一个不断变化的指标。如果在昨天的测试基准中发现 X 比 Y 要快，那么在今天就可能已经过时了。</p>
</blockquote>
<h2 id=133-公平性>13.3 公平性</h2>
<p>在 ReentrantLock 的构造函数中提供了两种公平性选择：创建一个非公平的锁或一个公平的锁。在公平的锁上，线程将按照它们发出请求的顺序来获得锁，但在非公平的锁上，则允许“插队”：当一个线程请求非公平的锁时，如果在发出请求的同时该锁的状态变为可用，那么这个线程将跳过队列中所有的等待线程并获得这个锁。(在 Semaphore 中同样可以选择采用公平或非公平的获取顺序)。非公平的 ReentrantLock 并不提倡插队行为，但无法防止某个线程在合适的时候进行插队。在公平的锁中，如果有另一个线程持有这个锁或者有其他线程在队列中等待这个锁，那么新发出请求的线程将被放入队列中。在非公平的锁中，只有当锁被某个线程持有时，新发出请求的线程才会被放入队列中。</p>
<p>我们为什么不希望所有的锁都是公平的？毕竟，公平是一种好的行为，而不公平是一种不好的行为，对不对？当执行加锁操作时，公平性将由于在挂起线程和恢复线程时存在的开销而极大的降低性能。在实际情况中，统计上的公平性保证——确保被阻塞的线程能最终获得锁，通常已经够用了，并且实际开销也小的多。有些算法依赖于公平的排队算法以确保他们的正确性，但这些算法并不常见。在大多数情况下，非公平锁的性能要高于公平锁的性能。</p>
<p>图 13-2 给出了 Map 的性能测试，并比较由公平的以及非公平的 ReentrantLock 包装的 HashMap 的性能，测试程序在一个 4 路的 Opteron 系统上运行，操作系统为 Solaris，在绘制结果曲线时采用了对数缩放比例。从图中可以看出，公平性把性能指标降低了约两个数量级。不必要的话，不要为公平性付出代价。</p>
<div align=center>
<img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20181118175330.png style=display:block;width:70% alt=13-2 align=center>
</div>
<p>在竞争激烈的情况下，非公平锁的性能高于公平锁的性能的一个原因是：在恢复一个被挂起的线程与该线程真正开始运行之间存在着严重的延迟。假设线程 A 持有一个锁，并且线程 B 请求这个锁。由于该锁已经被线程 A 持有，因此线程 B 被挂起。当 A 释放时，B 将被唤醒，因此会再次尝试获取锁。与此同时，如果 C 也在请求该锁，那么 C 可能会在 B 被唤醒之前获得、使用以及释放这个锁。这样的情况是一种双赢的局面：B 获得锁的时刻并没有被推迟，C 更早的获得了锁，并且吞吐量也获得了提升。</p>
<p>当持有锁的时间相对较长，或者请求锁的平均时间间隔较长，那么应该使用公平锁。在这些情况下，插队带来的吞吐量提升(但锁处于可用状态时，线程却还处于被唤醒的过程中)则可能不会出现。</p>
<p>与默认的 ReentrantLock 一样，内置锁并不会提供确定的公平性保证，但在大多情况下，在锁实现统计上的公平性保证已经足够了。Java 语言规范并没有要求 JVM 以公平的方式来实现内置锁，而在各种 JVM 中也没有这么做。ReentrantLock 并没有进一步降低锁的公平性，而只是使一些已经存在的内容更明显。</p>
<h2 id=在-synchronized-和-reentrantlock-之间选择>在 synchronized 和 ReentrantLock 之间选择</h2>
<p>ReentrantLock 在加锁和内存上提供的语义与内置锁相同，此外还提供了一些其他功能，包括定时的锁等待、可中断的锁等待、公平性，以及实现非块结构的加锁。ReentrantLock 在性能上似乎优于内置锁，其中在 Java 6 中略有胜出，而在 Java 5.0 中则是远远胜出。那么为什么不放弃 synchronized，并在所有新的并发代码中都使用 ReentrantLock？事实上有些作者已经建议这么做了，将 synchronized 作为一种“遗留”结构，但这会将好事情变坏。</p>
<p>与显式锁相比，内置锁仍然具有很大的优势。内置锁为许多开发人员所熟悉，并且间接紧凑，而且在很多现有的程序中都使用了内置锁——如果将这两种机制混用，那么不仅会容易令人迷惑，也容易发生错误。ReentrantLock 的危险性比同步机制要高，如果忘记在 finally 块中调用 unlock，那么虽然代码表面上能继续正常运行，但实际上已经买下了一颗定时炸弹，并很有可能伤及其他代码。仅当内置锁不能满足需求时，才可以考虑使用 ReentrantLock。</p>
<blockquote>
<p>在一些内置锁无法满足需求的情况下，ReentrantLock 可以作为一种高级工具。当需要一些高级功能时才应该使用 ReentrantLock，这些功能包括：可定时的、可轮询的与可中断的锁获取操作，公平队列，以及非块结构的锁。否则，还是应该优先使用内置锁。</p>
</blockquote>
<p>在 Java 5.0 中，内置锁与 ReentrantLock 相比还有一个优点：在线程转储中能够给出在哪些调用帧中获得了哪些锁，并能够检测和识别发生死锁的线程。JVM 并不知道哪些线程持有 ReentrantLock，因此咋调试使用 ReentrantLock 的线程问题时，将起不到帮助作用。Java 6 解决了这个问题，它提供了一个管理和调试接口，锁可以通过该接口进行注册，从而与 ReentrantLock 相关的加锁信息就能出现在线程转储中，并通过其他的管理接口和调试接口来访问。与 synchronized 相比，这些调试消息是一种重要的优势，即便它们大部分都是临时性消息，线程转储中的加锁能够给很多程序员的带来帮助。ReentrantLock 的非块结构特性仍然意味着，获取锁的操作不能与特定的帧栈关联起来，而内置锁却可以。</p>
<p>未来可能会提升 synchronized 而不是 ReentrantLock 的性能。因为 synchronized 是 JVM 内置的属性，它能执行一些优化，例如对线程封闭的锁对象的锁执行消除优化，通过增加锁的粒度来消除内置锁的同步，而如果通过基于类库的锁来实现这些功能，则可能性不大。除非将来需要在 Java 5 上部署应用程序，并且在该平台上确实需要 ReentrantLock 包含的伸缩性优势，否则就性能方面来说，应该选择内置锁而不是 ReentrantLock。</p>
<h2 id=135-读写锁>13.5 读写锁</h2>
<p>ReentrantLock 实现了一种标准的互斥锁：每次最多有一个线程能持有 ReentrantLock。但对于维护数据的完整性来说，互斥通常是一种过于强硬的加锁规则，因此也就不必要的限制了并发性。互斥是一种保守的加锁策略，虽然可以避免“写写”冲突和“读写”冲突，但同时也避免了“读读”冲突。在许多情况下，数据结构上的操作大多是“读”操作——虽然他们也是可变的并且在某些情况下会被修改，但其中大多数访问操作都是读操作。此时，如果能够放宽加锁需求，允许多个执行读操作的线程同时访问数据结构，那么将提升程序的性能。只要每个线程都能确保读取到最新的数据，并且在读取数据时不会有其他的线程修改数据，那么就不会出现问题。在这种情况下就可以使用读写锁：一个资源可以被多个读操作同时访问，或者被一个写操作独占访问，但读写不能同时进行。</p>
<p>在程序清单 13-6 的 ReadWritLock 中暴露了两个 Lock 对象，其中一个用于读操作，另一个用于写操作。要读取由 ReadWriteLock 保护的数据，必须首先获得读取锁。尽管这两个锁看上去彼此独立，但读锁和写锁这是整个读写锁的不同视图。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>interface</span> <span style=color:#000>ReadWriteLock</span> <span style=color:#ce5c00;font-weight:700>{</span>
  <span style=color:#000>Lock</span> <span style=color:#000>readLock</span><span style=color:#ce5c00;font-weight:700>();</span>
  <span style=color:#000>Lock</span> <span style=color:#000>writeLock</span><span style=color:#ce5c00;font-weight:700>();</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>在读写锁实现的加锁策略中，允许多个读操作同时进行，但每次只允许一个写操作。与 Lock 一样，ReadWriteLock 可以采用多种不同的实现方式，这些方式在性能、调度保证、获取优先性、公平性以及加锁语义等方面可能有所不同。</p>
<p>读写锁是一种性能优化措施，在一些特定的情况下能实现更高的并发性。在实际情况中，对于在多处理器系统上被频繁读取的数据结构，读写锁能够提高性能。而在其他情况下，读写锁的性能比独占锁的性能要略差一些，这是因为他们的复杂性很高。如果要判断在某种情况下使用读写锁是否会带来性能提升，最好对程序进行分析。由于 ReadWriteLock 使用 Lock 来实现锁的读写部分，因此如果分析结果表明读写锁没有提高性能，那么可以很容易的将读写锁换位独占锁。</p>
<p>在读锁和写锁之间的交互可以采用多种实现方式。ReadWriteLock 中的一些可选实现包括：</p>
<p><strong>释放优先</strong>。当一个写入操作释放写入锁时，并且队列中同时存在读线程和写线程，那么应该优先选择读线程、写线程、还是最先发出请求的线程？</p>
<p><strong>读线程插队</strong>。如果锁由读线程持有，但有写线程正在等待，那么新到达的读线程能否立即获得访问权，还是应该在写线程后面等待？如果允许读线程插队到写线程之前，呢么将提高并发性，但却可能造成写线程发生饥饿问题。</p>
<p><strong>重入性</strong>。读锁和写锁是否是可重入的？</p>
<p><strong>降级</strong>。如果一个线程持有写锁，那么它能否在不释放该锁的情况下获得读锁？这可能会使得写锁被降级为读锁，同时不允许其他写线程修改被保护的资源。</p>
<p><strong>升级</strong>。读锁能否有限于其他正在等待的读、写线程而升级为一个写入锁？在大多数的读-写锁实现中并不支持升级，因为如果没有显式的升级操作，那么很容易造成死锁。(如果两个读线程视图同时升级为写入锁，那么二者都不会释放读取所)。</p>
<p>ReentrantReadWriteLock 为这两种锁都提供了可重入的加锁语义。与 ReentrantLock 类似，ReentrantReadWriteLock 在构造时可以选择公平性。在公平的锁时等待时间最长的线程将优先获得锁。如果这个锁由度线程持有，而另一个线程请求写入锁，那么其他读线程都不能获得读锁，直到写线程使用完并释放了写锁。在非公平的锁中，线程获得访问许可的顺序是不确定的。写线程降级为读线程是可以的，但从读线程升级为写线程是不可以的(这样做会导致死锁)。</p>
<p>与 ReentrantLock 类似的是：ReentrantReadWriteLock 中的写锁是独占的，并且只能由获得该锁的线程来释放。在 Java 5 中，读锁的行为更类似于一个 Semaphore 而不是锁，它只维护活跃的读线程的数量，而不考虑它们的标识。在 Java 6 中修改了这个行为：将会记录哪些线程已经获得了读锁。</p>
<p>当锁的持有时间较长且大部分操作都不会修改被保护的资源时，那么读写锁能提高并发性。在程序清单 13-7 的 ReadWriteMap 中使用了 ReentrantReadWriteLock 来包装 Map，从而使它能在读线程之间被安全的共享，并且仍然能够避免“读写”或“写写”冲突。在实现中，ConcurrentHashMap 的性能已经很好了，因此如果只是需要一个并发的基于散列的映射，那么就可以使用 ConcurrentHashMap 来代替这种方法，但如果需要对另一种 Map 实现(如 LinkedHashMap)提供并发性更高的访问，那么可以使用这种技术。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>ReadWriteMap</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>K</span><span style=color:#ce5c00;font-weight:700>,</span><span style=color:#000>V</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#ce5c00;font-weight:700>{</span>

  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>Map</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>K</span><span style=color:#ce5c00;font-weight:700>,</span><span style=color:#000>V</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>map</span><span style=color:#ce5c00;font-weight:700>;</span> 
  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>ReadWriteLock</span> <span style=color:#000>lock</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>ReentrantReadWriteLock</span><span style=color:#ce5c00;font-weight:700>();</span> 
  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>Lock</span> <span style=color:#000>r</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>lock</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>readLock</span><span style=color:#ce5c00;font-weight:700>();</span> 
  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>Lock</span> <span style=color:#000>w</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>lock</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>writeLock</span><span style=color:#ce5c00;font-weight:700>();</span>

  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#000>ReadWriteMap</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>Map</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>K</span><span style=color:#ce5c00;font-weight:700>,</span><span style=color:#000>V</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>map</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span> 
    <span style=color:#204a87;font-weight:700>this</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>map</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>map</span><span style=color:#ce5c00;font-weight:700>;</span> 
  <span style=color:#ce5c00;font-weight:700>}</span>

  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#000>V</span> <span style=color:#000>put</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>K</span> <span style=color:#000>key</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>V</span> <span style=color:#000>value</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span> 
    <span style=color:#000>w</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>lock</span><span style=color:#ce5c00;font-weight:700>();</span> 
    <span style=color:#204a87;font-weight:700>try</span> <span style=color:#ce5c00;font-weight:700>{</span> 
      <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>map</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>put</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>key</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>value</span><span style=color:#ce5c00;font-weight:700>);</span> 
    <span style=color:#ce5c00;font-weight:700>}</span> <span style=color:#204a87;font-weight:700>finally</span> <span style=color:#ce5c00;font-weight:700>{</span> 
      <span style=color:#000>w</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>unlock</span><span style=color:#ce5c00;font-weight:700>();</span> 
    <span style=color:#ce5c00;font-weight:700>}</span> 
  <span style=color:#ce5c00;font-weight:700>}</span> 
  <span style=color:#8f5902;font-style:italic>// Do the same for remove(), putAll(), clear()
</span><span style=color:#8f5902;font-style:italic></span>
  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#000>V</span> <span style=color:#000>get</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>Object</span> <span style=color:#000>key</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span> 
    <span style=color:#000>r</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>lock</span><span style=color:#ce5c00;font-weight:700>();</span> 
    <span style=color:#204a87;font-weight:700>try</span> <span style=color:#ce5c00;font-weight:700>{</span> 
      <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>map</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>get</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>key</span><span style=color:#ce5c00;font-weight:700>);</span> 
    <span style=color:#ce5c00;font-weight:700>}</span> <span style=color:#204a87;font-weight:700>finally</span> <span style=color:#ce5c00;font-weight:700>{</span> 
      <span style=color:#000>r</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>unlock</span><span style=color:#ce5c00;font-weight:700>();</span> 
    <span style=color:#ce5c00;font-weight:700>}</span> 
  <span style=color:#ce5c00;font-weight:700>}</span> 
  <span style=color:#8f5902;font-style:italic>// Do the same for other read-only Map methods
</span><span style=color:#8f5902;font-style:italic></span><span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>图 13-3 给出了分别用 ReentrantLock 和 ReadWriteLock 来封装 ArrayList 的吞吐量比较，测试程序在 4 路的 Opteron 系统上运行，操作系统为 Solaris。这里使用的测试程序与本书使用的 Map 性能测试基本类似——每个操作都随机选择一个值并在容器中查找该值，并且只有少量的操作会修改这个容器中的内容。</p>
<div align=center>
<img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20181118175438.png style=display:block;width:70% alt=13-3 align=center>
</div>
<h2 id=小结>小结</h2>
<p>与内置锁相比，显式 Lock 提供了一些扩展功能，在处理锁的不可用性方面有着更高的灵活性，并且对队列行有着更好的控制。但 ReentrantLock 不能完全替代内置锁，只有在内置锁无法满足需求时，才应该使用它。</p>
<p>读写锁允许多个读线程并发的访问被保护的对象，当访问以读取操作为主的数据结构时，它能提高程序的可伸缩性。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-3eb4fd5dd1e91653a446b51ef13a16f9>14 - CH14-自定义扩展</h1>
<p>类库中包含了很多存在状态依赖的类，比如 FutureTask、Semaphore、BlockingQueue 等。在这些类的操作中有着基于状态的前提条件，比如，不能从一个空队列中删除元素，或者获取一个尚未结束的任务的计算结果，在这些操作可以执行之前，必须等到对了进入“非空”状态，或者任务进入“已完成”状态。</p>
<p>创建状态依赖类的最简单方式通常是在类库中现有的状态依赖类的基础上进行构建。比如，在第 8 章的 ValueLatch 中就采用了这种方法，其中使用了 CountDownLatch 来提供所需的阻塞行为。但如果类库中没有提供所需的功能，那么还可以使用 Java 语言和类库提供的底层机制来构造自己的同步机制，包括内置的条件队列、显式的 Condition 对象以及 AbstractQueuedSynchronizer 框架。本章将介绍实现状态依赖性的各种选择，以及在使用平台提供的状态依赖性机制时需要遵守的各项规则。</p>
<h2 id=141-状态依赖性的管理>14.1 状态依赖性的管理</h2>
<p>在单线程程序中调用一个方法时，如果某个基于状态的前置条件未得到满足(比如“连接池必须为空”)，那么这个条件将永远无法为真。因此，在编写串行程序中的类时，要使得这些类在他们的前提条件未满足时就失败。但在并发程序中，基于状态的条件可能会由于其他线程的操作而改变：一个资源池可能在几条指令之前还是空的，但稍后却被填充，因为另一个线程可能会返回一个元素到资源池。对于并发对象上依赖状态的方法，虽然有时候在前提条件不满足的情况下也不会失败，但通常有一种更好的选择，即等待前提提交转变为真。</p>
<p>依赖状态的操作可以一直阻塞到可以继续执行，这比使它们先失败再实现起来要更为方便且不易出错。内置的条件对了可以使线程一直阻塞，直到对象进入某个进程可以继续执行的状态，并且当被阻塞的线程可以执行时再唤醒它们。我们将在 14.2 节介绍条件队列的详细内容，但为了突出高效的条件等待机制的价值，我们将首先介绍如何通过轮询与休眠等方式来(勉强的)解决状态依赖问题。</p>
<p>可阻塞的状态依赖操作的形式如程序清单 14-1 所示。这种加锁模式有些不同寻常，因为锁是在操作的执行过程中被释放并重新获取的。构成前提条件的状态标量必须由对象的锁来保护，从而使它们在检查前提条件的同时保持不变。如果前提条件尚未满足，就必须释放锁，以便其他线程可以修改对象的状态，否则，前提条件就永远无法被转变为真。在再次检查前提条件之前，又必须重新获得锁。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>blockingAction</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#204a87;font-weight:700>throws</span> <span style=color:#000>InterruptedException</span> <span style=color:#ce5c00;font-weight:700>{</span> 
  <span style=color:#000>acquire</span> <span style=color:#000>lock</span> <span style=color:#000>on</span> <span style=color:#000>object</span> <span style=color:#000>state</span> 
  <span style=color:#000>while</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>precondition</span> <span style=color:#000>does</span> <span style=color:#000>not</span> <span style=color:#000>hold</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span> 
    <span style=color:#000>release</span> <span style=color:#000>lock</span> 
    <span style=color:#000>wait</span> <span style=color:#000>until</span> <span style=color:#000>precondition</span> <span style=color:#000>might</span> <span style=color:#000>hold</span> 
    <span style=color:#000>optionally</span> <span style=color:#000>fail</span> <span style=color:#204a87;font-weight:700>if</span> <span style=color:#000>interrupted</span> <span style=color:#000>or</span> <span style=color:#000>timeout</span> <span style=color:#000>expires</span> 
    <span style=color:#000>reacquire</span> <span style=color:#000>lock</span> 
  <span style=color:#ce5c00;font-weight:700>}</span> 
  <span style=color:#000>perform</span> <span style=color:#000>action</span> 
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>在生成消费设计中经常会使用像 ArrayBlockingQueue 这样的有界缓存。在有界缓存提供的 put 和 take 操作中都包含一个前提条件：不能从空缓存中获取元素，也不能讲元素放入已满的缓存中。当前提条件未满足时，依赖状态的操作可以抛出一个异常或者返回一个错误状态(使其成为调用者的一个问题)，也可以保持阻塞直到对象进入正确的状态。</p>
<p>接下来介绍有界缓存的几种实现，其中将采用不同的方法来处理前提条件失败的问题。在每种实现中都扩展了程序清单 14-2 中的 BaseBoundedBuffer，在这个类中实现了一个基于数组的循环缓存，其中各个缓存状态变量均由缓存的内置锁来保护。它还提供了同步的 doPut 和 doTake 方法，并在子类中通过这些方法来实现 put 和 take 操作，底层的状态将对子类隐藏。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#5c35cc;font-weight:700>@ThreadSafe</span> <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>abstract</span> <span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>BaseBoundedBuffer</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>V</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#ce5c00;font-weight:700>{</span>

  <span style=color:#5c35cc;font-weight:700>@GuardedBy</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#4e9a06>&#34;this&#34;</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>V</span><span style=color:#ce5c00;font-weight:700>[]</span> <span style=color:#000>buf</span><span style=color:#ce5c00;font-weight:700>;</span> 
  <span style=color:#5c35cc;font-weight:700>@GuardedBy</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#4e9a06>&#34;this&#34;</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>tail</span><span style=color:#ce5c00;font-weight:700>;</span> 
  <span style=color:#5c35cc;font-weight:700>@GuardedBy</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#4e9a06>&#34;this&#34;</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>head</span><span style=color:#ce5c00;font-weight:700>;</span> 
  <span style=color:#5c35cc;font-weight:700>@GuardedBy</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#4e9a06>&#34;this&#34;</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>count</span><span style=color:#ce5c00;font-weight:700>;</span>

  <span style=color:#204a87;font-weight:700>protected</span> <span style=color:#000>BaseBoundedBuffer</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>capacity</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span> 
    <span style=color:#204a87;font-weight:700>this</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>buf</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>V</span><span style=color:#ce5c00;font-weight:700>[])</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>Object</span><span style=color:#ce5c00;font-weight:700>[</span><span style=color:#000>capacity</span><span style=color:#ce5c00;font-weight:700>];</span> 
  <span style=color:#ce5c00;font-weight:700>}</span>

  <span style=color:#204a87;font-weight:700>protected</span> <span style=color:#204a87;font-weight:700>synchronized</span> <span style=color:#204a87;font-weight:700>final</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>doPut</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>V</span> <span style=color:#000>v</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span> 
    <span style=color:#000>buf</span><span style=color:#ce5c00;font-weight:700>[</span><span style=color:#000>tail</span><span style=color:#ce5c00;font-weight:700>]</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>v</span><span style=color:#ce5c00;font-weight:700>;</span> 
    <span style=color:#204a87;font-weight:700>if</span> <span style=color:#ce5c00;font-weight:700>(++</span><span style=color:#000>tail</span> <span style=color:#ce5c00;font-weight:700>==</span> <span style=color:#000>buf</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>length</span><span style=color:#ce5c00;font-weight:700>)</span> 
      <span style=color:#000>tail</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>0</span><span style=color:#ce5c00;font-weight:700>;</span> 
    <span style=color:#ce5c00;font-weight:700>++</span><span style=color:#000>count</span><span style=color:#ce5c00;font-weight:700>;</span> 
  <span style=color:#ce5c00;font-weight:700>}</span>

  <span style=color:#204a87;font-weight:700>protected</span> <span style=color:#204a87;font-weight:700>synchronized</span> <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>V</span> <span style=color:#000>doTake</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span> 
    <span style=color:#000>V</span> <span style=color:#000>v</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>buf</span><span style=color:#ce5c00;font-weight:700>[</span><span style=color:#000>head</span><span style=color:#ce5c00;font-weight:700>];</span> 
    <span style=color:#000>buf</span><span style=color:#ce5c00;font-weight:700>[</span><span style=color:#000>head</span><span style=color:#ce5c00;font-weight:700>]</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>null</span><span style=color:#ce5c00;font-weight:700>;</span> 
    <span style=color:#204a87;font-weight:700>if</span> <span style=color:#ce5c00;font-weight:700>(++</span><span style=color:#000>head</span> <span style=color:#ce5c00;font-weight:700>==</span> <span style=color:#000>buf</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>length</span><span style=color:#ce5c00;font-weight:700>)</span> 
      <span style=color:#000>head</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>0</span><span style=color:#ce5c00;font-weight:700>;</span> 
    <span style=color:#ce5c00;font-weight:700>--</span><span style=color:#000>count</span><span style=color:#ce5c00;font-weight:700>;</span> 
    <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>v</span><span style=color:#ce5c00;font-weight:700>;</span> 
  <span style=color:#ce5c00;font-weight:700>}</span>

  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>synchronized</span> <span style=color:#204a87;font-weight:700>final</span> <span style=color:#204a87;font-weight:700>boolean</span> <span style=color:#000>isFull</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span> 
    <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>count</span> <span style=color:#ce5c00;font-weight:700>==</span> <span style=color:#000>buf</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>length</span><span style=color:#ce5c00;font-weight:700>;</span> 
  <span style=color:#ce5c00;font-weight:700>}</span>

  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>synchronized</span> <span style=color:#204a87;font-weight:700>final</span> <span style=color:#204a87;font-weight:700>boolean</span> <span style=color:#000>isEmpty</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span> 
    <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>count</span> <span style=color:#ce5c00;font-weight:700>==</span> <span style=color:#000>0</span><span style=color:#ce5c00;font-weight:700>;</span> 
  <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><h3 id=1411-示例将前提条件的失败传递给调用者>14.1.1 示例：将前提条件的失败传递给调用者</h3>
<p>程序清单 14-3 的 GrumpyBoundedBuffer 是第一个简单的有界缓存实现。put 和 take 方法都进行了同步以确保实现对缓存状态的独占访问，因为这两个方法都进行了同步以确保实现对缓存状态的独占访问，因为这两个方法在访问缓存时都采用“先检查再运行”的逻辑策略。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#5c35cc;font-weight:700>@ThreadSafe</span> <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>GrumpyBoundedBuffer</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>V</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#204a87;font-weight:700>extends</span> <span style=color:#000>BaseBoundedBuffer</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>V</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#ce5c00;font-weight:700>{</span> 
  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#000>GrumpyBoundedBuffer</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>size</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span> <span style=color:#204a87;font-weight:700>super</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>size</span><span style=color:#ce5c00;font-weight:700>);</span> <span style=color:#ce5c00;font-weight:700>}</span>

  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>synchronized</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>put</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>V</span> <span style=color:#000>v</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#204a87;font-weight:700>throws</span> <span style=color:#000>BufferFullException</span> <span style=color:#ce5c00;font-weight:700>{</span> 
    <span style=color:#204a87;font-weight:700>if</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>isFull</span><span style=color:#ce5c00;font-weight:700>())</span> 
      <span style=color:#204a87;font-weight:700>throw</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>BufferFullException</span><span style=color:#ce5c00;font-weight:700>();</span> 
    <span style=color:#000>doPut</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>v</span><span style=color:#ce5c00;font-weight:700>);</span> 
  <span style=color:#ce5c00;font-weight:700>}</span>

  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>synchronized</span> <span style=color:#000>V</span> <span style=color:#000>take</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#204a87;font-weight:700>throws</span> <span style=color:#000>BufferEmptyException</span> <span style=color:#ce5c00;font-weight:700>{</span> 
    <span style=color:#204a87;font-weight:700>if</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>isEmpty</span><span style=color:#ce5c00;font-weight:700>())</span> 
      <span style=color:#204a87;font-weight:700>throw</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>BufferEmptyException</span><span style=color:#ce5c00;font-weight:700>();</span>
    <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>doTake</span><span style=color:#ce5c00;font-weight:700>();</span> 
  <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>尽管这种方法实现起来很简单，但使用起来却并非如此。异常应该用于真正发生异常条件的场景。“缓存已满”并不不是有界缓存的一个异常条件，就像“红灯”并不表示交通信号灯出现了异常。在实现缓存时得到的简化(直接抛出异常，由使调用者管理状态依赖性)并不能抵消在使用时存在的复杂性，因为现在调用者必须做好捕获异常的准备，并且在每次缓存操作时都需要重试。程序清单 14-4 给出了对 take 的调用——并不是很漂亮，尤其是当程序中很多地方都要调用 put 和 take 方法时。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#204a87;font-weight:700>while</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>true</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
  <span style=color:#204a87;font-weight:700>try</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#000>V</span> <span style=color:#000>item</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>buffer</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>take</span><span style=color:#ce5c00;font-weight:700>();</span>
    <span style=color:#8f5902;font-style:italic>// 对 item 执行一些操作
</span><span style=color:#8f5902;font-style:italic></span>    <span style=color:#204a87;font-weight:700>break</span><span style=color:#ce5c00;font-weight:700>;</span>
  <span style=color:#ce5c00;font-weight:700>}</span> <span style=color:#204a87;font-weight:700>catch</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>BufferEmptyException</span> <span style=color:#000>e</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#000>Thread</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>sleep</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>SLEEP_GRANULARITY</span><span style=color:#ce5c00;font-weight:700>);</span>
  <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>这种方法的一种变化形式是，当缓存处于一种错误的状态时返回一个错误值。这是一种改进，因为并没有放弃异常机制，抛出的异常意味着“对不起，请再试一次”。但这种方法并没有解决根本问题：调用者需要自行处理前置条件失败的情况。</p>
<p>程序清单 14-4 中的客户端代码并非实现重试的唯一方式。调用者可以不用进入休眠状态，而直接重新调用 take 方法，这种方式被称为忙等待或自旋等待。如果缓存的状态在很长一段时间内都不会发生变化，那么使用这种方式将会消耗大量的 CPU 时间。但是，调用者也可以进入休眠状态来避免消耗过多的 CPU 时间，但如果缓存的状态在刚调用完 sleep 就立即发生了变化，那么将不必要的休眠一段时间。因此，客户端代码必须在二者之间进行选择：要么容忍自旋导致的 CPU 时钟周期浪费，要么容忍由于休眠而导致的低响应性。(除了忙等待与休眠之外，还有一种选择是调用 Thread.yield，这相当于给调度器一个提示：现在需要让出一定的 CPU 时间给别的线程运行。假设正在等待另一个线程执行工作，那么如果选择让出处理器而不是消耗完整个 CPU 调度时间片，那么可以使整体的执行过程变快。)</p>
<h3 id=1412-示例通过轮询与休眠来实现简单的阻塞>14.1.2 示例：通过轮询与休眠来实现简单的阻塞</h3>
<p>程序清单 14-5 中的 SleepyBoundedBuffer 尝试通过 put 和 take 方法来实现一种简单的“轮询与休眠”重试机制，从而使调用者无需在每次调用时都实现重试逻辑。如果缓存为空，那么 take 将休眠直到另一个线程向缓存中放入数据；如果缓存是满的，那么 put 将休眠直到另一个线程从缓存中取出一些数据，以便有空间容纳新的数据。这种方法将前置条件的管理操作封装了起来，并简化了对缓存的作用——这正是朝着正确的改进方向迈进了一步。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#5c35cc;font-weight:700>@ThreadSafe</span> 
<span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>SleepyBoundedBuffer</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>V</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#204a87;font-weight:700>extends</span> <span style=color:#000>BaseBoundedBuffer</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>V</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#ce5c00;font-weight:700>{</span> 
  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#000>SleepyBoundedBuffer</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>size</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span> <span style=color:#204a87;font-weight:700>super</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>size</span><span style=color:#ce5c00;font-weight:700>);</span> <span style=color:#ce5c00;font-weight:700>}</span>

  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>put</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>V</span> <span style=color:#000>v</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#204a87;font-weight:700>throws</span> <span style=color:#000>InterruptedException</span> <span style=color:#ce5c00;font-weight:700>{</span> 
    <span style=color:#204a87;font-weight:700>while</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>true</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span> 
      <span style=color:#204a87;font-weight:700>synchronized</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>this</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span> 
        <span style=color:#204a87;font-weight:700>if</span> <span style=color:#ce5c00;font-weight:700>(!</span><span style=color:#000>isFull</span><span style=color:#ce5c00;font-weight:700>())</span> <span style=color:#ce5c00;font-weight:700>{</span> 
          <span style=color:#000>doPut</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>v</span><span style=color:#ce5c00;font-weight:700>);</span> 
          <span style=color:#204a87;font-weight:700>return</span><span style=color:#ce5c00;font-weight:700>;</span> 
        <span style=color:#ce5c00;font-weight:700>}</span>
      <span style=color:#ce5c00;font-weight:700>}</span>
      <span style=color:#000>Thread</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>sleep</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>SLEEP_GRANULARITY</span><span style=color:#ce5c00;font-weight:700>);</span>
    <span style=color:#ce5c00;font-weight:700>}</span>
  <span style=color:#ce5c00;font-weight:700>}</span>

  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#000>V</span> <span style=color:#000>take</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#204a87;font-weight:700>throws</span> <span style=color:#000>InterruptedException</span> <span style=color:#ce5c00;font-weight:700>{</span> 
    <span style=color:#204a87;font-weight:700>while</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>true</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span> 
      <span style=color:#204a87;font-weight:700>synchronized</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>this</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span> 
        <span style=color:#204a87;font-weight:700>if</span> <span style=color:#ce5c00;font-weight:700>(!</span><span style=color:#000>isEmpty</span><span style=color:#ce5c00;font-weight:700>())</span> 
          <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>doTake</span><span style=color:#ce5c00;font-weight:700>();</span> 
      <span style=color:#ce5c00;font-weight:700>}</span> 
      <span style=color:#000>Thread</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>sleep</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>SLEEP_GRANULARITY</span><span style=color:#ce5c00;font-weight:700>);</span> 
    <span style=color:#ce5c00;font-weight:700>}</span> 
  <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>SleepyBoundedBuffer 的实现远比之前的实现要复杂。缓存代码必须在持有缓存锁的时候才能测试相应的状态条件，因为表示状态条件的变量是由缓存锁保护的。如果检查失败，那么当前执行的线程首先释放锁并休眠一段时间，从而使其他线程能够访问缓存。当线程醒来时，它将重新请求锁并再次尝试执行操作，因而线程将反复的在休眠以及测试条件等过程之间进行切换，直到可以执行操作为止。</p>
<p>从调用者的角度来看，这种方法能很好的运行，如果某个操作可以执行，那么就立即执行，否则就阻塞，调用者无需处理失败和重试。要选择合适的休眠时间间隔，就需要在响应性与 CPU 使用率之间进行权衡。休眠的间隔越小，响应性就越高，但消耗的 CPU 资源也越高。图 14-1 给出了休眠间隔对响应性的影响：在缓存中出现可用空间的时刻与线程醒来并再次执行检查的时刻之间可能存在延迟。</p>
<div align=center>
<img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20181118175653.png style=display:block;width:70% alt=14-1 align=center>
</div>
<p>SleepyBoundedBuffer 给调用者提出了一个新的需求：处理中断异常。当一个方法由于等待某个条件为真而阻塞时，需要提供一种取消机制。与大多数具备良好行为的阻塞库方法一样，SleepyBoundedBuffer 通过中断来支持取消，如果该方法被中断，那么将提前返回并抛出中断异常。</p>
<p>这种通过轮询与休眠来实现阻塞操作的过程需要付出大量的努力。如果存在某种挂起线程的方法，并且这种方法能够确保当某个条件为真时线程会立即醒来，那么将极大的简化实现工作。这正是条件队列实现的功能。</p>
<h3 id=1413-条件队列>14.1.3 条件队列</h3>
<p>条件队列就好像烤面包机中通知“面包已烤好”的铃声。如果你注意听着铃声，那么当面包烤好后可以立即得到通知，然后放下手头的事情(或者先把手头的事情做完，例如先看完报纸)开始品尝面包。如果没有听见铃声(可能出去拿报纸了)，那么会错过通知消息，但回到厨房时还可以观察烤面包机的状态，如果已经烤好，那么就取出面包，如果尚未烤好，就再次开始留意铃声。</p>
<p>“条件队列”这个名字的来源是：它使得一组线程(称为等待线程集合)能够通过某种方式来等待特定的条件变为真。传统队列的元素是一个个数据，与之不同的是，条件队列中的元素是一个个正在等待相关条件的线程。</p>
<p>正如每个 Java 对象都可以作为一个锁，每个对象同样可以作为一个条件队列，并且 Object 中的 wait、notify、notifyAll 方法就构成了内部条件队列的 API。对象的内置锁与其内部条件队列是相互关联的，要调用对象 X 中条件队列的任何一个方法，必须持有对象 X 上的锁。这是因为“等待由状态构成的条件”与“维护状态一致性”这两种机制必须紧密的被绑定在一起：只有能对状态进行检查时，才能在某个条件上等待，并且只有能修改状态时，才能从条件等待中释放另一个线程。</p>
<p>Object.wait 会自动释放锁，并请求操作系统挂起当前线程，从而使其他线程能够获得这个锁并修改对象的状态。当被挂起的线程醒来时，它将在返回之前重新获取锁。从直观上来理解，调用 wait 意味着“我要去休息了”，但当发生特定的事情时唤醒为，而调用通知方法就意味着“特定的事情发生了”。</p>
<p>在程序清单 14-6 中的 BoundedBuffer 使用了 wait 和 notifyAll 来实现一个有界缓存。这比使用“休眠”的有界缓存更加简单，并且更加高效(当缓存状态没有发生变化时，线程醒来的次数将更少)，响应性也更高(当发生特定状态变化时将立即醒来)。这是一个较大的改进，但要注意：与使用“休眠”的有界缓存相比，条件队列并没有改变原来的语义。它只是在多个方面进行了优化：CPU 效率、上下文切换开销和响应性等。如果某个功能无法通过“轮询与休眠”来实现，那么使用条件队列也无法实现，但条件队列使得在表达和管理状态依赖性时更加简单和高效。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#5c35cc;font-weight:700>@ThreadSafe</span> 
<span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>BoundedBuffer</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>V</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#204a87;font-weight:700>extends</span> <span style=color:#000>BaseBoundedBuffer</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>V</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#ce5c00;font-weight:700>{</span>

  <span style=color:#8f5902;font-style:italic>// CONDITION PREDICATE: not-full (!isFull())
</span><span style=color:#8f5902;font-style:italic></span>  <span style=color:#8f5902;font-style:italic>// CONDITION PREDICATE: not-empty (!isEmpty())
</span><span style=color:#8f5902;font-style:italic></span>
  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#000>BoundedBuffer</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>size</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span> <span style=color:#204a87;font-weight:700>super</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>size</span><span style=color:#ce5c00;font-weight:700>);</span> <span style=color:#ce5c00;font-weight:700>}</span>

  <span style=color:#8f5902;font-style:italic>// BLOCKS-UNTIL: not-full 
</span><span style=color:#8f5902;font-style:italic></span>  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>synchronized</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>put</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>V</span> <span style=color:#000>v</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#204a87;font-weight:700>throws</span> <span style=color:#000>InterruptedException</span> <span style=color:#ce5c00;font-weight:700>{</span> 
    <span style=color:#204a87;font-weight:700>while</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>isFull</span><span style=color:#ce5c00;font-weight:700>())</span> 
      <span style=color:#000>wait</span><span style=color:#ce5c00;font-weight:700>();</span> 
    <span style=color:#000>doPut</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>v</span><span style=color:#ce5c00;font-weight:700>);</span> 
    <span style=color:#000>notifyAll</span><span style=color:#ce5c00;font-weight:700>();</span> 
  <span style=color:#ce5c00;font-weight:700>}</span>

  <span style=color:#8f5902;font-style:italic>// BLOCKS-UNTIL: not-empty 
</span><span style=color:#8f5902;font-style:italic></span>  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>synchronized</span> <span style=color:#000>V</span> <span style=color:#000>take</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#204a87;font-weight:700>throws</span> <span style=color:#000>InterruptedException</span> <span style=color:#ce5c00;font-weight:700>{</span> 
    <span style=color:#204a87;font-weight:700>while</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>isEmpty</span><span style=color:#ce5c00;font-weight:700>())</span> 
      <span style=color:#000>wait</span><span style=color:#ce5c00;font-weight:700>();</span> 
    <span style=color:#000>V</span> <span style=color:#000>v</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>doTake</span><span style=color:#ce5c00;font-weight:700>();</span> 
    <span style=color:#000>notifyAll</span><span style=color:#ce5c00;font-weight:700>();</span> 
    <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>v</span><span style=color:#ce5c00;font-weight:700>;</span> 
  <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>最终，BoundedBuffer 变得足够好了，不仅简单易用，而且实现了明确的状态依赖性管理。在产品的正式版本中还应该包括限时版本的 put 和 take，这样当阻塞操作不能在预期的时间内完成时，可以因超时而返回。通过使用定时版本的 Object.wait，可以很容易实现这些方法。</p>
<h2 id=142-使用条件队列>14.2 使用条件队列</h2>
<p>条件队列使构建高效及高可响应性的状态依赖类变得更容易，但同时也很容易被误用。虽然很多规则都能确保正确的使用条件队列，但在编译器或系统平台上却并没有强制要求遵循这些规则。(这也是为什么要尽量基于 LinkedBlockingQueue、Latch、Semaphore 和 FutureTask 等类来构造程序的原因之一，如果能避免使用条件队列，那么实现起来将容易很多。)</p>
<h3 id=1421-条件谓词>14.2.1 条件谓词</h3>
<p>要想正确的使用条件队列，关键是找出对象在哪个条件谓词上等待。条件谓词将在等待与通知等过程中引起很多困惑，因为在 API 中没有对条件谓词进行实例化的方法，并且在 Java 语言规范或 JVM 实现中也没有任何信息可以确保正确的使用它们。事实上，在 Java 语言规范或 Javadoc 中根本没有直接提到过它。但如果没有条件谓词，条件等待机制将无法发挥作用。</p>
<p>条件谓词是使某个操作成为状态依赖操作的前提条件。在有界缓存中，只有当缓存不为空时，take 方法才能执行，否则必须等待。对 take 方法来说，它的条件谓词就是“缓存不为空”，take 方法必须在执行之前必须首先测试条件谓词。同样，put 方法的条件谓词是“缓存不满”。条件谓词是由类中各个状态变量构成的表达式。BaseBoundedBuffer 在测试“缓存不为空”时将把 count 与 0 进行比较，在测试“缓存不满”时将 count 与缓存的大小进行比较。</p>
<blockquote>
<p>将与条件队列相关联的条件谓词以及在这些条件谓词上等待的操作都写入文档。</p>
</blockquote>
<p>在条件等待中存在一种重要的三元关系：加锁、wait 方法、和一个条件谓词。在条件谓词中包含多个状态变量，而状态变量由一个锁来保护，因此在测试条件谓词之前必须先持有这个锁。锁对象与条件队列对象(即调用 wait 和 notify 等方法所在的对象)必须是同一个对象。</p>
<p>在 BoundedBuffer 中，缓存的状态由缓存锁保护，并且缓存对象被用作条件队列。take 方法将获取请求缓存锁，然后对条件谓词(缓存非空)进行测试。如果缓存非空，那么它会移除一个原色，之所以能这么做，是因为 take 此时仍然持有保护缓存状态的锁。</p>
<p>如果条件谓词不为真(缓存为空)，那么 take 方法必须等待直到另一个线程在缓存中放入一个对象。take 将在缓存的内置条件队列上条用 wait 方法，这需要持有条件队列对象上的锁。这是一种严谨的设计，因为 take 方法已经持有在测试条件谓词时(并且如果条件谓词为真，那么在同一个原子操作中修改缓存的状态)需要的锁。wait 方法将释放锁，阻塞当前线程，并等待直到超时，然后线程被中断或者通过一个通知被唤醒。在唤醒进程后，wait 在返回前还要重新获取锁。当线程从 wait 方法中被唤醒时，它在重新请求锁时不具有任何特殊的优先级，而要与任何其他尝试进入同步代码块的线程一起正常的在锁上进行竞争。</p>
<blockquote>
<p>每一次 wait 调用都会隐式的与特定的条件谓词关联起来。当调用某个特定条件谓词的 wait 时，调用者必须已经持有与条件队列相关的锁，并且这个锁必须保护着构成条件谓词的状态变量。</p>
</blockquote>
<h3 id=1422-过早唤醒>14.2.2 过早唤醒</h3>
<p>虽然在锁、条件谓词和条件队列之间的三元关系并不复杂，但 wait 方法的返回并不一定意味着线程正在等待的条件谓词已经变味真了。</p>
<p>内置条件队列可以与多个条件谓词一起使用。当一个线程由于调用 notifyAll 而醒来时，并不意味着该线程正在等待的条件谓词已经为真了。(这就像烤面包机和咖啡机公用一个铃声，而响铃后，你必须检查是哪个设备发出的铃声)。另外，wait 方法还可以“假装”返回，而不是由于某个线程条用了 notify。</p>
<p>当执行控制重新进入调用 wait 的代码时，它已经重新获取与跳进队列相关的锁。现在条件谓词是不是已经为真了呢？或许，在发出通知的线程调用 notifyAll 时，条件谓词可能已经变为真，但在重新获取锁时将再次变为假。在线程被唤醒到 wait 重新获取锁的这段时间内，可能有其他线程已经获取过这个锁，并修改了对象的状态。或者，条件谓词从调用 wait 起根本就没有变为真。你并不知道另一个线程为什么会调用 notifyAll 或 notify，也许是因为与同一个条件队列相关的另一个条件谓词变为了真。“一个条件队列与多个条件谓词相关”是一种很常见的情况——在 BoundedBuffer 中使用的条件队列与“非满”和“非空”两个条件谓词相关。</p>
<p>基于所有这些原因，每当线程从 wait 中醒来时，都必须再次测试条件谓词，如果条件谓词不为真，那么就继续等待(或者失败)。由于线程在条件谓词不为真的情况下也可以反复的醒来，因此必须在一个循环中调用 wait，并在每次迭代中都测试条件谓词。程序清单 14-7 给出了条件等待的标准形式。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>stateDependentMethod</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#204a87;font-weight:700>throws</span> <span style=color:#000>InterruptedException</span> <span style=color:#ce5c00;font-weight:700>{</span> 
  <span style=color:#8f5902;font-style:italic>// condition predicate must be guarded by lock 
</span><span style=color:#8f5902;font-style:italic></span>  <span style=color:#204a87;font-weight:700>synchronized</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>lock</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span> 
    <span style=color:#204a87;font-weight:700>while</span> <span style=color:#ce5c00;font-weight:700>(!</span><span style=color:#000>conditionPredicate</span><span style=color:#ce5c00;font-weight:700>())</span> 
      <span style=color:#000>lock</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>wait</span><span style=color:#ce5c00;font-weight:700>();</span> 
    <span style=color:#8f5902;font-style:italic>// object is now in desired state 
</span><span style=color:#8f5902;font-style:italic></span>  <span style=color:#ce5c00;font-weight:700>}</span> 
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><blockquote>
<p>当使用条件等待时(如 Object.wait 或 Condition.await)：</p>
<ul>
<li>通常都有一个条件谓词——包括一些对象状态的测试，线程在执行前必须首先通过这些测试。</li>
<li>在调用 wait 之前测试条件谓词，并且从 wait 中返回时再次进行测试。</li>
<li>在一个循环中调用 wait。</li>
<li>确保使用与条件队列相关的锁来保护构成条件谓词的各个状态变量。</li>
<li>当调用 wait、notify、notifyAll 方法时，一定要持有与条件队列相关的锁。</li>
<li>在检查条件谓词之后又以及开始执行相应的操作之前，不要释放锁。</li>
</ul>
</blockquote>
<h3 id=1423-丢失的信号>14.2.3 丢失的信号</h3>
<p>第 10 章曾经介讨论过活跃性故障，比如死锁和活锁。另一种形式的活跃性故障是丢失的信号。指的是：线程必须等待一个已经为真的条件，但在开始等待之前没有检查条件谓词。现在，线程将等待一个已经发出的事件。这就好比在启动了烤面包机之后出去拿报纸，当你在屋外时烤面包机的铃声响了，但你没有听到，因此还会坐在厨房的桌子前等待烤面包机的铃声。你可能会等待很长时间。通知并不像你涂在面包上的果酱，它没有“黏附性”。如果线程 A 通知了一个条件队列，而线程 B 随后在这个条件队列上等待，那么线程 B 将不会立即醒来，而是需要另一个通知来唤醒它。像上述程序清单中警示之类的编码错误(比如，没有在调用 wait 之前检测条件谓词)就会导致信号的丢失。如果按照程序清单 14-7 的方式来设计条件等待，那么就不会发生信号丢失事件。</p>
<h3 id=1424-通知>14.2.4 通知</h3>
<p>到目前为止，我们介绍了条件等待的前一半内容：等待。另一半内容则是通知。在有界缓存中，如果缓存为空，那么在调用 take 时将阻塞。在缓存变为非空时，为了使 take 解除阻塞，必须确保在每条使缓存变为非空的代码路径中发出一个通知。在 BoundedBuffer 中，只有一条代码路径，即在 put 方法之后。因此，put 在成功的将一个元素添加到缓存后，将调用 notifyAll。同样，take 在移除一个元素之后将调用 notifyAll，向任何正在等待“非满”条件的线程发出通知：缓存现在有可用的空间了。</p>
<blockquote>
<p>每当在等待一个条件时，一定要确保在条件谓词变为真时通过某种方式发出通知。</p>
</blockquote>
<p>在条件队列 API 中有两个发出通知的方法，即 notifyAll 和 notify。无论调用哪一个，都必须持有与条件队列对象相关联的锁。在调用 notify 时，JVM 会从这个条件对了上等待的多个线程中选择一个来唤醒，而调用 notifyAll 则会唤醒所有在这个条件队列上等待的线程。由于在调用 notify 和 notifyAll 时必须持有条件队列对象的锁，而如果这些等待中的线程此时不能重新获得锁，那么无法从 wait 返回，因此发出通知的线程应该尽快的释放锁，从而确保正在等待的线程尽可能快的解除阻塞。</p>
<p>由于多个线程可以基于不同的条件谓词在同一个条件队列上等待，因此如果使用 notify 而不是 notifyAll，那么将是一种危险的动作，因为单一的通知很容易导致类似信号丢失的问题。</p>
<p>在 BoundedBuffer 中很好的说明了为什么在大多数情况下应该优先使用 notifyAll 而不是单个的 notify。这里的条件队列用于两个不同的条件谓词：“非空”和“非满”。假设线程 A 在条件队列上等待条件谓词 PA，同时线程 B 在同一个条件队列上等待条件谓词 PB。现在，假设 PB 变为真，并且线程 C 执行了一个 notify：JVM 将从它拥有的众多线程中选择一个并唤醒。如果选择了线程 A，那么 A 将被唤醒，并且看到 PA 尚未变为真，因此将继续等待。同时，线程 B 本可以开始执行，却没有被唤醒。这并不是严格意义上的“丢失信号”，而更像是一种“被劫持的”信号，但导致的问题是相同的：线程正在等待一个已经(或者本应该)发生过的信号。</p>
<blockquote>
<p>只有同时满足以下两个条件时，才能用单一的 notify 而不是 notifyAll：</p>
<ol>
<li>所有等待线程的类型都相同。只有一个条件谓词与条件队列相关，并且每个线程在从 wait 返回后将执行相同的操作。</li>
<li>单进单出。在条件变量上的每次通知，最多只能唤醒一个线程来执行。</li>
</ol>
</blockquote>
<p>BoundedBuffer 满足“单进单出”的条件，但不满足“所有等待线程的类型都相同”，因此正在等待的线程可能是在等待“非满”，也可能是在等待“非空”。例如第 5 章的 TestHarness 中使用的“开始阀门”闭锁(单个事件释放一组线程)并不满足“单进单出”的需求，因为这个“开始阀门”将使得多个线程开始执行。</p>
<p>由于大多数类并不满足这些需求，因此普遍认可的做法是优先使用 notifyAll 而不是 notify。虽然 notifyAll 可能比 notify 更低效，但却更容易确保类的行为是正确的。</p>
<p>有些开发人员并不赞同这种“普遍认可的做法”。当只有一个线程可以执行时，如果使用 notifyAll，那么将是低效的，这种低效情况带来的影响有时候很小，但有时候却非常大。如果有 10 个线程在一个条件队列上等待，那么调用 notifyAll 将唤醒每个线程，并使得他们在锁上发生竞争。然后，他们中的大多数或者全部又都回到休眠状态。因而，在每个线程执行一个事件的同时，将出现大量的上下文切换操作以及发生竞争的加锁操作。(最坏的情况是，在使用 notifyAll 时将导致 O(n^2)次唤醒操作，而实际上只需要 n 次唤醒操作就足够了)。这是“性能考虑因素与安全考虑因素互相矛盾”的另一种情况。</p>
<p>在 BoundedBuffer 的 put 和 take 方法中采用的通知机制是保守的：每当将一个对象放入缓存或者从缓存中移走一个对象时，就执行一次通知。我们可以对其进行优化：首先，仅当缓存从空变为非空，或者从满变为非满时，才需要释放一个线程。并且，仅当 put 和 take 影响到这些状态转换时，才发出通知。这也被称为“条件通知”。虽然“条件通知”可以提升性能，但却很难正确的实现(而且还会使子类的实现变得复杂)，因此在使用时应当谨慎。程序清单 14-8 给出了如何在 BoundedBuffer.put 中使用“条件通知”。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>synchronized</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>put</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>V</span> <span style=color:#000>v</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#204a87;font-weight:700>throws</span> <span style=color:#000>InterruptedException</span> <span style=color:#ce5c00;font-weight:700>{</span> 
  <span style=color:#204a87;font-weight:700>while</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>isFull</span><span style=color:#ce5c00;font-weight:700>())</span> 
    <span style=color:#000>wait</span><span style=color:#ce5c00;font-weight:700>();</span> 
  <span style=color:#204a87;font-weight:700>boolean</span> <span style=color:#000>wasEmpty</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>isEmpty</span><span style=color:#ce5c00;font-weight:700>();</span> 
  <span style=color:#000>doPut</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>v</span><span style=color:#ce5c00;font-weight:700>);</span> 
  <span style=color:#204a87;font-weight:700>if</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>wasEmpty</span><span style=color:#ce5c00;font-weight:700>)</span> 
    <span style=color:#000>notifyAll</span><span style=color:#ce5c00;font-weight:700>();</span> 
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>单次通知和条件通知都属于优化措施。通常，在使用这些优化措施时，应该遵循“首先使程序正确的运行，然后再使其运行的更快”这个原则。如果不正确的使用这些优化措施，那么很容易在程序中引入奇怪的活跃性故障。</p>
<h3 id=1425-示例阀门类>14.2.5 示例：阀门类</h3>
<p>在第 5 章的 TestHarness 中使用的“开始阀门闭锁”在初始化时指定的参数为 1，从而创建了一个二元闭锁：它只有两种状态，即初始状态和结束状态。闭锁能阻止线程通过开始阀门，并直到阀门被打开，此时所有的线程都可以通过该阀门。虽然闭锁机制通常能满足需求，但在某些情况下存在一些缺陷：按照这种方式构造的阀门在打开后无法重新关闭。</p>
<p>通过使用条件等待，可以很容易的实现一个可重新打开关闭的 TreadGate 类，如程序清单 14-9 所示。ThreadGate 可以打开和关闭阀门，并提供一个 await 方法，该方法能一直阻塞直到阀门被打开。在 open 方法中使用 notifyAll，这是因为这个类的语义不满足单次通知的“单进单出”测试。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#5c35cc;font-weight:700>@ThreadSafe</span> <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>ThreadGate</span> <span style=color:#ce5c00;font-weight:700>{</span>

  <span style=color:#8f5902;font-style:italic>// CONDITION-PREDICATE: opened-since(n) (isOpen || generation&gt;n) 
</span><span style=color:#8f5902;font-style:italic></span>  <span style=color:#5c35cc;font-weight:700>@GuardedBy</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#4e9a06>&#34;this&#34;</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>boolean</span> <span style=color:#000>isOpen</span><span style=color:#ce5c00;font-weight:700>;</span> 
  <span style=color:#5c35cc;font-weight:700>@GuardedBy</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#4e9a06>&#34;this&#34;</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>generation</span><span style=color:#ce5c00;font-weight:700>;</span>

  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>synchronized</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>close</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span> 
    <span style=color:#000>isOpen</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>false</span><span style=color:#ce5c00;font-weight:700>;</span> 
  <span style=color:#ce5c00;font-weight:700>}</span>

  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>synchronized</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>open</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span> 
    <span style=color:#ce5c00;font-weight:700>++</span><span style=color:#000>generation</span><span style=color:#ce5c00;font-weight:700>;</span> 
    <span style=color:#000>isOpen</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>true</span><span style=color:#ce5c00;font-weight:700>;</span> 
    <span style=color:#000>notifyAll</span><span style=color:#ce5c00;font-weight:700>();</span> 
  <span style=color:#ce5c00;font-weight:700>}</span>

  <span style=color:#8f5902;font-style:italic>// BLOCKS-UNTIL: opened-since(generation on entry) 
</span><span style=color:#8f5902;font-style:italic></span>  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>synchronized</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>await</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#204a87;font-weight:700>throws</span> <span style=color:#000>InterruptedException</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>arrivalGeneration</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>generation</span><span style=color:#ce5c00;font-weight:700>;</span>
    <span style=color:#204a87;font-weight:700>while</span> <span style=color:#ce5c00;font-weight:700>(!</span><span style=color:#000>isOpen</span> <span style=color:#ce5c00;font-weight:700>&amp;&amp;</span> <span style=color:#000>arrivalGeneration</span> <span style=color:#ce5c00;font-weight:700>==</span> <span style=color:#000>generation</span><span style=color:#ce5c00;font-weight:700>)</span>
      <span style=color:#000>wait</span><span style=color:#ce5c00;font-weight:700>();</span> 
  <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>在 wait 中使用的条件谓词比测试 isOpen 复杂的多。这种条件谓词是必须的，因为如果当阀门打开时有 N 个线程正在等待它，那么这些线程都应该被允许执行。然而，如果阀门在打开后又非常快速的关闭了，并且 await 方法只能检查 isOpen，那么所有的线程都可能无法释放：当所有线程收到通知时，将重新请求锁并退出 wait，而此时的阀门可能已经再次关闭了。因此，在 ThreadGate 中使用了一个更复杂的条件谓词：每次阀门关闭时，递增一个 “Generation” 计数器，如果阀门现在是打开的，或者阀门自从该线程到达后就一直是打开的，那么线程就可以通过 wait。</p>
<p>由于 ThreadGate 只支持等待打开阀门，因此只有在 open 中执行通知。要想既支持“等待打开”又支持“等待关闭”，那么 ThreadGate 必须在 open 和 close 中都进行通知。这很好的说明了为什么在维护状态依赖的类时是非常困难的——当增加一个新的状态依赖操作时，可能需要多多条修改对象的代码路径进行调整，才能正确的执行通知。</p>
<h3 id=1426-子类的安全问题>14.2.6 子类的安全问题</h3>
<p>在使用条件通知或单次通知时，一些约束条件使的子类化过程变得更加复杂。要想支持子类化，那么在设计时就需要保证：如果在实施子类化时违背了条件通知或单次通知的某个需求，那么在子类中可以增加合适的通知机制来代表基类。</p>
<p>对于状态依赖的类，要么将其等待和通知协议完全向子类公开并写入正式文档，要么完全阻止子类参与到等待和通知等过程中。(这是对“要么围绕着继承来设计和子类化，要么禁止使用继承”这条规则的一种扩展)。当设计一个可以被继承的状态依赖类时，至少需要公开条件队列和锁，并将条件谓词和同步策略写入文档。此外，还可能需要公开一些底层的状态变量。(最糟糕的情况是，一个状态依赖的类虽然将其状态向子类公开，但却没有将相应的等待和通知等协议写入文档，这就类似于虽然公开了它的状态变量，但却没有将其不变性写入文档一样。)</p>
<p>另外一种选择是完全禁止子类化，比如将类声明为 final 类型，或者将条件队列、锁和状态变量等都隐藏依赖，使子类无法看到。否则，如果子类破坏了在基类中使用 notify 的方式，那么基类就需要修复这种破坏。考虑一个无界的可阻塞栈，当栈为空时，pop 操作将其阻塞，但 push 操作通常可以执行。这就满足了使用单次通知的需求。如果在这个类中使用了单次通知，并且在其中一个子类中添加了一个阻塞的“弹出连续两个元素”方法，那么就会出现两种类型的等待线程：等待弹出一个元素的线程和等待弹出连个元素的线程。但如果基类将条件队列公开出来，并且将使用该条件队列的协议也写入文档，那么子类就可以将 push 方法改写为执行 notifyAll，而重新确保安全性。</p>
<h3 id=1427-封装条件队列>14.2.7 封装条件队列</h3>
<p>通常，我们应该把条件队列封装起来，因而消除了使用条件队列的类，就不能在其他地方访问它。否则，调用者会自以为理解类在等待和通知上使用的协议，并且采用一种违背设计的方式来使用条件队列。(除非条件队列对象对于你无法控制的代码来说是不可访问的，否则就不可能要求在单次通知中的所有等待线程都是同一类型的。如果外部代码错误的在条件对了上等待，那么可能通知协议，并导致一个“被劫持的”信号)。</p>
<p>不幸的是，这条建议——将条件队列对象封装起来，与线程安全类的最常见设计模式并不一致，在这种模式中建议使用对象的内置锁来保护对象自身的状态。在 BoundedBuffer 中给出了这种常见的模式，即缓存对象自身即为锁、又是条件队列。然而，可以很容易将 BoundedBuffer 重新设计为使用私有的锁对象和条件队列，唯一的不同之处在于，新的 BoundedBuffer 不再支持任何形式的客户端加锁。</p>
<h3 id=1428-入口协议与出口协议>14.2.8 入口协议与出口协议</h3>
<p>Wellings 通过“入口协议和出口协议”来描述 wait 和 notify 方法的正确使用。对于每个依赖状态的操作，以及每个修改其他操作依赖状态的操作，都应该定义一个入口协议和出口协议。入口协议就是该操作的条件谓词，出口协议则包括：检查被该操作修改的所有状态变量，并确认它们是否使某个其他的条件谓词变为真，如果是，则通知相关的条件队列。</p>
<p>在 AbstractQueuedSynchronizer (JUC 中大多数依赖状态的类都是基于这个类构建的)中使用出口协议。这个类并不是由同步器类执行自己的通知，而是要求同步器方法返回一个值来表示该类的操作是否已经解除了一个或多个等待线程的阻塞状态。这种明确的 API 调用需求使得难以“忘记”在某些状态转换发生时通知。</p>
<h2 id=143-显式的-condition-对象>14.3 显式的 Condition 对象</h2>
<p>第 13 章曾经介绍过，在某些情况下，当内置锁过于灵活时，可以使用显式锁。正如 Lock 是一种广义的内置锁，Condition 也是一种广义的内置条件队列。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>interface</span> <span style=color:#000>Condition</span> <span style=color:#ce5c00;font-weight:700>{</span>

  <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>await</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#204a87;font-weight:700>throws</span> <span style=color:#000>InterruptedException</span><span style=color:#ce5c00;font-weight:700>;</span> 
  
  <span style=color:#204a87;font-weight:700>boolean</span> <span style=color:#000>await</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>long</span> <span style=color:#000>time</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>TimeUnit</span> <span style=color:#000>unit</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#204a87;font-weight:700>throws</span> <span style=color:#000>InterruptedException</span><span style=color:#ce5c00;font-weight:700>;</span> 
  
  <span style=color:#204a87;font-weight:700>long</span> <span style=color:#000>awaitNanos</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>long</span> <span style=color:#000>nanosTimeout</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#204a87;font-weight:700>throws</span> <span style=color:#000>InterruptedException</span><span style=color:#ce5c00;font-weight:700>;</span> 
  
  <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>awaitUninterruptibly</span><span style=color:#ce5c00;font-weight:700>();</span> 
  
  <span style=color:#204a87;font-weight:700>boolean</span> <span style=color:#000>awaitUntil</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>Date</span> <span style=color:#000>deadline</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#204a87;font-weight:700>throws</span> <span style=color:#000>InterruptedException</span><span style=color:#ce5c00;font-weight:700>;</span>

  <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>signal</span><span style=color:#ce5c00;font-weight:700>();</span> 
  
  <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>signalAll</span><span style=color:#ce5c00;font-weight:700>();</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>内置条件队列存在一些缺陷。每个内置锁都只能有一个相关联的条件队列，因为在像 BoundedBuffer 这种类中，多个线程可能在同一个条件队列上等待不同的条件谓词，并且在最常见的加锁模式下公开条件队列对象。这些因素都是的无法满足在使用 notifyAll 时所有等待线程为同一类型的需求。如果想要编写一个带有多个条件谓词的并发对象，或者想获得出列条件队列可见性之外的更多控制权，就可以使用显式的 Lock 和 Condition 而不是内置锁和条件队列，这是一种更灵活的选择。</p>
<p>一个 Condition 和一个 Lock 关联在一起，就像一个条件队列和一个内置锁相关联一样。要创建一个 Condition，可以在相关联的 Lock 上调用 Lock.newCondition 方法。正如 Lock 比内置加锁提供了更为丰富的功能，Condition 同样比内置条件队列提供了更丰富的功能：在每个锁上可存在多个等待、条件等待可以是可中断的或不可中断的、基于时限的等待，以及公平或非公平的队列操作。</p>
<p>与内置条件队列不同的是，对于每个 Lock，可以有任意数量的 Condition 对象。Condition 对象继承了相关 Lock 对象的公平性，对于公平的锁，线程会依照 FIFO 顺序从 Condition.await 中释放。</p>
<blockquote>
<p>特别注意：在 Condition 对象中，与 wait、notify、notifyAll 方法对应的分别是 await、singal、signalAll。但是，Condition 继承了 Object，因而它也拥有 wait 和 notify 方法。一定要确保使用正确的方法——await 和 signal。</p>
</blockquote>
<p>程序清单 14-11 给出了有界缓存的另一种实现，即使用两个 Condition，分别为 notFull 和 notEmpty，用于表示“非满”与“非空”两个条件谓词。当缓存为空时，take 将阻塞并等待 notEmpty，此时 put 向 notEmpty 发送信号，可以解除任何在 take 中阻塞的线程。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#5c35cc;font-weight:700>@ThreadSafe</span> <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>ConditionBoundedBuffer</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>T</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#ce5c00;font-weight:700>{</span>

  <span style=color:#204a87;font-weight:700>protected</span> <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>Lock</span> <span style=color:#000>lock</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>ReentrantLock</span><span style=color:#ce5c00;font-weight:700>();</span> 
  <span style=color:#8f5902;font-style:italic>// CONDITION PREDICATE: notFull (count &lt; items.length) 	
</span><span style=color:#8f5902;font-style:italic></span>  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>Condition</span> <span style=color:#000>notFull</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>lock</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>newCondition</span><span style=color:#ce5c00;font-weight:700>();</span> 
  <span style=color:#8f5902;font-style:italic>// CONDITION PREDICATE: notEmpty (count &gt; 0) 
</span><span style=color:#8f5902;font-style:italic></span>  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>Condition</span> <span style=color:#000>notEmpty</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>lock</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>newCondition</span><span style=color:#ce5c00;font-weight:700>();</span> 
  <span style=color:#5c35cc;font-weight:700>@GuardedBy</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#4e9a06>&#34;lock&#34;</span><span style=color:#ce5c00;font-weight:700>)</span> 
  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>T</span><span style=color:#ce5c00;font-weight:700>[]</span> <span style=color:#000>items</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>T</span><span style=color:#ce5c00;font-weight:700>[])</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>Object</span><span style=color:#ce5c00;font-weight:700>[</span><span style=color:#000>BUFFER_SIZE</span><span style=color:#ce5c00;font-weight:700>];</span> 
  <span style=color:#5c35cc;font-weight:700>@GuardedBy</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#4e9a06>&#34;lock&#34;</span><span style=color:#ce5c00;font-weight:700>)</span> 
  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>tail</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>head</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>count</span><span style=color:#ce5c00;font-weight:700>;</span>

  <span style=color:#8f5902;font-style:italic>// BLOCKS-UNTIL: notFull 
</span><span style=color:#8f5902;font-style:italic></span>  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>put</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>T</span> <span style=color:#000>x</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#204a87;font-weight:700>throws</span> <span style=color:#000>InterruptedException</span> <span style=color:#ce5c00;font-weight:700>{</span> 
    <span style=color:#000>lock</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>lock</span><span style=color:#ce5c00;font-weight:700>();</span> 
    <span style=color:#204a87;font-weight:700>try</span> <span style=color:#ce5c00;font-weight:700>{</span> 
      <span style=color:#204a87;font-weight:700>while</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>count</span> <span style=color:#ce5c00;font-weight:700>==</span> <span style=color:#000>items</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>length</span><span style=color:#ce5c00;font-weight:700>)</span> 
        <span style=color:#000>notFull</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>await</span><span style=color:#ce5c00;font-weight:700>();</span> 
      <span style=color:#000>items</span><span style=color:#ce5c00;font-weight:700>[</span><span style=color:#000>tail</span><span style=color:#ce5c00;font-weight:700>]</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>x</span><span style=color:#ce5c00;font-weight:700>;</span> 
      <span style=color:#204a87;font-weight:700>if</span> <span style=color:#ce5c00;font-weight:700>(++</span><span style=color:#000>tail</span> <span style=color:#ce5c00;font-weight:700>==</span> <span style=color:#000>items</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>length</span><span style=color:#ce5c00;font-weight:700>)</span> 
        <span style=color:#000>tail</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>0</span><span style=color:#ce5c00;font-weight:700>;</span> 
      <span style=color:#ce5c00;font-weight:700>++</span><span style=color:#000>count</span><span style=color:#ce5c00;font-weight:700>;</span> 
      <span style=color:#000>notEmpty</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>signal</span><span style=color:#ce5c00;font-weight:700>();</span> 
    <span style=color:#ce5c00;font-weight:700>}</span> <span style=color:#204a87;font-weight:700>finally</span> <span style=color:#ce5c00;font-weight:700>{</span> 
      <span style=color:#000>lock</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>unlock</span><span style=color:#ce5c00;font-weight:700>();</span> 
    <span style=color:#ce5c00;font-weight:700>}</span>
  <span style=color:#ce5c00;font-weight:700>}</span>

  <span style=color:#8f5902;font-style:italic>// BLOCKS-UNTIL: notEmpty 
</span><span style=color:#8f5902;font-style:italic></span>  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#000>T</span> <span style=color:#000>take</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#204a87;font-weight:700>throws</span> 	<span style=color:#000>InterruptedException</span> <span style=color:#ce5c00;font-weight:700>{</span> 
    <span style=color:#000>lock</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>lock</span><span style=color:#ce5c00;font-weight:700>();</span> 
    <span style=color:#204a87;font-weight:700>try</span> <span style=color:#ce5c00;font-weight:700>{</span> 
      <span style=color:#204a87;font-weight:700>while</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>count</span> <span style=color:#ce5c00;font-weight:700>==</span> <span style=color:#000>0</span><span style=color:#ce5c00;font-weight:700>)</span> 
        <span style=color:#000>notEmpty</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>await</span><span style=color:#ce5c00;font-weight:700>();</span> 
      <span style=color:#000>T</span> <span style=color:#000>x</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>items</span><span style=color:#ce5c00;font-weight:700>[</span><span style=color:#000>head</span><span style=color:#ce5c00;font-weight:700>];</span> 
      <span style=color:#000>items</span><span style=color:#ce5c00;font-weight:700>[</span><span style=color:#000>head</span><span style=color:#ce5c00;font-weight:700>]</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>null</span><span style=color:#ce5c00;font-weight:700>;</span> 
      <span style=color:#204a87;font-weight:700>if</span> <span style=color:#ce5c00;font-weight:700>(++</span><span style=color:#000>head</span> <span style=color:#ce5c00;font-weight:700>==</span> <span style=color:#000>items</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>length</span><span style=color:#ce5c00;font-weight:700>)</span> 
        <span style=color:#000>head</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>0</span><span style=color:#ce5c00;font-weight:700>;</span> 
      <span style=color:#ce5c00;font-weight:700>--</span><span style=color:#000>count</span><span style=color:#ce5c00;font-weight:700>;</span> 
      <span style=color:#000>notFull</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>signal</span><span style=color:#ce5c00;font-weight:700>();</span> 
      <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>x</span><span style=color:#ce5c00;font-weight:700>;</span> 
    <span style=color:#ce5c00;font-weight:700>}</span> <span style=color:#204a87;font-weight:700>finally</span> <span style=color:#ce5c00;font-weight:700>{</span> 
      <span style=color:#000>lock</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>unlock</span><span style=color:#ce5c00;font-weight:700>();</span> 
    <span style=color:#ce5c00;font-weight:700>}</span>
  <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>ConditionBoundedBuffer 的行为和 BoundedBuffer 相同，但他对条件队列的使用方式更易理解——在分析使用了多个 Condition 的类时，比分析一个使用单一内部队列加上多个条件谓词的类简单的多。通过将连个条件谓词分开并放到两个等待线程集中，Condition 使其更容易满足单次通知的需求。signal 比 signalAll 更高效，它能极大的减少在每次缓存操作中发生的上下文切换与锁请求次数。</p>
<p>与内置锁和条件队列一样，当使用显式的 Lock 和 Condition 时，也必须满足锁、条件谓词和条件变量之间的三元关系。在条件谓词中包含的变量必须由 Lock 来保护，并且在检查条件谓词以及调用 await 和 signal 时，必须持有 Lock 对象。</p>
<p>在使用显式的 Condition 和内置条件对了之间进行选择时，与在 ReentrantLock 和 synchronized 之间进行选择是一样的：如果需要一些高级功能，例如使用公平的队列操作或者在每个锁上对应多个等待线程集，那么应该优先使用 Condition 而非内置条件队列。</p>
<h2 id=144-synchronizer-剖析>14.4 Synchronizer 剖析</h2>
<p>在 ReentrantLock 和 Semaphore 这两个接口之间存在许多共同点。这两个类都可以用作一个阀门，即每次只允许一定数量的线程通过，并当在线程到达阀门时，可以通过(在调用 lock 或 acquire 时成功返回)，也可以等待(在调用 lock 或 acquire 时阻塞)，还可以取消(在调用 tryLock 或 tryAcquire 时返回 false，表示在指定的时间内锁是不可用的或者无法获得许可)。而且，这两个接口都支持可中断的、不可中断的以及限时的获取操作，并且也都支持等待线程执行公平或非公平的队列操作。</p>
<p>列出了这种共性后，你或许会认为 Semaphore 是基于 ReentrantLock 实现的，或者认为 ReentrantLock 实际上是带有一个许可的 Semaphore。这些实现方式都是可行的，一个很常见的练习就是，证明可以通过锁来实现计数信号量(如程序清单 14-12 中的 SemaphoreOnLock 所示)，以及可以通过计数信号量来实现锁。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#8f5902;font-style:italic>// Not really how java.util.concurrent.Semaphore is implemented @ThreadSafe 
</span><span style=color:#8f5902;font-style:italic></span><span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>SemaphoreOnLock</span> <span style=color:#ce5c00;font-weight:700>{</span>

  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>Lock</span> <span style=color:#000>lock</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>ReentrantLock</span><span style=color:#ce5c00;font-weight:700>();</span> 
  <span style=color:#8f5902;font-style:italic>// CONDITION PREDICATE: permitsAvailable (permits &gt; 0) 
</span><span style=color:#8f5902;font-style:italic></span>  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>Condition</span> <span style=color:#000>permitsAvailable</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>lock</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>newCondition</span><span style=color:#ce5c00;font-weight:700>();</span>
   <span style=color:#5c35cc;font-weight:700>@GuardedBy</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#4e9a06>&#34;lock&#34;</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>permits</span><span style=color:#ce5c00;font-weight:700>;</span>

  <span style=color:#000>SemaphoreOnLock</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>initialPermits</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span> 
    <span style=color:#000>lock</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>lock</span><span style=color:#ce5c00;font-weight:700>();</span> 
    <span style=color:#204a87;font-weight:700>try</span> <span style=color:#ce5c00;font-weight:700>{</span> 
      <span style=color:#000>permits</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>initialPermits</span><span style=color:#ce5c00;font-weight:700>;</span> 
    <span style=color:#ce5c00;font-weight:700>}</span> <span style=color:#204a87;font-weight:700>finally</span> <span style=color:#ce5c00;font-weight:700>{</span> 
      <span style=color:#000>lock</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>unlock</span><span style=color:#ce5c00;font-weight:700>();</span> 
    <span style=color:#ce5c00;font-weight:700>}</span>
  <span style=color:#ce5c00;font-weight:700>}</span>

  <span style=color:#8f5902;font-style:italic>// BLOCKS-UNTIL: permitsAvailable 
</span><span style=color:#8f5902;font-style:italic></span>  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>acquire</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#204a87;font-weight:700>throws</span> <span style=color:#000>InterruptedException</span> <span style=color:#ce5c00;font-weight:700>{</span> 
    <span style=color:#000>lock</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>lock</span><span style=color:#ce5c00;font-weight:700>();</span> 
    <span style=color:#204a87;font-weight:700>try</span> <span style=color:#ce5c00;font-weight:700>{</span> 
      <span style=color:#204a87;font-weight:700>while</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>permits</span> <span style=color:#ce5c00;font-weight:700>&lt;=</span> <span style=color:#000>0</span><span style=color:#ce5c00;font-weight:700>)</span> 
        <span style=color:#000>permitsAvailable</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>await</span><span style=color:#ce5c00;font-weight:700>();</span> 
      <span style=color:#ce5c00;font-weight:700>--</span><span style=color:#000>permits</span><span style=color:#ce5c00;font-weight:700>;</span> 
    <span style=color:#ce5c00;font-weight:700>}</span> <span style=color:#204a87;font-weight:700>finally</span> <span style=color:#ce5c00;font-weight:700>{</span> 
      <span style=color:#000>lock</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>unlock</span><span style=color:#ce5c00;font-weight:700>();</span> 
    <span style=color:#ce5c00;font-weight:700>}</span> 
  <span style=color:#ce5c00;font-weight:700>}</span>

  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>release</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span> 
    <span style=color:#000>lock</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>lock</span><span style=color:#ce5c00;font-weight:700>();</span> 
    <span style=color:#204a87;font-weight:700>try</span> <span style=color:#ce5c00;font-weight:700>{</span> 
      <span style=color:#ce5c00;font-weight:700>++</span><span style=color:#000>permits</span><span style=color:#ce5c00;font-weight:700>;</span> 
      <span style=color:#000>permitsAvailable</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>signal</span><span style=color:#ce5c00;font-weight:700>();</span> 
    <span style=color:#ce5c00;font-weight:700>}</span> <span style=color:#204a87;font-weight:700>finally</span> <span style=color:#ce5c00;font-weight:700>{</span> 
      <span style=color:#000>lock</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>unlock</span><span style=color:#ce5c00;font-weight:700>();</span> 
    <span style=color:#ce5c00;font-weight:700>}</span> 
  <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>事实上，它们在实现时都基于共同的基类，即 AQS，这个类也是其他许多同步类的基类。AQS 是一个用于构建锁和同步器的框架，许多同步容器都可以通过 AQS 很容易并且高效的构造出来。不仅 ReentrantLock 和 Semaphore 是基于 AQS 构建的，还包括 CountDownLatch、ReentrantReadWriteLock、SynchronousQueue 和 FutureTask。</p>
<p>AQS 解决了在实现同步器时涉及的大量细节问题，例如等待线程采用 FIFO 队列操作书序。在不同的同步器中还可以定义一些灵活的标准来判断某个线程是应该通过还是需要等待。</p>
<p>基于 AQS 来构建同步器能带来很多好处。它不仅能极大的减少实现工作，而且也不必处理在多个位置上发生的竞争问题(这是在没有使用 AQS 来构建同步器时的情况)。在 SemaphoreOnLock 中，获取许可的操作可能在两个时刻阻塞——当锁保护信号量状态时，或者当许可不可用时。在基于 AQS 构建的同步容器中，只可能在一个时刻发生阻塞，从而降低上下文切换的开销，并提高吞吐量。在设计 AQS 时充分考虑了可伸缩性，因此 JUC 中所有基于 AQS 构建的同步器都能获得这种优势。</p>
<h2 id=145-aqsabstractqueuedsynchronizer>14.5 AQS：AbstractQueuedSynchronizer</h2>
<p>大多数开发者都不会直接使用 AQS，标准同步器的集合能够满足绝大多数的需求。但如果能了解标准同步器类的实现方式，那么对于理解它们的工作原理将会非常有帮助。</p>
<p>在基于 AQS 构建的同步容器中，最基本的操作包括各种形式的获取和释放操作。获取操作是一种状态依赖操作，并且通常会阻塞。当使用锁或信号量时，“获取”操作的含义就很直观，即获取的是锁或许可，并且调用者可能会一直等待直到同步器类处于可被获取的状态。在使用 CountDownLatch 时，“获取”操作意味着“等待直到闭锁到达结束状态”，而在使用 FutureTask 时，则意味着“等待直到任务已经完成”。“释放”并不是一个可阻塞的操作，当执行“释放”操作时，所有在请求时被阻塞的线程都会开始执行。</p>
<p>如果一个类想成为状态依赖的类，那么它必须拥有一些状态。AQS 负责管理同步容器类中的状态，它管理了一个整数状态信息，可以通过 getState、setState 以及 compareAndSwap 等 protected 方法来进行操作。这个整数可以用于表示任务状态。比如，ReentrantLock 用它来表示所有者线程已经重复获取锁的次数，Semaphore 用它来表示剩余的许可数量，FutureTask 用它来表示任务的状态(尚未开始、正在运行、已完成、已取消)。在同步容器中还可以自行管理一些额外的状态变量，比如，ReentrantLock 保存了锁的当前所有者信息，这样就能区分某个操作是重入的还是竞争的。</p>
<p>程序清单 14-13 给出了 AQS 中获取和释放操作的形式。根据同步器的不同，获取操作可以是一种独占操作(如 ReentrantLock)，也可以是一种非独占操作(如 Semaphore 和 CountDownLatch)。一个获取操作包含两个部分。首先，同步器判断当前状态十分允许获取操作，如果是，则允许线程执行，否则获取操作将阻塞或失败。这种判断是由同步器语义来决定的。例如，对于所来说，如果它没有被某个线程持有，那么就能被成功的获取，而对于闭锁来说，如果它处于结束状态，那么也能被成功的获取。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback>boolean acquire() throws InterruptedException {
  while (state does not permit acquire) { 
    if (blocking acquisition requested) { 
      enqueue current thread if not already queued 
      block current thread 
    } 
    else return failure 
  } 
  
  possibly update synchronization state 
  dequeue thread if it was queued 
  return success
}

void release() { 
  update synchronization state 
  if (new state may permit a blocked thread to acquire) 
    unblock one or more queued threads 
}
</code></pre></div><p>其次，就是更新同步器的状态，获取同步器的某个线程可能会对其他线程能够也获取该同步器造成影响。比如，当获取一个锁后，锁的状态将从“未被持有”变成“已被持有”，而从 Semaphore 中获得一个许可后，将把剩余许可的数量减去 1。然而，当一个线程获取闭锁时，并不会影响其他线程能否获取它，因此获取闭锁的操作不会改变闭锁的状态。</p>
<p>如果某个同步器支持独占的获取操作，那么需要实现一些保护方法，包括 tryAcquire、tryRelease 和 isHeldExclusively 等，而对于支持共享获取的同步器，则应该实现 tryAcquireShared 和 tryReleaseShared 等方法。AQS 中的 accuire、acquireShared、release 和 releaseShared 等方法都将调用这些方法在子类中带有前缀 try- 的版本来判断某个操作是否能够执行。在同步器的子类中，可以根据其获取操作和释放操作的语义，使用 getState、setState 以及 compareAndSetState 来检查和更新状态，并通过返回的状态值来告知基类“获取”和“释放”同步器的操作是否成功。例如，如果 tryAcquireShared 返回一个值，那么表示获取操作失败，返回零值表示同步器通过独占方式被获取，返回正值则表示同步器通过非独占方式被获取。对于 tryRelease 和 tryReleaseShared 方法来说，如果释放操作使得所有在获取同步器时被阻塞的线程恢复执行，那么这两个方法应该返回 true。</p>
<p>为了使支持条件队列的锁(如 ReentrantLock)实现起来更简单，AQS 还提供了一些机制来构造与同步器相关联的条件变量。</p>
<h3 id=一个简单的闭锁>一个简单的闭锁</h3>
<p>程序清单 14-14 中的 OneSlotLatch 是一个使用 AQS 实现的二元闭锁。它包括两个公有方法：await 和 signal，分别对应获取操作和释放操作。起初，闭锁是关闭的，任何调用 await 的线程都将阻塞并直到闭锁被打开。当通过调用 signal 打开闭锁时，所有等待中的线程都将被释放，并且后续到达闭锁的线程也被允许执行。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#5c35cc;font-weight:700>@ThreadSafe</span> 
<span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>OneShotLatch</span> <span style=color:#ce5c00;font-weight:700>{</span> 
  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>Sync</span> <span style=color:#000>sync</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>Sync</span><span style=color:#ce5c00;font-weight:700>();</span>

  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>signal</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span> 
    <span style=color:#000>sync</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>releaseShared</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>0</span><span style=color:#ce5c00;font-weight:700>);</span> 
  <span style=color:#ce5c00;font-weight:700>}</span>

  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>await</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#204a87;font-weight:700>throws</span> <span style=color:#000>InterruptedException</span> <span style=color:#ce5c00;font-weight:700>{</span> 
    <span style=color:#000>sync</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>acquireSharedInterruptibly</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>0</span><span style=color:#ce5c00;font-weight:700>);</span> 
  <span style=color:#ce5c00;font-weight:700>}</span>

  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>Sync</span> <span style=color:#204a87;font-weight:700>extends</span> <span style=color:#000>AbstractQueuedSynchronizer</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#204a87;font-weight:700>protected</span> <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>tryAcquireShared</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>ignored</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span> 
      <span style=color:#8f5902;font-style:italic>// Succeed if latch is open (state == 1), else fail 
</span><span style=color:#8f5902;font-style:italic></span>      <span style=color:#204a87;font-weight:700>return</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>getState</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>==</span> <span style=color:#000>1</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>?</span> <span style=color:#000>1</span> <span style=color:#ce5c00;font-weight:700>:</span> <span style=color:#ce5c00;font-weight:700>-</span><span style=color:#000>1</span><span style=color:#ce5c00;font-weight:700>;</span> 
    <span style=color:#ce5c00;font-weight:700>}</span>

    <span style=color:#204a87;font-weight:700>protected</span> <span style=color:#204a87;font-weight:700>boolean</span> <span style=color:#000>tryReleaseShared</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>ignored</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
      <span style=color:#000>setState</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>1</span><span style=color:#ce5c00;font-weight:700>);</span> 
      <span style=color:#8f5902;font-style:italic>// Latch is now open 
</span><span style=color:#8f5902;font-style:italic></span>      <span style=color:#204a87;font-weight:700>return</span> <span style=color:#204a87;font-weight:700>true</span><span style=color:#ce5c00;font-weight:700>;</span> 
      <span style=color:#8f5902;font-style:italic>// Other threads may now be able to acquire
</span><span style=color:#8f5902;font-style:italic></span>    <span style=color:#ce5c00;font-weight:700>}</span>
  <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>在 OneShotLatch 中，AQS 状态用来表示闭锁状态——关闭(0)或者打开(1)。await 方法调用 AQS 的 acquireSharedInterruptibly，然后接着调用 OneShotLatch 中的 tryAcquireShared 方法。在 tryAcquireShared 的实现中必须返回一个值来表示该获取操作能否执行。如果之间已经打开了闭锁，那么 tryAcquireShared 将返回成功并允许线程通过，否则就会返回一个表示获取操作失败的值。acquireSharedInterruptibly 方法在处理失败的方式，是把这个线程放入等待线程队列中。类似的，signal 将调用 releaseShared，接下来又会调用 tryReleaseShared。在 tryReleaseShared 中将无条件的将闭锁的状态设置为打开，(通过返回值)表示该同步器处于完全释放的状态。因而 AQS 让所有等待中的线程都尝试重新请求该同步器，并且由于 tryAcquireShared 将返回成功，因此现在的请求操作将成功。</p>
<p>OneShotLatch 是一个功能全面的、可用的、性能较好的同步器，并且仅使用了大约 20 多行代码就实现了。当然，它缺少了一些有用的特性，比如限时的请求操作或检查闭锁状态的操作，但这些功能实现起来同样简单，因为 AQS 提供了限时版本的获取方法，以及一些在常见检查中使用的辅助方法。</p>
<p>OneShotLatch 也可以通过扩展 AQS 来实现，而不是将一些功能委托给 AQS，但这种做法并不合理，原因有很多。这样做将破坏 OneShotLatch 接口(只有两个方法)的简洁性，并且虽然 AQS 的公共方法不允许调用者破坏闭锁的状态，但调用者仍可以很容易的误用它们。JUC 中的所有同步器类都没有直接扩展 AQS，而是都将它们的相应功能委托给私有的 AQS 子类来实现。</p>
<h2 id=146-juc-同步类中的-aqs>14.6 JUC 同步类中的 AQS</h2>
<p>JUC 中的很多课阻塞类，如 ReentrantLock、Semaphore、ReentrantReadWriteLock、CountDownLatch、SynchronousQueue 和 FutureTask 等，都是基于 AQS 构建的。我们快速的浏览一下每个类是如何使用 AQS 的，不需要过于深入了解细节。</p>
<h3 id=1461-reentrantlock>14.6.1 ReentrantLock</h3>
<p>ReentrantLock 仅支持独占方式的获取操作，因此它实现了 tryAcquire、tryRelease 和 isHeledExclusively，程序清单 14-15 给出了非公平版本的 tryAcquire。ReentrantLock 将同步状态用于保存加锁操作的次数，并且还维护了一个 owner 变量来保存当前所有者线程的标示符，只有在当前线程刚刚获取到锁，或者正要释放锁的时候，才会修改这个变量。在 tryRelease 中检查 owner 域，从而确保当前线程在执行 unlock 操作之前确实已经获得了锁：在 tryAcquire 中将使用这个域来区分获取操作是重入的还是竞争的。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#204a87;font-weight:700>protected</span> <span style=color:#204a87;font-weight:700>boolean</span> <span style=color:#000>tryAcquire</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>ignored</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>

  <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>Thread</span> <span style=color:#000>current</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>Thread</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>currentThread</span><span style=color:#ce5c00;font-weight:700>();</span> 
  <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>c</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>getState</span><span style=color:#ce5c00;font-weight:700>();</span> 
  
  <span style=color:#204a87;font-weight:700>if</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>c</span> <span style=color:#ce5c00;font-weight:700>==</span> <span style=color:#000>0</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#204a87;font-weight:700>if</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>compareAndSetState</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>0</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>1</span><span style=color:#ce5c00;font-weight:700>))</span> <span style=color:#ce5c00;font-weight:700>{</span>
      <span style=color:#000>owner</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>current</span><span style=color:#ce5c00;font-weight:700>;</span>
      <span style=color:#204a87;font-weight:700>return</span> <span style=color:#204a87;font-weight:700>true</span><span style=color:#ce5c00;font-weight:700>;</span>
    <span style=color:#ce5c00;font-weight:700>}</span> 
  <span style=color:#ce5c00;font-weight:700>}</span> 
  <span style=color:#204a87;font-weight:700>else</span> <span style=color:#204a87;font-weight:700>if</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>current</span> <span style=color:#ce5c00;font-weight:700>==</span> <span style=color:#000>owner</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#000>setState</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>c</span><span style=color:#ce5c00;font-weight:700>+</span><span style=color:#000>1</span><span style=color:#ce5c00;font-weight:700>);</span>
    <span style=color:#204a87;font-weight:700>return</span> <span style=color:#204a87;font-weight:700>true</span><span style=color:#ce5c00;font-weight:700>;</span> 
  <span style=color:#ce5c00;font-weight:700>}</span> 
  
  <span style=color:#204a87;font-weight:700>return</span> <span style=color:#204a87;font-weight:700>false</span><span style=color:#ce5c00;font-weight:700>;</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>当一个线程尝试获取锁时，tryAcquire 将首先检查所的状态。如果锁未被持有，那么它将尝试更新锁的状态以表示锁已经被持有。由于状态可能在检查后被立即修改，因此 tryAcquire 使用 compareAndSetState 来原子的更新状态，表示这个锁已经被占有，并确保状态在最后一次检查以后就没有被修改过。(请参考 15.3 节中对 compareAndSet 的描述)。如果锁状态表示已经被持有，并且如果当前线程是锁的拥有者，那么获取计数会被递增，如果当前线程不是锁的拥有者，那么获取操作将失败。</p>
<p>ReentrantLock 还利用了 AQS 对多个条件变量和多个等待线程集的内置支持。Lock.newCondition 将返回一个新的 ConditionObject 实例，这是 AQS 的一个内部类。</p>
<h3 id=1462-semaphore-与-countdownlatch>14.6.2 Semaphore 与 CountDownLatch</h3>
<p>Semaphore 将 AQS 的同步状态用于保存当前可用许可的数量。tryAcquireShared 方法(见程序清单 14-16)首先计算剩余许可的数量，如果没有足够的许可，那么会翻译个值表示获取操作失败。如果还有剩余的许可，那么 tryAcquireShared 会通过 compareAndSetState 以原子方式来降低许可的计数。如果这个操作成功(这意味着许可的计数自从上一次读取后就没有被修改过)，那么将返回一个值来表示获取操作成功。在返回值中包含了表示其他共享获取操作能否成功的信息，如果成功，那么其他等待的线程同样会解除阻塞。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#204a87;font-weight:700>protected</span> <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>tryAcquireShared</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>acquires</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span> 
  <span style=color:#204a87;font-weight:700>while</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>true</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span> 
    <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>available</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>getState</span><span style=color:#ce5c00;font-weight:700>();</span> 
    <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>remaining</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>available</span> <span style=color:#ce5c00;font-weight:700>-</span> <span style=color:#000>acquires</span><span style=color:#ce5c00;font-weight:700>;</span> 
    <span style=color:#204a87;font-weight:700>if</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>remaining</span> <span style=color:#ce5c00;font-weight:700>&lt;</span> <span style=color:#000>0</span> <span style=color:#ce5c00;font-weight:700>||</span> <span style=color:#000>compareAndSetState</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>available</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>remaining</span><span style=color:#ce5c00;font-weight:700>))</span> 
      <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>remaining</span><span style=color:#ce5c00;font-weight:700>;</span> 
  <span style=color:#ce5c00;font-weight:700>}</span> 
<span style=color:#ce5c00;font-weight:700>}</span>

<span style=color:#204a87;font-weight:700>protected</span> <span style=color:#204a87;font-weight:700>boolean</span> <span style=color:#000>tryReleaseShared</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>releases</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span> 
  <span style=color:#204a87;font-weight:700>while</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>true</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span> 
    <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>p</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>getState</span><span style=color:#ce5c00;font-weight:700>();</span> 
    <span style=color:#204a87;font-weight:700>if</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>compareAndSetState</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>p</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>p</span> <span style=color:#ce5c00;font-weight:700>+</span> <span style=color:#000>releases</span><span style=color:#ce5c00;font-weight:700>))</span> 
      <span style=color:#204a87;font-weight:700>return</span> <span style=color:#204a87;font-weight:700>true</span><span style=color:#ce5c00;font-weight:700>;</span> 
  <span style=color:#ce5c00;font-weight:700>}</span> 
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>当没有足够的许可，或者当 tryAcquireShared 可以通过原子方式来更新许可的计数以响应获取操作时，while 循环将终止。虽然对 compareAndSetState 的调用可能由于与另一个线程发生竞争而失败(请参考 15.3 节)，使其重新尝试，但在经过了一定次数的重试操作之后，在两个结束条件中有一个会变为真。同样，tryReleaseShare 将增加许可计数，这可能会截除等待中线程的阻塞状态，并且不断的重试直到操作成功。tryReleaseShared 的返回值表示在这次释放操作中解除了其他线程的阻塞。</p>
<p>CountDownLatch 使用 AQS 的方式与 Semaphore 很相似：在同步状态中保存的是当前的计数值。countDown 方法将调用 release，从而导致计数值递减，并且当计数值为零时解除所有等待线程的阻塞。await 调用 acquire，当计数器为 0 时，acquire 将立即返回，否则将阻塞。</p>
<h3 id=1463-futuretask>14.6.3 FutureTask</h3>
<p>咋一看，FutureTask 甚至不像一个容器，但 Future.get 的语义非常类似于闭锁的语义——如果发生了某件事(由 FutureTask 表示的任务执行完成或被取消)，那么线程就可以恢复执行，否则这些线程将停留在队列中直到该事件发生。</p>
<p>在 FutureTask 中，AQS 同步状态被用来保存任务的状态，如正在运行、已完成或已取消。FutureTask 还维护一写额外的状态变量，用来保存计算结果或抛出的异常。此外，它还为了一个引用，指向正在执行计算任务的线程(如果当该线程还处于运行状态时)，因而如果任务取消，该线程就会被中断。</p>
<h3 id=1464-reentrantreadwritelock>14.6.4 ReentrantReadWriteLock</h3>
<p>ReadWriteLock 接口表示存在两个锁：一个读锁一个写锁，但在基于 AQS 实现的 ReentrantReadWriteLock 中，单个 AQS 子类将同时管理读取加锁和写入加锁。ReentrantReadWriteLock 使用了一个 16 位的状态来表示写入锁的计数，并且使用了另一个 16 位的状态来表示读取锁的计数。在读取锁上操作将使用共享的获取方法与释放方法，在写入锁上的操作将使用独占的获取方法与释放方法。</p>
<p>AQS 在内部维护一个等待线程队列，其中记录了某个线程请求的是独占访问还是共享访问。在 ReentrantReadWriteLock 中，当锁可用时，如果位于对了头部的线程执行写入操作，那么线程会得到该锁，如果位于队列头部的线程执行的是获取访问，那么队列在第一个写入线程之前的所有线程都将获得这个锁。</p>
<h2 id=小结>小结</h2>
<p>要实现一个依赖状态的类——如果没有满足依赖状态的前提条件，那么这个类的方法必须阻塞，那么最好的方式是基于现有的类库来构建，比如 Semaphore、BlockingQueue 或 CountDownLatch。如第八章的 ValueLatch 所示。然而，有时候现有类库不能提供足够的功能，在这种情况下，可以使用内置的条件队列、显式的 Condition 对象或者 AQS 来构建自己的同步器。内置条件队列与内置锁是紧密绑定在一起的，这是因为管理状态依赖性的机制必须与确保状态一致性的机制关联起来。同样，显式的 Condition 与显式的 Lock 也是紧密的绑定在一起的，并且与内置条件队列相比，还提供了一个扩展的功能集，包括每个锁对于多个等待线程集，可中断或不可中断的条件等待，公平或非公平的队列操作，以及基于时限的等待。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-0f6189a0f6b1890e973a603e114094a4>15 - CH15-原子与非阻塞同步</h1>
<p>在 JUC 包的许多类中，如 Semaphore 和 ConcurrentLinkedQueue，都提供了比 synchronized 机制更高的性能和可伸缩性。本章将介绍这种性能提升的主要来源：原子变量和非阻塞同步机制。</p>
<p>近年来，在并发算法领域的大多数研究都侧重于非阻塞算法，这种算法用底层的原子机器指令(如 CAS)代替锁来确保数据在并发访问中的一致性。非阻塞算法被广泛的用于在操作系统和 JVM 中实现线程/进程调度机制、垃圾回收机制、锁和其他并发数据结构。</p>
<p>与基于锁的方法相比，非阻塞算法在设计和实现上都要复杂的多，但它们在可伸缩性和活跃性上却拥有巨大的优势。由于非阻塞算法可以使多个线程在竞争相同的数据时不会发生阻塞，因此它能在粒度更细的层次上进行协调，并且极大的减少调度开销。而且，在非阻塞算法中不存在死锁和其他活跃性问题。在基于锁的算法中，如果一个线程在休眠或自旋的同时持有一个锁，那么其他线程都无法执行下去，而非阻塞算法不会受到单个线程失败的影响。从 Java 5.0 开始，可以使用原子变量类(如 AtomicInteger)来构建高效的非阻塞算法。</p>
<p>即使原子变量没有用于非阻塞算法的开发，他们也可以被用作一种“更好的 volatile 变量”。原子变量提供了与 volatile 变量相同的内存语义，此处还支持原子更新操作，从而使它们更加适用于实现计数器、序列发生器和统计数据收集等，同时还能比基于锁的方法提供更高的可伸缩性。</p>
<h2 id=151-锁的劣势>15.1 锁的劣势</h2>
<p>通过使用一致的锁协议来协调对共享状态的访问，可以确保无论哪个线程持有守护变量的锁，都能采用独占的方式来访问这些变量，并且对变量的任何修改对后续获得这个锁的其他线程都是可见的。</p>
<p>现代的许多 JVM 都给非竞争的加解锁操作进行极大的优化，但如果有多个线程同时加锁，那么 JVM 就需要借助操作系统的能力。如果出现了这种情况，那么一些线程将被挂起并且在稍后恢复运行。当线程恢复执行时，必须等待其他线程执行完成它们的时间片以后，才能被调度执行。在挂起和恢复线程等过程中存在很大的开销，并且通常存在着较长时间的中断。如果在基于锁的类中包含细粒度的操作(如同步容器类，在其大多数情况中仅包含了少量操作)，那么当在锁上存在着激烈的竞争时，调度开销将大大超出工作开销。</p>
<p>与锁相比，volatile 变量是一种更轻量级的同步机制，因为在使用这些变量时不会发生上下文切换或线程调度等操作。然而，volatile 变量同样存在一些局限：虽然它提供了相似的可见性保证，但不能用于构建原子的复合操作。因此，在一个变量依赖其他的变量时，或者当变量的新值依赖于旧值时，就无法使用 volatile 变量。这都限制了 volatile 变量的使用范围，因此他们不能用来实现一些常见的工具，如计数器或互斥体(mutex)。</p>
<p>比如，虽然自增操作看起来像是一个原子操作，但事实上却包含了 3 个独立的操作——获取变量的值、将该值加 1、写入新值到变量。为了确保更新操作不会丢失，整个的读-改-写操作都必须是原子的。到目前为止，我们实现这种原子操作的唯一途径就是使用锁定的方式，如第二章的 Counter 所示。</p>
<p>Counter 是线程安全的，并且在没有竞争的情况下运行良好。但在竞争的情况下，其性能会由于上下文切换的开销和调度延迟而降低。如果锁的持有时间非常短，俺么挡在不恰当的时间请求锁时，使线程休眠将付出很高的代价。</p>
<p>锁定还存在一些其他缺点。当一个线程正在等待锁时，他不能做任何其他事情。如果一个线程在持有锁的情况下被延迟执行(如发生内存缺页、调度延迟等)，那么所有需要该锁的线程都将无法继续执行。如果被阻塞的线程的优先级很高，而持有锁的线程优先级较低，那么这将是一个严重的问题——也被称为优先级反转。即使高优先级的线程可抢先执行，但仍然需要等待锁被释放，从而导致它的优先级会降至低优先级线程的级别。如果持有锁的线程被永久的阻塞(如出现了无限循环、死锁、活锁或其他活跃性故障)，所有等待该锁的线程都将永远无法继续执行。</p>
<p>即使忽略这种风险，锁定方式对于细粒度的操作(如递增计数器)来说仍然是一种高开销的机制。在管理线程之间的竞争时应该有一种粒度更细的技术，类似于 volatile 变量的机制，同时还要支持原子的更新操作。幸运的是，在现代的处理器中提供了这种机制。</p>
<h2 id=152-硬件对并发的支持>15.2 硬件对并发的支持</h2>
<p>独占锁是一项悲观技术——它假设最坏的情况(如果不锁门，那么捣蛋鬼就会闯入并搞破坏)，并且只有在确保其他线程不会干扰(通过获取正确的锁)的情况下才能执行下去。</p>
<p>对于细粒度的操作，还有另外一种更高效的方法，也是一种乐观的方法，通过这种方法可以在不发生干扰的情况下完成更新操作。这种方法需要借助冲突检测机制来判断在更新过程中是否存在来自其他线程的干扰，如果存在，该操作将失败，但可以选择是否重试。这种乐观方式就好像一句谚语：“原谅比准许更易获得”，其中“更易”在这里相当于“更高效”。</p>
<p>在针对多处理器操作而设计的处理器中提供了一些特殊指令，用于管理共享数据的并发访问。在早期的处理器中支持原子的测试并设置(TestAndSet)、获取并递增(FetchAndIncrement)、交换(Swap)等指令，这些指令足以实现各种互斥体，而这些互斥体又可以实现一些更复杂的并发对象。现在，几乎所有的现代处理器中都包含了某种形式的原子读-该-写指令，如比较并交换(CAS)、关联加载/条件存储(LoadLinked/StoreConditional)。操作系统和 JVM 使用这些指令来实现锁和并发数据结构，但在 Java 5.0 之前，在 Java 类中还不能直接使用这些指令。</p>
<h3 id=cas>CAS</h3>
<p>在大多数处理架构中采用的方法是实现一个 CAS 指令。CAS 包含 3 个操作数——需要读写的内存位置 V、进行比较的值 A、拟写入的新值 B。当且仅当 V 的值等于 A 时，CAS 才会通过原子方式用新值 B 来更新 V 的值，否则不会执行任何操作。无论 V 的值是否等于 A，都将返回 V 原有的值。(这种变化形式被称为“比较并设置”，无论操作是否成功都将放回)。CAS 的含义是：“我认为 V 的值应该是 A，如果是，那么将 V 的值更新为 B，否则不修改，并告诉我 V 的实际值是什么”。CAS 是一种乐观技术，它希望能成功的执行更新操作，并且如果有另一个线程在最近一次检查后更新了该变量，那么 CAS 能检测到这个错误。程序清单 15-1 中的 SimulatedCAS 说明了 CAS 语义(并非实现和性能)。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#5c35cc;font-weight:700>@ThreadSafe</span> <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>SimulatedCAS</span> <span style=color:#ce5c00;font-weight:700>{</span> 
  <span style=color:#5c35cc;font-weight:700>@GuardedBy</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#4e9a06>&#34;this&#34;</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>value</span><span style=color:#ce5c00;font-weight:700>;</span>

  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>synchronized</span> <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>get</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span> 
    <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>value</span><span style=color:#ce5c00;font-weight:700>;</span> 
  <span style=color:#ce5c00;font-weight:700>}</span>

  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>synchronized</span> <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>compareAndSwap</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>expectedValue</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>newValue</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span> 
    <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>oldValue</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>value</span><span style=color:#ce5c00;font-weight:700>;</span> 
    <span style=color:#204a87;font-weight:700>if</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>oldValue</span> <span style=color:#ce5c00;font-weight:700>==</span> <span style=color:#000>expectedValue</span><span style=color:#ce5c00;font-weight:700>)</span> 
      <span style=color:#000>value</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>newValue</span><span style=color:#ce5c00;font-weight:700>;</span> 
    <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>oldValue</span><span style=color:#ce5c00;font-weight:700>;</span> 
  <span style=color:#ce5c00;font-weight:700>}</span>

  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>synchronized</span> <span style=color:#204a87;font-weight:700>boolean</span> <span style=color:#000>compareAndSet</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>expectedValue</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>newValue</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span> 
    <span style=color:#204a87;font-weight:700>return</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>expectedValue</span> <span style=color:#ce5c00;font-weight:700>==</span> <span style=color:#000>compareAndSwap</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>expectedValue</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>newValue</span><span style=color:#ce5c00;font-weight:700>));</span> 
  <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>当多个线程尝试使用 CAS 同时更新同一个变量时，只有其中一个线程更够成功更新变量的值，而其他线程都将失败。然而，失败的线程并不会被挂起(这与获取锁的情况不同，当获取锁失败时线程将被挂起)，而是被告知在这次竞争中失败，并可以再次尝试。有一个线程在竞争 CAS 时失败不会阻塞，因此它可以决定是否进行重试，或者执行一些恢复动作，也或者不执行任何操作。这种灵活性就大大减少了与锁相关的活跃性风险(尽管在一些不常见的情况下仍然存在活锁风险——见 10.3.3 节)。</p>
<p>CAS 的典型使用模式是：首先从 V 中读取值 A，并根据 A 值计算新值 B，然后通过 CAS 以原子方式将 V 中的值由 A 变成 B(只要在这期间没有任何线程将 V 的值修改为其他值)。由于 CAS 能检测到来自其他线程的干扰，因此即使不适用锁也能实现原子的读-该-写操作序列。</p>
<h3 id=1522-非阻塞计数器>15.2.2 非阻塞计数器</h3>
<p>程序清单 15-2 中的 CasCounter 使用 CAS 实现了一个线程安全的计数器。递增操作采用了标准形式——读取旧值，根据旧值计算出新值(+1)，并使用 CAS 来设置新值。如果 CAS 失败，那么该操作将立即重试。通常，返回重试是一种合理的策略，但在一些竞争很激烈的情况下，更好的方式是在重试之前首先等待一段时间或回退，从而避免造成活锁问题。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#5c35cc;font-weight:700>@ThreadSafe</span> <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>CasCounter</span> <span style=color:#ce5c00;font-weight:700>{</span> 
  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#000>SimulatedCAS</span> <span style=color:#000>value</span><span style=color:#ce5c00;font-weight:700>;</span>

  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>getValue</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span> 
    <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>value</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>get</span><span style=color:#ce5c00;font-weight:700>();</span> 
  <span style=color:#ce5c00;font-weight:700>}</span>

  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>increment</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span> 
    <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>v</span><span style=color:#ce5c00;font-weight:700>;</span> 
    
    <span style=color:#204a87;font-weight:700>do</span> <span style=color:#ce5c00;font-weight:700>{</span> 
      <span style=color:#000>v</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>value</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>get</span><span style=color:#ce5c00;font-weight:700>();</span> 
    <span style=color:#ce5c00;font-weight:700>}</span> <span style=color:#204a87;font-weight:700>while</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>v</span> <span style=color:#ce5c00;font-weight:700>!=</span> <span style=color:#000>value</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>compareAndSwap</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>v</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>v</span> <span style=color:#ce5c00;font-weight:700>+</span> <span style=color:#000>1</span><span style=color:#ce5c00;font-weight:700>));</span> 
    
    <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>v</span> <span style=color:#ce5c00;font-weight:700>+</span> <span style=color:#000>1</span><span style=color:#ce5c00;font-weight:700>;</span> 
  <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>CasCounter 不会阻塞，但如果其他线程同时更新计数器，那么会多次执行重试操作。(在实际情况中，如果仅需要一个计数器或序列生成器，那么可以直接使用 AtomicInteger 或 AtomicLong，它们能提供原子的递增方法和其他一些算术方法)。</p>
<p>咋一看，基于 CAS 的计数器似乎比基于锁的计数器在性能上会更差一些，因为它需要执行更多的操作和更复杂的控制流，并且还依赖于看似复杂的 CAS 操作。但实际上，当竞争程度不高时，基于 CAS 的计数器在性能上远远超过基于锁的计数器，而在没有竞争时甚至更高。如果要快速获取无竞争的锁，那么至少需要一次 CAS 操作再加上与其他锁相关的操作，因此基于所的计数器即使在最好的情况下也会比基于 CAS 的计数器在一般情况下能执行更多的操作。由于 CAS 在大多数情况下都能成功执行(假设竞争程度不高)，因此硬件能够正确的越策 while 循环中的分支，从而把复杂控制逻辑的开销将至最低。</p>
<p>虽然 Java 语言的锁定语法比较简单，但 JVM 和操作在管理锁时需要完成的工作却并不简单。在实现锁定时需要遍历 JVM 中一条非常复杂的代码路径，并可能导致操作系统级的锁定、线程挂起、上下文切换等操作。在最好的情况下，在锁定时至少需要一次 CAS，因此虽然在使用锁时没有用到 CAS，但实际上也无法节约任何执行开销。另一方面，在程序内部执行 CAS 时不需要执行 JVM 代码、系统调用或线程调度操作。在应用级看起来越长的代码路径，如果加上 JVM 和操作系统中的代码调用，那么事实上却变得更短。CAS 的主要缺点是，它将使调用者处理竞争问题(通过重试、回退、放弃)，而在锁中能自动处理竞争问题(线程在获得锁之前将一直阻塞)。</p>
<p>CAS 的性能会随着处理器数量的不同而变化很大。在单 CPU 系统中，CAS 通常只需要很少的时钟周期，因为不需要处理器之间的同步。在编写本书时，非竞争的 CAS 在多 CPU 系统中需要 10 到 150 个时钟周期的开销。CAS 的执行性能不仅在不同的体系架构之间变化很大，甚至在相同处理器的不同版本之间也会发生变化。生产厂商迫于竞争的压力，在接下来的几年内还会继续提高 CAS 的性能。一个很有效的经验法则是：在大多数处理器上，在无竞争的加解锁“快速代码路径”上的开销，大约是 CAS 开销的两倍。</p>
<h3 id=1523-jvm-对-cas-的支持>15.2.3 JVM 对 CAS 的支持</h3>
<p>那么，Java 代码如何确保处理器执行 CAS 操作呢？在 Java 5.0 之前，如果不编写明确的代码，那么就无法执行 CAS。在 Java 5.0 中引入了底层的支持，在 int、long 和对象的引用类型上都公开了 CAS 操作，并且 JVM 把他们编译为底层硬件提供的最有效方法。在支持 CAS 的平台上，运行时再把这些方法编译为对应的(多条)机器指令。在最坏的情况下，如果不支持 CAS 指令，那么 JVM 将使用自旋锁。在原子类变量(AtomicXxx)中使用了这些底层的 JVM 支持为数字类型和引用类型提供了一种高效的 CAS 操作，而在 JUC 中的大多数类在实现时则直接或间接的引用了这些原子变量类。</p>
<h2 id=153-原子变量类>15.3 原子变量类</h2>
<p>原子变量比锁的粒度更细、更加轻量级，这对于在处理器系统上实现高性能并发代码来说是非常关键的。原子变量将发生竞争的范围缩小到单个变量上，这是你获得的粒度最细的情况(假设算法能够基于这种细粒度来实现)。更新原子变量的快速(非竞争)路径不会比获取锁的路径慢，并且通常会更快，而它的慢速路径肯定比锁的慢速路径要快，因为它不需要挂起或重新调度线程。在使用基于原子变量而非锁的算法中，线程在执行时更不易出现延迟，并且如果遇到竞争，也更容易恢复过来。</p>
<p>原子变量类相当于一种泛化的 volatile 变量，能够支持原子的和有条件的读-该-写操作。AtomicInteger 表示一种 int 类型的值，并提供了 get 和 set 方法，这些 volatile 类型的 int 变量在读取和写入上有着相同的内存语义。它还提供了一个原子的 compareAndSet 方法(如果该方法执行成功，那么将实现与读取/写入一个 volatile 变量相同的内存效果)，以及原子的添加、递增和递减等方法。AtomicInteger 表面上非常像一个扩展的 Counter 类，但在发生竞争的情况下能够提供更高的可伸缩性，因为它直接利用了硬件对并发的支持。</p>
<p>共有 12 个原子变量类，可分为 4 组：标量类(Scalar)、更新器类、数组类、符合变量类。最常用的原子变量就是标量类：AtomicInteger、AtomicLong、AtomicBoolean、AtomicReference。所有这些类都支持 CAS，此外，AtomicInteger 和 AtomicLong 还支持算术运算。(要想模拟其他基本类型的原子变量，可以将 short 或 byte 等类型与 int 类型进行转换，以及使用 floatToIntBits 或 doubleToLongBits 来转换浮点数)。</p>
<p>原子数组类(仅支持 Integer、Long、Reference 版本)中的元素可以实现原子更新。原子数组类为数组的元素提供了 volatile 类型的访问语义，这是普通数组所不具备的特性——volatile 类型的数组仅在数组引用上具有 volatile 语义，而在其元素上则没有。</p>
<p>尽管原子标量类扩展了 Number 类，但并没有扩展一些基本类型的包装类，例如 Integer 或 Long。事实上，它们也不能进行扩展：基本类型的包装类是不可修改的，而原子变量类是可修改的。在原子变量类中同样没有定义 hashCode 和 equals 方法，每个实例都是不同的。与其他可变对象相同，它们也不宜用作基于散列的容器中的键值。</p>
<h3 id=1531-原子变量是一种更好的-volatile>15.3.1 原子变量是一种更好的 volatile</h3>
<p>在 3.4.2 节中，我们使用了一个指向不可变对象的 volatile 引用来原子的更新多个状态变量。这个示例依赖于“先检查再运行”，但在这种特殊的情况下，竞争是无害的，因为我们并不关心是否会遇到偶尔的丢失更新操作。而在大多数情况下，这种“先检查再运行”不会是无害的，并且可能会破坏数据的一致性。例如，在第四章中的 NumberRange 既不能使用指向不可变对象的 volatile 引用来安全的实现上界和下界，也不能使用原子的整数来保存这两个边界。由于有一个不变性条件限制了两个数值，并且它们无法在同时更新时还维持该不变性条件，因此如果在数值范围类中使用 volatile 引用或多个原子整数，那么将出现不安全的“先检查再运行”操作序列。</p>
<p>可以将 OneValueCache 中的技术与原子引用结合起来，并通过对指向不可变对象(其中保存了上界和下界)的引用进行原子更新以避免竟态条件。在程序清单 15-3 的 CasNumgerRange 中使用了 AtomicReference 和 IntPair 来保存状态，并通过使用 compareAndSet，使它在更新上界或下界时能避免 NumberRange 的竟态条件。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>CasNumberRange</span> <span style=color:#ce5c00;font-weight:700>{</span>

  <span style=color:#5c35cc;font-weight:700>@Immutable</span> <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>static</span> <span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>IntPair</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#204a87;font-weight:700>final</span> <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>lower</span><span style=color:#ce5c00;font-weight:700>;</span> <span style=color:#8f5902;font-style:italic>// Invariant: lower &lt;= upper
</span><span style=color:#8f5902;font-style:italic></span>    <span style=color:#204a87;font-weight:700>final</span> <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>upper</span><span style=color:#ce5c00;font-weight:700>;</span>
    <span style=color:#ce5c00;font-weight:700>...</span>
  <span style=color:#ce5c00;font-weight:700>}</span> 
  
  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>AtomicReference</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>IntPair</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>values</span> <span style=color:#ce5c00;font-weight:700>=</span>
    <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>AtomicReference</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>IntPair</span><span style=color:#ce5c00;font-weight:700>&gt;(</span><span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>IntPair</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>0</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>0</span><span style=color:#ce5c00;font-weight:700>));</span>

  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>getLower</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span> 
    <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>values</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>get</span><span style=color:#ce5c00;font-weight:700>().</span><span style=color:#c4a000>lower</span><span style=color:#ce5c00;font-weight:700>;</span> 
  <span style=color:#ce5c00;font-weight:700>}</span> 
  
  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>getUpper</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span> 
    <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>values</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>get</span><span style=color:#ce5c00;font-weight:700>().</span><span style=color:#c4a000>upper</span><span style=color:#ce5c00;font-weight:700>;</span> 
  <span style=color:#ce5c00;font-weight:700>}</span>

  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>setLower</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>i</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#204a87;font-weight:700>while</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>true</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span> 
      <span style=color:#000>IntPair</span> <span style=color:#000>oldv</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>values</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>get</span><span style=color:#ce5c00;font-weight:700>();</span> 
      <span style=color:#204a87;font-weight:700>if</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>i</span> <span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>oldv</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>upper</span><span style=color:#ce5c00;font-weight:700>)</span> 
        <span style=color:#204a87;font-weight:700>throw</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>IllegalArgumentException</span><span style=color:#ce5c00;font-weight:700>(</span> <span style=color:#4e9a06>&#34;Can&#39;t set lower to &#34;</span> <span style=color:#ce5c00;font-weight:700>+</span> <span style=color:#000>i</span> <span style=color:#ce5c00;font-weight:700>+</span> <span style=color:#4e9a06>&#34; &gt; upper&#34;</span><span style=color:#ce5c00;font-weight:700>);</span> 
      <span style=color:#000>IntPair</span> <span style=color:#000>newv</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>IntPair</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>i</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>oldv</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>upper</span><span style=color:#ce5c00;font-weight:700>);</span> 
      <span style=color:#204a87;font-weight:700>if</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>values</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>compareAndSet</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>oldv</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>newv</span><span style=color:#ce5c00;font-weight:700>))</span> 
        <span style=color:#204a87;font-weight:700>return</span><span style=color:#ce5c00;font-weight:700>;</span> 
    <span style=color:#ce5c00;font-weight:700>}</span>
  <span style=color:#ce5c00;font-weight:700>}</span> 
  <span style=color:#8f5902;font-style:italic>// similarly for setUpper
</span><span style=color:#8f5902;font-style:italic></span><span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><h3 id=1532-性能比较锁与原子变量>15.3.2 性能比较：锁与原子变量</h3>
<p>为了说明锁和原子变量之间的可伸缩性差异，我们构造了一个基准测试，其中将比较伪随机数生成器(PRNG)的集中不同实现。在 PRNG 中，当生产下一个随机数时需要用到上一个数字，所以在 PRNG 中必须记录上一个数值并将其作为状态的一部分。</p>
<p>程序清单 15-4 和程序清单 15-5 给出了线程安全的 PRNG 的两种实现，一种使用 ReentrantLock，另一种使用 AtomicInteger。测试程序将返回调用它们，在每次迭代中将生成一个伪随机数(在此过程中将读取并修改共享的 seed 状态)，并执行一些仅在线程本地数据上执行的“繁忙”迭代，这种方式模拟了一些典型操作，以及一些在共享状态以及线程本地状态上的操作。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#5c35cc;font-weight:700>@ThreadSafe</span> 
<span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>ReentrantLockPseudoRandom</span> <span style=color:#204a87;font-weight:700>extends</span> <span style=color:#000>PseudoRandom</span> <span style=color:#ce5c00;font-weight:700>{</span>

  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>Lock</span> <span style=color:#000>lock</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>ReentrantLock</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>false</span><span style=color:#ce5c00;font-weight:700>);</span>
  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>seed</span><span style=color:#ce5c00;font-weight:700>;</span>

  <span style=color:#000>ReentrantLockPseudoRandom</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>seed</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span> 
    <span style=color:#204a87;font-weight:700>this</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>seed</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>seed</span><span style=color:#ce5c00;font-weight:700>;</span> 
  <span style=color:#ce5c00;font-weight:700>}</span>

  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>nextInt</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>n</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#000>lock</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>lock</span><span style=color:#ce5c00;font-weight:700>();</span> 
    <span style=color:#204a87;font-weight:700>try</span> <span style=color:#ce5c00;font-weight:700>{</span> 
      <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>s</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>seed</span><span style=color:#ce5c00;font-weight:700>;</span> 
      <span style=color:#000>seed</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>calculateNext</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>s</span><span style=color:#ce5c00;font-weight:700>);</span> 
      <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>remainder</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>s</span> <span style=color:#ce5c00;font-weight:700>%</span> <span style=color:#000>n</span><span style=color:#ce5c00;font-weight:700>;</span> 
      <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>remainder</span> <span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>0</span> <span style=color:#ce5c00;font-weight:700>?</span> <span style=color:#000>remainder</span> <span style=color:#ce5c00;font-weight:700>:</span> <span style=color:#000>remainder</span> <span style=color:#ce5c00;font-weight:700>+</span> <span style=color:#000>n</span><span style=color:#ce5c00;font-weight:700>;</span> 
    <span style=color:#ce5c00;font-weight:700>}</span> <span style=color:#204a87;font-weight:700>finally</span> <span style=color:#ce5c00;font-weight:700>{</span> 
      <span style=color:#000>lock</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>unlock</span><span style=color:#ce5c00;font-weight:700>();</span> 
    <span style=color:#ce5c00;font-weight:700>}</span>
  <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#5c35cc;font-weight:700>@ThreadSafe</span> 
<span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>AtomicPseudoRandom</span> <span style=color:#204a87;font-weight:700>extends</span> <span style=color:#000>PseudoRandom</span> <span style=color:#ce5c00;font-weight:700>{</span> 
  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#000>AtomicInteger</span> <span style=color:#000>seed</span><span style=color:#ce5c00;font-weight:700>;</span>

  <span style=color:#000>AtomicPseudoRandom</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>seed</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span> 
    <span style=color:#204a87;font-weight:700>this</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>seed</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>AtomicInteger</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>seed</span><span style=color:#ce5c00;font-weight:700>);</span> 
  <span style=color:#ce5c00;font-weight:700>}</span>

  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>nextInt</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>n</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span> 
    <span style=color:#204a87;font-weight:700>while</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>true</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span> 
      <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>s</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>seed</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>get</span><span style=color:#ce5c00;font-weight:700>();</span> 
      <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>nextSeed</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>calculateNext</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>s</span><span style=color:#ce5c00;font-weight:700>);</span> 
      <span style=color:#204a87;font-weight:700>if</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>seed</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>compareAndSet</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>s</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>nextSeed</span><span style=color:#ce5c00;font-weight:700>))</span> <span style=color:#ce5c00;font-weight:700>{</span> 
        <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>remainder</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>s</span> <span style=color:#ce5c00;font-weight:700>%</span> <span style=color:#000>n</span><span style=color:#ce5c00;font-weight:700>;</span> 
        <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>remainder</span> <span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>0</span> <span style=color:#ce5c00;font-weight:700>?</span> <span style=color:#000>remainder</span> <span style=color:#ce5c00;font-weight:700>:</span> <span style=color:#000>remainder</span> <span style=color:#ce5c00;font-weight:700>+</span> <span style=color:#000>n</span><span style=color:#ce5c00;font-weight:700>;</span>
      <span style=color:#ce5c00;font-weight:700>}</span> 
    <span style=color:#ce5c00;font-weight:700>}</span> 
  <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>图 15-1 和图 15-2 给出了在每次迭代中工作量较低以及适中情况下的吞吐量。如果线程本地的计算量较少，那么在锁和原子变量上的竞争将非常激烈，如果线程本地的计算量较多，那么在锁和原子变量上的竞争会降低，因为线程访问锁和原子变量的频率将会降低。</p>
<div align=center>
<img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20181118180105.png style=display:block;width:70% alt=15-1 align=center>
</div>
<div align=center>
<img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20181118180121.png style=display:block;width:70% alt=15-2 align=center>
</div>
<p>从这些图中可以看出，在高度竞争的情况下，锁的性能将超过原子变量的性能，但是在更真实的竞争情况下，原子变量的性能则会超过锁的性能。这是因为锁在发生竞争时会挂起线程，从而降低了 CPU 的使用率和共享内存总线上的同步通信量。(这类似于在生产者消费者设计中的可阻塞生产者，它能降低消费者上的工作负担，使消费者的处理速度赶上生产者的处理速度)。另一方面，如果使用原子变量，那么发出调用的类负责对竞争进行管理。与大多数基于 CAS 的算法一样，AtomicPseudoRandom 在遇到竞争时会立即重试，这通常是一种正确的做法，但在激烈竞争的环境下却导致了更多的竞争。</p>
<p>在批评 AtomicPseudoRandom 写得太糟糕或者原子变量比锁更糟糕之前，应该意识到图 15-1 中竞争级别过高而有些不切实际：任何一个真实的程序都不会除了竞争锁或原子变量，其他什么工作都不做。在实际情况中，原子变量在可伸缩性上要高于锁，因为在应对常见的竞争程度时，原子变量的效率会更高。</p>
<p>锁与原子变量在不同竞争程度上的性能差异很好的说明了各自的优势和劣势。在中低程度的竞争下，原子变量能够提供更好的可伸缩性，而在高轻度的竞争下，锁能够更有效的避免竞争。(在单 CPU 系统中，基于 CAS 算法在性能上同样会超过基于所的算法，因为 CAS 在单 CPU 的系统上通常能执行成功，只有在偶然情况下，线程才会在执行读-改-写的操作过程中被其他线程抢占执行)。</p>
<p>在图 15-1 和图 15-2 中都包含了第三条曲线，它是一个使用 ThreadLocal 来保存 PRNG 状态的 RseudoRandom。这种实现方法改变了类的行为，即每个线程都只能看到自己私有的伪随机数序列，而不是所有线程共享同一个随机数序列，这说明了，如果能够避免使用共享状态，那么开销将会更小。我们可以通过提供处理竞争的效率来提高可伸缩性，但只有完全消除竞争，才能实现真正的可伸缩性。</p>
<h2 id=154-非阻塞算法>15.4 非阻塞算法</h2>
<p>在基于所的算法中可能会发生各种活跃性故障。如果线程在持有锁时由于阻塞 IO、内存缺页、或其他延迟而导致推迟执行，那么很可能所有线程都不能继续执行下去。如果在某种算法中，一个线程的失败或挂起不会导致其他线程也失败或挂起，那么这种算法就被称为非阻塞算法。如果在算法的每个步骤中都存在某个线程能够执行下去，那么这种算法也被称为无锁(lock-free)算法。如果在算法中仅将 CAS 用于协调线程之间的操作，并且能够正确的实现，那么它既是一种非阻塞算法，又是一种无锁算法。无竞争的 CAS 通常都能执行成功，并且如果有多个线程竞争同一个 CAS，那么总会有一个线程在竞争中胜出并执行下去。在非阻塞算法中通常不会出现死锁和优先级反转问题(但可能会出现饥饿和活锁问题，因为在算法中会反复的出现重试)。到目前为止，我们已经看到了一个非阻塞算法：CasCounter。在许多常见的数据结构中都可以使用非阻塞算法，包括栈、队列、优先队列、以及散列表等，而要设计一些新的这种数据结构，最好还是由专家们来完成。</p>
<h3 id=1541-非阻塞的栈>15.4.1 非阻塞的栈</h3>
<p>在实现相同功能的前提下，非阻塞算法通常比基于锁的算法更为复杂。创建非阻塞算法的关键在于，找出如何将原子修改的范围缩小到单个变量上，同时还要维护数据的一致性。在链式容器类中，有时候无需将状态转换操作表示为对节点链接的修改，也无需使用 AtomicReference 来表示每个必须采用原子操作来更新链接。</p>
<p>栈是最简单的链式数据结构：每个元素仅指向一个元素，并且每个元素也只被一个元素引用。在程序清单 15-6 的 ConcurrentStack 中给出了如何通过原子引用来构建栈的示例。栈是由 Node 元素构成的一个链表，其中栈顶作为根节点，并且在每个元素中都包含了一个值以及指向下一个元素的链接。put 方法创建一个新的节点，该节点的 next 域指向当前的栈顶，然后使用 CAS 把这个新节点放入栈顶。如果在开始插入节点时，位于栈顶的节点没有发生变化，那么 CAS 就会成功，如果栈顶节点发生了变化(比如由于其他线程在本线程开始之前插入或移除了元素)，那么 CAS 将会失败，而 push 方法会根据栈的当前状态来更新节点，并且再次尝试。无论哪种情况，在 CAS 执行完成后，栈仍会处于一致的状态。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#5c35cc;font-weight:700>@ThreadSafe</span> 
<span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>ConcurrentStack</span> <span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>E</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#ce5c00;font-weight:700>{</span> 
  <span style=color:#000>AtomicReference</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>Node</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>E</span><span style=color:#ce5c00;font-weight:700>&gt;&gt;</span> <span style=color:#000>top</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>AtomicReference</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>Node</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>E</span><span style=color:#ce5c00;font-weight:700>&gt;&gt;();</span>

  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>push</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>E</span> <span style=color:#000>item</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span> 
    <span style=color:#000>Node</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>E</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>newHead</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>Node</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>E</span><span style=color:#ce5c00;font-weight:700>&gt;(</span><span style=color:#000>item</span><span style=color:#ce5c00;font-weight:700>);</span> 
    <span style=color:#000>Node</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>E</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>oldHead</span><span style=color:#ce5c00;font-weight:700>;</span> 
    <span style=color:#204a87;font-weight:700>do</span> <span style=color:#ce5c00;font-weight:700>{</span> 
      <span style=color:#000>oldHead</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>top</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>get</span><span style=color:#ce5c00;font-weight:700>();</span> 
      <span style=color:#000>newHead</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>next</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>oldHead</span><span style=color:#ce5c00;font-weight:700>;</span> 
    <span style=color:#ce5c00;font-weight:700>}</span> <span style=color:#204a87;font-weight:700>while</span> <span style=color:#ce5c00;font-weight:700>(!</span><span style=color:#000>top</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>compareAndSet</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>oldHead</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>newHead</span><span style=color:#ce5c00;font-weight:700>));</span> 
  <span style=color:#ce5c00;font-weight:700>}</span>

  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#000>E</span> <span style=color:#000>pop</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#000>Node</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>E</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>oldHead</span><span style=color:#ce5c00;font-weight:700>;</span> 
    <span style=color:#000>Node</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>E</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>newHead</span><span style=color:#ce5c00;font-weight:700>;</span> 
    <span style=color:#204a87;font-weight:700>do</span> <span style=color:#ce5c00;font-weight:700>{</span>
      <span style=color:#000>oldHead</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>top</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>get</span><span style=color:#ce5c00;font-weight:700>();</span>
      <span style=color:#204a87;font-weight:700>if</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>oldHead</span> <span style=color:#ce5c00;font-weight:700>==</span> <span style=color:#204a87;font-weight:700>null</span><span style=color:#ce5c00;font-weight:700>)</span>
        <span style=color:#204a87;font-weight:700>return</span> <span style=color:#204a87;font-weight:700>null</span><span style=color:#ce5c00;font-weight:700>;</span>
      <span style=color:#000>newHead</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>oldHead</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>next</span><span style=color:#ce5c00;font-weight:700>;</span> 
    <span style=color:#ce5c00;font-weight:700>}</span> <span style=color:#204a87;font-weight:700>while</span> <span style=color:#ce5c00;font-weight:700>(!</span><span style=color:#000>top</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>compareAndSet</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>oldHead</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>newHead</span><span style=color:#ce5c00;font-weight:700>));</span> 
    
    <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>oldHead</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>item</span><span style=color:#ce5c00;font-weight:700>;</span>
  <span style=color:#ce5c00;font-weight:700>}</span>

  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>static</span> <span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>Node</span> <span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>E</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#ce5c00;font-weight:700>{</span> 
    <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>E</span> <span style=color:#000>item</span><span style=color:#ce5c00;font-weight:700>;</span> <span style=color:#204a87;font-weight:700>public</span> <span style=color:#000>Node</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>E</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>next</span><span style=color:#ce5c00;font-weight:700>;</span>
  
    <span style=color:#204a87;font-weight:700>public</span> <span style=color:#000>Node</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>E</span> <span style=color:#000>item</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span> <span style=color:#204a87;font-weight:700>this</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>item</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>item</span><span style=color:#ce5c00;font-weight:700>;</span> <span style=color:#ce5c00;font-weight:700>}</span>
  <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>在 CasCounter 和 ConcurrentStack 中说明了非阻塞算法的所有特性：某项工作的完成具有不确定性，必须重新执行。在 ConcurrentStack 中，当构造表示新元素的 Node 时，我们系统当把这个新节点压入到栈时，其 next 引用的值仍然是正确的，同时也准备好在发生竞争时的清下重新尝试。</p>
<p>在像 ConcurrentStack 这样的非阻塞算法中都能确保线程安全性，因为 compareAndSet 像锁定机制一样，技能提高原子性，又能提高可见性。当一个线程需要改变栈的状态时，将调用 compareAndSet，这个方法与写入 volatile 变量一样有着相同的内存效果。当线程检查站的状态时，将在同一个 AtomicReference 上调用 get 方法，该方法与读取 volatile 变量有着相同的内存效果。因此，一个线程执行的任何修改结构都可以安全的发布给其他正在查看状态的线程。并且，这个栈是通过 compareAndSet 来修改的，因此将采用原子操作来更新 top 的引用，或者在发现存在其他线程干扰的情况下，修改操作将失败。</p>
<h3 id=1542-非阻塞链表>15.4.2 非阻塞链表</h3>
<p>到目前为止，我们已经看到了两个非阻塞算法，计数器和栈，它们很好的说明了 CAS 的基本使用状态：在更新某个值时存在不确定性，以及在更新失败时重新尝试。构建非阻塞算法的技巧在于：将执行原子修改的范围缩小到单个变量上。这在计数器中很容易实现，在栈中也很简单，但对于一些更复杂的数据结构来说，如队列、散列表、树，这也要复杂的多。</p>
<p>连接队列比栈更为复杂，因为他必须支持对头结点和尾节点的快速访问。因此，它需要单独维护头指针和尾指针。有两个指针指向位于尾部的节点：当前最后一个元素的 next 指针，以及尾节点。当成功的插入一个新元素时，这两个指针都需要采用原子操作来更新。初看起来，这个操作无法通过原子变量来实现。在更新这两个指针时需要不同的 CAS 操作，并且如果第一个 CAS 成功，但第二个 CAS 失败，那么队列将处于不一致的状态。并且，即使这两个 CAS 都成功了，那么在执行这两个 CAS 之间，让可能有另一个线程会访问队列。因此，在为链表队列构建非阻塞算法时，需要考虑到这两种情况。</p>
<p>我们需要使用一种技巧。第一个技巧是，即使在一个包含多个步骤的更新过程中，也要确保数据结构总是处于一致的状态。这样，当线程 B 到达时，如果发现线程 A 正在执行更新，那么线程 B 就可以知道有一个操作已经部分完成，并且不能立即开始自己的更新操作。然后，B 可以等待(通过反复检查队列的状态)并直到 A 完成更新，从而使两个线程不会互相干扰。</p>
<p>虽然这种方法能够使不同的线程“轮流”访问数据结构，并且不会造成破坏，但如果一个线程在更新操作中失败了，那么其他线程都无法再访问队列。要使得该算法成为一个非阻塞算法，必须确保当一个线程失败时不会妨碍其他线程继续执行下去。因此，第二个技巧在于，如果当 B 到达时发现 A 正在修改数据结构，那么在数据结构中应该有足够多的信息，使得 B 能够完成 A 的更新操作。如果 B “帮助” A 完成了更新操作，那么 B 就可以执行自己的操作，而不用等待 A 的操作完成。当 A 恢复后再试图完成其操作时，会发现 B 已经替他完成了。</p>
<p>在程序清单 15-7 中的 LinkedQueue 中给出了 Michael-Scott 提出的非阻塞链接队列算法中的插入部分，在 ConcurrentLinkedQueue 中使用的正式该算法。在许多队列算法中，空队列通常都包含一个“哨兵节点”或者“哑节点”，并且头节点和尾节点在初始化时都指向该哨兵节点。尾节点通常要么指向哨兵节点(如果队列为空)，即队列的最后一个元素；要么指向(当有操作正在进行更新时)指向倒数第二个元素。图 15-3 给出了一个处于正常状态(或者说稳定状态)的包含两个元素的队列。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#5c35cc;font-weight:700>@ThreadSafe</span> 
<span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>LinkedQueue</span> <span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>E</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#ce5c00;font-weight:700>{</span>

  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>static</span> <span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>Node</span> <span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>E</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#ce5c00;font-weight:700>{</span> 
    <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>E</span> <span style=color:#000>item</span><span style=color:#ce5c00;font-weight:700>;</span> 
    <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>AtomicReference</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>Node</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>E</span><span style=color:#ce5c00;font-weight:700>&gt;&gt;</span> <span style=color:#000>next</span><span style=color:#ce5c00;font-weight:700>;</span>

    <span style=color:#204a87;font-weight:700>public</span> <span style=color:#000>Node</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>E</span> <span style=color:#000>item</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>Node</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>E</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>next</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span> 
      <span style=color:#204a87;font-weight:700>this</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>item</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>item</span><span style=color:#ce5c00;font-weight:700>;</span> 
      <span style=color:#204a87;font-weight:700>this</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>next</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>AtomicReference</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>Node</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>E</span><span style=color:#ce5c00;font-weight:700>&gt;&gt;(</span><span style=color:#000>next</span><span style=color:#ce5c00;font-weight:700>);</span> 
    <span style=color:#ce5c00;font-weight:700>}</span>
  <span style=color:#ce5c00;font-weight:700>}</span>

  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>Node</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>E</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>dummy</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>Node</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>E</span><span style=color:#ce5c00;font-weight:700>&gt;(</span><span style=color:#204a87;font-weight:700>null</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#204a87;font-weight:700>null</span><span style=color:#ce5c00;font-weight:700>);</span> 	
  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>AtomicReference</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>Node</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>E</span><span style=color:#ce5c00;font-weight:700>&gt;&gt;</span> <span style=color:#000>head</span> <span style=color:#ce5c00;font-weight:700>=</span> 
    <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>AtomicReference</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>Node</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>E</span><span style=color:#ce5c00;font-weight:700>&gt;&gt;(</span><span style=color:#000>dummy</span><span style=color:#ce5c00;font-weight:700>);</span> 
  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>AtomicReference</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>Node</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>E</span><span style=color:#ce5c00;font-weight:700>&gt;&gt;</span> <span style=color:#000>tail</span> <span style=color:#ce5c00;font-weight:700>=</span> 
    <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>AtomicReference</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>Node</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>E</span><span style=color:#ce5c00;font-weight:700>&gt;&gt;(</span><span style=color:#000>dummy</span><span style=color:#ce5c00;font-weight:700>);</span>

  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>boolean</span> <span style=color:#000>put</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>E</span> <span style=color:#000>item</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#000>Node</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>E</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>newNode</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>Node</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>E</span><span style=color:#ce5c00;font-weight:700>&gt;(</span><span style=color:#000>item</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#204a87;font-weight:700>null</span><span style=color:#ce5c00;font-weight:700>);</span> 
    <span style=color:#204a87;font-weight:700>while</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>true</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span> 
      <span style=color:#000>Node</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>E</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>curTail</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>tail</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>get</span><span style=color:#ce5c00;font-weight:700>();</span> 
      <span style=color:#000>Node</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>E</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>tailNext</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>curTail</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>next</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>get</span><span style=color:#ce5c00;font-weight:700>();</span> 
      <span style=color:#204a87;font-weight:700>if</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>curTail</span> <span style=color:#ce5c00;font-weight:700>==</span> <span style=color:#000>tail</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>get</span><span style=color:#ce5c00;font-weight:700>())</span> <span style=color:#ce5c00;font-weight:700>{</span>
        <span style=color:#204a87;font-weight:700>if</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>tailNext</span> <span style=color:#ce5c00;font-weight:700>!=</span> <span style=color:#204a87;font-weight:700>null</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span> 
          <span style=color:#8f5902;font-style:italic>// Queue in intermediate state, advance tail
</span><span style=color:#8f5902;font-style:italic></span>          <span style=color:#000>tail</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>compareAndSet</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>curTail</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>tailNext</span><span style=color:#ce5c00;font-weight:700>);</span> 
        <span style=color:#ce5c00;font-weight:700>}</span> <span style=color:#204a87;font-weight:700>else</span> <span style=color:#ce5c00;font-weight:700>{</span> 
          <span style=color:#8f5902;font-style:italic>// In quiescent state, try inserting new node
</span><span style=color:#8f5902;font-style:italic></span>          <span style=color:#204a87;font-weight:700>if</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>curTail</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>next</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>compareAndSet</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>null</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>newNode</span><span style=color:#ce5c00;font-weight:700>))</span> <span style=color:#ce5c00;font-weight:700>{</span> 
            <span style=color:#8f5902;font-style:italic>// Insertion succeeded, try advancing tail
</span><span style=color:#8f5902;font-style:italic></span>            <span style=color:#000>tail</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>compareAndSet</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>curTail</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>newNode</span><span style=color:#ce5c00;font-weight:700>);</span> 
            <span style=color:#204a87;font-weight:700>return</span> <span style=color:#204a87;font-weight:700>true</span><span style=color:#ce5c00;font-weight:700>;</span>
          <span style=color:#ce5c00;font-weight:700>}</span>
        <span style=color:#ce5c00;font-weight:700>}</span>
      <span style=color:#ce5c00;font-weight:700>}</span>
    <span style=color:#ce5c00;font-weight:700>}</span>	
  <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><div align=center>
<img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20181118180145.png style=display:block;width:70% alt=15-3 align=center>
</div>
<p>当插入一个新的元素时，需要更新两个指针。首先更新当前最后一个元素的 nex 指针，将新节点连接到列表队尾，然后更新尾节点，将其指向这个新元素。在这两个操作之间，队列处于一种中间状态，如图 15-4 所示。在第二次更新完成后，队列将再次处于稳定状态，如图 15-5 所示。</p>
<div align=center>
<img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20181118180159.png style=display:block;width:70% alt=15-4 align=center>
</div>
<div align=center>
<img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20181118180213.png style=display:block;width:70% alt=15-5 align=center>
</div>
<p>实现这两个技巧时的关键点在于：当队列处于稳定状态时，尾节点的 next 域将为空，如果队列处于中间状态，呢么 tail.next 将为非空。因此，任何线程队能够通过检查 tail.next 来获取队列的当前状态。而且，当队列处于中间状态时，可以通过将尾节点向前移动一个节点，从而结束其他线程正在执行的插入元素操作，并使得队列恢复为稳定状态。</p>
<p>LinkedQueue.put 方法在插入新元素之前，将首先检查队列是否处于中间状态(步骤 A)。如果是，那么有另一个线程正在插入元素(在步骤 C 和 D 之间)。此时当前线程不会等待其他线程执行完成，而是帮助它完成操作，并将尾节点向前推进一个节点(步骤 B)。然后，它将重新恢复执行这种检查，以免另一个线程已经开始插入新元素，并继续推进尾节点，知道它发现队列处于稳定状态之后，才会开始执行自己的插入操作。</p>
<p>由于步骤 C 中的 CAS 将把新节点链接到队列尾部，因此如果两个线程同时插入元素，那么这个 CAS 将失败。在这样的情况下，并不会造成破坏：不会发生任何变化，并且当前的线程只需要重新读取尾节点并再次重试。如果步骤 C 成功了，那么插入操作将生效，第二个 CAS(步骤 D)被认为是一个“清理操作”，因为它既可以由执行插入操作的线程来执行，也可以由其他任何线程来执行。如果步骤 D 失败了，那么执行插入操作的线程将返回，而不是重新执行 CAS，因为不再需要重试——另一个线程已经在步骤 B 中完成了这个工作。这种方式能够工作，因为在任何线程尝试将一个新节点插入到队列之前，都会首先通过检查 tail.next 是否为空来判断是否需要执行清理工作。如果是，它首先会推进尾节点(可能需要执行多次)，知道队列处于稳定状态。</p>
<h3 id=1543-原子的域更新器>15.4.3 原子的域更新器</h3>
<p>程序清单 15-7 说明了在 ConcurrentLinkedQueue 中使用的算法，但在实际的实现中略有区别。在 ConcurrentLinkedQueue 中没有使用原子引用来表示每个 Node，而是使用普通的 volatile 类型应用，并通过基于反射的 AtomicReferenceFieldUpdater 来进行更新，如程序清单 15-8 所示。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>Node</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>E</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#ce5c00;font-weight:700>{</span>
  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>E</span> <span style=color:#000>item</span><span style=color:#ce5c00;font-weight:700>;</span> <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>volatile</span> <span style=color:#000>Node</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>E</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>next</span><span style=color:#ce5c00;font-weight:700>;</span>

  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#000>Node</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>E</span> <span style=color:#000>item</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span> 
    <span style=color:#204a87;font-weight:700>this</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>item</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>item</span><span style=color:#ce5c00;font-weight:700>;</span> 
  <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#ce5c00;font-weight:700>}</span>

<span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>static</span> <span style=color:#000>AtomicReferenceFieldUpdater</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>Node</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>Node</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>nextUpdater</span> <span style=color:#ce5c00;font-weight:700>=</span> 
  <span style=color:#000>AtomicReferenceFieldUpdater</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>newUpdater</span><span style=color:#ce5c00;font-weight:700>(</span> <span style=color:#000>Node</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>class</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>Node</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>class</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#4e9a06>&#34;next&#34;</span><span style=color:#ce5c00;font-weight:700>);</span>
</code></pre></div><p>原子的类更新器类表示现有的 volatile 域的一种基于反射的视图，从而能够在已有的 volatile 域上使用 CAS。在更新器类中没有构造函数，要创建一个更新器对象，可以调用 newUpdater 工厂方法，并指定类和域的名字。域更新器类没有与某个特定的实例关联在一起，因而可以更新目标类的任意实例中的指定域。更新器提供的原子性保证比普通原子类更弱一些，因为无法保证底层的域不被直接修改——compareAndSet 以及其他算法方法只能确保其他使用原子域更新器方法的线程的原子性。</p>
<p>在 ConcurrentLinkedQueue 中，使用 nextUpdater 的 compareAndSet 方法来更新 Node 的 next 域。这个方法有点繁琐，但完全是为了提升性能。对于一些频繁分配并且生命周期很短的对象，如队列的链接节点，如果能去掉每个 Node 的 AtomicReference 创建过程，那么将极大的降低插入操作的开销。然而，几乎在所有情况下，普通原子变量的性能都很不错，只有在很少的情况下才需要使用原子的域更新器。(如果在执行原子更新的同时还需要维持现有类的串行化形式，那么原子的域更新器将非常有用)。</p>
<h3 id=1544-aba-问题>15.4.4 ABA 问题</h3>
<p>ABA 问题是一种异常现象：如果在算法中的节点可以被循环使用，那么在使用 CAS 指令时就可能出现这种问题(主要在没有垃圾回收机制的环境中)。在 CAS 操作中将判断 “V 的值是否仍然为 A？”，并且如果是的话就继续执行更新操作。在大多数情况下，包括本章给出的示例，这种判断是完全足够的。然而，有时候还是需要知道“自从上次看到 V 的值为 A 以来，这个值是否发生过变化？”。在某些算法中，如果 V 的值首先由 A 变为 B，再由 B 变为 A，那么仍然被认为是发生了变化，并需要重新执行算法中的某些步骤。</p>
<p>如果在算法中采用自己的方式来管理节点对象的内存，那么可能出现 ABA 问题。在这种情况下，即使链表的头结点仍然指向之前观察到的节点，那么也不足以说明链表的内容没有发生改变。如果通过垃圾回收器来管理链表节点仍然无法避免 ABA 问题，那么还有一个相对简单的解决方案：不是更新某个引用的值，而是更新两个值，包括一个引用和一个版本号。即使这个值由 A 变为 B，然后又变为 A，版本号也将是不同的。AtomicStampedReference(以及 AtomicMarkableReference)支持在两个变量上执行原子的条件更新。AtomicStampedReference 将更新一个“对象-引用”二元组，通过在引用上加上“版本号”，从而避免 ABA 问题。类似的，AtomicMarkableReference 将更新一个“对象引用-布尔值”二元组，在某些算法中将通过这种二元组使节点保存在链表中同时又将其标记为“已删除的节点”。</p>
<h2 id=小结>小结</h2>
<p>非阻塞算法通过底层的并发原语(如 CAS 而不是锁)来维持线程安全性。这些底层的原语通过原子变量类向外公开，这些类也用作一种“更好的 volatile 变量”，从而为整数和对象引用提供原子的更新操作。</p>
<p>非阻塞算法在设计和实现时非常困难，但通常能够提供更高的可伸缩性，并能更好的防止活跃性故障的发生。在 JVM 从一个版本升级到下一个版本的过程中，并发性能的主要提升都来自于(在 JVM 内部以及平台类库中)对非阻塞算法的使用。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-1e8879bd4c4535a8d4a95fb00a603a9c>16 - CH16-内存模型</h1>
<p>本书中，我们尽可能的避开了 Java 内存模型(JMM)的底层细节，而将重点放在一些高层次的设计问题，如安全发布、同步策略的规范以及一致性等。它们的安全性都来自于 JMM，并且当你理解了这些机制的工作原理之后，就能更容易的使用它们。本章将介绍 JMM 的底层需求以及它提供的保证，此外还将介绍在本书给出的一些高层设计原则背后的原理。</p>
<h2 id=161-什么是内存模型为什么需要它>16.1 什么是内存模型，为什么需要它</h2>
<p>假设一个线程为变量 aVariable 赋值：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#000>aVariable</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>3</span><span style=color:#ce5c00;font-weight:700>;</span>
</code></pre></div><p>内存模型需要解决一个问题：“在什么条件下，读取 aVariable 的线程将看到它的值为 3？”。这听起来似乎是一个愚蠢的问题，但如果缺少同步，那么将会发生很多因素使得线程无法立即甚至永远看到另一个线程的操作结果。在编译器中生成的指令顺序，可以与源码中的顺序不同，此外编译器还会把变量保存在寄存器而非内存中：处理器可以采用乱序执行或并行等方式来执行指令；缓存可能会改变将写入变量提交到主存的次序；而且，保存在处理器本地缓存中的值，对于其他处理器是不可见的。这些因素都会使得一个线程无法看到变量的最新值，并且会导致其他线程中的内存操作似乎在乱序执行——如果没有使用正确的同步。</p>
<p>在单线程环境中，我们无法看到所有这些底层技术，它们除了提高程序的执行速度外，不会产生太大的影响。Java 语言规范要求 JVM 在线程中维护一种类似串行的语义：只要程序的最终结果与在严格串行环境中执行的结果相同，那么上述所有操作都是允许的。这确实是一件好事情，因为在最近几年中，计算性能的提升在很大程度上要归功于这些重排序措施。当然，时钟频率的提升同样提升了性能，此外还有不断提升的并行性——采用流水线的超标量执行单元、动态指令调度、猜测执行以及完备的多级缓存。随着处理器变得越来越强大，编译器也不断地在改进：通过对指令重排序来实现执行优化，以及使用成熟的全局寄存器分配算法。由于时钟频率越来越难以提高，因此许多处理器制造厂商都开始转而生产多核处理器，因为能够提高的只有硬件的并行性。</p>
<p>在多线程环境中，维护程序的串行性将导致很大的性能开销。对于开发应用程序中的线程来说，他们在大部分时间里都执行各自的任务，因此在线程之间的协调操作只会降低应用程序的运行速度，而不会带来任何好处。只有当多个线程要共享数据时，才必须协调它们之间的操作，并且 JVM 依赖程序通过通过操作来找出这些协调操作将会在何时发生。</p>
<p>JMM 规定了 JVM 必须遵循一组最小保证，这组保证规定了对变量的写入操作在何时将对于其他线程可见。JMM 在设计是就在可预测性和程序的易于开发性之间进行了权衡，从而在各种主流的处理器体系架构上能够实现高性能的 JVM。如果你不了解现代处理器和编译器中使用的程序性能优化措施，那么在刚刚接触 JMM 的某些方面时会感到困惑。</p>
<h3 id=1611-平台的内存模型>16.1.1 平台的内存模型</h3>
<p>在共享内存的多处理器体系架构中，每个处理器都拥有自己的缓存，并且定期的与主内存进行协调。在不同的处理器架构中提供了不同级别的缓存一致性(Cache Coherence)，其中一部分只提供最低的保证，即允许不同的处理器在任意时刻从一个存储位置上看到不同的值。操作系统、编译器以及运行时(有时甚至还包括应用程序)需要弥合这种在硬件能力与线程安全需求之间的差异。</p>
<p>要想确保每个处理器都能在任意时刻知道其他处理器正在进行的工作，将需要非常大的开销。在大多数时间里，这种信息都是不需要的，因此处理器会适当放宽存储一致性保证，以换取性能的提升。在架构定义的内存模型中将告诉应用程序可以从内存系统中获取怎样的保证，此外还定义了一些特殊的指令(称为内存屏障或屏障)，当需要共享数据时，这些指令就能实现额外的存储协调保证。为了使 Java 开发在人员无需关心不同架构上内存模型之间的差异，Java 还提供了自己的内存模型，并且 JVM 通过在适当的位置上插入内存屏障来屏蔽在 JMM 与底层平台内存模型之间的差异。</p>
<p>程序执行一段简单的假设：想象在程序中只存在唯一的操作执行顺序，而不考虑这些操作在何种处理器上执行，并且在每次读取变量时，都能获得在执行时序中(在任何处理器)最近一次写入该变量的值。这种乐观的模型就被称为串行一致性。软件开发人员经常会错误的假设存在串行一致性，但在任何一款现代多处理器架构中都不会提供这种串行一致性，JMM 也是如此。冯诺依曼模型中这种经典串行计算模型，只能近似描述现代多处理器的行为。</p>
<p>在现代支持共享内存的多处理器(和编译器)中，当跨线程共享数据时，会出现一些奇怪的情况，除非通过使用内存屏障来防止这些情况的发生。幸运的是，Java 程序不需要指定内存屏障的位置，而只需要正确的使用同步来找出何时将访问共享状态。</p>
<h3 id=1612-重排序>16.1.2 重排序</h3>
<p>在第二章中介绍竟态条件和原子性故障时，我们使用了交互图来说明：在没有充分同步的程序中，如果调度器采用不恰当的方式来交替执行不同线程的操作，那么将导致不正确的结果。更糟的是，JMM 还使得不同线程看到的操作执行顺序是不同的，从而导致在缺乏同步的情况下，要推断操作的执行顺序将变得更加复杂。各种使操作延迟或者看似乱序执行的不同原因，都可以归为重排序。</p>
<p>在程序清单 16-1 的 PossibleReording 中说明了，在么有正确同步的情况下，即使要推断最简单的并发程序的行为也是很困难的。很容易想象 PossibleReording 是如何输出(1,0)或(0,1)或(1,1)的：线程 A 可以在线程 B 开始之前就执行完成，线程 B 也可以在线程 A 开始之前执行完成，或者二者的操作交替执行。但奇怪的是，PossibleReording 还可以输出 (0,0)。由于每个线程中的各个操作之间不存在数据流依赖性，因此这些操作可以乱序执行。(即使这些操作按顺序执行，但在将缓存刷新到主内存的不同时序中也可能出现这种情况，从线程 B 的角度看，线程 A 中的复制操作可能以相反的次序执行)。图 16-1 给出了一种可能由重排序导致的交替执行方式，这种情况恰好会输出 (0,0)。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>PossibleReordering</span> <span style=color:#ce5c00;font-weight:700>{</span> 
  <span style=color:#204a87;font-weight:700>static</span> <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>x</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>0</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>y</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>0</span><span style=color:#ce5c00;font-weight:700>;</span> 
  <span style=color:#204a87;font-weight:700>static</span> <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>a</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>0</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>b</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>0</span><span style=color:#ce5c00;font-weight:700>;</span>

  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>static</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>main</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>String</span><span style=color:#ce5c00;font-weight:700>[]</span> <span style=color:#000>args</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#204a87;font-weight:700>throws</span> <span style=color:#000>InterruptedException</span> <span style=color:#ce5c00;font-weight:700>{</span> 
    <span style=color:#000>Thread</span> <span style=color:#000>one</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>Thread</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>Runnable</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span> 
      <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>run</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span> 
        <span style=color:#000>a</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>1</span><span style=color:#ce5c00;font-weight:700>;</span> 
        <span style=color:#000>x</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>b</span><span style=color:#ce5c00;font-weight:700>;</span> 
      <span style=color:#ce5c00;font-weight:700>}</span> 
    <span style=color:#ce5c00;font-weight:700>});</span> 
    
    <span style=color:#000>Thread</span> <span style=color:#000>other</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>Thread</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>Runnable</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span> 
      <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>run</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span> 
        <span style=color:#000>b</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>1</span><span style=color:#ce5c00;font-weight:700>;</span> 
        <span style=color:#000>y</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>a</span><span style=color:#ce5c00;font-weight:700>;</span> 
      <span style=color:#ce5c00;font-weight:700>}</span> 
    <span style=color:#ce5c00;font-weight:700>});</span> 
    
    <span style=color:#000>one</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>start</span><span style=color:#ce5c00;font-weight:700>();</span> 
    <span style=color:#000>other</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>start</span><span style=color:#ce5c00;font-weight:700>();</span> 
    <span style=color:#000>one</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>join</span><span style=color:#ce5c00;font-weight:700>();</span> 
    <span style=color:#000>other</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>join</span><span style=color:#ce5c00;font-weight:700>();</span> 
    <span style=color:#000>System</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>out</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>println</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#4e9a06>&#34;( &#34;</span><span style=color:#ce5c00;font-weight:700>+</span> <span style=color:#000>x</span> <span style=color:#ce5c00;font-weight:700>+</span> <span style=color:#4e9a06>&#34;,&#34;</span> <span style=color:#ce5c00;font-weight:700>+</span> <span style=color:#000>y</span> <span style=color:#ce5c00;font-weight:700>+</span> <span style=color:#4e9a06>&#34;)&#34;</span><span style=color:#ce5c00;font-weight:700>);</span>
  <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><div align=center>
<img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20181118180345.png style=display:block;width:70% alt=16-1 align=center>
</div>
<p>PossibleReording 是一个简单的程序，但要列举出它所有可能的结果却非常困难。内存级重排序会使程序的行为变得不可预测。如果没有使用同步，那么推断出执行顺序将是非常困难的，而要确保在程序中正确的使用同步确实非常容易的。同步将限制编译器、运行时和硬件对内存操作重排序的方式，从而在实施重排序时不会破坏 JMM 提供的可见性保证。</p>
<h3 id=1613-jmm-简介>16.1.3 JMM 简介</h3>
<p>JMM 是通过各种操作来定义的，包括对变量的读写操作、监视器的加解锁操作、线程的启动和合并操作。JMM 为程序中所有的操作定义了一个偏序关系，称之为 HappensBefore。要想保证执行操作 B 的线程能够看到操作 A 的结果(无论 A 和 B 是否在同一个线程中执行)，那么在 A 和 B 之间必须满足 HappensBefore 关系。如果两个操作之间缺乏 HappensBefore 关系，那么 JVM 可以对它们进行任意的重排序。</p>
<blockquote>
<p>偏序关系 π 是集合上的一种关系，具有反对称、自反和传递性，但对于任意两个元素 x、y 来说，并不需要一定满足 x π y 或 y π x 的关系。我们每天都在使用偏序关系来表达喜好，如我们可以使用更喜欢寿司而不是三明治，可以更喜欢莫扎特而不是马勒，但我们不必在三明治和莫扎特之间做出明确的喜好选择。</p>
</blockquote>
<p>当一个变量被多个线程读取并且至少被一个线程写入时，如果在读取操作和写入操作之间没有依照 HappensBefore 来排序，那么就会产生数据竞争问题。在正确同步的程序中不存在数据竞争，并会表现出串行一致性，这意味着程序中的所有操作都会安装一种固定的和全局的顺序执行。</p>
<p>HappensBefore 规则包括：</p>
<ul>
<li>程序顺序规则。如果程序中操作 A 在操作 B 之前，那么在线程中 A 操作将在 B 操作之间执行。</li>
<li>监视器锁规则。在监视器上的解锁操作必须在同一个监视器锁上的加锁操作之前执行。</li>
<li>volatile 变量规则。对 volatile 变量的写入操作必须在对该变量的读取操作之前执行。</li>
<li>程序启动规则。在线程上对 Thread.start 的调用必须在该线程中执行任何操作之前执行。</li>
<li>线程结束规则。线程中任何操作都必须在其他线程检测到该线程已经结束之前执行，或者从 Thread.join 中成功返回，或者在调用 Thread.isAlive 时返回 false。</li>
<li>中断规则。当一个线程在另一个线程上调用 interrupt 时，必须在被中断线程检测到 interrupt 调用之前执行(或者抛出中断异常，或者调用 isInterrupted 和 interrupted)。</li>
<li>终结器规则。对象的构造函数必须在启动该对象的终结器之间执行完成。</li>
<li>传递性。如果操作 A 在操作 B 之前执行，并且操作 B 在操作 C 之前执行，那么操作 A 必须在操作 C 之前执行。</li>
</ul>
<p>虽然这些操作只满足偏序关系，但同步操作，如锁的获取与释放操作，以及 volatile 变量的读写操作，都满足全序关系。因此，在描述 HappensBefore 关系时，就可以使用“后续的加锁操作”和“后续的 volatile 变量读取操作”等表述语句。</p>
<p>图 16-2 给出了当两个线程使用同一个锁进行同步时，在它们之间的 HappensBefore 关系。在线程 A 内部的所有操作都按照他们在源程序中的先后顺序来排序，在线程 B 内部的操作也是如此。由于 A 释放了锁 M，并且 B 随后获得了锁 M，因此 A 中所有在释放锁之前的操作，也就位于 B 请求锁之后的所有操作之前。如果这两个线程在不同的锁上进行同步，那么就不能推断出它们之间的动作关系，因为这两个线程的操作之间并不存在 HappensBefore 关系。</p>
<div align=center>
<img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20181118180401.png style=display:block;width:70% alt=16-2 align=center>
</div>
<h3 id=1614-借助同步>16.1.4 借助同步</h3>
<p>由于 HappensBefore 的排序功能很强大，因此有时候可以“借助”现有同步机制的可见性属性。这需要将 HappensBefore 的程序顺序规则与其他某个顺序规则(通常是监视器锁或 volatile 变量规则)结合起来，从而对某个未被锁保护的变量的访问操作进行排序。这项技术由于对语句的顺序非常敏感，因此很容易出错。这是一项高级技术，并且只有当需要最大限度的提升某些类(如 ReentrantLock)的性能时，才应该使用这种技术。</p>
<p>在 FutureTask 的保护方法 AQS 中说明了如何使用这种借助技术。AQS 维护一个表示同步器状态的整数，FutureTask 用这个整数来保存任务的状态：正在运行、已完成、已取消。但 FutureTask 还维护了其他一些变量，如计数结果。当一个线程调用 set 来保存结果并且另一个线程调用 get 来获取该结果时，这两个线程最好按照 HappensBefore 进行排序，这可以通过将执行结果的引用声明为 volatile 类型来实现，但利用现有的同步机制可以更容易地实现相同的功能。</p>
<p>FutureTask 在设计时能够确保，在调用 tryAcquireShared 之前总能成功的调用 tryReleaseShared。tryReleaseShared 会写入一个 volatile 类型的变量，而 tryAcquireShared 将读取该变量。程序清单 16-2 给出了 innerSet 和 innerGet 等方法，在保存和获取 result 时将调用这些方法。由于 innerSet 将在调用 releaseShared (这又将调用 tryReleaseShared)之前写入 result，并且 innerGet 将在调用 acquireShared (这又将调用 tryReleaseShared)之后读取 result，因此将程序顺序规则与 volatile 变量规则结合在一起，就可以确保 innerSet 中的写入操作在 innerGet 中的读取操作之前执行。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#8f5902;font-style:italic>// Inner class of FutureTask 
</span><span style=color:#8f5902;font-style:italic></span><span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>final</span> <span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>Sync</span> <span style=color:#204a87;font-weight:700>extends</span> <span style=color:#000>AbstractQueuedSynchronizer</span> <span style=color:#ce5c00;font-weight:700>{</span>
  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>static</span> <span style=color:#204a87;font-weight:700>final</span> <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>RUNNING</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>1</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>RAN</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>2</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>CANCELLED</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>4</span><span style=color:#ce5c00;font-weight:700>;</span> 
  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#000>V</span> <span style=color:#000>result</span><span style=color:#ce5c00;font-weight:700>;</span> <span style=color:#204a87;font-weight:700>private</span> <span style=color:#000>Exception</span> <span style=color:#000>exception</span><span style=color:#ce5c00;font-weight:700>;</span>

  <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>innerSet</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>V</span> <span style=color:#000>v</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#204a87;font-weight:700>while</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>true</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span> 
      <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>s</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>getState</span><span style=color:#ce5c00;font-weight:700>();</span> 
      <span style=color:#204a87;font-weight:700>if</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>ranOrCancelled</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>s</span><span style=color:#ce5c00;font-weight:700>))</span> 
        <span style=color:#204a87;font-weight:700>return</span><span style=color:#ce5c00;font-weight:700>;</span> 
      <span style=color:#204a87;font-weight:700>if</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>compareAndSetState</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>s</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>RAN</span><span style=color:#ce5c00;font-weight:700>))</span> 
        <span style=color:#204a87;font-weight:700>break</span><span style=color:#ce5c00;font-weight:700>;</span> 
    <span style=color:#ce5c00;font-weight:700>}</span> 
    <span style=color:#000>result</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>v</span><span style=color:#ce5c00;font-weight:700>;</span> 
    <span style=color:#000>releaseShared</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>0</span><span style=color:#ce5c00;font-weight:700>);</span> 
    <span style=color:#000>done</span><span style=color:#ce5c00;font-weight:700>();</span>
  <span style=color:#ce5c00;font-weight:700>}</span>

  <span style=color:#000>V</span> <span style=color:#000>innerGet</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#204a87;font-weight:700>throws</span> <span style=color:#000>InterruptedException</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>ExecutionException</span> <span style=color:#ce5c00;font-weight:700>{</span> 
    <span style=color:#000>acquireSharedInterruptibly</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>0</span><span style=color:#ce5c00;font-weight:700>);</span> 
    <span style=color:#204a87;font-weight:700>if</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>getState</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>==</span> <span style=color:#000>CANCELLED</span><span style=color:#ce5c00;font-weight:700>)</span> 
      <span style=color:#204a87;font-weight:700>throw</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>CancellationException</span><span style=color:#ce5c00;font-weight:700>();</span> 
    <span style=color:#204a87;font-weight:700>if</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>exception</span> <span style=color:#ce5c00;font-weight:700>!=</span> <span style=color:#204a87;font-weight:700>null</span><span style=color:#ce5c00;font-weight:700>)</span> 
      <span style=color:#204a87;font-weight:700>throw</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>ExecutionException</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>exception</span><span style=color:#ce5c00;font-weight:700>);</span> 
    <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>result</span><span style=color:#ce5c00;font-weight:700>;</span> 
  <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>之所以将这项技术成为“借助”，是因为它使用了一种现有的 HappensBefore 顺序来确保对象 X 的可见性，而不是专门为了发布 X 而创建一种 HappensBefore 顺序。</p>
<p>在 FutureTask 中使用的借助技术很容易出错，因此要谨慎使用。但在某些情况下，这种借助技术是非常合理的。如，当某个类在其规范中规定他的各个方法之间必须遵循一种 HappensBefore 关系，基于 BlockingQueue 实现的安全发布就是一种“借助”。如果一个线程将对象置入队列并且另一个线程随后获取这个对象，那么这就是一种安全发布，因为在 BlockingQueue 的实现中包含有足够的内部同步来确保入列操作在出列操作之前执行。</p>
<p>在类中提供的其他 HappensBefore 排序包括：</p>
<ul>
<li>将一个元素放入一个线程安全容器的操作将在另一个线程从该容器中获得这个元素的操作之前执行。</li>
<li>在 CountDownLatch 上的倒数操作将在线程从闭锁上的 await 方法中返回之前执行。</li>
<li>在释放 Semaphore 许可的操作将在从该 Semaphore 上获得一个许可之前执行。</li>
<li>Future 表示的任务的所有操作将在从 Future.get 中返回之前执行。</li>
<li>向 Executor 提交一个 Runnable 或 Callable 的操作将在任务开始执行之前执行。</li>
<li>一个线程到达 CyclicBarrier 或 Exchanger 的操作将在其他到达该栅栏或交换点的线程被释放之前执行。如果 CyclicBarrier 使用一个栅栏操作，那么到达栅栏的操作将在栅栏操作之前执行，而栅栏操作又会在线程从栅栏中释放之前执行。</li>
</ul>
<h2 id=162-发布>16.2 发布</h2>
<p>第三章介绍了如何安全的或者不正确的发布一个对象。对于其中介绍的各种安全技术，他们的安全性都来自于 JMM 提供的保证，而造成不正确发布的真正原因，就是在“发布一个共享对象”与“另一个线程访问该对象”之间缺少一种 HappensBefore 排序。</p>
<h3 id=1621-不安全的发布>16.2.1 不安全的发布</h3>
<p>当缺少 HappensBefore 关系时，就能出现重排序问题，这就解释了为什么在么有充分同步的情况下发布一个对象会导致另一个线程看到一个只被部分构造的对象。在初始化一个新的对象时需要写入多个变量，即新对象中的各个域。同样，在发布一个引用时也需要写入一个变量，即新对象的引用。如果无法确保发布共享对象引用的操作在另一个线程加载该共享引用之前执行，那么对新对象引用的写入操作将于对象中各个域的写入操作重排序(从使用该对象的线程的角度来看)。在这种情况下，另一个线程可能看到对象引用的最新值，但同时也将看到对象的某些或全部状态中包含的是无效值，即一个被部分构造的对象。</p>
<p>错误的延迟初始化将导致不正确的发布，如程序清单 16-3 所示。初看起来，在程序中存在的问题只有在 2.2.2 中介绍的竟态条件问题。在某些特定条件下，例如当 Resource 的所有实例都相同时，你或许会忽略这些问题(以及在多次创建 Resource 实例时存在低效率问题)。然而，即使不考虑这些问题，UnsafeLazyInitialization 仍然是不安全的，因为另一个线程可能看到对部分构造的 Resource 实例的引用。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#5c35cc;font-weight:700>@NotThreadSafe</span> 
<span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>UnsafeLazyInitialization</span> <span style=color:#ce5c00;font-weight:700>{</span> 
  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>static</span> <span style=color:#000>Resource</span> <span style=color:#000>resource</span><span style=color:#ce5c00;font-weight:700>;</span>

  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>static</span> <span style=color:#000>Resource</span> <span style=color:#000>getInstance</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span> 
    <span style=color:#204a87;font-weight:700>if</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>resource</span> <span style=color:#ce5c00;font-weight:700>==</span> <span style=color:#204a87;font-weight:700>null</span><span style=color:#ce5c00;font-weight:700>)</span> 
      <span style=color:#000>resource</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>Resource</span><span style=color:#ce5c00;font-weight:700>();</span> <span style=color:#8f5902;font-style:italic>// unsafe publication 
</span><span style=color:#8f5902;font-style:italic></span>    <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>resource</span><span style=color:#ce5c00;font-weight:700>;</span> 
  <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>假设线程 A 是一个调用 getInstance 的线程。它将看到 resource 为 null，并且初始化一个新的 Resource，然后将 resource 设置为执行这个新实例。当线程 B 随后调用 getInstance，它可能看到 resource 的值为非空，因此使用这个已经构造好的 Resource。最初看不出任何问题，但线程 A 写入 resource 的操作与线程 B 读取 resource 的操作之间不存在 HappensBefore 关系。在发布对象时存在数据竞争问题，因此 B 并不一定看到 Resource 的正确状态。</p>
<p>当新分配一个 Resource 时，Resource 的构造函数将把新实例中的各个域由默认值(由 Object 构造函数写入的)修改为他们的初始值。由于在两个线程中都没有使用同步，因此线程 B 看到的线程 A 中的操作顺序，可能与线程 A 执行这些操作时的顺序并不相同。因此，即使线程 A 初始化 Resource 实例之后再将 resource 设置为指向他，线程 B 仍可能看到对 resource 的写入操作将在对 Resource 各个域的写入操作之前发生。因此，线程 B 就可能看到一个被部分构造的 Resource 实例，该实例肯呢个处于无效的状态，并在随后该实例的状态可能出现无法预料的变化。</p>
<blockquote>
<p>除了不改变对象以外，使用被另一个线程初始化的对象通常都是不安全的，除非对象的发布操作是在使用该对象的线程开始使用之前执行。</p>
</blockquote>
<h3 id=1622-安全的发布>16.2.2 安全的发布</h3>
<p>第三章中介绍的安全发布常用模式可以确保被发布对象对于其他对象是可见的，因为他们保证发布对象的操作将在使用对象的线程开始使用该对象的引用之前执行。如果线程 A 将 X 放入 BlockingQueue (并且随后没有线程修改它)，线程 B 从队列中获取 X，那么可以确保 B 看到的 X 与 A 放入的 X 相同。这是因为在 BlockingQueue 的实现中有足够的内部同步确保了 put 方法在 take 方法之前执行。同样，通过使用一个由锁保护共享变量或者使用共享的 volatile 类型变量，也可以确保对该变量的读取操作和写入操作按照 HappensBefore 关系来排序。</p>
<p>事实上，HappensBefore 比安全发布提供了更强的可见性与顺序保证。如果将 X 从 A 安全的发布到 B，那么这种安全发布可以保证 X 状态的可见性，但无法保证 A 访问的其他变量的状态可见性。然而，如果 A 将 X 置入队列的操作在线程 B 从队列中获取 X 的操作之间执行，那么 B 不仅能看到 A 留下的 X 的状态，(假设线程 A 或其他线程都没有对 X 再次进行修改)，而且还能看到 A 在移交 X 之前所做的任何操作。</p>
<p>既然 JMM 已经提供了这种更强大的 HappensBefore 关系，那么为什么还要介绍 <code>@GuardedBy</code> 和安全发布呢？与内存写入操作的可见性相比，从转移对象的所有权以及对象公布等角度来看，它们更符合大多数程序的设计。HappensBefore 排序是在内存访问级别上的操作，它是一种“并发级汇编语言”，而安全发布的运行级别更接近程序设计。</p>
<h3 id=1623-安全初始化模式>16.2.3 安全初始化模式</h3>
<p>有时候，我们需要推迟一些高开销的对象的初始化操作，并且只有当使用这些对象时才对其进行初始化，但我们也看到了在无用延迟初始化时导致的问题。在程序清单 16-4 中，通过将 getResource 方法声明为 synchronized，可以修复 UnsafeLazyInitialization 中的问题。由于 getInstance 的代码路径很短(只包括一个判断遇见和一个预测分支)，因此如果 getInstance 没有被多个线程频繁调用，那么在 SafeLazyInitialization 上不会存在激烈的竞争，从而提供令人满意的性能。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#5c35cc;font-weight:700>@ThreadSafe</span> 
<span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>SafeLazyInitialization</span> <span style=color:#ce5c00;font-weight:700>{</span> 
  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>static</span> <span style=color:#000>Resource</span> <span style=color:#000>resource</span><span style=color:#ce5c00;font-weight:700>;</span>

  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>synchronized</span> <span style=color:#204a87;font-weight:700>static</span> <span style=color:#000>Resource</span> <span style=color:#000>getInstance</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span> 
    <span style=color:#204a87;font-weight:700>if</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>resource</span> <span style=color:#ce5c00;font-weight:700>==</span> <span style=color:#204a87;font-weight:700>null</span><span style=color:#ce5c00;font-weight:700>)</span> 
      <span style=color:#000>resource</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>Resource</span><span style=color:#ce5c00;font-weight:700>();</span> 
    <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>resource</span><span style=color:#ce5c00;font-weight:700>;</span> 
  <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>在初始化中采用了特殊的方式来处理静态域(或者在静态初始化块中初始化的值)，并提供了额外的线程安全性保证。静态初始化器是由 JVM 在类的初始化阶段执行的，即在类被加载后并且被线程使用之前。由于 JVM 将在初始化期间获得一个锁，并且每个线程都至少获取一次这个锁以确保该类已被加载，因此在静态初始化期间，内存写入操作将自动对所有线程可见。因此无论是在被构造期间还是被引用时，静态初始化的对象都不需要显式的同步。然而，这个规则仅适用于在构造时的状态，如果对象是可变的，那么在读线程和写线程之间仍然需要通过同步机制来确保随后的修改操作是可见的，以及避免数据被破坏。</p>
<p>如程序清单 16-5 所示，通过使用提前初始化，避免了在每次调用 SafeLazyInitialization 中的 getInstance 时所产生的同步开销。通过将这项技术和 JVM 的延迟加载机制结合起来，可以形成一种延迟初始化技术，从而在常见的代码路径中避免使用同步。在程序清单 16-6 的“延迟初始化占位类模式”中使用了一个专门的类来初始化 Resource。JVM 将推迟 ResourceHolder 的初始化操作，直到开始使用这个类时才初始化，并且由于通过一个静态初始化来创建 Resource，因此不需要额外的同步。当任何一个线程第一次调用 getResource 时，都会使 ResourceHolder 被加载和被初始化，此时静态初始化器将执行 Resource 的初始化操作。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#5c35cc;font-weight:700>@ThreadSafe</span> <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>EagerInitialization</span> <span style=color:#ce5c00;font-weight:700>{</span> 
  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>static</span> <span style=color:#000>Resource</span> <span style=color:#000>resource</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>Resource</span><span style=color:#ce5c00;font-weight:700>();</span>

  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>static</span> <span style=color:#000>Resource</span> <span style=color:#000>getResource</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span> <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>resource</span><span style=color:#ce5c00;font-weight:700>;</span> <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#5c35cc;font-weight:700>@ThreadSafe</span> <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>ResourceFactory</span> <span style=color:#ce5c00;font-weight:700>{</span>

  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>static</span> <span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>ResourceHolder</span> <span style=color:#ce5c00;font-weight:700>{</span> 
    <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>static</span> <span style=color:#000>Resource</span> <span style=color:#000>resource</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>Resource</span><span style=color:#ce5c00;font-weight:700>();</span> 
  <span style=color:#ce5c00;font-weight:700>}</span>

  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>static</span> <span style=color:#000>Resource</span> <span style=color:#000>getResource</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span> 
    <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>ResourceHolder</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>resource</span> <span style=color:#ce5c00;font-weight:700>;</span> 
  <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><h3 id=1624-双重检查加锁>16.2.4 双重检查加锁</h3>
<p>在任何一本介绍并发的书中都会讨论声名狼藉的双重检查加锁(DCL)，如程序清单 16-7 所示。在早期的 JVM 中，同步(甚至是无竞争的同步)都存在着巨大的同步开销。因此，人们先出了许多“聪明的(或者至少看上去聪明)”技巧来降低同步的影响，有些技巧很好，但有些技巧却不然，甚至是糟糕的，DSL 就属于糟糕的一类。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#5c35cc;font-weight:700>@NotThreadSafe</span> 
<span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>DoubleCheckedLocking</span> <span style=color:#ce5c00;font-weight:700>{</span> 
  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>static</span> <span style=color:#000>Resource</span> <span style=color:#000>resource</span><span style=color:#ce5c00;font-weight:700>;</span>

  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>static</span> <span style=color:#000>Resource</span> <span style=color:#000>getInstance</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span> 
    <span style=color:#204a87;font-weight:700>if</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>resource</span> <span style=color:#ce5c00;font-weight:700>==</span> <span style=color:#204a87;font-weight:700>null</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span> 
      <span style=color:#204a87;font-weight:700>synchronized</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>DoubleCheckedLocking</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>class</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span> 
        <span style=color:#204a87;font-weight:700>if</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>resource</span> <span style=color:#ce5c00;font-weight:700>==</span> <span style=color:#204a87;font-weight:700>null</span><span style=color:#ce5c00;font-weight:700>)</span> 
          <span style=color:#000>resource</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>Resource</span><span style=color:#ce5c00;font-weight:700>();</span> 
      <span style=color:#ce5c00;font-weight:700>}</span> 
    <span style=color:#ce5c00;font-weight:700>}</span> 
    <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>resource</span><span style=color:#ce5c00;font-weight:700>;</span> 
  <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>由于早期的 JVM 在性能上存在一些有待优化的地方，因此延迟初始化经常被用来避免不必要的高开销操作，或者用来降低程序的启动时间。在编写正确的延迟初始化方法中需要使用同步。但在当时，同步不仅执行速度慢，并且重要的是，开发人员还没有完全理解同步的含义：虽然人们能很好的理解了“独占性”，却没有很好的理解“可见性”的含义。</p>
<p>DCL 声称能实现两全其美——在常见的代码路径上的延迟初始化中不存在同步开销。它的工作原理是，首先检查是否在没有同步的情况下需要初始化，如果 resource 引用不为空，那么就直接使用它。否则，就进行同步并再次检查 Resource 是否已被初始化，从而保证只有一个线程对其共享的 Resource 执行初始化。在常见的代码路径中——获取一个已构造完成的 Resource 引用时并没有使用同步。这就是问题所在：在 16.2.1 中介绍过，线程能够看到一个仅被部分构造的 Resource。</p>
<p>DCL 的真正问题在于：当在没有同步的情况下读取一个共享对象时，可能发生的最糟糕情况就是看到一个失效值(在这个例子中是一个空值)，此时 DCL 方法将通过在持有锁的情况下再次尝试来避免这种风险。然而，实际情况远比这种情况要糟糕——线程可能看到引用的当前值，但对象的状态值却是失效的，这意味着线程可以看到对象处于失效或错误的状态。</p>
<p>在 JMM 的后续版本(5.0 及以上)中，如果把 resource 声明为 volatile，那么就能启用 DCL，并且这种技术对性能的影响很小，因为 volatile 变量读取操作的性能通常只是略高于非 volatile 变量读取操作的性能。然而，DCL 的这种用法已经被广泛得废弃了——促使该模式出现的驱动力(无竞争同步的执行速度很慢每、JVM 启动时很慢)已经不复存在，因而他不是一种高效的优化措施。延迟初始化占位类模式能带来同样的优势，并且更易理解。</p>
<h2 id=163-初始化过程中的安全性>16.3 初始化过程中的安全性</h2>
<p>如果能够确保初始化过程的安全性，那么就可以使的被正确构造的不可变对象在没有同步的情况下也能安全的在多个线程之间共享，而不管他们是如何发布的，甚至通过某种数据竞争来发布。(这意味着，如果 Resource 是不可变的，那么 UnsafeLazyInitialization 实际上是线程安全的)。</p>
<p>如果不能确保初始化的安全性，那么当在发布或线程中没有使用同步时，一些本因为不可变对象(如 String)的值将会发生改变。安全性架构依赖于 String 的不可变性，如果缺少了初始化安全性，那么可能导致一个安全漏洞，从而使恶意代码绕过安全检查。</p>
<blockquote>
<p>初始化安全性将确保，对于被正确构造的对象，所有线程都能看到由构造函数为对象各个 final 域设置的正确值，而不管采用何种方式来发布对象。而且，对于可以通过被正确构造对象中某个 fianl 域到达的任意变量(如某个 final 数组中的元素，或者由一个 final 域引用的 HashMap 的内容)将同样对于其他线程是可见的。</p>
</blockquote>
<p>对于含有 final 域的对象，初始化安全性可以防止对对象的初始引用被重排序到构造过程之前。当构造函数完成时，沟站函数对 final 域的所有写入操作，以及对通过这些域可以到达的任何变量的写入操作，都将被“冻结”，并且任何获得该对象引用的线程都至少能确保看到被冻结的值。对于通过 fianl 域可到达的初始变量的写入操作，将不会与构造过程后的操作一起被重排序。</p>
<p>初始化安全性意味着，程序清单 16-8 的 SafeStates 可以安全的发布，即便通过不安全的延迟初始化，或者在没有同步的情况下将 SafeStates 的引用放到一个工友的静态域，或者没有使用同步以及依赖于非线程安全的 HashSet。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#5c35cc;font-weight:700>@ThreadSafe</span> 
<span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>SafeStates</span> <span style=color:#ce5c00;font-weight:700>{</span> 
  <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>Map</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>String</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>String</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>states</span><span style=color:#ce5c00;font-weight:700>;</span>

  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#000>SafeStates</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span> 
    <span style=color:#000>states</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>HashMap</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>String</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>String</span><span style=color:#ce5c00;font-weight:700>&gt;();</span> 	
    <span style=color:#000>states</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>put</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#4e9a06>&#34;alaska&#34;</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#4e9a06>&#34;AK&#34;</span><span style=color:#ce5c00;font-weight:700>);</span> 
    <span style=color:#000>states</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>put</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#4e9a06>&#34;alabama&#34;</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#4e9a06>&#34;AL&#34;</span><span style=color:#ce5c00;font-weight:700>);</span> 
    <span style=color:#ce5c00;font-weight:700>...</span>

    <span style=color:#000>states</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>put</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#4e9a06>&#34;wyoming&#34;</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#4e9a06>&#34;WY&#34;</span><span style=color:#ce5c00;font-weight:700>);</span> <span style=color:#ce5c00;font-weight:700>}</span>

  <span style=color:#204a87;font-weight:700>public</span> <span style=color:#000>String</span> <span style=color:#000>getAbbreviation</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>String</span> <span style=color:#000>s</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span> 
    <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>states</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>get</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>s</span><span style=color:#ce5c00;font-weight:700>);</span> 
  <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>然而，许多对 SafeStates 的细微修改可能会破坏它的线程安全性。如果 states 不是 final 类型，或者存在除构造函数以外的其他方法能修改 states，那么初始化安全性将无法确保在缺少同步的情况下安全的访问 SafeStates。如果在 SafeStates 中还有其他的非 final 域，那么其他线程任然可能看到这些域上的不正确的值。这也导致了对象在构造过程中逸出，从而使初始化安全性的保证失效。</p>
<blockquote>
<p>初始化安全性只能保证通过 final 域可达的值从构造过程完成时开始的可见性。对于通过非 final 域科大的值，或者在构成过程完成后可能改变的值，必须采用同步来确保可见性。</p>
</blockquote>
<h2 id=小结>小结</h2>
<p>Java 内存模型说明了某个内存操作在哪些情况下对于其他线程是可见的。其中包括确保这些操作是按照一种 HappensBefore 的偏序关系进行排序，而这种关旭是基于内存操作和同步操作等级别来定义的。如果缺少充足的同步，那么在当线程访问共享数据时，会发生一些非常奇怪的问题。然而，如果使用第二、三章介绍的更高级规则，如 <code>@GuardedBy</code> 和安全发布，那么即使不考虑 HappensBefore 的底层细节，也能确保线程安全性。</p>
</div>
</main>
</div>
</div>
<footer class="bg-dark py-5 row d-print-none">
<div class="container-fluid mx-sm-5">
<div class=row>
<div class="col-6 col-sm-4 text-xs-center order-sm-2">
</div>
<div class="col-6 col-sm-4 text-right text-xs-center order-sm-3">
<ul class="list-inline mb-0">
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Weibo aria-label=Weibo>
<a class=text-white target=_blank rel="noopener noreferrer" href=https://weibo.com/u/3848950217>
<i class="fab fa-weibo"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Twitter aria-label=Twitter>
<a class=text-white target=_blank rel="noopener noreferrer" href=https://twitter.com/zhange_zzg>
<i class="fab fa-twitter"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="Stack Overflow" aria-label="Stack Overflow">
<a class=text-white target=_blank rel="noopener noreferrer" href=https://stackoverflow.com>
<i class="fab fa-stack-overflow"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=GitHub aria-label=GitHub>
<a class=text-white target=_blank rel="noopener noreferrer" href=https://github.com/infilos/infilos.com>
<i class="fab fa-github"></i>
</a>
</li>
</ul>
</div>
<div class="col-12 col-sm-4 text-center py-2 order-sm-2">
<small class=text-white>&copy; 2021 infilos.com All Rights Reserved</small>
</div>
</div>
</div>
</footer>
</div>
<script src=/js/popper.min.js integrity=sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49 crossorigin=anonymous></script>
<script src=/js/bootstrap.min.js integrity=sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy crossorigin=anonymous></script>
<script src=/js/main.min.5c74b870c6953931a705f390a49c7e4c0a842ec5c83b24354758dd674343ed0d.js integrity="sha256-XHS4cMaVOTGnBfOQpJx+TAqELsXIOyQ1R1jdZ0ND7Q0=" crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/docsearch.js@2.6.3/dist/cdn/docsearch.min.js></script>
<script>docsearch({apiKey:'123',indexName:'infilos_com',inputSelector:'.td-search-input',debug:!1})</script>
</body>
</html>