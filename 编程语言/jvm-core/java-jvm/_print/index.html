<!doctype html><html lang=zh class=no-js>
<head>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=generator content="Hugo 0.92.2">
<meta name=ROBOTS content="INDEX, FOLLOW">
<link rel=canonical type=text/html href=/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/jvm-core/java-jvm/>
<link rel="shortcut icon" href=/favicons/favicon.ico>
<link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180>
<link rel=icon type=image/png href=/favicons/favicon-16x16.png sizes=16x16>
<link rel=icon type=image/png href=/favicons/favicon-32x32.png sizes=32x32>
<link rel=icon type=image/png href=/favicons/android-36x36.png sizes=36x36>
<link rel=icon type=image/png href=/favicons/android-48x48.png sizes=48x48>
<link rel=icon type=image/png href=/favicons/android-72x72.png sizes=72x72>
<link rel=icon type=image/png href=/favicons/android-96x96.png sizes=96x96>
<link rel=icon type=image/png href=/favicons/android-144x144.png sizes=144x144>
<link rel=icon type=image/png href=/favicons/android-192x192.png sizes=192x192>
<title>JVM Core | infilos.com</title><meta property="og:title" content="JVM Core">
<meta property="og:description" content="Infilos Wiki Website">
<meta property="og:type" content="website">
<meta property="og:url" content="/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/jvm-core/java-jvm/"><meta property="og:site_name" content="infilos.com">
<meta itemprop=name content="JVM Core">
<meta itemprop=description content="Infilos Wiki Website"><meta name=twitter:card content="summary">
<meta name=twitter:title content="JVM Core">
<meta name=twitter:description content="Infilos Wiki Website">
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga('create','UA-123062585-1','auto'),ga('send','pageview'))</script>
<script async src=https://www.google-analytics.com/analytics.js></script>
<link rel=preload href=/scss/main.min.847464b684a6e89d7276700a5c500c17ab494dd1755b2654a7b27d8b59e3347e.css as=style>
<link href=/scss/main.min.847464b684a6e89d7276700a5c500c17ab494dd1755b2654a7b27d8b59e3347e.css rel=stylesheet integrity>
<script src=/js/jquery-3.5.1.min.js integrity="sha256-9/aliU8dGd2tb6OSsuzixeV4y/faTqgFtohetphbbj0=" crossorigin=anonymous></script>
</head>
<body class=td-section>
<header>
<nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-column flex-md-row td-navbar">
<a class=navbar-brand href=/>
<span class=navbar-logo><svg id="Capa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 512 512" style="enable-background:new 0 0 512 512"><path style="fill:#ffc107" d="M432.384 143.616c-4.165-4.164-10.917-4.164-15.083.0l-60.352 60.352c-4.164 4.165-4.164 10.917.0 15.083 21.187 20.463 54.951 19.876 75.413-1.311 19.962-20.668 19.962-53.435.0-74.102L432.384 143.616z"/><path style="fill:#607d8b" d="M42.667 277.334c-5.891.003-10.669-4.771-10.672-10.662-.002-4.338 2.623-8.245 6.64-9.882l234.667-96c5.455-2.233 11.687.38 13.92 5.835s-.38 11.687-5.835 13.92l-234.667 96C45.433 277.069 44.056 277.337 42.667 277.334z"/><path style="fill:#546e7a" d="M391.552 56.448l-32-32C343.938 8.745 322.689-.059 300.544.0h-3.755c-46.082.024-83.432 37.374-83.456 83.456v3.755c-.053 22.138 8.75 43.377 24.448 58.987l32 32c4.165 4.164 10.917 4.164 15.083.0L391.531 71.531C395.701 67.372 395.71 60.62 391.552 56.448z"/><path style="fill:#607d8b" d="M160 469.334c-3.279.006-6.379-1.497-8.405-4.075L34.261 315.926c-3.635-4.636-2.823-11.341 1.813-14.976s11.341-2.823 14.976 1.813l117.333 149.333c3.629 4.641 2.809 11.344-1.832 14.973C164.681 468.533 162.375 469.329 160 469.334z"/><path style="fill:#455a64" d="M487.467 86.848l-3.669-3.648c-37.687-36.557-97.71-36.197-134.955.811l-51.413 51.413c-36.996 37.25-37.357 97.263-.811 134.955l3.584 3.669c1.7 2.457 4.671 3.706 7.616 3.2 2.831.005 5.548-1.115 7.552-3.115l172.181-172.181c4.189-4.143 4.226-10.896.083-15.085-.028-.028-.055-.056-.083-.083L487.467 86.848z"/><g><path style="fill:#ffc107" d="M501.333 192H480c-5.891.0-10.667-4.776-10.667-10.667s4.776-10.667 10.667-10.667h21.333c5.891.0 10.667 4.776 10.667 10.667S507.225 192 501.333 192z"/><path style="fill:#ffc107" d="M394.667 298.667c-5.891.0-10.667-4.776-10.667-10.667v-21.333c0-5.891 4.776-10.667 10.667-10.667 5.891.0 10.667 4.776 10.667 10.667V288C405.333 293.891 400.558 298.667 394.667 298.667z"/><path style="fill:#ffc107" d="M480 277.334c-2.831.005-5.548-1.115-7.552-3.115l-21.333-21.333c-4.093-4.237-3.975-10.99.262-15.083 4.134-3.993 10.687-3.993 14.821.0l21.333 21.333c4.159 4.172 4.148 10.926-.024 15.085C485.514 276.209 482.815 277.327 480 277.334z"/></g><g><path style="fill:#455a64" d="M266.667 448H96c-29.455.0-53.333 23.878-53.333 53.333.0 5.891 4.776 10.667 10.667 10.667h256c5.891.0 10.667-4.776 10.667-10.667C320 471.878 296.122 448 266.667 448z"/><circle style="fill:#455a64" cx="32" cy="288" r="32"/></g><g/><g/><g/><g/><g/><g/><g/><g/><g/><g/><g/><g/><g/><g/><g/></svg></span><span class=font-weight-bold>infilos.com</span>
</a>
<div class="collapse navbar-collapse" id=navbarSupportedContent>
<ul class="navbar-nav mr-auto">
<li class=nav-item style=max-width:90px;min-width:10px>
<a class=nav-link href=/%e5%9f%ba%e7%a1%80%e7%9f%a5%e8%af%86>
<span>基础</span>
</a>
</li>
<li class=nav-item style=max-width:90px;min-width:10px>
<a class=nav-link href=/%e7%bc%96%e7%a8%8b%e8%af%ad%e8%a8%80>
<span>语言</span>
</a>
</li>
<li class=nav-item style=max-width:90px;min-width:10px>
<a class=nav-link href=/%e6%a1%86%e6%9e%b6%e4%b8%8e%e5%ba%93>
<span>框架库</span>
</a>
</li>
<li class="nav-item dropdown" style=max-width:90px;min-width:10px>
<a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>
分布式
<span>+</span>
</a>
<div class=dropdown-menu aria-labelledby=navbarDropdown>
<a class=dropdown-item href=/%e5%88%86%e5%b8%83%e5%bc%8f/base>基本构成</a>
</div>
</li>
<li class="nav-item dropdown" style=max-width:90px;min-width:10px>
<a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>
大数据
<span>+</span>
</a>
<div class=dropdown-menu aria-labelledby=navbarDropdown>
<a class=dropdown-item href=/%e5%ad%98%e5%82%a8%e7%b3%bb%e7%bb%9f>存储系统</a>
<a class=dropdown-item href=/%e6%9f%a5%e8%af%a2%e7%b3%bb%e7%bb%9f>查询系统</a>
<a class=dropdown-item href=/%e6%b6%88%e6%81%af%e7%b3%bb%e7%bb%9f>消息系统</a>
<a class=dropdown-item href=/%e5%a4%84%e7%90%86%e7%b3%bb%e7%bb%9f>处理系统</a>
<a class=dropdown-item href=/%e6%95%b0%e6%8d%ae%e6%b2%bb%e7%90%86>数据治理</a>
</div>
</li>
<li class="nav-item dropdown" style=max-width:90px;min-width:10px>
<a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>
中后台
<span>+</span>
</a>
<div class=dropdown-menu aria-labelledby=navbarDropdown>
<a class=dropdown-item href=/%e5%9f%ba%e7%a1%80%e8%ae%be%e6%96%bd>基础设施</a>
<a class=dropdown-item href=/%e7%94%a8%e6%88%b7%e7%b3%bb%e7%bb%9f>用户系统</a>
<a class=dropdown-item href=/%e4%ba%a4%e4%ba%92%e7%95%8c%e9%9d%a2>交互界面</a>
<a class=dropdown-item href=/%e4%b8%9a%e5%8a%a1%e7%b3%bb%e7%bb%9f>业务系统</a>
</div>
</li>
<li class=nav-item style=max-width:90px;min-width:10px>
<a class=nav-link href=/%e6%a8%a1%e5%bc%8f%e6%9e%b6%e6%9e%84>
<span>模式架构</span>
</a>
</li>
<li class=nav-item style=max-width:90px;min-width:10px>
<a class=nav-link href=/%e9%9d%a2%e8%af%95%e9%97%ae%e7%ad%94>
<span>面试</span>
</a>
</li>
<li class=nav-item style=max-width:90px;min-width:10px>
<a class=nav-link href=/%e7%ae%a1%e7%90%86%e8%b7%af%e5%be%84>
<span>管理</span>
</a>
</li>
<li class=nav-item style=max-width:90px;min-width:10px>
<a class=nav-link href=/%e5%bc%80%e6%ba%90%e9%a1%b9%e7%9b%ae>
<span>开源</span>
</a>
</li>
</ul>
<div class="form-inline my-2 my-lg-0">
<div class="nav-item nav-search-item my-2 my-md-0">
<input type=search class="form-control td-search-input" placeholder="&#xf002; 站内搜索…" aria-label=站内搜索… autocomplete=off>
</div>
</div>
</div>
</nav>
</header>
<div class="container-fluid td-outer">
<div class=td-main>
<div class="row flex-xl-nowrap">
<div class="col-12 col-md-3 col-xl-2 td-sidebar d-print-none">
</div>
<div class="d-none d-xl-block col-xl-2 td-toc d-print-none">
</div>
<main class="col-12 col-md-9 col-xl-8 pl-md-5" role=main>
<div class=td-content>
<div class="pageinfo pageinfo-primary d-print-none">
<p>
这是本节的多页打印视图。
<a href=# onclick="return print(),!1">点击此处打印</a>.
</p><p>
<a href=/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/jvm-core/java-jvm/>返回本页常规视图</a>.
</p>
</div>
<h1 class=title>JVM Core</h1>
<ul>
<li>1: <a href=#pg-e681536f7d1cc0cca2238d381b5fa47a>CH01-JVM概览</a></li>
<li>2: <a href=#pg-b38ffc56643777b708c418084c1fc6c7>CH02-JVM字节码</a></li>
<li>3: <a href=#pg-3fe7ca4dd715cdb713abf4472ca1870b>CH03-JVM类加载</a></li>
<li>4: <a href=#pg-55cdabdc2dcacd0ec93d06c4f0abb5d7>CH04-JVM内存结构</a></li>
<li>5: <a href=#pg-84806c308a9c70c248e777b89a50aaae>CH05-JVM内存模型-1</a></li>
<li>6: <a href=#pg-b8e7b8cb58035d8f6a6b6b4e95a058fe>CH06-JVM内存模型-2</a></li>
<li>7: <a href=#pg-520b338700064b344a321992ce37e92e>CH07-JVM垃圾回收</a></li>
<li>8: <a href=#pg-a582f9956d80b5ccc3719732dd43cd13>CH08-JVM-G1</a></li>
<li>9: <a href=#pg-6983a235393b24ffee7070ac7d663d23>CH09-JVM-ZGC</a></li>
<li>10: <a href=#pg-f194418061ea5558c2acd97b857a5023>CH10-JVM调优参数</a></li>
<li>11: <a href=#pg-e19d55b8cead9eccdf89a99ddc2a0c6b>CH11-JVM-OOM</a></li>
<li>12: <a href=#pg-fe6406617d166593ccc3396d0d3c028a>CH12-JVM线程Dump</a></li>
<li>13: <a href=#pg-efaf97ffa8b43d339724810fdd828778>CH13-JVM调试命令</a></li>
<li>14: <a href=#pg-738f442a261896462d3e74cf97e8d132>CH14-JVM调试工具</a></li>
<li>15: <a href=#pg-79c89a1a04f19d45ae69a0cc19e2363d>CH15-JVM动态调试</a></li>
</ul>
<div class=content>
</div>
</div>
<div class=td-content>
<h1 id=pg-e681536f7d1cc0cca2238d381b5fa47a>1 - CH01-JVM概览</h1>
<h2 id=jvm-结构>JVM 结构</h2>
<div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210430150917.png style=display:block;width:100% alt=NAME align=center> </div>
<h2 id=jvm-调试>JVM 调试</h2>
<div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210430151005.png style=display:block;width:100% alt=NAME align=center> </div>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-b38ffc56643777b708c418084c1fc6c7>2 - CH02-JVM字节码</h1>
<h2 id=多语言编译为-jvm-能够执行的字节码>多语言编译为 JVM 能够执行的字节码</h2>
<p>计算机是不能直接运行java代码的，必须要先运行java虚拟机，再由java虚拟机运行编译后的java代码。这个编译后的java代码，就是本文要介绍的java字节码。</p>
<p>为什么jvm不能直接运行java代码呢，这是因为在cpu层面看来计算机中所有的操作都是一个个指令的运行汇集而成的，java是高级语言，只有人类才能理解其逻辑，计算机是无法识别的，所以java代码必须要先编译成字节码文件，jvm才能正确识别代码转换后的指令并将其运行。</p>
<ul>
<li>
<p>Java代码间接翻译成字节码，储存字节码的文件再交由运行于不同平台上的JVM虚拟机去读取执行，从而实现一次编写，到处运行的目的。</p>
</li>
<li>
<p>JVM 不仅支持Java，由此衍生出了许多基于JVM的编程语言，如Groovy, Scala, Koltin等等。</p>
</li>
</ul>
<div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210430153224.png style=display:block;width:50% alt=NAME align=center> </div>
<h2 id=java字节码文件>Java字节码文件</h2>
<p>class文件本质上是一个以8位字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑的排列在class文件中。jvm根据其特定的规则解析该二进制数据，从而得到相关信息。</p>
<p>Class文件采用一种伪结构来存储数据，它有两种类型：无符号数和表。</p>
<h3 id=class文件的结构属性>Class文件的结构属性</h3>
<p>在理解之前先从整体看下java字节码文件包含了哪些类型的数据：</p>
<div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210430153430.png style=display:block;width:50% alt=NAME align=center> </div>
<h3 id=实例>实例</h3>
<p>下面以一个简单的例子来逐步讲解字节码。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#8f5902;font-style:italic>//Main.java
</span><span style=color:#8f5902;font-style:italic></span><span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>Main</span> <span style=color:#ce5c00;font-weight:700>{</span>
    
    <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>m</span><span style=color:#ce5c00;font-weight:700>;</span>
    
    <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>inc</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span>
        <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>m</span> <span style=color:#ce5c00;font-weight:700>+</span> <span style=color:#000>1</span><span style=color:#ce5c00;font-weight:700>;</span>
    <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>通过以下命令, 可以在当前所在路径下生成一个Main.class文件。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>javac Main.java
</code></pre></div><p>以文本的形式打开生成的class文件，内容如下:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback>cafe babe 0000 0034 0013 0a00 0400 0f09
0003 0010 0700 1107 0012 0100 016d 0100
0149 0100 063c 696e 6974 3e01 0003 2829
5601 0004 436f 6465 0100 0f4c 696e 654e
756d 6265 7254 6162 6c65 0100 0369 6e63
0100 0328 2949 0100 0a53 6f75 7263 6546
696c 6501 0009 4d61 696e 2e6a 6176 610c
0007 0008 0c00 0500 0601 0010 636f 6d2f
7268 7974 686d 372f 4d61 696e 0100 106a
6176 612f 6c61 6e67 2f4f 626a 6563 7400
2100 0300 0400 0000 0100 0200 0500 0600
0000 0200 0100 0700 0800 0100 0900 0000
1d00 0100 0100 0000 052a b700 01b1 0000
0001 000a 0000 0006 0001 0000 0003 0001
000b 000c 0001 0009 0000 001f 0002 0001
0000 0007 2ab4 0002 0460 ac00 0000 0100
0a00 0000 0600 0100 0000 0800 0100 0d00
0000 0200 0e
</code></pre></div><ul>
<li>
<p>文件开头的4个字节(&ldquo;cafe babe&rdquo;)称之为 <code>魔数</code>，唯有以"cafe babe"开头的class文件方可被虚拟机所接受，这4个字节就是字节码文件的身份识别。</p>
</li>
<li>
<p>0000是编译器jdk版本的次版本号0，0034转化为十进制是52,是主版本号，java的版本号从45开始，除1.0和1.1都是使用45.x外,以后每升一个大版本，版本号加一。也就是说，编译生成该class文件的jdk版本为1.8.0。</p>
</li>
</ul>
<h3 id=反编译字节码文件>反编译字节码文件</h3>
<p>输入命令<code>javap -verbose -p Main.class</code>查看输出内容:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback>Classfile /E:/JavaCode/TestProj/out/production/TestProj/com/rhythm7/Main.class
  Last modified 2018-4-7; size 362 bytes
  MD5 checksum 4aed8540b098992663b7ba08c65312de
  Compiled from &#34;Main.java&#34;
public class com.rhythm7.Main
  minor version: 0
  major version: 52
  flags: ACC_PUBLIC, ACC_SUPER
Constant pool:
   #1 = Methodref          #4.#18         // java/lang/Object.&#34;&lt;init&gt;&#34;:()V
   #2 = Fieldref           #3.#19         // com/rhythm7/Main.m:I
   #3 = Class              #20            // com/rhythm7/Main
   #4 = Class              #21            // java/lang/Object
   #5 = Utf8               m
   #6 = Utf8               I
   #7 = Utf8               &lt;init&gt;
   #8 = Utf8               ()V
   #9 = Utf8               Code
  #10 = Utf8               LineNumberTable
  #11 = Utf8               LocalVariableTable
  #12 = Utf8               this
  #13 = Utf8               Lcom/rhythm7/Main;
  #14 = Utf8               inc
  #15 = Utf8               ()I
  #16 = Utf8               SourceFile
  #17 = Utf8               Main.java
  #18 = NameAndType        #7:#8          // &#34;&lt;init&gt;&#34;:()V
  #19 = NameAndType        #5:#6          // m:I
  #20 = Utf8               com/rhythm7/Main
  #21 = Utf8               java/lang/Object
{
  private int m;
    descriptor: I
    flags: ACC_PRIVATE

  public com.rhythm7.Main();
    descriptor: ()V
    flags: ACC_PUBLIC
    Code:
      stack=1, locals=1, args_size=1
         0: aload_0
         1: invokespecial #1                  // Method java/lang/Object.&#34;&lt;init&gt;&#34;:()V
         4: return
      LineNumberTable:
        line 3: 0
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0       5     0  this   Lcom/rhythm7/Main;

  public int inc();
    descriptor: ()I
    flags: ACC_PUBLIC
    Code:
      stack=2, locals=1, args_size=1
         0: aload_0
         1: getfield      #2                  // Field m:I
         4: iconst_1
         5: iadd
         6: ireturn
      LineNumberTable:
        line 8: 0
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0       7     0  this   Lcom/rhythm7/Main;
}
SourceFile: &#34;Main.java&#34;
</code></pre></div><h3 id=字节码文件信息>字节码文件信息</h3>
<p>开头的7行信息包括:Class文件当前所在位置，最后修改时间，文件大小，MD5值，编译自哪个文件，类的全限定名，jdk次版本号，主版本号。</p>
<p>然后紧接着的是该类的访问标志：ACC_PUBLIC, ACC_SUPER，访问标志的含义如下:</p>
<table>
<thead>
<tr>
<th>标志名称</th>
<th>标志值</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>ACC_PUBLIC</td>
<td>0x0001</td>
<td>是否为Public类型</td>
</tr>
<tr>
<td>ACC_FINAL</td>
<td>0x0010</td>
<td>是否被声明为final，只有类可以设置</td>
</tr>
<tr>
<td>ACC_SUPER</td>
<td>0x0020</td>
<td>是否允许使用invokespecial字节码指令的新语义．</td>
</tr>
<tr>
<td>ACC_INTERFACE</td>
<td>0x0200</td>
<td>标志这是一个接口</td>
</tr>
<tr>
<td>ACC_ABSTRACT</td>
<td>0x0400</td>
<td>是否为abstract类型，对于接口或者抽象类来说，次标志值为真，其他类型为假</td>
</tr>
<tr>
<td>ACC_SYNTHETIC</td>
<td>0x1000</td>
<td>标志这个类并非由用户代码产生</td>
</tr>
<tr>
<td>ACC_ANNOTATION</td>
<td>0x2000</td>
<td>标志这是一个注解</td>
</tr>
<tr>
<td>ACC_ENUM</td>
<td>0x4000</td>
<td>标志这是一个枚举</td>
</tr>
</tbody>
</table>
<h3 id=常量池>常量池</h3>
<p>常量池可以理解成Class文件中的资源仓库。主要存放的是两大类常量：字面量(Literal)和符号引用(Symbolic References)。字面量类似于java中的常量概念，如文本字符串，final常量等，而符号引用则属于编译原理方面的概念，包括以下三种:</p>
<ul>
<li>类和接口的全限定名(Fully Qualified Name)</li>
<li>字段的名称和描述符号(Descriptor)</li>
<li>方法的名称和描述符</li>
</ul>
<p>不同于C/C++, JVM是在加载Class文件的时候才进行的动态链接，也就是说这些字段和方法符号引用只有在运行期转换后才能获得真正的内存入口地址。当虚拟机运行时，需要从常量池获得对应的符号引用，再在类创建或运行时解析并翻译到具体的内存地址中。 直接通过反编译文件来查看字节码内容：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback>#1 = Methodref          #4.#18         // java/lang/Object.&#34;&lt;init&gt;&#34;:()V
#4 = Class              #21            // java/lang/Object
#7 = Utf8               &lt;init&gt;
#8 = Utf8               ()V
#18 = NameAndType        #7:#8          // &#34;&lt;init&gt;&#34;:()V
#21 = Utf8               java/lang/Object
</code></pre></div><p><strong>第一个常量</strong>是一个方法定义，指向了第4和第18个常量。以此类推查看第4和第18个常量。最后可以拼接成第一个常量右侧的注释内容:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback>java/lang/Object.&#34;&lt;init&gt;&#34;:()V
</code></pre></div><p>这段可以理解为该类的实例构造器的声明，由于Main类没有重写构造方法，所以调用的是父类的构造方法。此处也说明了Main类的直接父类是Object。 该方法默认返回值是V, 也就是void，无返回值。</p>
<p><strong>第二个常量</strong>同理可得:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback>#2 = Fieldref           #3.#19         // com/rhythm7/Main.m:I
#3 = Class              #20            // com/rhythm7/Main
#5 = Utf8               m
#6 = Utf8               I
#19 = NameAndType        #5:#6          // m:I
#20 = Utf8               com/rhythm7/Main
</code></pre></div><p>此处声明了一个字段m，类型为I, I即是int类型。关于字节码的类型对应如下：</p>
<table>
<thead>
<tr>
<th>标识字符</th>
<th>含义</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>B</td>
<td>基本类型byte</td>
<td></td>
</tr>
<tr>
<td>C</td>
<td>基本类型char</td>
<td></td>
</tr>
<tr>
<td>D</td>
<td>基本类型double</td>
<td></td>
</tr>
<tr>
<td>F</td>
<td>基本类型float</td>
<td></td>
</tr>
<tr>
<td>I</td>
<td>基本类型int</td>
<td></td>
</tr>
<tr>
<td>J</td>
<td>基本类型long</td>
<td></td>
</tr>
<tr>
<td>S</td>
<td>基本类型short</td>
<td></td>
</tr>
<tr>
<td>Z</td>
<td>基本类型boolean</td>
<td></td>
</tr>
<tr>
<td>V</td>
<td>特殊类型void</td>
<td></td>
</tr>
<tr>
<td>L</td>
<td>对象类型，以分号结尾，如Ljava/lang/Object;</td>
<td></td>
</tr>
</tbody>
</table>
<p>对于数组类型，每一位使用一个前置的<code>[</code>字符来描述，如定义一个<code>java.lang.String[][]</code>类型的维数组，将被记录为<code>[[Ljava/lang/String;</code></p>
<h3 id=方法表集合>方法表集合</h3>
<p>在常量池之后的是对类内部的方法描述，在字节码中以表的集合形式表现，暂且不管字节码文件的16进制文件内容如何，我们直接看反编译后的内容。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback>private int m;
  descriptor: I
  flags: ACC_PRIVATE
</code></pre></div><p>此处声明了一个私有变量m，类型为int，返回值为int</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback>public com.rhythm7.Main();
   descriptor: ()V
   flags: ACC_PUBLIC
   Code:
     stack=1, locals=1, args_size=1
        0: aload_0
        1: invokespecial #1                  // Method java/lang/Object.&#34;&lt;init&gt;&#34;:()V
        4: return
     LineNumberTable:
       line 3: 0
     LocalVariableTable:
       Start  Length  Slot  Name   Signature
           0       5     0  this   Lcom/rhythm7/Main;
</code></pre></div><p>这里是构造方法：Main()，返回值为void, 公开方法。</p>
<p>code内的主要属性为:</p>
<ul>
<li>
<p><strong>stack</strong>: 最大操作数栈，JVM运行时会根据这个值来分配栈帧(Frame)中的操作栈深度,此处为1</p>
</li>
<li>
<p><strong>locals</strong>: 局部变量所需的存储空间，单位为Slot, Slot是虚拟机为局部变量分配内存时所使用的最小单位，为4个字节大小。方法参数(包括实例方法中的隐藏参数this)，显示异常处理器的参数(try catch中的catch块所定义的异常)，方法体中定义的局部变量都需要使用局部变量表来存放。值得一提的是，locals的大小并不一定等于所有局部变量所占的Slot之和，因为局部变量中的Slot是可以重用的。</p>
</li>
<li>
<p><strong>args_size</strong>: 方法参数的个数，这里是1，因为每个实例方法都会有一个隐藏参数this</p>
</li>
<li>
<p><strong>attribute_info</strong>: 方法体内容，0,1,4为字节码"行号"，该段代码的意思是将第一个引用类型本地变量推送至栈顶，然后执行该类型的实例方法，也就是常量池存放的第一个变量，也就是注释里的"java/lang/Object.&ldquo;&ldquo;😦)V&rdquo;, 然后执行返回语句，结束方法。</p>
</li>
<li>
<p><strong>LineNumberTable</strong>: 该属性的作用是描述源码行号与字节码行号(字节码偏移量)之间的对应关系。可以使用 -g:none 或-g:lines选项来取消或要求生成这项信息，如果选择不生成LineNumberTable，当程序运行异常时将无法获取到发生异常的源码行号，也无法按照源码的行数来调试程序。</p>
</li>
<li>
<p><strong>LocalVariableTable</strong>: 该属性的作用是描述帧栈中局部变量与源码中定义的变量之间的关系。可以使用 -g:none 或 -g:vars来取消或生成这项信息，如果没有生成这项信息，那么当别人引用这个方法时，将无法获取到参数名称，取而代之的是arg0, arg1这样的占位符。 start 表示该局部变量在哪一行开始可见，length表示可见行数，Slot代表所在帧栈位置，Name是变量名称，然后是类型签名。</p>
</li>
</ul>
<p>同理可以分析Main类中的另一个方法"inc()":</p>
<p>方法体内的内容是：将this入栈，获取字段#2并置于栈顶, 将int类型的1入栈，将栈内顶部的两个数值相加，返回一个int类型的值。</p>
<h3 id=类名>类名</h3>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback>SourceFile: &#34;Main.java&#34;
</code></pre></div><h2 id=典型问题try-catch-finally>典型问题：try-catch-finally</h2>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>TestCode</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>foo</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span>
        <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>x</span><span style=color:#ce5c00;font-weight:700>;</span>
        <span style=color:#204a87;font-weight:700>try</span> <span style=color:#ce5c00;font-weight:700>{</span>
            <span style=color:#000>x</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>1</span><span style=color:#ce5c00;font-weight:700>;</span>
            <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>x</span><span style=color:#ce5c00;font-weight:700>;</span>
        <span style=color:#ce5c00;font-weight:700>}</span> <span style=color:#204a87;font-weight:700>catch</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>Exception</span> <span style=color:#000>e</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
            <span style=color:#000>x</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>2</span><span style=color:#ce5c00;font-weight:700>;</span>
            <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>x</span><span style=color:#ce5c00;font-weight:700>;</span>
        <span style=color:#ce5c00;font-weight:700>}</span> <span style=color:#204a87;font-weight:700>finally</span> <span style=color:#ce5c00;font-weight:700>{</span>
            <span style=color:#000>x</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>3</span><span style=color:#ce5c00;font-weight:700>;</span>
        <span style=color:#ce5c00;font-weight:700>}</span>
    <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback>public int foo();
    descriptor: ()I
    flags: ACC_PUBLIC
    Code:
      stack=1, locals=5, args_size=1
         0: iconst_1 //int型1入栈 -&gt;栈顶=1
         1: istore_1 //将栈顶的int型数值存入第二个局部变量 -&gt;局部2=1
         2: iload_1 //将第二个int型局部变量推送至栈顶 -&gt;栈顶=1
         3: istore_2 //!!将栈顶int型数值存入第三个局部变量 -&gt;局部3=1
         
         4: iconst_3 //int型3入栈 -&gt;栈顶=3
         5: istore_1 //将栈顶的int型数值存入第二个局部变量 -&gt;局部2=3
         6: iload_2 //!!将第三个int型局部变量推送至栈顶 -&gt;栈顶=1
         7: ireturn //从当前方法返回栈顶int数值 -&gt;1
         
         8: astore_2 // -&gt;局部3=Exception
         9: iconst_2 // -&gt;栈顶=2
        10: istore_1 // -&gt;局部2=2
        11: iload_1 //-&gt;栈顶=2
        12: istore_3 //!! -&gt;局部4=2
        
        13: iconst_3 // -&gt;栈顶=3
        14: istore_1 // -&gt;局部1=3
        15: iload_3 //!! -&gt;栈顶=2
        16: ireturn // -&gt; 2
        
        17: astore        4 //将栈顶引用型数值存入第五个局部变量=any
        19: iconst_3 //将int型数值3入栈 -&gt; 栈顶3
        20: istore_1 //将栈顶第一个int数值存入第二个局部变量 -&gt; 局部2=3
        21: aload         4 //将局部第五个局部变量(引用型)推送至栈顶
        23: athrow //将栈顶的异常抛出
      Exception table:
         from    to  target type
             0     4     8   Class java/lang/Exception //0到4行对应的异常，对应#8中储存的异常
             0     4    17   any //Exeption之外的其他异常
             8    13    17   any
            17    19    17   any
</code></pre></div><p>在字节码的4,5，以及13,14中执行的是同一个操作，就是将int型的3入操作数栈顶，并存入第二个局部变量。这正是我们源码在finally语句块中内容。也就是说，JVM在处理异常时，会在每个可能的分支都将finally语句重复执行一遍。</p>
<p>通过一步步分析字节码，可以得出最后的运行结果是：</p>
<ul>
<li>不发生异常时: return 1</li>
<li>发生异常时: return 2</li>
<li>发生非Exception及其子类的异常，抛出异常，不返回值</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-3fe7ca4dd715cdb713abf4472ca1870b>3 - CH03-JVM类加载</h1>
<h2 id=类的生命周期>类的生命周期</h2>
<p>其中类加载的过程包括了<code>加载</code>、<code>验证</code>、<code>准备</code>、<code>解析</code>、<code>初始化</code>五个阶段。在这五个阶段中，<code>加载</code>、<code>验证</code>、<code>准备</code>和<code>初始化</code>这四个阶段发生的顺序是确定的，<em>而<code>解析</code>阶段则不一定，它在某些情况下可以在初始化阶段之后开始，这是为了支持Java语言的运行时绑定(也成为动态绑定或晚期绑定)</em>。另外注意这里的几个阶段是按顺序开始，而不是按顺序进行或完成，因为这些阶段通常都是互相交叉地混合进行的，通常在一个阶段执行的过程中调用或激活另一个阶段。</p>
<div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210430155349.png style=display:block;width:50% alt=NAME align=center> </div>
<h3 id=类的加载-查找并加载类的二进制数据>类的加载: 查找并加载类的二进制数据</h3>
<p>加载时类加载过程的第一个阶段，在加载阶段，虚拟机需要完成以下三件事情:</p>
<ul>
<li>通过一个类的全限定名来获取其定义的二进制字节流。</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li>
<li>在Java堆中生成一个代表这个类的java.lang.Class对象，作为对方法区中这些数据的访问入口。</li>
</ul>
<div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210430155617.png style=display:block;width:50% alt=NAME align=center> </div>
<p>开发人员既可以使用系统提供的类加载器来完成加载，也可以自定义自己的类加载器来完成加载。</p>
<ul>
<li>从本地系统中直接加载</li>
<li>通过网络下载.class文件</li>
<li>从zip，jar等归档文件中加载.class文件</li>
<li>从专有数据库中提取.class文件</li>
<li>将Java源文件动态编译为.class文件</li>
</ul>
<p>加载阶段完成后，虚拟机外部的 二进制字节流就按照虚拟机所需的格式存储在方法区之中，而且在Java堆中也创建一个<code>java.lang.Class</code>类的对象，这样便可以通过该对象访问方法区中的这些数据。</p>
<p>类加载器并不需要等到某个类被“首次主动使用”时再加载它，JVM规范允许类加载器在预料某个类将要被使用时就预先加载它，如果在预先加载的过程中遇到了.class文件缺失或存在错误，类加载器必须在程序首次主动使用该类时才报告错误(LinkageError错误)如果这个类一直没有被程序主动使用，那么类加载器就不会报告错误。</p>
<h3 id=连接>连接</h3>
<h4 id=验证-确保被加载的类的正确性>验证: 确保被加载的类的正确性</h4>
<p>验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。验证阶段大致会完成4个阶段的检验动作:</p>
<ul>
<li><code>文件格式验证</code>: 验证字节流是否符合Class文件格式的规范；例如: 是否以<code>0xCAFEBABE</code>开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。</li>
<li><code>元数据验证</code>: 对字节码描述的信息进行语义分析(注意: 对比<code>javac</code>编译阶段的语义分析)，以保证其描述的信息符合Java语言规范的要求；例如: 这个类是否有父类，除了<code>java.lang.Object</code>之外。</li>
<li><code>字节码验证</code>: 通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。</li>
<li><code>符号引用验证</code>: 确保解析动作能正确执行。</li>
</ul>
<blockquote>
<p>验证阶段是非常重要的，但不是必须的，它对程序运行期没有影响，<em>如果所引用的类经过反复验证，那么可以考虑采用<code>-Xverifynone</code>参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。</em></p>
</blockquote>
<h4 id=准备-为类的静态变量分配内存并将其初始化为默认值>准备: 为类的静态变量分配内存，并将其初始化为默认值</h4>
<p>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，<strong>这些内存都将在方法区中分配</strong>。对于该阶段有以下几点需要注意:</p>
<ul>
<li>
<p>这时候进行内存分配的仅包括类变量(<code>static</code>)，而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在Java堆中。</p>
</li>
<li>
<p>这里所设置的初始值通常情况下是数据类型默认的零值(如<code>0</code>、<code>0L</code>、<code>null</code>、<code>false</code>等)，而不是被在Java代码中被显式地赋予的值。</p>
<p>假设一个类变量的定义为: <code>public static int value = 3</code>；那么变量value在准备阶段过后的初始值为<code>0</code>，而不是<code>3</code>，因为这时候尚未开始执行任何Java方法，而把value赋值为3的<code>put static</code>指令是在程序编译后，存放于类构造器<code>&lt;clinit>()</code>方法之中的，所以把value赋值为3的动作将在初始化阶段才会执行。</p>
</li>
</ul>
<p>另外：</p>
<ul>
<li>对基本数据类型来说，对于类变量(static)和全局变量，如果不显式地对其赋值而直接使用，则系统会为其赋予默认的零值，而对于局部变量来说，在使用前必须显式地为其赋值，否则编译时不通过。</li>
<li>对于同时被<code>static</code>和<code>final</code>修饰的常量，必须在声明的时候就为其显式地赋值，否则编译时不通过；而只被final修饰的常量则既可以在声明时显式地为其赋值，也可以在类初始化时显式地为其赋值，总之，在使用前必须为其显式地赋值，系统不会为其赋予默认零值。</li>
<li>对于引用数据类型<code>reference</code>来说，如数组引用、对象引用等，如果没有对其进行显式地赋值而直接使用，系统都会为其赋予默认的零值，即<code>null</code>。</li>
<li>如果在数组初始化时没有对数组中的各元素赋值，那么其中的元素将根据对应的数据类型而被赋予默认的零值。</li>
<li>如果类字段的字段属性表中存在ConstantValue属性，即同时被final和static修饰，那么在准备阶段变量value就会被初始化为ConstValue属性所指定的值。假设上面的类变量value被定义为: <code>public static final int value = 3；</code>编译时Javac将会为value生成ConstantValue属性，在准备阶段虚拟机就会根据ConstantValue的设置将value赋值为3。我们可以理解为<code>static final</code>常量在编译期就将其结果放入了调用它的类的常量池中</li>
</ul>
<h4 id=解析-把类中的符号引用转换为直接引用>解析: 把类中的符号引用转换为直接引用</h4>
<p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，解析动作主要针对<code>类</code>或<code>接口</code>、<code>字段</code>、<code>类方法</code>、<code>接口方法</code>、<code>方法类型</code>、<code>方法句柄</code>和<code>调用点</code>限定符7类符号引用进行。符号引用就是一组符号来描述目标，可以是任何字面量。</p>
<p><code>直接引用</code>就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。</p>
<h3 id=初始化>初始化</h3>
<p>初始化，为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化。在Java中对类变量进行初始值设定有两种方式:</p>
<ul>
<li>声明类变量时指定初始值</li>
<li>使用静态代码块为类变量指定初始值</li>
</ul>
<p><strong>JVM初始化步骤</strong></p>
<ul>
<li>假如这个类还没有被加载和连接，则程序先加载并连接该类</li>
<li>假如该类的直接父类还没有被初始化，则先初始化其直接父类</li>
<li>假如类中有初始化语句，则系统依次执行这些初始化语句</li>
</ul>
<p><strong>类初始化时机</strong>: 只有当对类的主动使用的时候才会导致类的初始化，类的主动使用包括以下六种:</p>
<ul>
<li>创建类的实例，也就是new的方式</li>
<li>访问某个类或接口的静态变量，或者对该静态变量赋值</li>
<li>调用类的静态方法</li>
<li>反射(如Class.forName(&ldquo;com.pdai.jvm.Test&rdquo;))</li>
<li>初始化某个类的子类，则其父类也会被初始化</li>
<li>Java虚拟机启动时被标明为启动类的类(Java Test)，直接使用java.exe命令来运行某个主类</li>
</ul>
<h3 id=使用>使用</h3>
<p>类访问方法区内的数据结构的接口，对象是Heap区的数据。</p>
<h3 id=卸载>卸载</h3>
<p><strong>Java虚拟机将结束生命周期的几种情况</strong></p>
<ul>
<li>执行了System.exit()方法</li>
<li>程序正常执行结束</li>
<li>程序在执行过程中遇到了异常或错误而异常终止</li>
<li>由于操作系统出现错误而导致Java虚拟机进程终止</li>
</ul>
<h2 id=类加载器>类加载器</h2>
<h3 id=类加载器的层次>类加载器的层次</h3>
<div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210430160419.png style=display:block;width:50% alt=NAME align=center> </div>
<p>注意: 这里父类加载器并不是通过继承关系来实现的，而是采用组合实现的。</p>
<p><strong>站在Java虚拟机的角度来讲，只存在两种不同的类加载器:</strong></p>
<ul>
<li>启动类加载器: 它使用C++实现(这里仅限于<code>Hotspot</code>，也就是JDK1.5之后默认的虚拟机，有很多其他的虚拟机是用Java语言实现的)，是虚拟机自身的一部分；</li>
<li>所有其他的类加载器: 这些类加载器都由Java语言实现，独立于虚拟机之外，并且全部继承自抽象类<code>java.lang.ClassLoader</code>，这些类加载器需要由启动类加载器加载到内存中之后才能去加载其他的类。</li>
</ul>
<p><strong>站在Java开发人员的角度来看，类加载器可以大致划分为以下三类</strong> :</p>
<p><code>启动类加载器</code>: Bootstrap ClassLoader，负责加载存放在JDK\jre\lib(JDK代表JDK的安装目录，下同)下，或被-Xbootclasspath参数指定的路径中的，并且能被虚拟机识别的类库(如rt.jar，所有的java.*开头的类均被Bootstrap ClassLoader加载)。启动类加载器是无法被Java程序直接引用的。</p>
<p><code>扩展类加载器</code>: Extension ClassLoader，该加载器由<code>sun.misc.Launcher$ExtClassLoader</code>实现，它负责加载JDK\jre\lib\ext目录中，或者由java.ext.dirs系统变量指定的路径中的所有类库(如javax.*开头的类)，开发者可以直接使用扩展类加载器。</p>
<p><code>应用程序类加载器</code>: Application ClassLoader，该类加载器由<code>sun.misc.Launcher$AppClassLoader</code>来实现，它负责加载用户类路径(ClassPath)所指定的类，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</p>
<p>应用程序都是由这三种类加载器互相配合进行加载的，如果有必要，我们还可以加入自定义的类加载器。因为JVM自带的ClassLoader只是懂得从本地文件系统加载标准的java class文件，因此如果编写了自己的ClassLoader，便可以做到如下几点:</p>
<ul>
<li>在执行非置信代码之前，自动验证数字签名。</li>
<li>动态地创建符合用户特定需要的定制化构建类。</li>
<li>从特定的场所取得java class，例如数据库中和网络中。</li>
</ul>
<h3 id=寻找类加载器>寻找类加载器</h3>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#000>ClassLoader</span> <span style=color:#000>loader</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>Thread</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>currentThread</span><span style=color:#ce5c00;font-weight:700>().</span><span style=color:#c4a000>getContextClassLoader</span><span style=color:#ce5c00;font-weight:700>();</span>
<span style=color:#000>System</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>out</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>println</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>loader</span><span style=color:#ce5c00;font-weight:700>);</span>
<span style=color:#000>System</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>out</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>println</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>loader</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>getParent</span><span style=color:#ce5c00;font-weight:700>());</span>
<span style=color:#000>System</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>out</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>println</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>loader</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>getParent</span><span style=color:#ce5c00;font-weight:700>().</span><span style=color:#c4a000>getParent</span><span style=color:#ce5c00;font-weight:700>());</span>

<span style=color:#8f5902;font-style:italic>// output:
</span><span style=color:#8f5902;font-style:italic></span><span style=color:#000>sun</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>misc</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>Launcher$AppClassLoader</span><span style=color:#5c35cc;font-weight:700>@64fef26a</span>
<span style=color:#000>sun</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>misc</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>Launcher$ExtClassLoader</span><span style=color:#5c35cc;font-weight:700>@1ddd40f3</span>
<span style=color:#204a87;font-weight:700>null</span>
</code></pre></div><p>从上面的结果可以看出，并没有获取到<code>ExtClassLoader</code>的父Loader，原因是<code>BootstrapLoader</code>(引导类加载器)是用C语言实现的，找不到一个确定的返回父Loader的方式，于是就返回<code>null</code>。</p>
<h3 id=类的加载>类的加载</h3>
<p>类加载有三种方式:</p>
<p>1、命令行启动应用时候由JVM初始化加载</p>
<p>2、通过Class.forName()方法动态加载</p>
<p>3、通过ClassLoader.loadClass()方法动态加载</p>
<p>Class.forName()和ClassLoader.loadClass()区别?</p>
<ul>
<li>Class.forName(): 将类的.class文件加载到jvm中之外，还会对类进行解释，执行类中的static块；</li>
<li>ClassLoader.loadClass(): 只干一件事情，就是将.class文件加载到jvm中，不会执行static中的内容,只有在newInstance才会去执行static块。</li>
<li>Class.forName(name, initialize, loader)带参函数也可控制是否加载static块。并且只有调用了newInstance()方法采用调用构造函数，创建类的对象 。</li>
</ul>
<h2 id=jvm-类加载机制>JVM 类加载机制</h2>
<ul>
<li>
<p><code>全盘负责</code>，当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入</p>
</li>
<li>
<p><code>父类委托</code>，先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类</p>
</li>
<li>
<p><code>缓存机制</code>，缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区寻找该Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区。这就是为什么修改了Class后，必须重启JVM，程序的修改才会生效</p>
</li>
<li>
<p><code>双亲委派机制</code>, 如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。</p>
<ul>
<li>系统类防止内存中出现多份同样的字节码</li>
<li>保证Java程序安全稳定运行</li>
</ul>
</li>
</ul>
<p><strong>双亲委派机制</strong></p>
<ol>
<li>当AppClassLoader加载一个class时，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器ExtClassLoader去完成。</li>
<li>当ExtClassLoader加载一个class时，它首先也不会自己去尝试加载这个类，而是把类加载请求委派给BootStrapClassLoader去完成。</li>
<li>如果BootStrapClassLoader加载失败(例如在$JAVA_HOME/jre/lib里未查找到该class)，会使用ExtClassLoader来尝试加载；</li>
<li>若ExtClassLoader也加载失败，则会使用AppClassLoader来加载，如果AppClassLoader也加载失败，则会报出异常ClassNotFoundException。</li>
</ol>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#204a87;font-weight:700>public</span> <span style=color:#000>Class</span><span style=color:#ce5c00;font-weight:700>&lt;?&gt;</span> <span style=color:#000>loadClass</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>String</span> <span style=color:#000>name</span><span style=color:#ce5c00;font-weight:700>)</span><span style=color:#204a87;font-weight:700>throws</span> <span style=color:#000>ClassNotFoundException</span> <span style=color:#ce5c00;font-weight:700>{</span>
		<span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>loadClass</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>name</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#204a87;font-weight:700>false</span><span style=color:#ce5c00;font-weight:700>);</span>
<span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#204a87;font-weight:700>protected</span> <span style=color:#204a87;font-weight:700>synchronized</span> <span style=color:#000>Class</span><span style=color:#ce5c00;font-weight:700>&lt;?&gt;</span> <span style=color:#000>loadClass</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>String</span> <span style=color:#000>name</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#204a87;font-weight:700>boolean</span> <span style=color:#000>resolve</span><span style=color:#ce5c00;font-weight:700>)</span><span style=color:#204a87;font-weight:700>throws</span> <span style=color:#000>ClassNotFoundException</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#8f5902;font-style:italic>// 首先判断该类型是否已经被加载
</span><span style=color:#8f5902;font-style:italic></span>    <span style=color:#000>Class</span> <span style=color:#000>c</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>findLoadedClass</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>name</span><span style=color:#ce5c00;font-weight:700>);</span>
    <span style=color:#204a87;font-weight:700>if</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>c</span> <span style=color:#ce5c00;font-weight:700>==</span> <span style=color:#204a87;font-weight:700>null</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
        <span style=color:#8f5902;font-style:italic>//如果没有被加载，就委托给父类加载或者委派给启动类加载器加载
</span><span style=color:#8f5902;font-style:italic></span>        <span style=color:#204a87;font-weight:700>try</span> <span style=color:#ce5c00;font-weight:700>{</span>
            <span style=color:#204a87;font-weight:700>if</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>parent</span> <span style=color:#ce5c00;font-weight:700>!=</span> <span style=color:#204a87;font-weight:700>null</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
                 <span style=color:#8f5902;font-style:italic>//如果存在父类加载器，就委派给父类加载器加载
</span><span style=color:#8f5902;font-style:italic></span>                <span style=color:#000>c</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>parent</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>loadClass</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>name</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#204a87;font-weight:700>false</span><span style=color:#ce5c00;font-weight:700>);</span>
            <span style=color:#ce5c00;font-weight:700>}</span> <span style=color:#204a87;font-weight:700>else</span> <span style=color:#ce5c00;font-weight:700>{</span>
            <span style=color:#8f5902;font-style:italic>//如果不存在父类加载器，就检查是否是由启动类加载器加载的类，通过调用本地方法native Class findBootstrapClass(String name)
</span><span style=color:#8f5902;font-style:italic></span>                <span style=color:#000>c</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>findBootstrapClass0</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>name</span><span style=color:#ce5c00;font-weight:700>);</span>
            <span style=color:#ce5c00;font-weight:700>}</span>
        <span style=color:#ce5c00;font-weight:700>}</span> <span style=color:#204a87;font-weight:700>catch</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>ClassNotFoundException</span> <span style=color:#000>e</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
         <span style=color:#8f5902;font-style:italic>// 如果父类加载器和启动类加载器都不能完成加载任务，才调用自身的加载功能
</span><span style=color:#8f5902;font-style:italic></span>            <span style=color:#000>c</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>findClass</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>name</span><span style=color:#ce5c00;font-weight:700>);</span>
        <span style=color:#ce5c00;font-weight:700>}</span>
    <span style=color:#ce5c00;font-weight:700>}</span>
    <span style=color:#204a87;font-weight:700>if</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>resolve</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
        <span style=color:#000>resolveClass</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>c</span><span style=color:#ce5c00;font-weight:700>);</span>
    <span style=color:#ce5c00;font-weight:700>}</span>
    <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>c</span><span style=color:#ce5c00;font-weight:700>;</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><h2 id=自定义类加载器>自定义类加载器</h2>
<p>自定义类加载器一般都是继承自 ClassLoader 类，从上面对 loadClass 方法来分析来看，我们只需要重写 findClass 方法即可。下面我们通过一个示例来演示自定义类加载器的流程:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#204a87;font-weight:700>package</span> <span style=color:#000>com.pdai.jvm.classloader</span><span style=color:#ce5c00;font-weight:700>;</span>
<span style=color:#204a87;font-weight:700>import</span> <span style=color:#000>java.io.*</span><span style=color:#ce5c00;font-weight:700>;</span>

<span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>MyClassLoader</span> <span style=color:#204a87;font-weight:700>extends</span> <span style=color:#000>ClassLoader</span> <span style=color:#ce5c00;font-weight:700>{</span>

    <span style=color:#204a87;font-weight:700>private</span> <span style=color:#000>String</span> <span style=color:#000>root</span><span style=color:#ce5c00;font-weight:700>;</span>

    <span style=color:#204a87;font-weight:700>protected</span> <span style=color:#000>Class</span><span style=color:#ce5c00;font-weight:700>&lt;?&gt;</span> <span style=color:#000>findClass</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>String</span> <span style=color:#000>name</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#204a87;font-weight:700>throws</span> <span style=color:#000>ClassNotFoundException</span> <span style=color:#ce5c00;font-weight:700>{</span>
        <span style=color:#204a87;font-weight:700>byte</span><span style=color:#ce5c00;font-weight:700>[]</span> <span style=color:#000>classData</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>loadClassData</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>name</span><span style=color:#ce5c00;font-weight:700>);</span>
        <span style=color:#204a87;font-weight:700>if</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>classData</span> <span style=color:#ce5c00;font-weight:700>==</span> <span style=color:#204a87;font-weight:700>null</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
            <span style=color:#204a87;font-weight:700>throw</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>ClassNotFoundException</span><span style=color:#ce5c00;font-weight:700>();</span>
        <span style=color:#ce5c00;font-weight:700>}</span> <span style=color:#204a87;font-weight:700>else</span> <span style=color:#ce5c00;font-weight:700>{</span>
            <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>defineClass</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>name</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>classData</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>0</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>classData</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>length</span><span style=color:#ce5c00;font-weight:700>);</span>
        <span style=color:#ce5c00;font-weight:700>}</span>
    <span style=color:#ce5c00;font-weight:700>}</span>

    <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>byte</span><span style=color:#ce5c00;font-weight:700>[]</span> <span style=color:#000>loadClassData</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>String</span> <span style=color:#000>className</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
        <span style=color:#000>String</span> <span style=color:#000>fileName</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>root</span> <span style=color:#ce5c00;font-weight:700>+</span> <span style=color:#000>File</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>separatorChar</span>
                <span style=color:#ce5c00;font-weight:700>+</span> <span style=color:#000>className</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>replace</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#4e9a06>&#39;.&#39;</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>File</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>separatorChar</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>+</span> <span style=color:#4e9a06>&#34;.class&#34;</span><span style=color:#ce5c00;font-weight:700>;</span>
        <span style=color:#204a87;font-weight:700>try</span> <span style=color:#ce5c00;font-weight:700>{</span>
            <span style=color:#000>InputStream</span> <span style=color:#000>ins</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>FileInputStream</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>fileName</span><span style=color:#ce5c00;font-weight:700>);</span>
            <span style=color:#000>ByteArrayOutputStream</span> <span style=color:#000>baos</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>ByteArrayOutputStream</span><span style=color:#ce5c00;font-weight:700>();</span>
            <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>bufferSize</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>1024</span><span style=color:#ce5c00;font-weight:700>;</span>
            <span style=color:#204a87;font-weight:700>byte</span><span style=color:#ce5c00;font-weight:700>[]</span> <span style=color:#000>buffer</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#204a87;font-weight:700>byte</span><span style=color:#ce5c00;font-weight:700>[</span><span style=color:#000>bufferSize</span><span style=color:#ce5c00;font-weight:700>];</span>
            <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>length</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>0</span><span style=color:#ce5c00;font-weight:700>;</span>
            <span style=color:#204a87;font-weight:700>while</span> <span style=color:#ce5c00;font-weight:700>((</span><span style=color:#000>length</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>ins</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>read</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>buffer</span><span style=color:#ce5c00;font-weight:700>))</span> <span style=color:#ce5c00;font-weight:700>!=</span> <span style=color:#ce5c00;font-weight:700>-</span><span style=color:#000>1</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
                <span style=color:#000>baos</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>write</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>buffer</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>0</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>length</span><span style=color:#ce5c00;font-weight:700>);</span>
            <span style=color:#ce5c00;font-weight:700>}</span>
            <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>baos</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>toByteArray</span><span style=color:#ce5c00;font-weight:700>();</span>
        <span style=color:#ce5c00;font-weight:700>}</span> <span style=color:#204a87;font-weight:700>catch</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>IOException</span> <span style=color:#000>e</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
            <span style=color:#000>e</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>printStackTrace</span><span style=color:#ce5c00;font-weight:700>();</span>
        <span style=color:#ce5c00;font-weight:700>}</span>
        <span style=color:#204a87;font-weight:700>return</span> <span style=color:#204a87;font-weight:700>null</span><span style=color:#ce5c00;font-weight:700>;</span>
    <span style=color:#ce5c00;font-weight:700>}</span>

    <span style=color:#204a87;font-weight:700>public</span> <span style=color:#000>String</span> <span style=color:#000>getRoot</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span>
        <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>root</span><span style=color:#ce5c00;font-weight:700>;</span>
    <span style=color:#ce5c00;font-weight:700>}</span>

    <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>setRoot</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>String</span> <span style=color:#000>root</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
        <span style=color:#204a87;font-weight:700>this</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>root</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>root</span><span style=color:#ce5c00;font-weight:700>;</span>
    <span style=color:#ce5c00;font-weight:700>}</span>

    <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>static</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>main</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>String</span><span style=color:#ce5c00;font-weight:700>[]</span> <span style=color:#000>args</span><span style=color:#ce5c00;font-weight:700>)</span>  <span style=color:#ce5c00;font-weight:700>{</span>

        <span style=color:#000>MyClassLoader</span> <span style=color:#000>classLoader</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>MyClassLoader</span><span style=color:#ce5c00;font-weight:700>();</span>
        <span style=color:#000>classLoader</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>setRoot</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#4e9a06>&#34;D:\\temp&#34;</span><span style=color:#ce5c00;font-weight:700>);</span>

        <span style=color:#000>Class</span><span style=color:#ce5c00;font-weight:700>&lt;?&gt;</span> <span style=color:#000>testClass</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>null</span><span style=color:#ce5c00;font-weight:700>;</span>
        <span style=color:#204a87;font-weight:700>try</span> <span style=color:#ce5c00;font-weight:700>{</span>
            <span style=color:#000>testClass</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>classLoader</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>loadClass</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#4e9a06>&#34;com.pdai.jvm.classloader.Test2&#34;</span><span style=color:#ce5c00;font-weight:700>);</span>
            <span style=color:#000>Object</span> <span style=color:#000>object</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>testClass</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>newInstance</span><span style=color:#ce5c00;font-weight:700>();</span>
            <span style=color:#000>System</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>out</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>println</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>object</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>getClass</span><span style=color:#ce5c00;font-weight:700>().</span><span style=color:#c4a000>getClassLoader</span><span style=color:#ce5c00;font-weight:700>());</span>
        <span style=color:#ce5c00;font-weight:700>}</span> <span style=color:#204a87;font-weight:700>catch</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>ClassNotFoundException</span> <span style=color:#000>e</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
            <span style=color:#000>e</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>printStackTrace</span><span style=color:#ce5c00;font-weight:700>();</span>
        <span style=color:#ce5c00;font-weight:700>}</span> <span style=color:#204a87;font-weight:700>catch</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>InstantiationException</span> <span style=color:#000>e</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
            <span style=color:#000>e</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>printStackTrace</span><span style=color:#ce5c00;font-weight:700>();</span>
        <span style=color:#ce5c00;font-weight:700>}</span> <span style=color:#204a87;font-weight:700>catch</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>IllegalAccessException</span> <span style=color:#000>e</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
            <span style=color:#000>e</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>printStackTrace</span><span style=color:#ce5c00;font-weight:700>();</span>
        <span style=color:#ce5c00;font-weight:700>}</span>
    <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>自定义类加载器的核心在于对字节码文件的获取，如果是加密的字节码则需要在该类中对文件进行解密。由于这里只是演示，我并未对class文件进行加密，因此没有解密的过程。</p>
<p><strong>这里有几点需要注意</strong> :</p>
<p>1、这里传递的文件名需要是类的全限定性名称，即<code>com.pdai.jvm.classloader.Test2</code>格式的，因为 defineClass 方法是按这种格式进行处理的。</p>
<p>2、最好不要重写loadClass方法，因为这样容易破坏双亲委托模式。</p>
<p>3、这类Test 类本身可以被 AppClassLoader 类加载，因此我们不能把com/pdai/jvm/classloader/Test2.class 放在类路径下。否则，由于双亲委托机制的存在，会直接导致该类由 AppClassLoader 加载，而不会通过我们自定义类加载器来加载。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-55cdabdc2dcacd0ec93d06c4f0abb5d7>4 - CH04-JVM内存结构</h1>
<h2 id=运行时数据区>运行时数据区</h2>
<p>内存是非常重要的系统资源，是硬盘和 CPU 的中间仓库及桥梁，承载着操作系统和应用程序的实时运行。JVM 内存布局规定了 Java 在运行过程中内存申请、分配、管理的策略，保证了 JVM 的高效稳定运行。不同的 JVM 对于内存的划分方式和管理机制存在着部分差异。</p>
<p>下图是 JVM 整体架构，中间部分就是 Java 虚拟机定义的各种运行时数据区域。</p>
<div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210430162632.png style=display:block;width:80% alt=NAME align=center> </div>
<p>Java 虚拟机定义了若干种程序运行期间会使用到的运行时数据区，其中有一些会随着虚拟机启动而创建，随着虚拟机退出而销毁。另外一些则是与线程一一对应的，这些与线程一一对应的数据区域会随着线程开始和结束而创建和销毁。</p>
<ul>
<li><strong>线程私有</strong>：程序计数器、栈、本地栈</li>
<li><strong>线程共享</strong>：堆、堆外内存（Java7的永久代或JDK8的元空间、代码缓存）</li>
</ul>
<h2 id=程序计数器>程序计数器</h2>
<p>程序计数寄存器（<strong>Program Counter Register</strong>），Register 的命名源于 CPU 的寄存器，寄存器存储指令相关的线程信息，CPU 只有把数据装载到寄存器才能够运行。</p>
<p>这里，并非是广义上所指的物理寄存器，叫程序计数器（或PC计数器或指令计数器）会更加贴切，并且也不容易引起一些不必要的误会。<strong>JVM 中的 PC 寄存器是对物理 PC 寄存器的一种抽象模拟</strong>。</p>
<p>程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的<strong>行号指示器</strong>。</p>
<h3 id=作用>作用</h3>
<p>PC 寄存器用来存储指向下一条指令的地址，即将要执行的指令代码。由执行引擎读取下一条指令。</p>
<p>进入class文件所在目录，执行 <code>javap -v xx.class</code> 反解析（或者通过 IDEA 插件 <code>Jclasslib</code> 直接查看，上图），可以看到当前类对应的Code区（汇编指令）、本地变量表、异常表和代码行偏移量映射表、常量池等信息。</p>
<div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210430162940.png style=display:block;width:50% alt=NAME align=center> </div>
<h3 id=概述>概述</h3>
<p>通过下面两个问题，理解下PC计数器：</p>
<p><strong>使用PC寄存器存储字节码指令地址有什么用呢？为什么使用PC寄存器记录当前线程的执行地址呢？</strong></p>
<ul>
<li>因为CPU需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行。JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令。</li>
</ul>
<p><strong>PC寄存器为什么会被设定为线程私有的？</strong></p>
<ul>
<li>多线程在一个特定的时间段内只会执行其中某一个线程方法，CPU会不停的做任务切换，这样必然会导致经常中断或恢复。为了能够准确的记录各个线程正在执行的当前字节码指令地址，所以为每个线程都分配了一个PC寄存器，每个线程都独立计算，不会互相影响。</li>
</ul>
<p>总结：</p>
<ul>
<li>
<p>它是一块很小的内存空间，几乎可以忽略不计。也是运行速度最快的存储区域</p>
</li>
<li>
<p>在 JVM 规范中，每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期一致</p>
</li>
<li>
<p>任何时间一个线程都只有一个方法在执行，也就是所谓的<strong>当前方法</strong>。如果当前线程正在执行的是 Java 方法，程序计数器记录的是 JVM 字节码指令地址，如果是执行 native 方法，则是未指定值（undefined）</p>
</li>
<li>
<p>它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成</p>
</li>
<li>
<p>字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令</p>
</li>
<li>
<p><strong>它是唯一一个在 JVM 规范中没有规定任何 <code>OutOfMemoryError</code> 情况的区域</strong></p>
</li>
</ul>
<h2 id=虚拟机栈>虚拟机栈</h2>
<h3 id=概述-1>概述</h3>
<p>Java 虚拟机栈(Java Virtual Machine Stacks)，早期也叫 Java 栈。每个线程在创建的时候都会创建一个虚拟机栈，其内部保存一个个的栈帧(Stack Frame），对应着一次次 Java 方法调用，是线程私有的，生命周期和线程一致。</p>
<h3 id=作用-1>作用</h3>
<p>主管 Java 程序的运行，它保存方法的局部变量、部分结果，并参与方法的调用和返回。</p>
<h3 id=特点>特点</h3>
<ul>
<li>栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器</li>
<li>JVM 直接对虚拟机栈的操作只有两个：每个方法执行，伴随着<strong>入栈</strong>（进栈/压栈），方法执行结束<strong>出栈</strong></li>
<li><strong>栈不存在垃圾回收问题</strong></li>
</ul>
<h3 id=相关异常>相关异常</h3>
<p>Java 虚拟机规范允许 <strong>Java虚拟机栈的大小是动态的或者是固定不变的</strong>。</p>
<ul>
<li>如果采用固定大小的 Java 虚拟机栈，那每个线程的 Java 虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过 Java 虚拟机栈允许的最大容量，Java 虚拟机将会抛出一个 <strong>StackOverflowError</strong> 异常</li>
<li>如果 Java 虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那 Java 虚拟机将会抛出一个<strong>OutOfMemoryError</strong>异常</li>
</ul>
<p>可以通过参数<code>-Xss</code>来设置线程的最大栈空间，栈的大小直接决定了函数调用的最大可达深度。</p>
<h3 id=存储单位>存储单位</h3>
<ul>
<li>每个线程都有自己的栈，栈中的数据都是以<strong>栈帧（Stack Frame）的格式存在</strong></li>
<li>在这个线程上正在执行的每个方法都各自有对应的一个栈帧</li>
<li>栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息</li>
</ul>
<h3 id=运行原理>运行原理</h3>
<ul>
<li>JVM 直接对 Java 栈的操作只有两个，对栈帧的<strong>压栈</strong>和<strong>出栈</strong>，遵循“先进后出/后进先出”原则</li>
<li>在一条活动线程中，一个时间点上，只会有一个活动的栈帧。即只有当前正在执行的方法的栈帧（<strong>栈顶栈帧</strong>）是有效的，这个栈帧被称为<strong>当前栈帧</strong>（Current Frame），与当前栈帧对应的方法就是<strong>当前方法</strong>（Current Method），定义这个方法的类就是<strong>当前类</strong>（Current Class）</li>
<li>执行引擎运行的所有字节码指令只针对当前栈帧进行操作</li>
<li>如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，放在栈的顶端，称为新的当前栈帧</li>
<li>不同线程中所包含的栈帧是不允许存在相互引用的，即不可能在一个栈帧中引用另外一个线程的栈帧</li>
<li>如果当前方法调用了其他方法，方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，接着，虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧</li>
<li>Java 方法有两种返回函数的方式，<strong>一种是正常的函数返回，使用 return 指令，另一种是抛出异常，不管用哪种方式，都会导致栈帧被弹出</strong></li>
</ul>
<p>IDEA 在 debug 时候，可以在 debug 窗口看到 Frames 中各种方法的压栈和出栈情况：</p>
<div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/0082zybply1gc9lezaxrbj319v0u0k4w-20210430163803130.jpg style=display:block;width:50% alt=NAME align=center> </div>
<h3 id=内部结构>内部结构</h3>
<p>每个<strong>栈帧</strong>（Stack Frame）中存储着：</p>
<ul>
<li>
<p>局部变量表（Local Variables）</p>
</li>
<li>
<p>操作数栈（Operand Stack）(或称为表达式栈)</p>
</li>
<li>
<p>动态链接（Dynamic Linking）：指向运行时常量池的方法引用</p>
</li>
<li>
<p>方法返回地址（Return Address）：方法正常退出或异常退出的地址</p>
</li>
<li>
<p>一些附加信息</p>
</li>
</ul>
<div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210430163913.png style=display:block;width:50% alt=NAME align=center> </div>
<h4 id=局部变量表>局部变量表</h4>
<ul>
<li>
<p>局部变量表也被称为局部变量数组或者本地变量表</p>
</li>
<li>
<p>是一组变量值存储空间，<strong>主要用于存储方法参数和定义在方法体内的局部变量</strong>，包括编译器可知的各种 Java 虚拟机<strong>基本数据类型</strong>（boolean、byte、char、short、int、float、long、double）、<strong>对象引用</strong>（reference类型，它并不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此相关的位置）和 <strong>returnAddress</strong> 类型（指向了一条字节码指令的地址，已被异常表取代）</p>
</li>
<li>
<p>由于局部变量表是建立在线程的栈上，是线程的私有数据，因此<strong>不存在数据安全问题</strong></p>
</li>
<li>
<p><strong>局部变量表所需要的容量大小是编译期确定下来的</strong>，并保存在方法的 Code 属性的 <code>maximum local variables</code> 数据项中。在方法运行期间是不会改变局部变量表的大小的</p>
</li>
<li>
<p>方法嵌套调用的次数由栈的大小决定。一般来说，<strong>栈越大，方法嵌套调用次数越多</strong>。对一个函数而言，它的参数和局部变量越多，使得局部变量表膨胀，它的栈帧就越大，以满足方法调用所需传递的信息增大的需求。进而函数调用就会占用更多的栈空间，导致其嵌套调用次数就会减少。</p>
</li>
<li>
<p><strong>局部变量表中的变量只在当前方法调用中有效</strong>。在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁。</p>
</li>
<li>
<p>参数值的存放总是在局部变量数组的 index0 开始，到数组长度 -1 的索引结束</p>
</li>
</ul>
<p>槽 Slot：</p>
<ul>
<li>
<p>局部变量表最基本的存储单元是 Slot（变量槽）</p>
</li>
<li>
<p>在局部变量表中，32 位以内的类型只占用一个 Slot(包括returnAddress类型)，64 位的类型（long和double）占用两个连续的 Slot</p>
<ul>
<li>byte、short、char 在存储前被转换为int，boolean也被转换为int，0 表示 false，非 0 表示 true</li>
<li>long 和 double 则占据两个 Slot</li>
</ul>
</li>
<li>
<p>JVM 会为局部变量表中的每一个 Slot 都分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量值，索引值的范围从 0 开始到局部变量表最大的 Slot 数量</p>
</li>
<li>
<p>当一个实例方法被调用的时候，它的方法参数和方法体内部定义的局部变量将会<strong>按照顺序被复制</strong>到局部变量表中的每一个 Slot 上</p>
</li>
<li>
<p><strong>如果需要访问局部变量表中一个 64bit 的局部变量值时，只需要使用前一个索引即可</strong>。（比如：访问 long 或 double 类型变量，不允许采用任何方式单独访问其中的某一个 Slot）</p>
</li>
<li>
<p>如果当前帧是由构造方法或实例方法创建的，那么该对象引用 this 将会存放在 index 为 0 的 Slot 处，其余的参数按照参数表顺序继续排列（这里就引出一个问题：静态方法中为什么不可以引用 this，就是因为this 变量不存在于当前方法的局部变量表中）</p>
</li>
<li>
<p><strong>栈帧中的局部变量表中的槽位是可以重用的</strong>，如果一个局部变量过了其作用域，那么在其作用域之后申明的新的局部变量就很有可能会复用过期局部变量的槽位，从而<strong>达到节省资源的目的</strong>。（下图中，this、a、b、c 理论上应该有 4 个变量，c 复用了 b 的槽）</p>
</li>
</ul>
<div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210430164217.png style=display:block;width:50% alt=NAME align=center> </div>
<ul>
<li>在栈帧中，与性能调优关系最为密切的就是局部变量表。在方法执行时，虚拟机使用局部变量表完成方法的传递</li>
<li><strong>局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收</strong></li>
</ul>
<h4 id=操作数栈>操作数栈</h4>
<ul>
<li>
<p>每个独立的栈帧中除了包含局部变量表之外，还包含一个<strong>后进先出</strong>（Last-In-First-Out）的操作数栈，也可以称为<strong>表达式栈</strong>（Expression Stack）</p>
</li>
<li>
<p><strong>操作数栈，在方法执行过程中，根据字节码指令，往操作数栈中写入数据或提取数据，即入栈（push）、出栈（pop）</strong></p>
</li>
<li>
<p>某些字节码指令将值压入操作数栈，其余的字节码指令将操作数取出栈。使用它们后再把结果压入栈。比如，执行复制、交换、求和等操作</p>
</li>
</ul>
<p>相关解释：</p>
<ul>
<li>
<p>操作数栈，<strong>主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间</strong></p>
</li>
<li>
<p>操作数栈就是 JVM 执行引擎的一个工作区，当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建出来，<strong>此时这个方法的操作数栈是空的</strong></p>
</li>
<li>
<p>每一个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需的最大深度在编译期就定义好了，保存在方法的 Code 属性的 <code>max_stack</code> 数据项中</p>
</li>
<li>
<p>栈中的任何一个元素都可以是任意的 Java 数据类型</p>
<ul>
<li>32bit 的类型占用一个栈单位深度</li>
<li>64bit 的类型占用两个栈单位深度</li>
</ul>
</li>
<li>
<p>操作数栈并非采用访问索引的方式来进行数据访问的，而是只能通过标准的入栈和出栈操作来完成一次数据访问</p>
</li>
<li>
<p><strong>如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中</strong>，并更新 PC 寄存器中下一条需要执行的字节码指令</p>
</li>
<li>
<p>操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，这由编译器在编译期间进行验证，同时在类加载过程中的类检验阶段的数据流分析阶段要再次验证</p>
</li>
<li>
<p>另外，我们说<strong>Java虚拟机的解释引擎是基于栈的执行引擎</strong>，其中的栈指的就是操作数栈</p>
</li>
</ul>
<p><strong>栈顶缓存—基于寄存器</strong></p>
<p>HotSpot 的执行引擎采用的并非是基于寄存器的架构，但这并不代表 HotSpot VM 的实现并没有间接利用到寄存器资源。寄存器是物理 CPU 中的组成部分之一，它同时也是 CPU 中非常重要的高速存储资源。一般来说，寄存器的读/写速度非常迅速，甚至可以比内存的读/写速度快上几十倍不止，不过寄存器资源却非常有限，不同平台下的CPU 寄存器数量是不同和不规律的。寄存器主要用于缓存本地机器指令、数值和下一条需要被执行的指令地址等数据。</p>
<p>基于栈式架构的虚拟机所使用的零地址指令更加紧凑，但完成一项操作的时候必然需要使用更多的入栈和出栈指令，这同时也就意味着将需要更多的指令分派（instruction dispatch）次数和内存读/写次数。由于操作数是存储在内存中的，因此频繁的执行内存读/写操作必然会影响执行速度。为了解决这个问题，HotSpot JVM 设计者们提出了栈顶缓存技术，<strong>将栈顶元素全部缓存在物理 CPU 的寄存器中，以此降低对内存的读/写次数，提升执行引擎的执行效率</strong>。</p>
<h4 id=动态链接指向运行时常量池的方法引用>动态链接：指向运行时常量池的方法引用</h4>
<ul>
<li>
<p><strong>每一个栈帧内部都包含一个指向运行时常量池中该栈帧所属方法的引用</strong>。包含这个引用的目的就是为了支持当前方法的代码能够实现动态链接(Dynamic Linking)。</p>
</li>
<li>
<p>在 Java 源文件被编译到字节码文件中时，所有的变量和方法引用都作为<strong>符号引用</strong>（Symbolic Reference）保存在 Class 文件的常量池中。比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么<strong>动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用</strong></p>
</li>
</ul>
<div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210430164706.png style=display:block;width:50% alt=NAME align=center> </div>
<h5 id=jvm-是如何执行方法调用的>JVM 是如何执行方法调用的</h5>
<p>方法调用不同于方法执行，方法调用阶段的唯一任务就是确定被调用方法的版本（即调用哪一个方法），暂时还不涉及方法内部的具体运行过程。Class 文件的编译过程中不包括传统编译器中的连接步骤，一切方法调用在 Class文件里面存储的都是<strong>符号引用</strong>，而不是方法在实际运行时内存布局中的入口地址（<strong>直接引用</strong>）。也就是需要在类加载阶段，甚至到运行期才能确定目标方法的直接引用。</p>
<p>在 JVM 中，将符号引用转换为调用方法的直接引用与方法的绑定机制有关：</p>
<ul>
<li><strong>静态链接</strong>：当一个字节码文件被装载进 JVM 内部时，如果被调用的<strong>目标方法在编译期可知</strong>，且运行期保持不变时。这种情况下将调用方法的符号引用转换为直接引用的过程称之为静态链接</li>
<li><strong>动态链接</strong>：如果被调用的方法在编译期无法被确定下来，也就是说，只能在程序运行期将调用方法的符号引用转换为直接引用，由于这种引用转换过程具备动态性，因此也就被称之为动态链接</li>
</ul>
<p>对应的方法的绑定机制为：早期绑定（Early Binding）和晚期绑定（Late Binding）。<strong>绑定是一个字段、方法或者类在符号引用被替换为直接引用的过程，这仅仅发生一次</strong>。</p>
<ul>
<li>早期绑定：<strong>早期绑定就是指被调用的目标方法如果在编译期可知，且运行期保持不变时</strong>，即可将这个方法与所属的类型进行绑定，这样一来，由于明确了被调用的目标方法究竟是哪一个，因此也就可以使用静态链接的方式将符号引用转换为直接引用。</li>
<li>晚期绑定：如果被调用的方法在编译器无法被确定下来，只能够在程序运行期根据实际的类型绑定相关的方法，这种绑定方式就被称为晚期绑定。</li>
</ul>
<h5 id=虚方法与非虚方法>虚方法与非虚方法：</h5>
<ul>
<li>如果方法在编译器就确定了具体的调用版本，这个版本在运行时是不可变的。这样的方法称为非虚方法，比如静态方法、私有方法、final 方法、实例构造器、父类方法都是非虚方法</li>
<li>其他方法称为虚方法</li>
</ul>
<h5 id=虚方法表>虚方法表</h5>
<p>在面向对象编程中，会频繁的使用到动态分派，如果每次动态分派都要重新在类的方法元数据中搜索合适的目标有可能会影响到执行效率。为了提高性能，JVM 采用在类的方法区建立一个虚方法表（virtual method table），使用索引表来代替查找。非虚方法不会出现在表中。</p>
<p>每个类中都有一个虚方法表，表中存放着各个方法的实际入口。</p>
<p>虚方法表会在类加载的连接阶段被创建并开始初始化，类的变量初始值准备完成之后，JVM 会把该类的方法表也初始化完毕。</p>
<h4 id=方法返回地址>方法返回地址</h4>
<p>用来存放调用该方法的 PC 寄存器的值。一个方法的结束，有两种方式：</p>
<ul>
<li>正常执行完成</li>
<li>出现未处理的异常，非正常退出</li>
</ul>
<p>无论通过哪种方式退出，在方法退出后都返回到该方法被调用的位置。方法正常退出时，调用者的 PC 计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址。而通过异常退出的，返回地址是要通过异常表来确定的，栈帧中一般不会保存这部分信息。</p>
<p>当一个方法开始执行后，只有两种方式可以退出这个方法：</p>
<ol>
<li>
<p>执行引擎遇到任意一个方法返回的字节码指令，会有返回值传递给上层的方法调用者，简称<strong>正常完成出口</strong></p>
<ul>
<li>
<p>一个方法的正常调用完成之后究竟需要使用哪一个返回指令还需要根据方法返回值的实际数据类型而定</p>
</li>
<li>
<p>在字节码指令中，返回指令包含 ireturn(当返回值是 boolean、byte、char、short 和 int 类型时使用)、lreturn、freturn、dreturn 以及 areturn，另外还有一个 return 指令供声明为 void 的方法、实例初始化方法、类和接口的初始化方法使用。</p>
</li>
</ul>
</li>
<li>
<p>在方法执行的过程中遇到了异常，并且这个异常没有在方法内进行处理，也就是只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出。简称<strong>异常完成出口</strong></p>
<ul>
<li>方法执行过程中抛出异常时的异常处理，存储在一个异常处理表，方便在发生异常的时候找到处理异常的代码。</li>
</ul>
</li>
</ol>
<p>本质上，<strong>方法的退出就是当前栈帧出栈的过程</strong>。此时，需要恢复上层方法的局部变量表、操作数栈、将返回值压入调用者栈帧的操作数栈、设置PC寄存器值等，让调用者方法继续执行下去。</p>
<p>正常完成出口和异常完成出口的区别在于：<strong>通过异常完成出口退出的不会给他的上层调用者产生任何的返回值</strong>。</p>
<h4 id=附加信息>附加信息</h4>
<p>栈帧中还允许携带与 Java 虚拟机实现相关的一些附加信息。例如，对程序调试提供支持的信息，但这些信息取决于具体的虚拟机实现。</p>
<h2 id=本地方法栈>本地方法栈</h2>
<h3 id=本地方法接口>本地方法接口</h3>
<p>简单的讲，一个 Native Method 就是一个 Java 调用非 Java 代码的接口。我们知道的 Unsafe 类就有很多本地方法。</p>
<blockquote>
<p>为什么需要本地方法(Native Method)？</p>
</blockquote>
<p>Java 使用起来非常方便，然而有些层次的任务用 Java 实现起来也不容易，或者我们对程序的效率很在意时，问题就来了</p>
<ul>
<li>与 Java 环境外交互：有时 Java 应用需要与 Java 外面的环境交互，这就是本地方法存在的原因。</li>
<li>与操作系统交互：JVM 支持 Java 语言本身和运行时库，但是有时仍需要依赖一些底层系统的支持。通过本地方法，我们可以实现用 Java 与实现了 jre 的底层系统交互， JVM 的一些部分就是 C 语言写的。</li>
<li>Sun&rsquo;s Java：Sun的解释器就是C实现的，这使得它能像一些普通的C一样与外部交互。jre大部分都是用 Java 实现的，它也通过一些本地方法与外界交互。比如，类 <code>java.lang.Thread</code> 的 <code>setPriority()</code> 的方法是用Java 实现的，但它实现调用的是该类的本地方法 <code>setPrioruty()</code>，该方法是C实现的，并被植入 JVM 内部。</li>
</ul>
<h3 id=本地方法栈native-method-stack>本地方法栈(Native Method Stack)</h3>
<ul>
<li>
<p>Java 虚拟机栈用于管理 Java 方法的调用，而本地方法栈用于管理本地方法的调用</p>
</li>
<li>
<p>本地方法栈也是线程私有的</p>
</li>
<li>
<p>允许线程固定或者可动态扩展的内存大小</p>
<ul>
<li>如果线程请求分配的栈容量超过本地方法栈允许的最大容量，Java 虚拟机将会抛出一个 StackOverflowError 异常</li>
<li>如果本地方法栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的本地方法栈，那么 Java虚拟机将会抛出一个<code>OutofMemoryError</code>异常</li>
</ul>
</li>
<li>
<p>本地方法是使用 C 语言实现的</p>
</li>
<li>
<p>它的具体做法是 <code>Mative Method Stack</code> 中登记 native 方法，在 <code>Execution Engine</code> 执行时加载本地方法库当某个线程调用一个本地方法时，它就进入了一个全新的并且不再受虚拟机限制的世界。它和虚拟机拥有同样的权限。</p>
</li>
<li>
<p>本地方法可以通过本地方法接口来访问虚拟机内部的运行时数据区，它甚至可以直接使用本地处理器中的寄存器，直接从本地内存的堆中分配任意数量的内存</p>
</li>
<li>
<p>并不是所有 JVM 都支持本地方法。因为 Java 虚拟机规范并没有明确要求本地方法栈的使用语言、具体实现方式、数据结构等。如果 JVM 产品不打算支持 native 方法，也可以无需实现本地方法栈</p>
</li>
<li>
<p>在 Hotspot JVM 中，直接将本地方栈和虚拟机栈合二为一</p>
</li>
</ul>
<hr>
<blockquote>
<ul>
<li>栈是运行时的单位，堆是存储的单位。</li>
<li>栈解决程序运行的问题，即程序如何执行，或者说如何处理数据。</li>
<li>堆解决的是数据存储的问题，即数据怎么放，放在那。</li>
</ul>
</blockquote>
<hr>
<h2 id=堆内存>堆内存</h2>
<h3 id=内存划分>内存划分</h3>
<ul>
<li>
<p>对于大多数应用，Java 堆是 Java 虚拟机管理的内存中最大的一块，被所有线程共享。</p>
</li>
<li>
<p>此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数据都在这里分配内存。</p>
</li>
</ul>
<p>为了进行高效的垃圾回收，虚拟机把堆内存在逻辑上分为 3 个区域(分代的唯一原因就是优化 GC 性能)：</p>
<ul>
<li><strong>新生代(年轻代)</strong>：新对象和没达到一定年龄的对象都都在新生代。</li>
<li><strong>老年代(老年区)</strong>：被长时间使用的对象，老年代的内存空间应该要比新生代更大。</li>
<li><strong>元空间(永久代)</strong>：如一些方法中操作的临时对象，1.8 之前使用 JVM 内存，1.8 之后直接使用物理内存。</li>
</ul>
<div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210430214019.png style=display:block;width:50% alt=NAME align=center> </div>
<p>Java 虚拟机规范规定，Java 堆可以是处于物理上不连续的内存空间中，只要逻辑上是连续的即可，像磁盘空间一样。实现时，既可以是固定大小，也可以是可扩展的，主流虚拟机都是可扩展的（通过 <code>-Xmx</code> 和 <code>-Xms</code> 控制），如果堆中没有完成实例分配，并且堆无法再扩展时，就会抛出 <code>OutOfMemoryError</code> 异常。</p>
<h4 id=新生代young-generation>新生代：Young Generation</h4>
<ul>
<li>新生代是存储所有新建对象的区域。</li>
<li>当填充(满)新生代时，执行垃圾收集。</li>
<li>这种垃圾收集称为 Minor GC。</li>
<li>新生代又被分为三个部分：
<ul>
<li>一个伊甸园(Eden Memory)和两个幸存区(Survivor Memory, from/to, s0/s1)</li>
<li>三个部分的比例是 8：1：1</li>
</ul>
</li>
<li>大多数新建的对象都位于伊甸园空间内。</li>
<li>当伊甸园空间被对象填充(满)时，执行 Minor GC，并将所有幸存者对象移动到一个幸存区</li>
<li>Minor 检查幸存者对象，并将它们移动到另一个幸存区，因此每次 Minor GC 之后会有一个空幸存区</li>
<li>经过多次 Minor GC 循环后仍然存活下来的对象被移动到老年代。
<ul>
<li>这是通过设置年轻代的年龄阈值来实现的，到达一定年龄后才有资格进入老年代。</li>
</ul>
</li>
</ul>
<h4 id=老年代old-generation>老年代：Old Generation</h4>
<ul>
<li>旧的一代内存包含那些经过许多轮小型 GC 后仍然存活的对象。</li>
<li>通常，垃圾收集是在老年代内存满时触发执行。</li>
<li>老年代垃圾收集称为主 GC——Major GC，通常需要更长时间。</li>
<li>大型对象会直接被放入老年代，大型对象是指需要大量连续内存空间的的对象，以避免在新生代的伊甸园和幸存区之间出现大量的内存拷贝。</li>
</ul>
<div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210430215029.png style=display:block;width:50% alt=NAME align=center> </div>
<h4 id=元空间永久代>元空间/永久代</h4>
<ul>
<li>即 Java 虚拟机规范中方法区的实现。</li>
<li>虽然 Java 虚拟机规范将方法区描述为堆的一个逻辑部分，但是它却有一个别名——Non-Heap(非堆)，目的是与 Java 堆区分开。</li>
</ul>
<h3 id=设置内存大小与-oom>设置内存大小与 OOM</h3>
<p>Java 堆用于存储 Java 对象实例，那么堆的大小在 JVM 启动的时候就确定了：</p>
<ul>
<li><code>-Xmx</code> 用来表示堆的起始内存，等价于 <code>-XX:InitialHeapSize</code></li>
<li><code>-Xms</code> 用来表示堆的最大内存，等价于 <code>-XX:MaxHeapSize</code></li>
</ul>
<p>如果堆的内存大小超过 <code>-Xms</code> 设定的最大内存， 就会抛出 <code>OutOfMemoryError</code> 异常。</p>
<p>我们通常会将 <code>-Xmx</code> 和 <code>-Xms</code> 两个参数配置为相同的值，其目的是为了能够在垃圾回收机制清理完堆区后不再需要重新分隔计算堆的大小，从而提高性能。</p>
<ul>
<li>默认情况下，初始堆内存大小为：电脑内存大小/64</li>
<li>默认情况下，最大堆内存大小为：电脑内存大小/4</li>
</ul>
<p>我们可以通过代码获取启动时设置的值，当然也可以模拟 OOM：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#8f5902;font-style:italic>//返回 JVM 堆大小
</span><span style=color:#8f5902;font-style:italic></span><span style=color:#204a87;font-weight:700>long</span> <span style=color:#000>initalMemory</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>Runtime</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>getRuntime</span><span style=color:#ce5c00;font-weight:700>().</span><span style=color:#c4a000>totalMemory</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>/</span> <span style=color:#000>1024</span> <span style=color:#ce5c00;font-weight:700>/</span><span style=color:#000>1024</span><span style=color:#ce5c00;font-weight:700>;</span>
<span style=color:#8f5902;font-style:italic>//返回 JVM 堆的最大内存
</span><span style=color:#8f5902;font-style:italic></span><span style=color:#204a87;font-weight:700>long</span> <span style=color:#000>maxMemory</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>Runtime</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>getRuntime</span><span style=color:#ce5c00;font-weight:700>().</span><span style=color:#c4a000>maxMemory</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>/</span> <span style=color:#000>1024</span> <span style=color:#ce5c00;font-weight:700>/</span><span style=color:#000>1024</span><span style=color:#ce5c00;font-weight:700>;</span>

<span style=color:#000>System</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>out</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>println</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#4e9a06>&#34;-Xms : &#34;</span><span style=color:#ce5c00;font-weight:700>+</span><span style=color:#000>initalMemory</span> <span style=color:#ce5c00;font-weight:700>+</span> <span style=color:#4e9a06>&#34;M&#34;</span><span style=color:#ce5c00;font-weight:700>);</span>
<span style=color:#000>System</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>out</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>println</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#4e9a06>&#34;-Xmx : &#34;</span><span style=color:#ce5c00;font-weight:700>+</span><span style=color:#000>maxMemory</span> <span style=color:#ce5c00;font-weight:700>+</span> <span style=color:#4e9a06>&#34;M&#34;</span><span style=color:#ce5c00;font-weight:700>);</span>

<span style=color:#000>System</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>out</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>println</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#4e9a06>&#34;系统内存大小：&#34;</span> <span style=color:#ce5c00;font-weight:700>+</span> <span style=color:#000>initalMemory</span> <span style=color:#ce5c00;font-weight:700>*</span> <span style=color:#000>64</span> <span style=color:#ce5c00;font-weight:700>/</span> <span style=color:#000>1024</span> <span style=color:#ce5c00;font-weight:700>+</span> <span style=color:#4e9a06>&#34;G&#34;</span><span style=color:#ce5c00;font-weight:700>);</span>
<span style=color:#000>System</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>out</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>println</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#4e9a06>&#34;系统内存大小：&#34;</span> <span style=color:#ce5c00;font-weight:700>+</span> <span style=color:#000>maxMemory</span> <span style=color:#ce5c00;font-weight:700>*</span> <span style=color:#000>4</span> <span style=color:#ce5c00;font-weight:700>/</span> <span style=color:#000>1024</span> <span style=color:#ce5c00;font-weight:700>+</span> <span style=color:#4e9a06>&#34;G&#34;</span><span style=color:#ce5c00;font-weight:700>);</span>
</code></pre></div><h4 id=查看-jvm-堆内存分配>查看 JVM 堆内存分配</h4>
<ul>
<li>在默认不配置 JVM 堆内存大小的情况下，JVM 根据默认值来配置当前内存大小</li>
<li>默认情况下新生代和老年代的比例是 1:2，可以通过 <code>–XX:NewRatio</code> 来配置</li>
<li>新生代中的 <strong>Eden</strong>:<strong>From Survivor</strong>:<strong>To Survivor</strong> 的比例是 <strong>8:1:1</strong>，可以通过 <code>-XX:SurvivorRatio</code> 来配置</li>
<li>若在 JDK 7 中开启了 <code>-XX:+UseAdaptiveSizePolicy</code>，JVM 会动态调整 JVM 堆中各个区域的大小以及进入老年代的年龄
<ul>
<li>此时 <code>–XX:NewRatio</code> 和 <code>-XX:SurvivorRatio</code> 将会失效，而 JDK 8 是默认开启<code>-XX:+UseAdaptiveSizePolicy</code></li>
<li>在 JDK 8中，<strong>不要随意关闭</strong><code>-XX:+UseAdaptiveSizePolicy</code>，除非对堆内存的划分有明确的规划</li>
</ul>
</li>
<li>每次 GC 后都会重新计算 Eden、From Survivor、To Survivor 的大小
<ul>
<li>计算依据是<strong>GC过程</strong>中统计的<strong>GC时间</strong>、<strong>吞吐量</strong>、<strong>内存占用量</strong></li>
</ul>
</li>
</ul>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback>java -XX:+PrintFlagsFinal -version | grep HeapSize
    uintx ErgoHeapSizeLimit                         = 0                                   {product}
    uintx HeapSizePerGCThread                       = 87241520                            {product}
    uintx InitialHeapSize                          := 134217728                           {product}
    uintx LargePageHeapSizeThreshold                = 134217728                           {product}
    uintx MaxHeapSize                              := 2147483648                          {product}
java version &#34;1.8.0_211&#34;
Java(TM) SE Runtime Environment (build 1.8.0_211-b12)
Java HotSpot(TM) 64-Bit Server VM (build 25.211-b12, mixed mode)

jmap -heap 进程号
</code></pre></div><h3 id=对象在堆中的生命周期>对象在堆中的生命周期</h3>
<ol>
<li>
<p>在 JVM 内存模型的堆中，堆被划分为新生代和老年代</p>
<ol>
<li>新生代又被进一步划分为 <strong>Eden区</strong> 和 <strong>Survivor区</strong></li>
<li>Survivor 区由 <strong>From Survivor</strong> 和 <strong>To Survivor</strong> 组成</li>
</ol>
</li>
<li>
<p>当创建一个对象时，对象会被优先分配到新生代的 Eden 区</p>
<ol>
<li>此时 JVM 会给对象定义一个<strong>对象年轻计数器</strong>（<code>-XX:MaxTenuringThreshold</code>）</li>
</ol>
</li>
<li>
<p>当 Eden 空间不足时，JVM 将执行新生代的垃圾回收（Minor GC）</p>
<ol>
<li>JVM 会把存活的对象转移到 Survivor 中，并且对象年龄 +1</li>
<li>对象在 Survivor 中同样也会经历 Minor GC，每经历一次 Minor GC，对象年龄都会+1</li>
</ol>
</li>
<li>
<p>如果分配的对象超过了<code>-XX:PetenureSizeThreshold</code>，对象会<strong>直接被分配到老年代</strong></p>
</li>
</ol>
<h3 id=对象的分配过程>对象的分配过程</h3>
<p>为对象分配内存是一件非常严谨和复杂的任务，JVM 的设计者们不仅需要考虑内存如何分配、在哪里分配等问题，并且由于内存分配算法和内存回收算法密切相关，所以还需要考虑 GC 执行完内存回收后是否会在内存空间中产生内存碎片。</p>
<ol>
<li>new 的对象先放在伊甸园区，此区有大小限制</li>
<li>当伊甸园的空间填满时，程序又需要创建对象，JVM 的垃圾回收器将对伊甸园区进行垃圾回收（Minor GC），将伊甸园区中的不再被其他对象所引用的对象进行销毁。再加载新的对象放到伊甸园区</li>
<li>然后将伊甸园中的剩余对象移动到幸存者 from 区</li>
<li>如果再次触发垃圾回收，此时上次幸存下来的放到幸存者 to 区，如果没有回收，就会放到幸存者 to 区</li>
<li>如果再次经历垃圾回收，此时会重新放回幸存者 from 区，接着再去幸存者 to 区</li>
<li>什么时候才会去老年代呢？ 默认是 15 次回收标记</li>
<li>在养老区，相对悠闲。当养老区内存不足时，再次触发 Major GC，进行养老区的内存清理</li>
<li>若养老区执行了 Major GC 之后发现依然无法进行对象的保存，就会产生 OOM 异常</li>
</ol>
<h3 id=gc-垃圾回收简介>GC 垃圾回收简介</h3>
<h4 id=minormajorfull>Minor、Major、Full</h4>
<p>JVM 在进行 GC 时，并非每次都对堆内存（新生代、老年代、方法区）区域一起回收的，大部分时候回收的都是指新生代。</p>
<p>针对 HotSpot VM 的实现，它里面的 GC 按照回收区域又分为两大类：部分收集（Partial GC），整堆收集（Full GC）。</p>
<ul>
<li>
<p>部分收集：不是完整收集整个 Java 堆的垃圾收集。其中又分为：</p>
<ul>
<li>新生代收集（Minor GC/Young GC）：只是新生代的垃圾收集</li>
<li>老年代收集（Major GC/Old GC）：只是老年代的垃圾收集
<ul>
<li>目前，只有 CMS GC 会有单独收集老年代的行为</li>
<li>很多时候 Major GC 会和 Full GC 混合使用，需要具体分辨是老年代回收还是整堆回收</li>
</ul>
</li>
<li>混合收集（Mixed GC）：收集整个新生代以及部分老年代的垃圾收集
<ul>
<li>目前只有 G1 GC 会有这种行为</li>
</ul>
</li>
</ul>
</li>
<li>
<p>整堆收集（Full GC）：收集整个 Java 堆和方法区的垃圾</p>
</li>
</ul>
<h3 id=tlabthread-local-allocation-buffer>TLAB：Thread Local Allocation Buffer</h3>
<h4 id=什么是-tlab>什么是 TLAB</h4>
<ul>
<li>
<p>从内存模型而不是垃圾回收的角度，对伊甸园继续进行划分，JVM 为每个线程分配了一个私有缓存区域，它包含在伊甸园内</p>
</li>
<li>
<p>多线程同时分配内存时，使用 TLAB 可以避免一系列的非线程安全问题，同时还能提升内存分配的吞吐量，因此我们可以将这种内存分配方式称为<strong>快速分配策略</strong></p>
</li>
<li>
<p>OpenJDK 衍生出来的 JVM 大都提供了 TLAB 设计</p>
</li>
</ul>
<h4 id=为什么使用-tlab>为什么使用 TLAB</h4>
<ul>
<li>
<p>堆区是线程共享的，任何线程都可以访问到堆区中的共享数据</p>
</li>
<li>
<p>由于对象实例的创建在 JVM 中非常频繁，因此在并发环境下从堆区中划分内存空间是线程不安全的</p>
</li>
<li>
<p>为避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度</p>
</li>
</ul>
<p>尽管不是所有的对象实例都能够在 TLAB 中成功分配内存，但 JVM 确实是将 TLAB 作为内存分配的首选。</p>
<ul>
<li>
<p>在程序中，可以通过 <code>-XX:UseTLAB</code> 设置是否开启 TLAB 空间。</p>
</li>
<li>
<p>默认情况下，TLAB 空间的内存非常小，仅占有整个伊甸园的 1%，我们可以通过 <code>-XX:TLABWasteTargetPercent</code> 设置 TLAB 空间所占用伊甸园的百分比大小。</p>
</li>
</ul>
<p>一旦对象在 TLAB 空间分配内存失败时，JVM 就会尝试着通过使用加锁机制确保数据操作的原子性，从而直接在伊甸园中分配内存。</p>
<h3 id=值能在堆中存储对象吗>值能在堆中存储对象吗</h3>
<blockquote>
<p>随着 JIT 编译期的发展和逃逸分析技术的逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。</p>
</blockquote>
<h4 id=逃逸分析>逃逸分析</h4>
<p><strong>逃逸分析(Escape Analysis)*<em>是目前 Java 虚拟机中比较前沿的优化技术*</em>。这是一种可以有效减少 Java 程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法</strong>。通过逃逸分析，Java Hotspot 编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上。</p>
<p>逃逸分析的基本行为就是分析<strong>对象动态作用域</strong>：</p>
<ul>
<li>当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸。</li>
<li>当一个对象在方法中被定义后，它被外部方法所引用，则认为发生逃逸。
<ul>
<li>例如作为调用参数传递到其他地方中，称为方法逃逸。</li>
</ul>
</li>
</ul>
<h5 id=参数设置>参数设置</h5>
<ul>
<li>在 JDK 6u23 版本之后，HotSpot 中默认就已经开启了逃逸分析</li>
<li>如果使用较早版本，可以通过<code>-XX"+DoEscapeAnalysis</code>显式开启</li>
</ul>
<p>开发中使用局部变量，就不要在方法外定义。</p>
<p>使用逃逸分析，编译器可以对代码做优化：</p>
<ul>
<li><strong>栈上分配</strong>：将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会逃逸，对象可能是栈分配的候选，而不是堆分配</li>
<li><strong>同步省略</strong>：如果一个对象被发现只能从一个线程被访问到，那么对于这个对象的操作可以不考虑同步</li>
<li><strong>分离对象或标量替换</strong>：有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而存储在 CPU 寄存器</li>
</ul>
<p>JIT 编译器在编译期间根据逃逸分析的结果，发现如果一个对象并没有逃逸出方法的话，就可能被优化成栈上分配。分配完成后，继续在调用栈内执行，最后线程结束，栈空间被回收，局部变量对象也被回收。这样就无需进行垃圾回收了。</p>
<p>常见栈上分配的场景：成员变量赋值、方法返回值、实例引用传递</p>
<h5 id=代码优化同步省略锁消除>代码优化：同步省略/锁消除</h5>
<ul>
<li>
<p>线程同步的代价是相当高的，同步的后果是降低并发性和性能</p>
</li>
<li>
<p>在动态编译同步块的时候，JIT 编译器可以借助逃逸分析来判断同步块所使用的锁对象是否能够被一个线程访问而没有被发布到其他线程。如果没有，那么 JIT 编译器在编译这个同步块的时候就会取消对这个代码的同步。这样就能大大提高并发性和性能。</p>
</li>
<li>
<p>这个取消同步的过程就叫做<strong>同步省略，也叫锁消除</strong>。</p>
</li>
</ul>
<h5 id=代码优化标量替换>代码优化：标量替换</h5>
<ul>
<li>
<p><strong>标量</strong>（Scalar）是指一个无法再分解成更小的数据的数据。Java 中的原始数据类型就是标量。</p>
</li>
<li>
<p>相对的，那些的还可以分解的数据叫做<strong>聚合量</strong>（Aggregate），Java 中的对象就是聚合量，因为其还可以分解成其他聚合量和标量。</p>
</li>
</ul>
<p>在 JIT 阶段，通过逃逸分析确定该对象不会被外部访问，并且对象可以被进一步分解时，JVM 不会创建该对象，而会将该对象成员变量分解若干个被这个方法使用的成员变量所代替。这些代替的成员变量在栈帧或寄存器上分配空间。这个过程就是<strong>标量替换</strong>。</p>
<p>通过 <code>-XX:+EliminateAllocations</code> 可以开启标量替换，<code>-XX:+PrintEliminateAllocations</code> 查看标量替换情况。</p>
<h5 id=代码优化栈上分配>代码优化：栈上分配</h5>
<p>我们通过 JVM 内存分配可以知道 JAVA 中的对象都是在堆上进行分配，当对象没有被引用的时候，需要依靠 GC 进行回收内存，如果对象数量较多的时候，会给 GC 带来较大压力，也间接影响了应用的性能。为了减少临时对象在堆内分配的数量，JVM 通过逃逸分析确定该对象不会被外部访问。那就通过标量替换将该对象分解在栈上分配内存，这样该对象所占用的内存空间就可以随栈帧出栈而销毁，就减轻了垃圾回收的压力。</p>
<h5 id=总结>总结</h5>
<p>关于逃逸分析的论文在1999年就已经发表了，但直到JDK 1.6才有实现，而且这项技术到如今也并不是十分成熟的。</p>
<p><strong>其根本原因就是无法保证逃逸分析的性能消耗一定能高于他的消耗。虽然经过逃逸分析可以做标量替换、栈上分配、和锁消除。但是逃逸分析自身也是需要进行一系列复杂的分析的，这其实也是一个相对耗时的过程。</strong></p>
<p>一个极端的例子，就是经过逃逸分析之后，发现没有一个对象是不逃逸的。那这个逃逸分析的过程就白白浪费掉了。</p>
<p>虽然这项技术并不十分成熟，但是他也是即时编译器优化技术中一个十分重要的手段。</p>
<h2 id=方法区元空间永久代>方法区—元空间—永久代</h2>
<ul>
<li>方法区（Method Area）与 Java 堆一样，是所有线程共享的内存区域。</li>
<li>虽然 Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫 Non-Heap（非堆），目的应该是与 Java 堆区分开。</li>
<li>运行时常量池（Runtime Constant Pool）是方法区的一部分。
<ul>
<li>Class 文件中除了有类的版本/字段/方法/接口等描述信息外，还有一项信息是常量池（Constant Pool Table），用于存放编译期生成的各种字面量和符号引用，这部分内容将类在加载后进入方法区的运行时常量池中存放。</li>
<li>运行期间也可能将新的常量放入池中，这种特性被开发人员利用得比较多的是 <code>String.intern()</code>方法。受方法区内存的限制，当常量池无法再申请到内存时会抛出 <code>OutOfMemoryErro</code>r 异常。</li>
</ul>
</li>
<li>方法区大小的设定方式与堆空间一样，可以选择固定大小也可选择可扩展，方法区的大小决定了系统可以放多少个类，如果系统类太多，导致方法区溢出，虚拟机同样会抛出内存溢出错误</li>
<li>JVM 关闭后方法区即被释放</li>
</ul>
<h3 id=元空间永久代方法区>元空间、永久代、方法区？</h3>
<ul>
<li><strong>方法区（method area）*<em>只是 **JVM 规范**中定义的一个*<em>概念</em></em>，用于存储类信息、常量池、静态变量、JIT编译后的代码等数据，并没有规定如何去实现它，不同的厂商有不同的实现。而</strong>永久代（PermGen）**是 **Hotspot** 虚拟机特有的概念， Java8 的时候又被**元空间**取代了，永久代和元空间都可以理解为方法区的落地实现。</li>
<li>永久代物理是堆的一部分，和新生代，老年代地址是连续的（受垃圾回收器管理），而元空间存在于本地内存（我们常说的堆外内存，不受垃圾回收器管理），这样就不受 JVM 限制了，也比较难发生OOM（都会有溢出异常）</li>
<li>Java7 中我们通过<code>-XX:PermSize</code> 和 <code>-xx:MaxPermSize</code> 来设置永久代参数，Java8 之后，随着永久代的取消，这些参数也就随之失效了，改为通过<code>-XX:MetaspaceSize</code> 和 <code>-XX:MaxMetaspaceSize</code> 用来设置元空间参数</li>
<li>存储内容不同：元空间存储类的元信息，静态变量和常量池等并入堆中。相当于永久代的数据被分到了堆和元空间中</li>
<li>如果方法区域中的内存不能用于满足分配请求，则 Java 虚拟机抛出 <code>OutOfMemoryError</code></li>
<li>JVM 规范说方法区在逻辑上是堆的一部分，但目前实际上是与 Java 堆分开的（Non-Heap）</li>
</ul>
<p>所以对于方法区，Java8 之后的变化：</p>
<ul>
<li>移除了永久代（PermGen），替换为元空间（Metaspace）；</li>
<li>永久代中的 class metadata 转移到了 native memory（本地内存，而不是虚拟机）；</li>
<li>永久代中的 interned Strings 和 class static variables 转移到了 Java heap；</li>
<li>永久代参数 （PermSize MaxPermSize） -> 元空间参数（MetaspaceSize MaxMetaspaceSize）</li>
</ul>
<h3 id=设置空间大小>设置空间大小</h3>
<p>JDK8 及以后：</p>
<ul>
<li>元数据区大小可以使用参数 <code>-XX:MetaspaceSize</code> 和 <code>-XX:MaxMetaspaceSize</code> 指定，替代上述原有的两个参数</li>
<li>默认值依赖于平台。Windows 下，<code>-XX:MetaspaceSize</code> 是 21M，<code>-XX:MaxMetaspacaSize</code> 的值是 -1，即没有限制</li>
<li>与永久代不同，如果不指定大小，默认情况下，虚拟机会耗尽所有的可用系统内存。如果元数据发生溢出，虚拟机一样会抛出异常 <code>OutOfMemoryError:Metaspace</code></li>
<li><code>-XX:MetaspaceSize</code> ：设置初始的元空间大小。对于一个 64 位的服务器端 JVM 来说，其默认的 <code>-XX:MetaspaceSize</code> 的值为20.75MB，这就是初始的高水位线，一旦触及这个水位线，Full GC 将会被触发并卸载没用的类（即这些类对应的类加载器不再存活），然后这个高水位线将会重置，新的高水位线的值取决于 GC 后释放了多少元空间。如果释放的空间不足，那么在不超过 <code>MaxMetaspaceSize</code>时，适当提高该值。如果释放空间过多，则适当降低该值</li>
<li>如果初始化的高水位线设置过低，上述高水位线调整情况会发生很多次，通过垃圾回收的日志可观察到 Full GC 多次调用。为了避免频繁 GC，建议将 <code>-XX:MetaspaceSize</code> 设置为一个相对较高的值。</li>
</ul>
<h3 id=内部结构-1>内部结构</h3>
<p>方法区用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等。</p>
<h4 id=类型信息>类型信息</h4>
<p>对每个加载的类型（类 class、接口 interface、枚举 enum、注解 annotation），JVM 必须在方法区中存储以下类型信息</p>
<ul>
<li>这个类型的完整有效名称（全名=包名.类名）</li>
<li>这个类型直接父类的完整有效名（对于 interface或是 java.lang.Object，都没有父类）</li>
<li>这个类型的修饰符（public，abstract，final 的某个子集）</li>
<li>这个类型直接接口的一个有序列表</li>
</ul>
<h4 id=字段信息>字段信息</h4>
<ul>
<li>
<p>JVM 必须在方法区中保存类型的所有域的相关信息以及域的声明顺序</p>
</li>
<li>
<p>域的相关信息包括：域名称、域类型、域修饰符（public、private、protected、static、final、volatile、transient 的某个子集）</p>
</li>
</ul>
<h4 id=方法信息>方法信息</h4>
<p>JVM 必须保存所有方法的：</p>
<ul>
<li>方法名称</li>
<li>方法的返回类型</li>
<li>方法参数的数量和类型</li>
<li>方法的修饰符（public，private，protected，static，final，synchronized，native，abstract 的一个子集）</li>
<li>方法的字符码（bytecodes）、操作数栈、局部变量表及大小（abstract 和 native 方法除外）</li>
<li>异常表（abstract 和 native 方法除外）
<ul>
<li>每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引</li>
</ul>
</li>
</ul>
<h4 id=方法区与堆栈>方法区与堆、栈</h4>
<div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210430223448.png style=display:block;width:50% alt=NAME align=center> </div>
<h3 id=运行时常量池>运行时常量池</h3>
<p>运行时常量池（Runtime Constant Pool）是方法区的一部分，理解运行时常量池的话，我们先来说说字节码文件（Class 文件）中的常量池（常量池表）。</p>
<h4 id=字节码常量池>字节码常量池</h4>
<p>一个有效的字节码文件中除了包含类的版本信息、字段、方法以及接口等描述信息外，还包含一项信息那就是常量池表（Constant Pool Table），包含各种字面量和对类型、域和方法的符号引用。</p>
<h5 id=为什么需要常量池>为什么需要常量池</h5>
<p>一个 Java 源文件中的类、接口，编译后产生一个字节码文件。而 Java 中的字节码需要数据支持，通常这种数据会很大以至于不能直接存到字节码里，换另一种方式，可以存到常量池，这个字节码包含了指向常量池的引用。在动态链接的时候用到的就是运行时常量池。</p>
<p>如下，我们通过 jclasslib 查看一个只有 Main 方法的简单类，字节码中的 #2 指向的就是 Constant Pool</p>
<div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210430223700.png style=display:block;width:50% alt=NAME align=center> </div>
<p>常量池可以看作是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等类型。</p>
<h4 id=运行时常量池-1>运行时常量池</h4>
<ul>
<li>
<p>在加载类和结构到虚拟机后，就会创建对应的运行时常量池</p>
</li>
<li>
<p>常量池表（Constant Pool Table）是 Class 文件的一部分，用于存储编译期生成的各种字面量和符号引用，<strong>这部分内容将在类加载后存放到方法区的运行时常量池中</strong></p>
</li>
<li>
<p>JVM 为每个已加载的类型（类或接口）都维护一个常量池。池中的数据项像数组项一样，是通过索引访问的</p>
</li>
<li>
<p>运行时常量池中包含各种不同的常量，包括编译器就已经明确的数值字面量，也包括到运行期解析后才能够获得的方法或字段引用。此时不再是常量池中的符号地址了，这里换为真实地址。</p>
<ul>
<li>运行时常量池，相对于 Class 文件常量池的另一个重要特征是：<strong>动态性</strong>，Java 语言并不要求常量一定在编译期间才能产生，运行期间也可以将新的常量放入池中，String 类的 <code>intern()</code> 方法就是这样的</li>
</ul>
</li>
<li>
<p>当创建类或接口的运行时常量池时，如果构造运行时常量池所需的内存空间超过了方法区所能提供的最大值，则 JVM 会抛出 OutOfMemoryError 异常。</p>
</li>
</ul>
<h3 id=方法区实现的演进>方法区实现的演进</h3>
<p>只有 HotSpot 才有永久代的说法：</p>
<table>
<thead>
<tr>
<th>jdk1.6及之前</th>
<th>有永久代，静态变量存放在永久代上</th>
</tr>
</thead>
<tbody>
<tr>
<td>jdk1.7</td>
<td>有永久代，但已经逐步“去永久代”，字符串常量池、静态变量移除，保存在堆中</td>
</tr>
<tr>
<td>jdk1.8及之后</td>
<td>取消永久代，类型信息、字段、方法、常量保存在本地内存的元空间，但字符串常量池、静态变量仍在堆中</td>
</tr>
</tbody>
</table>
<h4 id=移除永久代的原因>移除永久代的原因</h4>
<ul>
<li>
<p>为永久代设置空间大小是很难确定的。</p>
<ul>
<li>
<p>在某些场景下，如果动态加载类过多，容易产生 Perm 区的 OOM。如果某个实际 Web 工程中，因为功能点比较多，在运行过程中，要不断动态加载很多类，经常出现 OOM。</p>
</li>
<li>
<p>而元空间和永久代最大的区别在于，元空间不在虚拟机中，而是使用本地内存，所以默认情况下，元空间的大小仅受本地内存限制</p>
</li>
</ul>
</li>
<li>
<p>对永久代进行调优较困难</p>
</li>
</ul>
<h3 id=方法区垃圾回收>方法区垃圾回收</h3>
<p>方法区的垃圾收集主要回收两部分内容：<strong>常量池中废弃的常量和不再使用的类型</strong>。</p>
<p>先来说说方法区内常量池之中主要存放的两大类常量：字面量和符号引用。字面量比较接近 Java 语言层次的常量概念，如文本字符串、被声明为 final 的常量值等。而符号引用则属于编译原理方面的概念，包括下面三类常量：</p>
<ul>
<li>类和接口的全限定名</li>
<li>字段的名称和描述符</li>
<li>方法的名称和描述符</li>
</ul>
<p>HotSpot 虚拟机对常量池的回收策略是很明确的，只要常量池中的常量没有被任何地方引用，就可以被回收。</p>
<p>判定一个类型是否属于“不再被使用的类”，需要同时满足三个条件：</p>
<ul>
<li>
<p>该类所有的实例都已经被回收，也就是 Java 堆中不存在该类及其任何派生子类的实例</p>
</li>
<li>
<p>加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如 OSGi、JSP 的重加载等，否则通常很难达成</p>
</li>
<li>
<p>该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法</p>
</li>
</ul>
<p>Java 虚拟机被允许对满足上述三个条件的无用类进行回收，这里说的仅仅是“被允许”，而并不是和对象一样，不使用了就必然会回收。是否对类进行回收，HotSpot 虚拟机提供了 <code>-Xnoclassgc</code> 参数进行控制，还可以使用 <code>-verbose:class</code> 以及 <code>-XX:+TraceClassLoading</code> 、<code>-XX:+TraceClassUnLoading</code> 查看类加载和卸载信息。</p>
<p>在大量使用反射、动态代理、CGLib 等 ByteCode 框架、动态生成 JSP 以及 OSGi 这类频繁自定义 ClassLoader 的场景都需要虚拟机具备类卸载的功能，以保证永久代不会溢出。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-84806c308a9c70c248e777b89a50aaae>5 - CH05-JVM内存模型-1</h1>
<h2 id=内存结构--内存模型>内存结构 & 内存模型</h2>
<h3 id=堆栈>堆栈</h3>
<p>JVM 内部通过内存结构在线程栈和堆之间划分内存。 此图从逻辑角度说明了Java内存结构：</p>
<div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210430224637.png style=display:block;width:50% alt=NAME align=center> </div>
<h3 id=堆栈中的内容>堆栈中的内容</h3>
<p>线程堆栈还包含正在执行的每个方法的所有局部变量(调用堆栈上的所有方法)。 线程只能访问它自己的线程堆栈。 由线程创建的局部变量对于创建它的线程以外的所有其他线程是不可见的。 即使两个线程正在执行完全相同的代码，两个线程仍将在每个自己的线程堆栈中创建该代码的局部变量。 因此，每个线程都有自己的每个局部变量的版本。</p>
<p>基本类型的所有局部变量(boolean，byte，short，char，int，long，float，double)完全存储在线程堆栈中，因此对其他线程不可见。 一个线程可以将一个基本类型变量的副本传递给另一个线程，但它不能共享原始局部变量本身。</p>
<p>堆包含了在Java应用程序中创建的所有对象，无论创建该对象的线程是什么。 这包括基本类型的包装类(例如Byte，Integer，Long等)。 无论是创建对象并将其分配给局部变量，还是创建为另一个对象的成员变量，该对象仍然存储在堆上。</p>
<div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210430224702.png style=display:block;width:50% alt=NAME align=center> </div>
<p>局部变量可以是基本类型，在这种情况下，它完全保留在线程堆栈上。</p>
<p>局部变量也可以是对象的引用。 在这种情况下，引用(局部变量)存储在线程堆栈中，但是对象本身存储在堆(Heap)上。</p>
<p>对象的成员变量与对象本身一起存储在堆上。 当成员变量是基本类型时，以及它是对象的引用时都是如此。</p>
<p>静态类变量也与类定义一起存储在堆上。</p>
<h3 id=线程如何访问堆上的对象>线程如何访问堆上的对象？</h3>
<p>所有具有对象引用的线程都可以访问堆上的对象。 当一个线程有权访问一个对象时，它也可以访问该对象的成员变量。 如果两个线程同时在同一个对象上调用一个方法，它们都可以访问该对象的成员变量，但每个线程都有自己的局部变量副本。</p>
<div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210430224759.png style=display:block;width:50% alt=NAME align=center> </div>
<p>两个线程有一组局部变量。 其中一个局部变量(局部变量2)指向堆上的共享对象(对象3)。 两个线程各自对同一对象具有不同的引用。 它们的引用是局部变量，因此存储在每个线程的线程堆栈中(在每个线程堆栈上)。 但是，这两个不同的引用指向堆上的同一个对象。</p>
<p>注意共享对象(对象3)如何将对象2和对象4作为成员变量引用(由对象3到对象2和对象4的箭头所示)。 通过对象3中的这些成员变量引用，两个线程可以访问对象2和对象4.</p>
<p>该图还显示了一个局部变量，该变量指向堆上的两个不同对象。 在这种情况下，引用指向两个不同的对象(对象1和对象5)，而不是同一个对象。 理论上，如果两个线程都引用了两个对象，则两个线程都可以访问对象1和对象5。 但是在上图中，每个线程只引用了两个对象中的一个。</p>
<h3 id=线程栈访问堆对象>线程栈访问堆对象</h3>
<p>那么，什么样的Java代码可以导致上面的内存图? 好吧，代码就像下面的代码一样简单：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>MyRunnable</span> <span style=color:#204a87;font-weight:700>implements</span> <span style=color:#000>Runnable</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span>

    <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>run</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span>
        <span style=color:#000>methodOne</span><span style=color:#ce5c00;font-weight:700>();</span>
    <span style=color:#ce5c00;font-weight:700>}</span>

    <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>methodOne</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span>
        <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>localVariable1</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>45</span><span style=color:#ce5c00;font-weight:700>;</span>

        <span style=color:#000>MySharedObject</span> <span style=color:#000>localVariable2</span> <span style=color:#ce5c00;font-weight:700>=</span>
            <span style=color:#000>MySharedObject</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>sharedInstance</span><span style=color:#ce5c00;font-weight:700>;</span>

        <span style=color:#8f5902;font-style:italic>//... do more with local variables.
</span><span style=color:#8f5902;font-style:italic></span>
        <span style=color:#000>methodTwo</span><span style=color:#ce5c00;font-weight:700>();</span>
    <span style=color:#ce5c00;font-weight:700>}</span>

    <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>methodTwo</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span>
        <span style=color:#000>Integer</span> <span style=color:#000>localVariable1</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>Integer</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>99</span><span style=color:#ce5c00;font-weight:700>);</span>

        <span style=color:#8f5902;font-style:italic>//... do more with local variable.
</span><span style=color:#8f5902;font-style:italic></span>    <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#ce5c00;font-weight:700>}</span>

<span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>MySharedObject</span> <span style=color:#ce5c00;font-weight:700>{</span>

    <span style=color:#8f5902;font-style:italic>//static variable pointing to instance of MySharedObject
</span><span style=color:#8f5902;font-style:italic></span>
    <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>static</span> <span style=color:#204a87;font-weight:700>final</span> <span style=color:#000>MySharedObject</span> <span style=color:#000>sharedInstance</span> <span style=color:#ce5c00;font-weight:700>=</span>
        <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>MySharedObject</span><span style=color:#ce5c00;font-weight:700>();</span>


    <span style=color:#8f5902;font-style:italic>//member variables pointing to two objects on the heap
</span><span style=color:#8f5902;font-style:italic></span>
    <span style=color:#204a87;font-weight:700>public</span> <span style=color:#000>Integer</span> <span style=color:#000>object2</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>Integer</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>22</span><span style=color:#ce5c00;font-weight:700>);</span>
    <span style=color:#204a87;font-weight:700>public</span> <span style=color:#000>Integer</span> <span style=color:#000>object4</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>Integer</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>44</span><span style=color:#ce5c00;font-weight:700>);</span>

    <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>long</span> <span style=color:#000>member1</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>12345</span><span style=color:#ce5c00;font-weight:700>;</span>
    <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>long</span> <span style=color:#000>member1</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>67890</span><span style=color:#ce5c00;font-weight:700>;</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>如果两个线程正在执行run()方法，则前面显示的图表将是结果。 run()方法调用methodOne()，methodOne()调用methodTwo()。</p>
<p>methodOne()声明一个局部基本类型变量(类型为int的localVariable1)和一个局部变量，它是一个对象引用(localVariable2)。</p>
<p>执行methodOne()的每个线程将在各自的线程堆栈上创建自己的localVariable1和localVariable2副本。 localVariable1变量将完全相互分离，只存在于每个线程的线程堆栈中。 一个线程无法看到另一个线程对其localVariable1副本所做的更改。</p>
<p>执行methodOne()的每个线程也将创建自己的localVariable2副本。 但是，localVariable2的两个不同副本最终都指向堆上的同一个对象。 代码将localVariable2设置为指向静态变量引用的对象。 静态变量只有一个副本，此副本存储在堆上。 因此，localVariable2的两个副本最终都指向静态变量指向的MySharedObject的同一个实例。 MySharedObject实例也存储在堆上。 它对应于上图中的对象3。</p>
<p>注意MySharedObject类还包含两个成员变量。 成员变量本身与对象一起存储在堆上。 两个成员变量指向另外两个Integer对象。 这些Integer对象对应于上图中的Object 2和Object 4。</p>
<p>另请注意methodTwo()如何创建名为localVariable1的局部变量。 此局部变量是对Integer对象的对象引用。 该方法将localVariable1引用设置为指向新的Integer实例。 localVariable1引用将存储在执行methodTwo()的每个线程的一个副本中。 实例化的两个Integer对象将存储在堆上，但由于该方法每次执行该方法时都会创建一个新的Integer对象，因此执行此方法的两个线程将创建单独的Integer实例。 在methodTwo()中创建的Integer对象对应于上图中的Object 1和Object 5。</p>
<p>另请注意类型为long的MySharedObject类中的两个成员变量，它们是基本类型。 由于这些变量是成员变量，因此它们仍与对象一起存储在堆上。 只有局部变量存储在线程堆栈中。</p>
<h2 id=jmm-与硬件内存结构>JMM 与硬件内存结构</h2>
<h3 id=硬件内存结构简介>硬件内存结构简介</h3>
<p>现代硬件内存架构与内部Java内存模型略有不同。 了解硬件内存架构也很重要，以了解Java内存模型如何与其一起工作。 本节介绍了常见的硬件内存架构，后面的部分将介绍Java内存模型如何与其配合使用。</p>
<p>这是现代计算机硬件架构的简化图：</p>
<div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210430225114.png style=display:block;width:50% alt=NAME align=center> </div>
<p>现代计算机通常有2个或更多CPU。 其中一些CPU也可能有多个内核。 关键是，在具有2个或更多CPU的现代计算机上，可以同时运行多个线程。 每个CPU都能够在任何给定时间运行一个线程。 这意味着如果您的Java应用程序是多线程的，线程真的在可能同时运行.</p>
<p>每个CPU基本上都包含一组在CPU内存中的寄存器。 CPU可以在这些寄存器上执行的操作比在主存储器中对变量执行的操作快得多。 这是因为CPU可以比访问主存储器更快地访问这些寄存器。</p>
<p>每个CPU还可以具有CPU高速缓存存储器层。 事实上，大多数现代CPU都有一些大小的缓存存储层。 CPU可以比主存储器更快地访问其高速缓存存储器，但通常不会像访问其内部寄存器那样快。 因此，CPU高速缓存存储器介于内部寄存器和主存储器的速度之间。 某些CPU可能有多个缓存层(级别1和级别2)，但要了解Java内存模型如何与内存交互，这一点并不重要。 重要的是要知道CPU可以有某种缓存存储层。</p>
<p>计算机还包含主存储区(RAM)。 所有CPU都可以访问主内存。 主存储区通常比CPU的高速缓存存储器大得多。同时访问速度也就较慢.</p>
<p>通常，当CPU需要访问主存储器时，它会将部分主存储器读入其CPU缓存。 它甚至可以将部分缓存读入其内部寄存器，然后对其执行操作。 当CPU需要将结果写回主存储器时，它会将值从其内部寄存器刷新到高速缓冲存储器，并在某些时候将值刷新回主存储器。</p>
<h3 id=jmm-与硬件内存连接>JMM 与硬件内存连接</h3>
<p>如前所述，Java内存模型和硬件内存架构是不同的。 硬件内存架构不区分线程堆栈和堆。 在硬件上，线程堆栈和堆都位于主存储器中。 线程堆栈和堆的一部分有时可能存在于CPU高速缓存和内部CPU寄存器中。 这在图中说明：</p>
<div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210430225230.png style=display:block;width:50% alt=NAME align=center> </div>
<p>当对象和变量可以存储在计算机的各种不同存储区域中时，可能会出现某些问题。 两个主要问题是：</p>
<ul>
<li>Visibility of thread updates (writes) to shared variables.</li>
<li>Race conditions when reading, checking and writing shared variables. 以下各节将解释这两个问题。</li>
</ul>
<h3 id=jmm与硬件内存连接---对象共享后的可见性>JMM与硬件内存连接 - 对象共享后的可见性</h3>
<p>如果两个或多个线程共享一个对象，而没有正确使用volatile声明或同步，则一个线程对共享对象的更新可能对其他线程不可见。</p>
<p>想象一下，共享对象最初存储在主存储器中。 然后，在CPU上运行的线程将共享对象读入其CPU缓存中。 它在那里对共享对象进行了更改。 只要CPU缓存尚未刷新回主内存，共享对象的更改版本对于在其他CPU上运行的线程是不可见的。 这样，每个线程最终都可能拥有自己的共享对象副本，每个副本都位于不同的CPU缓存中。</p>
<p>下图描绘了该情况。 在左CPU上运行的一个线程将共享对象复制到其CPU缓存中，并将其count变量更改为2.对于在右边的CPU上运行的其他线程，此更改不可见，因为计数更新尚未刷新回主内存中.</p>
<div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210430225317.png style=display:block;width:50% alt=NAME align=center> </div>
<p>要解决此问题，您可以使用Java的volatile关键字。 volatile关键字可以确保直接从主内存读取给定变量，并在更新时始终写回主内存。</p>
<h3 id=jmm与硬件内存连接---竞态条件>JMM与硬件内存连接 - 竞态条件</h3>
<p>如果两个或多个线程共享一个对象，并且多个线程更新该共享对象中的变量，则可能会出现竞态。</p>
<p>想象一下，如果线程A将共享对象的变量计数读入其CPU缓存中。 想象一下，线程B也做同样的事情，但是进入不同的CPU缓存。 现在，线程A将一个添加到count，而线程B执行相同的操作。 现在var1已经增加了两次，每个CPU缓存一次。</p>
<p>如果这些增量是按先后顺序执行的，则变量计数将增加两次并将原始值+ 2写回主存储器。</p>
<p>但是，两个增量同时执行而没有适当的同步。 无论线程A和B中哪一个将其更新后的计数版本写回主存储器，更新的值将仅比原始值高1，尽管有两个增量。</p>
<p>该图说明了如上所述的竞争条件问题的发生：</p>
<div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210430225343.png style=display:block;width:50% alt=NAME align=center> </div>
<p>要解决此问题，您可以使用Java synchronized块。 同步块保证在任何给定时间只有一个线程可以进入代码的给定关键部分。 同步块还保证在同步块内访问的所有变量都将从主存储器中读入，当线程退出同步块时，所有更新的变量将再次刷新回主存储器，无论变量是不是声明为volatile。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-b8e7b8cb58035d8f6a6b6b4e95a058fe>6 - CH06-JVM内存模型-2</h1>
<h2 id=基础>基础</h2>
<h3 id=并发编程模型>并发编程模型</h3>
<p>在并发编程中，我们需要处理两个关键问题：线程之间如何通信及线程之间如何同步（这里的线程是指并发执行的活动实体）。通信是指线程之间以何种机制来交换信息。在命令式编程中，线程之间的通信机制有两种：共享内存和消息传递。</p>
<p>在共享内存的并发模型里，线程之间共享程序的公共状态，线程之间通过写 - 读内存中的公共状态来隐式进行通信。在消息传递的并发模型里，线程之间没有公共状态，线程之间必须通过明确的发送消息来显式进行通信。</p>
<p>同步是指程序用于控制不同线程之间操作发生相对顺序的机制。在共享内存并发模型里，同步是显式进行的。程序员必须显式指定某个方法或某段代码需要在线程之间互斥执行。在消息传递的并发模型里，由于消息的发送必须在消息的接收之前，因此同步是隐式进行的。</p>
<p>Java 的并发采用的是共享内存模型，Java 线程之间的通信总是隐式进行，整个通信过程对程序员完全透明。如果编写多线程程序的 Java 程序员不理解隐式进行的线程之间通信的工作机制，很可能会遇到各种奇怪的内存可见性问题。</p>
<h3 id=java-内存模型抽象>Java 内存模型抽象</h3>
<p>在 java 中，所有实例域、静态域和数组元素存储在堆内存中，堆内存在线程之间共享（本文使用“共享变量”这个术语代指实例域，静态域和数组元素）。局部变量（Local variables），方法定义参数（java 语言规范称之为 formal method parameters）和异常处理器参数（exception handler parameters）不会在线程之间共享，它们不会有内存可见性问题，也不受内存模型的影响。</p>
<p>Java 线程之间的通信由 Java 内存模型（本文简称为 JMM）控制，JMM 决定一个线程对共享变量的写入何时对另一个线程可见。从抽象的角度来看，JMM 定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），本地内存中存储了该线程以读 / 写共享变量的副本。本地内存是 JMM 的一个抽象概念，并不真实存在。它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化。Java 内存模型的抽象示意图如下：</p>
<div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210501143439.png style=display:block;width:50% alt=NAME align=center> </div>
<p>从上图来看，线程 A 与线程 B 之间如要通信的话，必须要经历下面 2 个步骤：</p>
<ul>
<li>首先，线程 A 把本地内存 A 中更新过的共享变量刷新到主内存中去。</li>
<li>然后，线程 B 到主内存中去读取线程 A 之前已更新过的共享变量。</li>
</ul>
<p>下面通过示意图来说明这两个步骤：</p>
<div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210501143507.png style=display:block;width:50% alt=NAME align=center> </div>
<p>如上图所示，本地内存 A 和 B 有主内存中共享变量 x 的副本。假设初始时，这三个内存中的 x 值都为 0。线程 A 在执行时，把更新后的 x 值（假设值为 1）临时存放在自己的本地内存 A 中。当线程 A 和线程 B 需要通信时，线程 A 首先会把自己本地内存中修改后的 x 值刷新到主内存中，此时主内存中的 x 值变为了 1。随后，线程 B 到主内存中去读取线程 A 更新后的 x 值，此时线程 B 的本地内存的 x 值也变为了 1。</p>
<p>从整体来看，这两个步骤实质上是线程 A 在向线程 B 发送消息，而且这个通信过程必须要经过主内存。<strong>JMM 通过控制主内存与每个线程的本地内存之间的交互，来为 java 程序员提供内存可见性保证。</strong></p>
<h3 id=重排序>重排序</h3>
<p>在执行程序时为了提高性能，编译器和处理器常常会对指令做重排序。重排序分三种类型：</p>
<ul>
<li>编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。</li>
<li>指令级并行的重排序。现代处理器采用了指令级并行技术（Instruction-Level Parallelism， ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</li>
<li>内存系统的重排序。由于处理器使用缓存和读 / 写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。</li>
</ul>
<p>从 java 源代码到最终实际执行的指令序列，会分别经历下面三种重排序：</p>
<div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210501143633.png style=display:block;width:50% alt=NAME align=center> </div>
<p>上述的 1 属于编译器重排序，2 和 3 属于处理器重排序。这些重排序都可能会导致多线程程序出现内存可见性问题。</p>
<ul>
<li>对于编译器，JMM 的编译器重排序规则会禁止特定类型的编译器重排序（不是所有的编译器重排序都要禁止）。</li>
<li>对于处理器重排序，JMM 的处理器重排序规则会要求 java 编译器在生成指令序列时，插入特定类型的内存屏障（memory barriers，intel 称之为 memory fence）指令，通过内存屏障指令来禁止特定类型的处理器重排序（不是所有的处理器重排序都要禁止）。</li>
</ul>
<p>JMM 属于语言级的内存模型，它确保在不同的编译器和不同的处理器平台之上，通过禁止特定类型的编译器重排序和处理器重排序，为程序员提供一致的内存可见性保证。</p>
<h3 id=处理器重排序与内存屏障指令>处理器重排序与内存屏障指令</h3>
<p>现代的处理器使用写缓冲区来临时保存向内存写入的数据。写缓冲区可以保证指令流水线持续运行，它可以避免由于处理器停顿下来等待向内存写入数据而产生的延迟。同时，通过以批处理的方式刷新写缓冲区，以及合并写缓冲区中对同一内存地址的多次写，可以减少对内存总线的占用。虽然写缓冲区有这么多好处，但每个处理器上的写缓冲区，仅仅对它所在的处理器可见。这个特性会对内存操作的执行顺序产生重要的影响：处理器对内存的读 / 写操作的执行顺序，不一定与内存实际发生的读 / 写操作顺序一致！为了具体说明，请看下面示例：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#8f5902;font-style:italic>// Processor A
</span><span style=color:#8f5902;font-style:italic></span><span style=color:#000>a</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>1</span><span style=color:#ce5c00;font-weight:700>;</span> <span style=color:#8f5902;font-style:italic>//A1  
</span><span style=color:#8f5902;font-style:italic></span><span style=color:#000>x</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>b</span><span style=color:#ce5c00;font-weight:700>;</span> <span style=color:#8f5902;font-style:italic>//A2
</span><span style=color:#8f5902;font-style:italic></span>
<span style=color:#8f5902;font-style:italic>// Processor B
</span><span style=color:#8f5902;font-style:italic></span><span style=color:#000>b</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>2</span><span style=color:#ce5c00;font-weight:700>;</span> <span style=color:#8f5902;font-style:italic>//B1  
</span><span style=color:#8f5902;font-style:italic></span><span style=color:#000>y</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>a</span><span style=color:#ce5c00;font-weight:700>;</span> <span style=color:#8f5902;font-style:italic>//B2
</span><span style=color:#8f5902;font-style:italic></span>
<span style=color:#8f5902;font-style:italic>// 初始状态：a = b = 0；处理器允许执行后得到结果：x = y = 0
</span></code></pre></div><p>假设处理器 A 和处理器 B 按程序的顺序并行执行内存访问，最终却可能得到 x = y = 0 的结果。具体的原因如下图所示：</p>
<div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210501143900.png style=display:block;width:50% alt=NAME align=center> </div>
<p>这里处理器 A 和处理器 B 可以同时把共享变量写入自己的写缓冲区（A1，B1），然后从内存中读取另一个共享变量（A2，B2），最后才把自己写缓存区中保存的脏数据刷新到内存中（A3，B3）。当以这种时序执行时，程序就可以得到 x = y = 0 的结果。</p>
<p>从内存操作实际发生的顺序来看，直到处理器 A 执行 A3 来刷新自己的写缓存区，写操作 A1 才算真正执行了。虽然处理器 A 执行内存操作的顺序为：A1->A2，但内存操作实际发生的顺序却是：A2->A1。此时，处理器 A 的内存操作顺序被重排序了（处理器 B 的情况和处理器 A 一样，这里就不赘述了）。</p>
<p>这里的关键是，由于写缓冲区仅对自己的处理器可见，它会导致处理器执行内存操作的顺序可能会与内存实际的操作执行顺序不一致。由于现代的处理器都会使用写缓冲区，因此现代的处理器都会允许对写 - 读操做重排序。</p>
<p>下面是常见处理器允许的重排序类型的列表：</p>
<table>
<thead>
<tr>
<th>Load-Load</th>
<th>Load-Store</th>
<th>Store-Store</th>
<th>Store-Load</th>
<th>数据依赖</th>
</tr>
</thead>
<tbody>
<tr>
<td>sparc-TSO</td>
<td>N</td>
<td>N</td>
<td>N</td>
<td>Y</td>
</tr>
<tr>
<td>x86</td>
<td>N</td>
<td>N</td>
<td>N</td>
<td>Y</td>
</tr>
<tr>
<td>ia64</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
</tr>
<tr>
<td>PowerPC</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
</tr>
</tbody>
</table>
<p>上表单元格中的“N”表示处理器不允许两个操作重排序，“Y”表示允许重排序。</p>
<p>从上表我们可以看出：常见的处理器都允许 Store-Load 重排序；常见的处理器都不允许对存在数据依赖的操作做重排序。sparc-TSO 和 x86 拥有相对较强的处理器内存模型，它们仅允许对写 - 读操作做重排序（因为它们都使用了写缓冲区）。</p>
<ul>
<li>※注 1：sparc-TSO 是指以 TSO(Total Store Order) 内存模型运行时，sparc 处理器的特性。</li>
<li>※注 2：上表中的 x86 包括 x64 及 AMD64。</li>
<li>※注 3：由于 ARM 处理器的内存模型与 PowerPC 处理器的内存模型非常类似，本文将忽略它。</li>
<li>※注 4：数据依赖性后文会专门说明。</li>
</ul>
<p>为了保证内存可见性，java 编译器在生成指令序列的适当位置会插入内存屏障指令来禁止特定类型的处理器重排序。JMM 把内存屏障指令分为下列四类：</p>
<table>
<thead>
<tr>
<th>屏障类型</th>
<th>指令示例</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>LoadLoad</td>
<td>Load1; LoadLoad; Load2</td>
<td>确保 Load1 数据的装载，先于 Load2 及所有后续装载指令的装载。</td>
</tr>
<tr>
<td>StoreStore</td>
<td>Store1; StoreStore; Store2</td>
<td>确保 Store1 数据对其他处理器可见(刷新到内存)，先于 Store2 及所有后续存储指令的存储。</td>
</tr>
<tr>
<td>LoadStore</td>
<td>Load1; LoadStore; Store2</td>
<td>确保 Load1 数据装载，先于 Store2 及所有后续的存储指令刷新到内存。</td>
</tr>
<tr>
<td>StoreLoad</td>
<td>Store1; StoreLoad; Load2</td>
<td>确保 Store1 数据对其他处理器变得可见（指刷新到内存），先于 Load2 及所有后续装载指令的装载。</td>
</tr>
</tbody>
</table>
<ul>
<li>StoreLoad 会使该屏障之前的所有内存访问指令（存储和装载指令）完成之后，才执行该屏障之后的内存访问指令。</li>
<li>StoreLoad 是一个“全能型”的屏障，它同时具有其他三个屏障的效果。现代的多处理器大都支持该屏障（其他类型的屏障不一定被所有处理器支持）。执行该屏障开销会很昂贵，因为当前处理器通常要把写缓冲区中的数据全部刷新到内存中（buffer fully flush）。</li>
</ul>
<h3 id=happens-before>happens-before</h3>
<p>从 JDK5 开始，java 使用新的 JSR -133 内存模型。JSR-133 提出了 happens-before 的概念，<strong>通过这个概念来阐述操作之间的内存可见性</strong>。如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须存在 happens-before 关系。这里提到的两个操作既可以是在一个线程之内，也可以是在不同线程之间。 与程序员密切相关的 happens-before 规则如下：</p>
<ul>
<li>程序顺序规则：一个线程中的每个操作，happens- before 于该线程中的任意后续操作。</li>
<li>监视器锁规则：对一个监视器锁的解锁，happens- before 于随后对这个监视器锁的加锁。</li>
<li>volatile 变量规则：对一个 volatile 域的写，happens- before 于任意后续对这个 volatile 域的读。</li>
<li>传递性：如果 A happens- before B，且 B happens- before C，那么 A happens- before C。</li>
</ul>
<p>注意，两个操作之间具有 happens-before 关系，并不意味着前一个操作必须要在后一个操作之前执行！happens-before 仅仅要求前一个操作（执行的结果）对后一个操作可见，且前一个操作按顺序排在第二个操作之前（the first is visible to and ordered before the second）。happens- before 的定义很微妙，后文会具体说明 happens-before 为什么要这么定义。</p>
<p>happens-before 与 JMM 的关系如下图所示：</p>
<div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210501144538.png style=display:block;width:50% alt=NAME align=center> </div>
<p>如上图所示，一个 happens-before 规则通常对应于多个编译器重排序规则和处理器重排序规则。对于 java 程序员来说，happens-before 规则简单易懂，它避免程序员为了理解 JMM 提供的内存可见性保证而去学习复杂的重排序规则以及这些规则的具体实现。</p>
<h2 id=重排序-1>重排序</h2>
<h3 id=数据依赖性>数据依赖性</h3>
<p>如果两个操作访问同一个变量，且这两个操作中有一个为写操作，此时这两个操作之间就存在数据依赖性。数据依赖分下列三种类型：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>代码示例</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>写后读</td>
<td>a = 1;b = a;</td>
<td>写一个变量之后，再读这个位置。</td>
</tr>
<tr>
<td>写后写</td>
<td>a = 1;a = 2;</td>
<td>写一个变量之后，再写这个变量。</td>
</tr>
<tr>
<td>读后写</td>
<td>a = b;b = 1;</td>
<td>读一个变量之后，再写这个变量。</td>
</tr>
</tbody>
</table>
<p>上面三种情况，只要重排序两个操作的执行顺序，程序的执行结果将会被改变。</p>
<p>前面提到过，编译器和处理器可能会对操作做重排序。编译器和处理器在重排序时，会遵守数据依赖性，编译器和处理器不会改变存在数据依赖关系的两个操作的执行顺序。</p>
<p>注意，这里所说的数据依赖性仅针对单个处理器中执行的指令序列和单个线程中执行的操作，不同处理器之间和不同线程之间的数据依赖性不被编译器和处理器考虑。</p>
<h3 id=as-if-serial-语义>as-if-serial 语义</h3>
<p>as-if-serial 语义的意思指：不管怎么重排序（编译器和处理器为了提高并行度），（单线程）程序的执行结果不能被改变。编译器，runtime 和处理器都必须遵守 as-if-serial 语义。</p>
<p>为了遵守 as-if-serial 语义，编译器和处理器不会对存在数据依赖关系的操作做重排序，因为这种重排序会改变执行结果。但是，如果操作之间不存在数据依赖关系，这些操作可能被编译器和处理器重排序。为了具体说明，请看下面计算圆面积的代码示例：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#204a87;font-weight:700>double</span> <span style=color:#000>pi</span>  <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>3</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>14</span><span style=color:#ce5c00;font-weight:700>;</span>    <span style=color:#8f5902;font-style:italic>//A
</span><span style=color:#8f5902;font-style:italic></span><span style=color:#204a87;font-weight:700>double</span> <span style=color:#000>r</span>   <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>1</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>0</span><span style=color:#ce5c00;font-weight:700>;</span>     <span style=color:#8f5902;font-style:italic>//B
</span><span style=color:#8f5902;font-style:italic></span><span style=color:#204a87;font-weight:700>double</span> <span style=color:#000>area</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>pi</span> <span style=color:#ce5c00;font-weight:700>*</span> <span style=color:#000>r</span> <span style=color:#ce5c00;font-weight:700>*</span> <span style=color:#000>r</span><span style=color:#ce5c00;font-weight:700>;</span> <span style=color:#8f5902;font-style:italic>//C
</span></code></pre></div><p>上面三个操作的数据依赖关系如下图所示：</p>
<div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210501150714.png style=display:block;width:50% alt=NAME align=center> </div>
<p>如上图所示，A 和 C 之间存在数据依赖关系，同时 B 和 C 之间也存在数据依赖关系。因此在最终执行的指令序列中，C 不能被重排序到 A 和 B 的前面（C 排到 A 和 B 的前面，程序的结果将会被改变）。但 A 和 B 之间没有数据依赖关系，编译器和处理器可以重排序 A 和 B 之间的执行顺序。下图是该程序的两种执行顺序：</p>
<div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210501150734.png style=display:block;width:50% alt=NAME align=center> </div>
<p>as-if-serial 语义把单线程程序保护了起来，遵守 as-if-serial 语义的编译器，runtime 和处理器共同为编写单线程程序的程序员创建了一个幻觉：单线程程序是按程序的顺序来执行的。as-if-serial 语义使单线程程序员无需担心重排序会干扰他们，也无需担心内存可见性问题。</p>
<h3 id=程序顺序规则>程序顺序规则</h3>
<p>根据 happens- before 的程序顺序规则，上面计算圆的面积的示例代码存在三个 happens- before 关系：</p>
<ul>
<li>A happens- before B；</li>
<li>B happens- before C；</li>
<li>A happens- before C；</li>
</ul>
<p>这里的第 3 个 happens- before 关系，是根据 happens- before 的传递性推导出来的。</p>
<p>这里 A happens- before B，但实际执行时 B 却可以排在 A 之前执行（看上面的重排序后的执行顺序）。在第一章提到过，如果 A happens- before B，JMM 并不要求 A 一定要在 B 之前执行。JMM 仅仅要求前一个操作（执行的结果）对后一个操作可见，且前一个操作按顺序排在第二个操作之前。这里操作 A 的执行结果不需要对操作 B 可见；而且重排序操作 A 和操作 B 后的执行结果，与操作 A 和操作 B 按 happens- before 顺序执行的结果一致。在这种情况下，JMM 会认为这种重排序并不非法（not illegal），JMM 允许这种重排序。</p>
<p>在计算机中，软件技术和硬件技术有一个共同的目标：在不改变程序执行结果的前提下，尽可能的开发并行度。编译器和处理器遵从这一目标，从 happens- before 的定义我们可以看出，JMM 同样遵从这一目标。</p>
<h3 id=重排序对多线程的影响>重排序对多线程的影响</h3>
<p>现在让我们来看看，重排序是否会改变多线程程序的执行结果。请看下面的示例代码：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>ReorderExample</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>a</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>0</span><span style=color:#ce5c00;font-weight:700>;</span>
    <span style=color:#204a87;font-weight:700>boolean</span> <span style=color:#000>flag</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>false</span><span style=color:#ce5c00;font-weight:700>;</span>

    <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>writer</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span>
        <span style=color:#000>a</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>1</span><span style=color:#ce5c00;font-weight:700>;</span>                   <span style=color:#8f5902;font-style:italic>//1
</span><span style=color:#8f5902;font-style:italic></span>        <span style=color:#000>flag</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>true</span><span style=color:#ce5c00;font-weight:700>;</span>             <span style=color:#8f5902;font-style:italic>//2
</span><span style=color:#8f5902;font-style:italic></span>    <span style=color:#ce5c00;font-weight:700>}</span>

    <span style=color:#000>Public</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>reader</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span>
        <span style=color:#204a87;font-weight:700>if</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>flag</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>                <span style=color:#8f5902;font-style:italic>//3
</span><span style=color:#8f5902;font-style:italic></span>            <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>i</span> <span style=color:#ce5c00;font-weight:700>=</span>  <span style=color:#000>a</span> <span style=color:#ce5c00;font-weight:700>*</span> <span style=color:#000>a</span><span style=color:#ce5c00;font-weight:700>;</span>        <span style=color:#8f5902;font-style:italic>//4
</span><span style=color:#8f5902;font-style:italic></span>            <span style=color:#a40000>……</span>
        <span style=color:#ce5c00;font-weight:700>}</span>
    <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>flag 变量是个标记，用来标识变量 a 是否已被写入。这里假设有两个线程 A 和 B，A 首先执行 writer() 方法，随后 B 线程接着执行 reader() 方法。线程 B 在执行操作 4 时，能否看到线程 A 在操作 1 对共享变量 a 的写入?</p>
<p>答案是：不一定能看到。</p>
<p>由于操作 1 和操作 2 没有数据依赖关系，编译器和处理器可以对这两个操作重排序；同样，操作 3 和操作 4 没有数据依赖关系，编译器和处理器也可以对这两个操作重排序。让我们先来看看，当操作 1 和操作 2 重排序时，可能会产生什么效果? 请看下面的程序执行时序图：</p>
<div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210501150934.png style=display:block;width:50% alt=NAME align=center> </div>
<p>如上图所示，操作 1 和操作 2 做了重排序。程序执行时，线程 A 首先写标记变量 flag，随后线程 B 读这个变量。由于条件判断为真，线程 B 将读取变量 a。此时，变量 a 还根本没有被线程 A 写入，在这里多线程程序的语义被重排序破坏了！</p>
<p>※注：本文统一用红色的虚箭线表示错误的读操作，用绿色的虚箭线表示正确的读操作。</p>
<p>下面再让我们看看，当操作 3 和操作 4 重排序时会产生什么效果（借助这个重排序，可以顺便说明控制依赖性）。下面是操作 3 和操作 4 重排序后，程序的执行时序图：</p>
<div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210501150948.png style=display:block;width:50% alt=NAME align=center> </div>
<p>在程序中，操作 3 和操作 4 存在控制依赖关系。当代码中存在控制依赖性时，会影响指令序列执行的并行度。为此，编译器和处理器会采用猜测（Speculation）执行来克服控制相关性对并行度的影响。以处理器的猜测执行为例，执行线程 B 的处理器可以提前读取并计算 a*a，然后把计算结果临时保存到一个名为重排序缓冲（reorder buffer ROB）的硬件缓存中。当接下来操作 3 的条件判断为真时，就把该计算结果写入变量 i 中。</p>
<p>从图中我们可以看出，猜测执行实质上对操作 3 和 4 做了重排序。重排序在这里破坏了多线程程序的语义！</p>
<p>在单线程程序中，对存在控制依赖的操作重排序，不会改变执行结果（这也是 as-if-serial 语义允许对存在控制依赖的操作做重排序的原因）；但在多线程程序中，对存在控制依赖的操作重排序，可能会改变程序的执行结果。</p>
<h2 id=顺序一致性>顺序一致性</h2>
<h3 id=数据竞争与顺序一致性保证>数据竞争与顺序一致性保证</h3>
<p>当程序未正确同步时，就会存在数据竞争。java 内存模型规范对数据竞争的定义如下：</p>
<ul>
<li>在一个线程中写一个变量，</li>
<li>在另一个线程读同一个变量，</li>
<li>而且写和读没有通过同步来排序。</li>
</ul>
<p>当代码中包含数据竞争时，程序的执行往往产生违反直觉的结果（前一章的示例正是如此）。如果一个多线程程序能正确同步，这个程序将是一个没有数据竞争的程序。</p>
<p>JMM 对正确同步的多线程程序的内存一致性做了如下保证：</p>
<ul>
<li>如果程序是正确同步的，程序的执行将具有顺序一致性（sequentially consistent）&ndash; 即程序的执行结果与该程序在顺序一致性内存模型中的执行结果相同（马上我们将会看到，这对于程序员来说是一个极强的保证）。这里的同步是指广义上的同步，包括对常用同步原语（lock，volatile 和 final）的正确使用。</li>
</ul>
<h3 id=顺序一致性内存模型>顺序一致性内存模型</h3>
<p>顺序一致性内存模型是一个被计算机科学家理想化了的理论参考模型，它为程序员提供了极强的内存可见性保证。顺序一致性内存模型有两大特性：</p>
<ul>
<li>一个线程中的所有操作必须按照程序的顺序来执行。 +（不管程序是否同步）所有线程都只能看到一个单一的操作执行顺序。在顺序一致性内存模型中，每个操作都必须原子执行且立刻对所有线程可见。 顺序一致性内存模型为程序员提供的视图如下：</li>
</ul>
<div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210501151120.png style=display:block;width:50% alt=NAME align=center> </div>
<p>在概念上，顺序一致性模型有一个单一的全局内存，这个内存通过一个左右摆动的开关可以连接到任意一个线程。同时，每一个线程必须按程序的顺序来执行内存读 / 写操作。从上图我们可以看出，在任意时间点最多只能有一个线程可以连接到内存。当多个线程并发执行时，图中的开关装置能把所有线程的所有内存读 / 写操作串行化。</p>
<p>为了更好的理解，下面我们通过两个示意图来对顺序一致性模型的特性做进一步的说明。</p>
<p>假设有两个线程 A 和 B 并发执行。其中 A 线程有三个操作，它们在程序中的顺序是：A1->A2->A3。B 线程也有三个操作，它们在程序中的顺序是：B1->B2->B3。</p>
<p>假设这两个线程使用监视器来正确同步：A 线程的三个操作执行后释放监视器，随后 B 线程获取同一个监视器。那么程序在顺序一致性模型中的执行效果将如下图所示：</p>
<div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210501151137.png style=display:block;width:50% alt=NAME align=center> </div>
<p>现在我们再假设这两个线程没有做同步，下面是这个未同步程序在顺序一致性模型中的执行示意图：</p>
<div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210501151156.png style=display:block;width:50% alt=NAME align=center> </div>
<p>未同步程序在顺序一致性模型中虽然整体执行顺序是无序的，但所有线程都只能看到一个一致的整体执行顺序。以上图为例，线程 A 和 B 看到的执行顺序都是：B1->A1->A2->B2->A3->B3。之所以能得到这个保证是因为顺序一致性内存模型中的每个操作必须立即对任意线程可见。</p>
<p>但是，在 JMM 中就没有这个保证。未同步程序在 JMM 中不但整体的执行顺序是无序的，而且所有线程看到的操作执行顺序也可能不一致。比如，在当前线程把写过的数据缓存在本地内存中，且还没有刷新到主内存之前，这个写操作仅对当前线程可见；从其他线程的角度来观察，会认为这个写操作根本还没有被当前线程执行。只有当前线程把本地内存中写过的数据刷新到主内存之后，这个写操作才能对其他线程可见。在这种情况下，当前线程和其它线程看到的操作执行顺序将不一致。</p>
<h3 id=同步程序的顺序一致性效果>同步程序的顺序一致性效果</h3>
<p>下面我们对前面的示例程序 ReorderExample 用监视器来同步，看看正确同步的程序如何具有顺序一致性。</p>
<p>请看下面的示例代码：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>SynchronizedExample</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>a</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>0</span><span style=color:#ce5c00;font-weight:700>;</span>
    <span style=color:#204a87;font-weight:700>boolean</span> <span style=color:#000>flag</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>false</span><span style=color:#ce5c00;font-weight:700>;</span>

    <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>synchronized</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>writer</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span>
        <span style=color:#000>a</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>1</span><span style=color:#ce5c00;font-weight:700>;</span>
        <span style=color:#000>flag</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>true</span><span style=color:#ce5c00;font-weight:700>;</span>
    <span style=color:#ce5c00;font-weight:700>}</span>

    <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>synchronized</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>reader</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span>
        <span style=color:#204a87;font-weight:700>if</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>flag</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
            <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>i</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>a</span><span style=color:#ce5c00;font-weight:700>;</span>
            <span style=color:#a40000>……</span>
        <span style=color:#ce5c00;font-weight:700>}</span>
    <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>上面示例代码中，假设 A 线程执行 writer() 方法后，B 线程执行 reader() 方法。这是一个正确同步的多线程程序。根据 JMM 规范，该程序的执行结果将与该程序在顺序一致性模型中的执行结果相同。下面是该程序在两个内存模型中的执行时序对比图：</p>
<div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210501151238.png style=display:block;width:50% alt=NAME align=center> </div>
<p>在顺序一致性模型中，所有操作完全按程序的顺序串行执行。而在 JMM 中，临界区内的代码可以重排序（但 JMM 不允许临界区内的代码“逸出”到临界区之外，那样会破坏监视器的语义）。JMM 会在退出监视器和进入监视器这两个关键时间点做一些特别处理，使得线程在这两个时间点具有与顺序一致性模型相同的内存视图（具体细节后文会说明）。虽然线程 A 在临界区内做了重排序，但由于监视器的互斥执行的特性，这里的线程 B 根本无法“观察”到线程 A 在临界区内的重排序。这种重排序既提高了执行效率，又没有改变程序的执行结果。</p>
<p>从这里我们可以看到 JMM 在具体实现上的基本方针：在不改变（正确同步的）程序执行结果的前提下，尽可能的为编译器和处理器的优化打开方便之门。</p>
<h3 id=未同步程序的执行特性>未同步程序的执行特性</h3>
<p>对于未同步或未正确同步的多线程程序，JMM 只提供最小安全性：线程执行时读取到的值，要么是之前某个线程写入的值，要么是默认值（0，null，false），JMM 保证线程读操作读取到的值不会无中生有（out of thin air）的冒出来。为了实现最小安全性，JVM 在堆上分配对象时，首先会清零内存空间，然后才会在上面分配对象（JVM 内部会同步这两个操作）。因此，在以清零的内存空间（pre-zeroed memory）分配对象时，域的默认初始化已经完成了。</p>
<p>JMM 不保证未同步程序的执行结果与该程序在顺序一致性模型中的执行结果一致。因为未同步程序在顺序一致性模型中执行时，整体上是无序的，其执行结果无法预知。保证未同步程序在两个模型中的执行结果一致毫无意义。</p>
<p>和顺序一致性模型一样，未同步程序在 JMM 中的执行时，整体上也是无序的，其执行结果也无法预知。同时，未同步程序在这两个模型中的执行特性有下面几个差异：</p>
<ul>
<li>顺序一致性模型保证单线程内的操作会按程序的顺序执行，而 JMM 不保证单线程内的操作会按程序的顺序执行（比如上面正确同步的多线程程序在临界区内的重排序）。这一点前面已经讲过了，这里就不再赘述。</li>
<li>顺序一致性模型保证所有线程只能看到一致的操作执行顺序，而 JMM 不保证所有线程能看到一致的操作执行顺序。这一点前面也已经讲过，这里就不再赘述。</li>
<li>JMM 不保证对 64 位的 long 型和 double 型变量的读 / 写操作具有原子性，而顺序一致性模型保证对所有的内存读 / 写操作都具有原子性。</li>
</ul>
<p>第 3 个差异与处理器总线的工作机制密切相关。在计算机中，数据通过总线在处理器和内存之间传递。每次处理器和内存之间的数据传递都是通过一系列步骤来完成的，这一系列步骤称之为总线事务（bus transaction）。总线事务包括读事务（read transaction）和写事务（write transaction）。读事务从内存传送数据到处理器，写事务从处理器传送数据到内存，每个事务会读 / 写内存中一个或多个物理上连续的字。这里的关键是，总线会同步试图并发使用总线的事务。在一个处理器执行总线事务期间，总线会禁止其它所有的处理器和 I/O 设备执行内存的读 / 写。下面让我们通过一个示意图来说明总线的工作机制：</p>
<div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210501151318.png style=display:block;width:50% alt=NAME align=center> </div>
<p>如上图所示，假设处理器 A，B 和 C 同时向总线发起总线事务，这时总线仲裁（bus arbitration）会对竞争作出裁决，这里我们假设总线在仲裁后判定处理器 A 在竞争中获胜（总线仲裁会确保所有处理器都能公平的访问内存）。此时处理器 A 继续它的总线事务，而其它两个处理器则要等待处理器 A 的总线事务完成后才能开始再次执行内存访问。假设在处理器 A 执行总线事务期间（不管这个总线事务是读事务还是写事务），处理器 D 向总线发起了总线事务，此时处理器 D 的这个请求会被总线禁止。</p>
<p>总线的这些工作机制可以把所有处理器对内存的访问以串行化的方式来执行；在任意时间点，最多只能有一个处理器能访问内存。这个特性确保了单个总线事务之中的内存读 / 写操作具有原子性。</p>
<p>在一些 32 位的处理器上，如果要求对 64 位数据的读 / 写操作具有原子性，会有比较大的开销。为了照顾这种处理器，java 语言规范鼓励但不强求 JVM 对 64 位的 long 型变量和 double 型变量的读 / 写具有原子性。当 JVM 在这种处理器上运行时，会把一个 64 位 long/ double 型变量的读 / 写操作拆分为两个 32 位的读 / 写操作来执行。这两个 32 位的读 / 写操作可能会被分配到不同的总线事务中执行，此时对这个 64 位变量的读 / 写将不具有原子性。</p>
<p>当单个内存操作不具有原子性，将可能会产生意想不到后果。请看下面示意图：</p>
<div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210501151335.png style=display:block;width:50% alt=NAME align=center> </div>
<p>如上图所示，假设处理器 A 写一个 long 型变量，同时处理器 B 要读这个 long 型变量。处理器 A 中 64 位的写操作被拆分为两个 32 位的写操作，且这两个 32 位的写操作被分配到不同的写事务中执行。同时处理器 B 中 64 位的读操作被拆分为两个 32 位的读操作，且这两个 32 位的读操作被分配到同一个的读事务中执行。当处理器 A 和 B 按上图的时序来执行时，处理器 B 将看到仅仅被处理器 A“写了一半“的无效值。</p>
<h2 id=总结>总结</h2>
<h3 id=处理器内存模型>处理器内存模型</h3>
<p>顺序一致性内存模型是一个理论参考模型，JMM 和处理器内存模型在设计时通常会把顺序一致性内存模型作为参照。JMM 和处理器内存模型在设计时会对顺序一致性模型做一些放松，因为如果完全按照顺序一致性模型来实现处理器和 JMM，那么很多的处理器和编译器优化都要被禁止，这对执行性能将会有很大的影响。</p>
<p>根据对不同类型读 / 写操作组合的执行顺序的放松，可以把常见处理器的内存模型划分为下面几种类型：</p>
<ul>
<li>放松程序中写 - 读操作的顺序，由此产生了 total store ordering 内存模型（简称为 TSO）。</li>
<li>在前面 1 的基础上，继续放松程序中写 - 写操作的顺序，由此产生了 partial store order 内存模型（简称为 PSO）。</li>
<li>在前面 1 和 2 的基础上，继续放松程序中读 - 写和读 - 读操作的顺序，由此产生了 relaxed memory order 内存模型（简称为 RMO）和 PowerPC 内存模型。</li>
</ul>
<p>注意，这里处理器对读 / 写操作的放松，是以两个操作之间不存在数据依赖性为前提的（因为处理器要遵守 as-if-serial 语义，处理器不会对存在数据依赖性的两个内存操作做重排序）。</p>
<p>下面的表格展示了常见处理器内存模型的细节特征：</p>
<table>
<thead>
<tr>
<th>内存模型名称</th>
<th>对应的处理器</th>
<th>Store-Load 重排序</th>
<th>Store-Store 重排序</th>
<th>Load-Load 和 Load-Store 重排序</th>
<th>可以更早读取到其它处理器的写</th>
<th>可以更早读取到当前处理器的写</th>
</tr>
</thead>
<tbody>
<tr>
<td>TSO</td>
<td>sparc-TSO X64</td>
<td>Y</td>
<td></td>
<td></td>
<td></td>
<td>Y</td>
</tr>
<tr>
<td>PSO</td>
<td>sparc-PSO</td>
<td>Y</td>
<td>Y</td>
<td></td>
<td></td>
<td>Y</td>
</tr>
<tr>
<td>RMO</td>
<td>ia64</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td></td>
<td>Y</td>
</tr>
<tr>
<td>PowerPC</td>
<td>PowerPC</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
</tr>
</tbody>
</table>
<p>在这个表格中，我们可以看到所有处理器内存模型都允许写 - 读重排序，原因在第一章以说明过：它们都使用了写缓存区，写缓存区可能导致写 - 读操作重排序。同时，我们可以看到这些处理器内存模型都允许更早读到当前处理器的写，原因同样是因为写缓存区：由于写缓存区仅对当前处理器可见，这个特性导致当前处理器可以比其他处理器先看到临时保存在自己的写缓存区中的写。</p>
<p>上面表格中的各种处理器内存模型，从上到下，模型由强变弱。越是追求性能的处理器，内存模型设计的会越弱。因为这些处理器希望内存模型对它们的束缚越少越好，这样它们就可以做尽可能多的优化来提高性能。</p>
<p>由于常见的处理器内存模型比 JMM 要弱，java 编译器在生成字节码时，会在执行指令序列的适当位置插入内存屏障来限制处理器的重排序。同时，由于各种处理器内存模型的强弱并不相同，为了在不同的处理器平台向程序员展示一个一致的内存模型，JMM 在不同的处理器中需要插入的内存屏障的数量和种类也不相同。下图展示了 JMM 在不同处理器内存模型中需要插入的内存屏障的示意图：</p>
<div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210501151413.png style=display:block;width:50% alt=NAME align=center> </div>
<p>如上图所示，JMM 屏蔽了不同处理器内存模型的差异，它在不同的处理器平台之上为 java 程序员呈现了一个一致的内存模型。</p>
<h3 id=jmm处理器内存模型与顺序一致性内存模型之间的关系>JMM，处理器内存模型与顺序一致性内存模型之间的关系</h3>
<p>JMM 是一个语言级的内存模型，处理器内存模型是硬件级的内存模型，顺序一致性内存模型是一个理论参考模型。下面是语言内存模型，处理器内存模型和顺序一致性内存模型的强弱对比示意图：</p>
<div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210501151453.png style=display:block;width:50% alt=NAME align=center> </div>
<p>从上图我们可以看出：常见的 4 种处理器内存模型比常用的 3 中语言内存模型要弱，处理器内存模型和语言内存模型都比顺序一致性内存模型要弱。同处理器内存模型一样，越是追求执行性能的语言，内存模型设计的会越弱。</p>
<h3 id=jmm-的设计>JMM 的设计</h3>
<p>从 JMM 设计者的角度来说，在设计 JMM 时，需要考虑两个关键因素：</p>
<ul>
<li>程序员对内存模型的使用。程序员希望内存模型易于理解，易于编程。程序员希望基于一个强内存模型来编写代码。</li>
<li>编译器和处理器对内存模型的实现。编译器和处理器希望内存模型对它们的束缚越少越好，这样它们就可以做尽可能多的优化来提高性能。编译器和处理器希望实现一个弱内存模型。</li>
</ul>
<p>由于这两个因素互相矛盾，所以 JSR-133 专家组在设计 JMM 时的核心目标就是找到一个好的平衡点：一方面要为程序员提供足够强的内存可见性保证；另一方面，对编译器和处理器的限制要尽可能的放松。下面让我们看看 JSR-133 是如何实现这一目标的。</p>
<p>为了具体说明，请看前面提到过的计算圆面积的示例代码</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#204a87;font-weight:700>double</span> <span style=color:#000>pi</span>  <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>3</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>14</span><span style=color:#ce5c00;font-weight:700>;</span>    <span style=color:#8f5902;font-style:italic>//A
</span><span style=color:#8f5902;font-style:italic></span><span style=color:#204a87;font-weight:700>double</span> <span style=color:#000>r</span>   <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>1</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>0</span><span style=color:#ce5c00;font-weight:700>;</span>     <span style=color:#8f5902;font-style:italic>//B
</span><span style=color:#8f5902;font-style:italic></span><span style=color:#204a87;font-weight:700>double</span> <span style=color:#000>area</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>pi</span> <span style=color:#ce5c00;font-weight:700>*</span> <span style=color:#000>r</span> <span style=color:#ce5c00;font-weight:700>*</span> <span style=color:#000>r</span><span style=color:#ce5c00;font-weight:700>;</span> <span style=color:#8f5902;font-style:italic>//C
</span></code></pre></div><p>上面计算圆的面积的示例代码存在三个 happens- before 关系：</p>
<ul>
<li>A happens- before B；</li>
<li>B happens- before C；</li>
<li>A happens- before C；</li>
</ul>
<p>由于 A happens- before B，happens- before 的定义会要求：A 操作执行的结果要对 B 可见，且 A 操作的执行顺序排在 B 操作之前。 但是从程序语义的角度来说，对 A 和 B 做重排序即不会改变程序的执行结果，也还能提高程序的执行性能（允许这种重排序减少了对编译器和处理器优化的束缚）。也就是说，上面这 3 个 happens- before 关系中，虽然 2 和 3 是必需要的，但 1 是不必要的。因此，JMM 把 happens- before 要求禁止的重排序分为了下面两类：</p>
<ul>
<li>会改变程序执行结果的重排序。</li>
<li>不会改变程序执行结果的重排序。</li>
</ul>
<p>JMM 对这两种不同性质的重排序，采取了不同的策略：</p>
<ul>
<li>对于会改变程序执行结果的重排序，JMM 要求编译器和处理器必须禁止这种重排序。</li>
<li>对于不会改变程序执行结果的重排序，JMM 对编译器和处理器不作要求（JMM 允许这种重排序）。</li>
</ul>
<p>下面是 JMM 的设计示意图：</p>
<div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210501151557.png style=display:block;width:50% alt=NAME align=center> </div>
<p>从上图可以看出两点：</p>
<ul>
<li>JMM 向程序员提供的 happens- before 规则能满足程序员的需求。JMM 的 happens- before 规则不但简单易懂，而且也向程序员提供了足够强的内存可见性保证（有些内存可见性保证其实并不一定真实存在，比如上面的 A happens- before B）。</li>
<li>JMM 对编译器和处理器的束缚已经尽可能的少。从上面的分析我们可以看出，JMM 其实是在遵循一个基本原则：只要不改变程序的执行结果（指的是单线程程序和正确同步的多线程程序），编译器和处理器怎么优化都行。比如，如果编译器经过细致的分析后，认定一个锁只会被单个线程访问，那么这个锁可以被消除。再比如，如果编译器经过细致的分析后，认定一个 volatile 变量仅仅只会被单个线程访问，那么编译器可以把这个 volatile 变量当作一个普通变量来对待。这些优化既不会改变程序的执行结果，又能提高程序的执行效率。</li>
</ul>
<h3 id=jmm-的内存可见性保证>JMM 的内存可见性保证</h3>
<p>Java 程序的内存可见性保证按程序类型可以分为下列三类：</p>
<ul>
<li>单线程程序。单线程程序不会出现内存可见性问题。编译器，runtime 和处理器会共同确保单线程程序的执行结果与该程序在顺序一致性模型中的执行结果相同。</li>
<li>正确同步的多线程程序。正确同步的多线程程序的执行将具有顺序一致性（程序的执行结果与该程序在顺序一致性内存模型中的执行结果相同）。这是 JMM 关注的重点，JMM 通过限制编译器和处理器的重排序来为程序员提供内存可见性保证。</li>
<li>未同步 / 未正确同步的多线程程序。JMM 为它们提供了最小安全性保障：线程执行时读取到的值，要么是之前某个线程写入的值，要么是默认值（0，null，false）。</li>
</ul>
<p>下图展示了这三类程序在 JMM 中与在顺序一致性内存模型中的执行结果的异同：</p>
<div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210501151637.png style=display:block;width:50% alt=NAME align=center> </div>
<p>只要多线程程序是正确同步的，JMM 保证该程序在任意的处理器平台上的执行结果，与该程序在顺序一致性内存模型中的执行结果一致。</p>
<h3 id=jsr-133-对旧内存模型的修补>JSR-133 对旧内存模型的修补</h3>
<p>JSR-133 对 JDK5 之前的旧内存模型的修补主要有两个：</p>
<ul>
<li>增强 volatile 的内存语义。旧内存模型允许 volatile 变量与普通变量重排序。JSR-133 严格限制 volatile 变量与普通变量的重排序，使 volatile 的写 - 读和锁的释放 - 获取具有相同的内存语义。</li>
<li>增强 final 的内存语义。在旧内存模型中，多次读取同一个 final 变量的值可能会不相同。为此，JSR-133 为 final 增加了两个重排序规则。现在，final 具有了初始化安全性。</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-520b338700064b344a321992ce37e92e>7 - CH07-JVM垃圾回收</h1>
<h2 id=判断对象是否可被回收>判断对象是否可被回收</h2>
<h3 id=引用计数法>引用计数法</h3>
<p>给对象添加一个引用计数器，当对象增加一个引用时计数器加 1，引用失效时计数器减 1。引用计数为 0 的对象可被回收。</p>
<p>两个对象出现循环引用的情况下，此时引用计数器永远不为 0，导致无法对它们进行回收。</p>
<p>正因为循环引用的存在，因此 Java 虚拟机不使用引用计数算法。</p>
<h3 id=可达性分析>可达性分析</h3>
<p>通过 GC Roots 作为起始点进行搜索，能够到达到的对象都是存活的，不可达的对象可被回收。</p>
<div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210501151941.png style=display:block;width:50% alt=NAME align=center> </div>
<p>Java 虚拟机使用该算法来判断对象是否可被回收，在 Java 中 GC Roots 一般包含以下内容:</p>
<ul>
<li>虚拟机栈中引用的对象</li>
<li>本地方法栈中引用的对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中的常量引用的对象</li>
</ul>
<h3 id=方法区回收>方法区回收</h3>
<p>因为方法区主要存放永久代(元空间)对象，而永久代对象的回收率比新生代低很多，因此在方法区上进行回收性价比不高。</p>
<ul>
<li>
<p>主要是对常量池的回收和对类的卸载。</p>
</li>
<li>
<p>在大量使用反射、动态代理、CGLib 等 ByteCode 框架、动态生成 JSP 以及 OSGi 这类频繁自定义 ClassLoader 的场景都需要虚拟机具备类卸载功能，以保证不会出现内存溢出。</p>
</li>
</ul>
<p>类的卸载条件很多，需要满足以下三个条件，并且满足了也不一定会被卸载:</p>
<ul>
<li>该类所有的实例都已经被回收，也就是堆中不存在该类的任何实例。</li>
<li>加载该类的 ClassLoader 已经被回收。</li>
<li>该类对应的 Class 对象没有在任何地方被引用，也就无法在任何地方通过反射访问该类方法。</li>
</ul>
<p>可以通过 -Xnoclassgc 参数来控制是否对类进行卸载。</p>
<h3 id=finalize>finalize</h3>
<p>finalize() 类似 C++ 的析构函数，用来做关闭外部资源等工作。但是 try-finally 等方式可以做的更好，并且该方法运行代价高昂，不确定性大，无法保证各个对象的调用顺序，因此最好不要使用。</p>
<p>当一个对象可被回收时，如果需要执行该对象的 finalize() 方法，那么就有可能通过在该方法中让对象重新被引用，从而实现自救。自救只能进行一次，如果回收的对象之前调用了 finalize() 方法自救，后面回收时不会调用 finalize() 方法。</p>
<h2 id=引用类型>引用类型</h2>
<p>无论是通过引用计算算法判断对象的引用数量，还是通过可达性分析算法判断对象是否可达，判定对象是否可被回收都与引用有关。</p>
<p>Java 具有四种强度不同的引用类型。</p>
<h3 id=强引用>强引用</h3>
<ul>
<li>
<p>被强引用关联的对象不会被回收。</p>
</li>
<li>
<p>使用 new 一个新对象的方式来创建强引用。</p>
</li>
</ul>
<h3 id=软引用>软引用</h3>
<ul>
<li>
<p>被软引用关联的对象只有在内存不够的情况下才会被回收。</p>
</li>
<li>
<p>使用 SoftReference 类来创建软引用。</p>
</li>
</ul>
<h3 id=弱引用>弱引用</h3>
<ul>
<li>
<p>被弱引用关联的对象一定会被回收，也就是说它只能存活到下一次垃圾回收发生之前。</p>
</li>
<li>
<p>使用 WeakReference 类来实现弱引用。</p>
</li>
</ul>
<h3 id=虚引用>虚引用</h3>
<ul>
<li>
<p>又称为幽灵引用或者幻影引用。</p>
</li>
<li>
<p>一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用取得一个对象。</p>
</li>
<li>
<p>为一个对象设置虚引用关联的<strong>唯一目的就是能在这个对象被回收时收到一个系统通知</strong>。</p>
</li>
<li>
<p>使用 PhantomReference 来实现虚引用。</p>
</li>
</ul>
<h2 id=回收算法>回收算法</h2>
<h3 id=标记-清除>标记-清除</h3>
<div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210501152411.png style=display:block;width:50% alt=NAME align=center> </div>
<p>将存活的对象进行标记，然后清理掉未被标记的对象。</p>
<p>不足:</p>
<ul>
<li>标记和清除过程效率都不高；</li>
<li>会产生大量不连续的内存碎片，导致无法给大对象分配内存。</li>
</ul>
<h3 id=标记-整理>标记-整理</h3>
<div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210501152431.png style=display:block;width:50% alt=NAME align=center> </div>
<p>让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。</p>
<h3 id=复制>复制</h3>
<div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210501152457.png style=display:block;width:50% alt=NAME align=center> </div>
<p>将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存用完了就将还存活的对象复制到另一块上面，然后再把使用过的内存空间进行一次清理。</p>
<p>主要不足是只使用了内存的一半。</p>
<p>现在的商业虚拟机都采用这种收集算法来回收<strong>新生代</strong>，但是并不是将新生代划分为大小相等的两块，而是分为一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 空间和其中一块 Survivor。在回收时，将 Eden 和 Survivor 中还存活着的对象一次性复制到另一块 Survivor 空间上，最后清理 Eden 和使用过的那一块 Survivor。</p>
<p>HotSpot 虚拟机的 Eden 和 Survivor 的大小比例默认为 8:1，保证了内存的利用率达到 90%。如果每次回收有多于 10% 的对象存活，那么一块 Survivor 空间就不够用了，此时需要依赖于老年代进行分配担保，也就是借用老年代的空间存储放不下的对象。</p>
<h3 id=分代收集>分代收集</h3>
<p>现在的商业虚拟机采用分代收集算法，它根据对象存活周期将内存划分为几块，不同块采用适当的收集算法。</p>
<p>一般将堆分为新生代和老年代。</p>
<ul>
<li>新生代使用: 复制算法</li>
<li>老年代使用: 标记 - 清除 或者 标记 - 整理 算法</li>
</ul>
<h2 id=垃圾收集器>垃圾收集器</h2>
<div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210501152644.png style=display:block;width:50% alt=NAME align=center> </div>
<p>以上是 HotSpot 虚拟机中的 7 个垃圾收集器，连线表示垃圾收集器可以配合使用。</p>
<ul>
<li>单线程与多线程: 单线程指的是垃圾收集器只使用一个线程进行收集，而多线程使用多个线程；</li>
<li>串行与并行:
<ul>
<li>串行指的是垃圾收集器与用户程序交替执行，这意味着在执行垃圾收集的时候需要停顿用户程序；</li>
<li>并形指的是垃圾收集器和用户程序同时执行。</li>
<li>除了 CMS 和 G1 之外，其它垃圾收集器都是以串行的方式执行。</li>
</ul>
</li>
</ul>
<h3 id=serial-收集器>Serial 收集器</h3>
<div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210501152758.png style=display:block;width:50% alt=NAME align=center> </div>
<ul>
<li>
<p>Serial 翻译为串行，也就是说它以串行的方式执行。</p>
</li>
<li>
<p>它是单线程的收集器，只会使用一个线程进行垃圾收集工作。</p>
</li>
<li>
<p>它的优点是简单高效，对于单个 CPU 环境来说，由于没有线程交互的开销，因此拥有最高的单线程收集效率。</p>
</li>
<li>
<p>它是 Client 模式下的默认新生代收集器，因为在用户的桌面应用场景下，分配给虚拟机管理的内存一般来说不会很大。</p>
</li>
<li>
<p>Serial 收集器收集几十兆甚至一两百兆的新生代停顿时间可以控制在一百多毫秒以内，只要不是太频繁，这点停顿是可以接受的。</p>
</li>
</ul>
<h3 id=parnew-收集器>ParNew 收集器</h3>
<div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210501153111.png style=display:block;width:50% alt=NAME align=center> </div>
<ul>
<li>
<p>它是 Serial 收集器的多线程版本。</p>
</li>
<li>
<p>是 Server 模式下的虚拟机首选新生代收集器，除了性能原因外，主要是因为除了 Serial 收集器，只有它能与 CMS 收集器配合工作。</p>
</li>
<li>
<p>默认开启的线程数量与 CPU 数量相同，可以使用 -XX:ParallelGCThreads 参数来设置线程数。</p>
</li>
</ul>
<h3 id=parallel-scavenge-收集器>Parallel Scavenge 收集器</h3>
<ul>
<li>
<p>与 ParNew 一样是多线程收集器。</p>
</li>
<li>
<p>其它收集器关注点是尽可能缩短垃圾收集时用户线程的停顿时间，而它的目标是达到一个可控制的吞吐量，它被称为“吞吐量优先”收集器。这里的吞吐量指 CPU 用于运行用户代码的时间占总时间的比值。</p>
</li>
<li>
<p>停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验。而高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。</p>
</li>
<li>
<p>缩短停顿时间是以牺牲吞吐量和新生代空间来换取的: 新生代空间变小，垃圾回收变得频繁，导致吞吐量下降。</p>
</li>
<li>
<p>可以通过一个开关参数打卡 GC 自适应的调节策略(GC Ergonomics)，就不需要手工指定新生代的大小(-Xmn)、Eden 和 Survivor 区的比例、晋升老年代对象年龄等细节参数了。虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量，这种方式称为 。</p>
</li>
</ul>
<h3 id=serial-old-收集器>Serial Old 收集器</h3>
<div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210501153245.png style=display:block;width:50% alt=NAME align=center> </div>
<p>是 Serial 收集器的老年代版本，也是给 Client 模式下的虚拟机使用。如果用在 Server 模式下，它有两大用途:</p>
<ul>
<li>在 JDK 1.5 以及之前版本(Parallel Old 诞生以前)中与 Parallel Scavenge 收集器搭配使用。</li>
<li>作为 CMS 收集器的后备预案，在并发收集发生 Concurrent Mode Failure 时使用。</li>
</ul>
<h3 id=parallel-old-收集器>Parallel Old 收集器</h3>
<div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210501153306.png style=display:block;width:50% alt=NAME align=center> </div>
<ul>
<li>
<p>是 Parallel Scavenge 收集器的老年代版本。</p>
</li>
<li>
<p>在注重吞吐量以及 CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器。</p>
</li>
</ul>
<h3 id=cms-收集器>CMS 收集器</h3>
<div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210501153330.png style=display:block;width:50% alt=NAME align=center> </div>
<p>CMS(Concurrent Mark Sweep)，Mark Sweep 指的是标记 - 清除算法。</p>
<p>分为以下四个流程:</p>
<ul>
<li>初始标记: 仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快，需要停顿。</li>
<li>并发标记: 进行 GC Roots Tracing 的过程，它在整个回收过程中耗时最长，不需要停顿。</li>
<li>重新标记: 为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要停顿。</li>
<li>并发清除: 不需要停顿。</li>
</ul>
<p>在整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，不需要进行停顿。</p>
<p>具有以下缺点:</p>
<ul>
<li>吞吐量低: 低停顿时间是以牺牲吞吐量为代价的，导致 CPU 利用率不够高。</li>
<li>无法处理浮动垃圾，可能出现 Concurrent Mode Failure。浮动垃圾是指并发清除阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次 GC 时才能进行回收。由于浮动垃圾的存在，因此需要预留出一部分内存，意味着 CMS 收集不能像其它收集器那样等待老年代快满的时候再回收。如果预留的内存不够存放浮动垃圾，就会出现 Concurrent Mode Failure，这时虚拟机将临时启用 Serial Old 来替代 CMS。</li>
<li>标记 - 清除算法导致的空间碎片，往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象，不得不提前触发一次 Full GC。</li>
</ul>
<h3 id=g1-收集器>G1 收集器</h3>
<p>G1(Garbage-First)，它是一款面向服务端应用的垃圾收集器，在多 CPU 和大内存的场景下有很好的性能。HotSpot 开发团队赋予它的使命是未来可以替换掉 CMS 收集器。</p>
<p>堆被分为新生代和老年代，其它收集器进行收集的范围都是整个新生代或者老年代，而 G1 可以直接对新生代和老年代一起回收。</p>
<div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210501153510.png style=display:block;width:50% alt=NAME align=center> </div>
<p>G1 把堆划分成多个大小相等的独立区域(Region)，新生代和老年代不再物理隔离。</p>
<div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210501153558.png style=display:block;width:50% alt=NAME align=center> </div>
<p>通过引入 Region 的概念，从而将原来的一整块内存空间划分成多个的小空间，使得每个小空间可以单独进行垃圾回收。这种划分方法带来了很大的灵活性，使得可预测的停顿时间模型成为可能。通过记录每个 Region 垃圾回收时间以及回收所获得的空间(这两个值是通过过去回收的经验获得)，并维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region。</p>
<p>每个 Region 都有一个 Remembered Set，用来记录该 Region 对象的引用对象所在的 Region。通过使用 Remembered Set，在做可达性分析的时候就可以避免全堆扫描。</p>
<div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210501153647.png style=display:block;width:50% alt=NAME align=center> </div>
<p>如果不计算维护 Remembered Set 的操作，G1 收集器的运作大致可划分为以下几个步骤:</p>
<ul>
<li>初始标记</li>
<li>并发标记</li>
<li>最终标记: 为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中。这阶段需要停顿线程，但是可并行执行。</li>
<li>筛选回收: 首先对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。</li>
</ul>
<p>具备如下特点:</p>
<ul>
<li>空间整合: 整体来看是基于“标记 - 整理”算法实现的收集器，从局部(两个 Region 之间)上来看是基于“复制”算法实现的，这意味着运行期间不会产生内存空间碎片。</li>
<li>可预测的停顿: 能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在 GC 上的时间不得超过 N 毫秒。</li>
</ul>
<h2 id=内存分配与回收策略>内存分配与回收策略</h2>
<h3 id=minor-gc-与-full-gc>Minor GC 与 Full GC</h3>
<ul>
<li>
<p>Minor GC: 发生在新生代上，因为新生代对象存活时间很短，因此 Minor GC 会频繁执行，执行的速度一般也会比较快。</p>
</li>
<li>
<p>Full GC: 发生在老年代上，老年代对象其存活时间长，因此 Full GC 很少执行，执行速度会比 Minor GC 慢很多。</p>
</li>
</ul>
<h3 id=内存分配策略>内存分配策略</h3>
<h4 id=1-对象优先在-eden-分配>1. 对象优先在 Eden 分配</h4>
<ul>
<li>大多数情况下，对象在新生代 Eden 区分配，当 Eden 区空间不够时，发起 Minor GC。</li>
</ul>
<h4 id=2-大对象直接进入老年代>2. 大对象直接进入老年代</h4>
<ul>
<li>
<p>大对象是指需要连续内存空间的对象，最典型的大对象是那种很长的字符串以及数组。</p>
</li>
<li>
<p>经常出现大对象会提前触发垃圾收集以获取足够的连续空间分配给大对象。</p>
</li>
<li>
<p>-XX:PretenureSizeThreshold，大于此值的对象直接在老年代分配，避免在 Eden 区和 Survivor 区之间的大量内存复制。</p>
</li>
</ul>
<h4 id=3-长期存活的对象进入老年代>3. 长期存活的对象进入老年代</h4>
<ul>
<li>
<p>为对象定义年龄计数器，对象在 Eden 出生并经过 Minor GC 依然存活，将移动到 Survivor 中，年龄就增加 1 岁，增加到一定年龄则移动到老年代中。</p>
</li>
<li>
<p>-XX:MaxTenuringThreshold 用来定义年龄的阈值。</p>
</li>
</ul>
<h4 id=4-动态对象年龄判定>4. 动态对象年龄判定</h4>
<ul>
<li>虚拟机并不是永远地要求对象的年龄必须达到 MaxTenuringThreshold 才能晋升老年代，如果在 Survivor 中相同年龄所有对象大小的总和大于 Survivor 空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代，无需等到 MaxTenuringThreshold 中要求的年龄。</li>
</ul>
<h4 id=5-空间分配担保>5. 空间分配担保</h4>
<ul>
<li>
<p>在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的。</p>
</li>
<li>
<p>如果不成立的话虚拟机会查看 HandlePromotionFailure 设置值是否允许担保失败，如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 Minor GC；如果小于，或者 HandlePromotionFailure 设置不允许冒险，那么就要进行一次 Full GC。</p>
</li>
</ul>
<h3 id=full-gc-触发条件>Full GC 触发条件</h3>
<p>对于 Minor GC，其触发条件非常简单，当 Eden 空间满时，就将触发一次 Minor GC。而 Full GC 则相对复杂，有以下条件:</p>
<h4 id=1-调用-systemgc>1. 调用 System.gc()</h4>
<ul>
<li>只是建议虚拟机执行 Full GC，但是虚拟机不一定真正去执行。不建议使用这种方式，而是让虚拟机管理内存。</li>
</ul>
<h4 id=2-老年代空间不足>2. 老年代空间不足</h4>
<ul>
<li>
<p>老年代空间不足的常见场景为前文所讲的大对象直接进入老年代、长期存活的对象进入老年代等。</p>
</li>
<li>
<p>为了避免以上原因引起的 Full GC，应当尽量不要创建过大的对象以及数组。</p>
</li>
<li>
<p>除此之外，可以通过 -Xmn 虚拟机参数调大新生代的大小，让对象尽量在新生代被回收掉，不进入老年代。</p>
</li>
<li>
<p>还可以通过 -XX:MaxTenuringThreshold 调大对象进入老年代的年龄，让对象在新生代多存活一段时间。</p>
</li>
</ul>
<h4 id=3-空间分配担保失败>3. 空间分配担保失败</h4>
<ul>
<li>使用复制算法的 Minor GC 需要老年代的内存空间作担保，如果担保失败会执行一次 Full GC。</li>
</ul>
<h4 id=4-jdk-17-及以前的永久代空间不足>4. JDK 1.7 及以前的永久代空间不足</h4>
<ul>
<li>
<p>在 JDK 1.7 及以前，HotSpot 虚拟机中的方法区是用永久代实现的，永久代中存放的为一些 Class 的信息、常量、静态变量等数据。</p>
</li>
<li>
<p>当系统中要加载的类、反射的类和调用的方法较多时，永久代可能会被占满，在未配置为采用 CMS GC 的情况下也会执行 Full GC。如果经过 Full GC 仍然回收不了，那么虚拟机会抛出 java.lang.OutOfMemoryError。</p>
</li>
<li>
<p>为避免以上原因引起的 Full GC，可采用的方法为增大永久代空间或转为使用 CMS GC。</p>
</li>
</ul>
<h4 id=5-concurrent-mode-failure>5. Concurrent Mode Failure</h4>
<ul>
<li>执行 CMS GC 的过程中同时有对象要放入老年代，而此时老年代空间不足(可能是 GC 过程中浮动垃圾过多导致暂时性的空间不足)，便会报 Concurrent Mode Failure 错误，并触发 Full GC。</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-a582f9956d80b5ccc3719732dd43cd13>8 - CH08-JVM-G1</h1>
<p>G1垃圾回收器是在Java7 update 4之后引入的一个新的垃圾回收器。同优秀的CMS垃圾回收器一样，G1也是关注最小时延的垃圾回收器，也同样适合大尺寸堆内存的垃圾收集，官方在ZGC还没有出现时也推荐使用G1来代替选择CMS。G1最大的特点是引入分区的思路，弱化了分代的概念，合理利用垃圾收集各个周期的资源，解决了其他收集器甚至CMS的众多缺陷。</p>
<h2 id=概述>概述</h2>
<p>G1是一个分代的，增量的，并行与并发的标记-复制垃圾回收器。它的设计目标是为了适应现在不断扩大的内存和不断增加的处理器数量，进一步降低停顿时间(pause time)，同时兼顾良好的吞吐量。</p>
<p>G1回收器和CMS比起来，有以下不同：</p>
<ul>
<li>G1垃圾回收器是 <strong>compacting</strong> 的，因此其回收得到的空间是连续的。这避免了CMS回收器因为不连续空间所造成的问题。如需要更大的堆空间，更多的floating garbage。连续空间意味着G1垃圾回收器可以不必采用空闲链表的内存分配方式，而可以直接采用bump-the-pointer的方式；</li>
<li>G1回收器的内存与CMS回收器要求的内存模型有极大的不同。G1将内存划分一个个固定大小的region，每个region可以是年轻代、老年代的一个。<strong>内存的回收是以region作为基本单位的</strong>；</li>
<li>G1还有一个及其重要的特性：<strong>软实时</strong>（soft real-time）。所谓的实时垃圾回收，是指在要求的时间内完成垃圾回收。“软实时”则是指，用户可以指定垃圾回收时间的限时，G1会努力在这个时限内完成垃圾回收，但是G1并不担保每次都能在这个时限内完成垃圾回收。通过设定一个合理的目标，可以让达到90%以上的垃圾回收时间都在这个时限内。</li>
</ul>
<h2 id=g1-内存模型>G1 内存模型</h2>
<h3 id=分区概念>分区概念</h3>
<div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210501161409.png style=display:block;width:50% alt=NAME align=center> </div>
<h4 id=分区-region>分区 Region</h4>
<p>G1采用了分区(Region)的思路，将整个堆空间分成若干个大小相等的内存区域，每次分配对象空间将逐段地使用内存。因此，在堆的使用上，G1并不要求对象的存储一定是物理上连续的，只要逻辑上连续即可；每个分区也不会确定地为某个代服务，可以按需在年轻代和老年代之间切换。启动时可以通过参数-XX:G1HeapRegionSize=n可指定分区大小(1MB~32MB，且必须是2的幂)，默认将整堆划分为2048个分区。</p>
<h4 id=卡片-card>卡片 Card</h4>
<p>在每个分区内部又被分成了若干个大小为512 Byte卡片(Card)，标识堆内存最小可用粒度所有分区的卡片将会记录在全局卡片表(Global Card Table)中，分配的对象会占用物理上连续的若干个卡片，当查找对分区内对象的引用时便可通过记录卡片来查找该引用对象(见RSet)。每次对内存的回收，都是对指定分区的卡片进行处理。</p>
<h4 id=堆-heap>堆 Heap</h4>
<p>G1同样可以通过-Xms/-Xmx来指定堆空间大小。当发生年轻代收集或混合收集时，通过计算GC与应用的耗费时间比，自动调整堆空间大小。如果GC频率太高，则通过增加堆尺寸，来减少GC频率，相应地GC占用的时间也随之降低；目标参数-XX:GCTimeRatio即为GC与应用的耗费时间比，G1默认为9，而CMS默认为99，因为CMS的设计原则是耗费在GC上的时间尽可能的少。另外，当空间不足，如对象空间分配或转移失败时，G1会首先尝试增加堆空间，如果扩容失败，则发起担保的Full GC。Full GC后，堆尺寸计算结果也会调整堆空间。</p>
<h3 id=分代模型>分代模型</h3>
<div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210501161710.png style=display:block;width:50% alt=NAME align=center> </div>
<h4 id=分代垃圾收集>分代垃圾收集</h4>
<p>分代垃圾收集可以将关注点集中在最近被分配的对象上，而无需整堆扫描，避免长命对象的拷贝，同时独立收集有助于降低响应时间。虽然分区使得内存分配不再要求紧凑的内存空间，但G1依然使用了分代的思想。与其他垃圾收集器类似，G1将内存在逻辑上划分为年轻代和老年代，其中年轻代又划分为Eden空间和Survivor空间。但年轻代空间并不是固定不变的，当现有年轻代分区占满时，JVM会分配新的空闲分区加入到年轻代空间。</p>
<p>整个年轻代内存会在初始空间<code>-XX:G1NewSizePercent</code>(默认整堆5%)与最大空间(默认60%)之间动态变化，且由参数目标暂停时间<code>-XX:MaxGCPauseMillis</code>(默认200ms)、需要扩缩容的大小以<code>-XX:G1MaxNewSizePercent</code>及分区的已记忆集合(RSet)计算得到。当然，G1依然可以设置固定的年轻代大小(参数-XX:NewRatio、-Xmn)，但同时暂停目标将失去意义。</p>
<h4 id=本地分配缓冲-local-allocation-buffer-lab>本地分配缓冲 Local allocation buffer (Lab)</h4>
<p>值得注意的是，由于分区的思想，每个线程均可以"认领"某个分区用于线程本地的内存分配，而不需要顾及分区是否连续。因此，每个应用线程和GC线程都会独立的使用分区，进而减少同步时间，提升GC效率，这个分区称为本地分配缓冲区(Lab)。</p>
<ul>
<li>其中，应用线程可以独占一个本地缓冲区(TLAB)来创建的对象，而大部分都会落入Eden区域(巨型对象或分配失败除外)，因此TLAB的分区属于Eden空间；</li>
<li>而每次垃圾收集时，每个GC线程同样可以独占一个本地缓冲区(GCLAB)用来转移对象，每次回收会将对象复制到Suvivor空间或老年代空间；</li>
<li>对于从Eden/Survivor空间晋升(Promotion)到Survivor/老年代空间的对象，同样有GC独占的本地缓冲区进行操作，该部分称为晋升本地缓冲区(PLAB)。</li>
</ul>
<h3 id=分区模型>分区模型</h3>
<div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210501161940.png style=display:block;width:50% alt=NAME align=center> </div>
<p>G1对内存的使用以分区(Region)为单位，而对对象的分配则以卡片(Card)为单位。</p>
<h4 id=巨形对象-humongous-region>巨形对象 Humongous Region</h4>
<p>一个大小达到甚至超过分区大小一半的对象称为巨型对象(Humongous Object)。当线程为巨型分配空间时，不能简单在TLAB进行分配，因为巨型对象的移动成本很高，而且有可能一个分区不能容纳巨型对象。因此，巨型对象会直接在老年代分配，所占用的连续空间称为巨型分区(Humongous Region)。G1内部做了一个优化，一旦发现没有引用指向巨型对象，则可直接在年轻代收集周期中被回收。</p>
<p>巨型对象会独占一个、或多个连续分区，其中第一个分区被标记为开始巨型(StartsHumongous)，相邻连续分区被标记为连续巨型(ContinuesHumongous)。由于无法享受TLab带来的优化，并且确定一片连续的内存空间需要扫描整堆，因此确定巨型对象开始位置的成本非常高，如果可以，应用程序应避免生成巨型对象。</p>
<h4 id=已记忆集合remember-set-rset>已记忆集合Remember Set (RSet)</h4>
<p>在串行和并行收集器中，GC通过整堆扫描，来确定对象是否处于可达路径中。然而G1为了避免STW式的整堆扫描，在每个分区记录了一个已记忆集合(RSet)，内部类似一个反向指针，记录引用分区内对象的卡片索引。当要回收该分区时，通过扫描分区的RSet，来确定引用本分区内的对象是否存活，进而确定本分区内的对象存活情况。</p>
<p>事实上，并非所有的引用都需要记录在RSet中，如果一个分区确定需要扫描，那么无需RSet也可以无遗漏的得到引用关系。那么引用源自本分区的对象，当然不用落入RSet中；同时，G1 GC每次都会对年轻代进行整体收集，因此引用源自年轻代的对象，也不需要在RSet中记录。最后只有老年代的分区可能会有RSet记录，这些分区称为拥有RSet分区(an RSet’s owning region)。</p>
<h4 id=per-region-table-prt>Per Region Table (PRT)</h4>
<p>RSet在内部使用Per Region Table(PRT)记录分区的引用情况。由于RSet的记录要占用分区的空间，如果一个分区非常"受欢迎"，那么RSet占用的空间会上升，从而降低分区的可用空间。G1应对这个问题采用了改变RSet的密度的方式，在PRT中将会以三种模式记录引用：</p>
<ul>
<li>稀少：直接记录引用对象的卡片索引</li>
<li>细粒度：记录引用对象的分区索引</li>
<li>粗粒度：只记录引用情况，每个分区对应一个比特位</li>
</ul>
<p>由上可知，粗粒度的PRT只是记录了引用数量，需要通过整堆扫描才能找出所有引用，因此扫描速度也是最慢的。</p>
<h3 id=收集集合-cset>收集集合 (CSet)</h3>
<div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210501162246.png style=display:block;width:50% alt=NAME align=center> </div>
<p>收集集合(CSet)代表每次GC暂停时回收的一系列目标分区。在任意一次收集暂停中，CSet所有分区都会被释放，内部存活的对象都会被转移到分配的空闲分区中。因此无论是年轻代收集，还是混合收集，工作的机制都是一致的。年轻代收集CSet只容纳年轻代分区，而混合收集会通过启发式算法，在老年代候选回收分区中，筛选出回收收益最高的分区添加到CSet中。</p>
<p>候选老年代分区的CSet准入条件，可以通过活跃度阈值-XX:G1MixedGCLiveThresholdPercent(默认85%)进行设置，从而拦截那些回收开销巨大的对象；同时，每次混合收集可以包含候选老年代分区，可根据CSet对堆的总大小占比-XX:G1OldCSetRegionThresholdPercent(默认10%)设置数量上限。</p>
<p>由上述可知，G1的收集都是根据CSet进行操作的，年轻代收集与混合收集没有明显的不同，最大的区别在于两种收集的触发条件。</p>
<h4 id=年轻代收集集合-cset-of-young-collection>年轻代收集集合 CSet of Young Collection</h4>
<p>应用线程不断活动后，年轻代空间会被逐渐填满。当JVM分配对象到Eden区域失败(Eden区已满)时，便会触发一次STW式的年轻代收集。在年轻代收集中，Eden分区存活的对象将被拷贝到Survivor分区；原有Survivor分区存活的对象，将根据任期阈值(tenuring threshold)分别晋升到PLAB中，新的survivor分区和老年代分区。而原有的年轻代分区将被整体回收掉。</p>
<p>同时，年轻代收集还负责维护对象的年龄(存活次数)，辅助判断老化(tenuring)对象晋升的时候是到Survivor分区还是到老年代分区。年轻代收集首先先将晋升对象尺寸总和、对象年龄信息维护到年龄表中，再根据年龄表、Survivor尺寸、Survivor填充容量-XX:TargetSurvivorRatio(默认50%)、最大任期阈值-XX:MaxTenuringThreshold(默认15)，计算出一个恰当的任期阈值，凡是超过任期阈值的对象都会被晋升到老年代。</p>
<h4 id=混合收集集合-cset-of-mixed-collection>混合收集集合 CSet of Mixed Collection</h4>
<p>年轻代收集不断活动后，老年代的空间也会被逐渐填充。当老年代占用空间超过整堆比IHOP阈值-XX:InitiatingHeapOccupancyPercent(默认45%)时，G1就会启动一次混合垃圾收集周期。为了满足暂停目标，G1可能不能一口气将所有的候选分区收集掉，因此G1可能会产生连续多次的混合收集与应用线程交替执行，每次STW的混合收集与年轻代收集过程相类似。</p>
<p>为了确定包含到年轻代收集集合CSet的老年代分区，JVM通过参数混合周期的最大总次数-XX:G1MixedGCCountTarget(默认8)、堆废物百分比-XX:G1HeapWastePercent(默认5%)。通过候选老年代分区总数与混合周期最大总次数，确定每次包含到CSet的最小分区数量；根据堆废物百分比，当收集达到参数时，不再启动新的混合收集。而每次添加到CSet的分区，则通过计算得到的GC效率进行安排。</p>
<h4 id=并发标记算法三色标记法>并发标记算法（三色标记法）</h4>
<p>CMS和G1在并发标记时使用的是同一个算法：三色标记法，使用白灰黑三种颜色标记对象。白色是未标记；灰色自身被标记，引用的对象未标记；黑色自身与引用对象都已标记。</p>
<div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210501162356.png style=display:block;width:50% alt=NAME align=center> </div>
<p>GC 开始前所有对象都是白色，GC 一开始所有根能够直达的对象被压到栈中，待搜索，此时颜色是灰色。然后灰色对象依次从栈中取出搜索子对象，子对象也会被涂为灰色，入栈。当其所有的子对象都涂为灰色之后该对象被涂为黑色。当 GC 结束之后灰色对象将全部没了，剩下黑色的为存活对象，白色的为垃圾。</p>
<div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/java-jvm-gc-g1-5-1.gif style=display:block;width:50% alt=NAME align=center> </div>
<h4 id=漏标问题>漏标问题</h4>
<p>在remark过程中，黑色指向了白色，如果不对黑色重新扫描，则会漏标。会把白色D对象当作没有新引用指向从而回收掉。</p>
<div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210501162606.png style=display:block;width:50% alt=NAME align=center> </div>
<p>并发标记过程中，Mutator删除了所有从灰色到白色的引用，会产生漏标。此时白色对象应该被回收</p>
<p>产生漏标问题的条件有两个：</p>
<ul>
<li>黑色对象指向了白色对象</li>
<li>灰色对象指向白色对象的引用消失</li>
</ul>
<p>所以要解决漏标问题，打破两个条件之一即可：</p>
<ul>
<li><strong>跟踪黑指向白的增加</strong> incremental update：增量更新，关注引用的增加，把黑色重新标记为灰色，下次重新扫描属性。CMS采用该方法。</li>
<li><strong>记录灰指向白的消失</strong> SATB snapshot at the beginning：关注引用的删除，当灰–>白消失时，要把这个 引用 推到GC的堆栈，保证白还能被GC扫描到。G1采用该方法。</li>
</ul>
<p><strong>为什么G1采用SATB而不用incremental update</strong>？</p>
<p>因为采用incremental update把黑色重新标记为灰色后，之前扫描过的还要再扫描一遍，效率太低。G1有RSet与SATB相配合。Card Table里记录了RSet，RSet里记录了其他对象指向自己的引用，这样就不需要再扫描其他区域，只要扫描RSet就可以了。</p>
<p>也就是说 灰色–>白色 引用消失时，如果没有 黑色–>白色，引用会被push到堆栈，下次扫描时拿到这个引用，由于有RSet的存在，不需要扫描整个堆去查找指向白色的引用，效率比较高。SATB配合RSet浑然天成。</p>
<h2 id=g1-的活动周期>G1 的活动周期</h2>
<h3 id=g1-垃圾收集活动汇总>G1 垃圾收集活动汇总</h3>
<div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210501162856.png style=display:block;width:80% alt=NAME align=center> </div>
<h3 id=rset-的维护>RSet 的维护</h3>
<p>由于不能整堆扫描，又需要计算分区确切的活跃度，因此，G1需要一个增量式的完全标记并发算法，通过维护RSet，得到准确的分区引用信息。在G1中，RSet的维护主要来源两个方面：写栅栏(Write Barrier)和并发优化线程(Concurrence Refinement Threads)。</p>
<h4 id=栅栏barrier>栅栏Barrier</h4>
<div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210501163002.png style=display:block;width:50% alt=NAME align=center> </div>
<p>我们首先介绍一下栅栏(Barrier)的概念。栅栏是指在原生代码片段中，当某些语句被执行时，栅栏代码也会被执行。而G1主要在赋值语句中，使用写前栅栏(Pre-Write Barrrier)和写后栅栏(Post-Write Barrrier)。事实上，写栅栏的指令序列开销非常昂贵，应用吞吐量也会根据栅栏复杂度而降低。</p>
<p><strong>写前栅栏 Pre-Write Barrrier</strong></p>
<p>即将执行一段赋值语句时，等式左侧对象将修改引用到另一个对象，那么等式左侧对象原先引用的对象所在分区将因此丧失一个引用，那么JVM就需要在赋值语句生效之前，记录丧失引用的对象。JVM并不会立即维护RSet，而是通过批量处理，在将来RSet更新(见SATB)。</p>
<p><strong>写后栅栏 Post-Write Barrrier</strong></p>
<p>当执行一段赋值语句后，等式右侧对象获取了左侧对象的引用，那么等式右侧对象所在分区的RSet也应该得到更新。同样为了降低开销，写后栅栏发生后，RSet也不会立即更新，同样只是记录此次更新日志，在将来批量处理(见Concurrence Refinement Threads)。</p>
<h4 id=起始快照算法snapshot-at-the-beginning-satb>起始快照算法Snapshot at the beginning (SATB)</h4>
<p>Taiichi Tuasa贡献的增量式完全并发标记算法起始快照算法(SATB)，主要针对标记-清除垃圾收集器的并发标记阶段，非常适合G1的分区块的堆结构，同时解决了CMS的主要烦恼：重新标记暂停时间长带来的潜在风险。</p>
<p>SATB会创建一个对象图，相当于堆的逻辑快照，从而确保并发标记阶段所有的垃圾对象都能通过快照被鉴别出来。当赋值语句发生时，应用将会改变了它的对象图，那么JVM需要记录被覆盖的对象。因此写前栅栏会在引用变更前，将值记录在SATB日志或缓冲区中。每个线程都会独占一个SATB缓冲区，初始有256条记录空间。当空间用尽时，线程会分配新的SATB缓冲区继续使用，而原有的缓冲去则加入全局列表中。最终在并发标记阶段，并发标记线程(Concurrent Marking Threads)在标记的同时，还会定期检查和处理全局缓冲区列表的记录，然后根据标记位图分片的标记位，扫描引用字段来更新RSet。此过程又称为并发标记/SATB写前栅栏。</p>
<h4 id=并发优化线程concurrence-refinement-threads>并发优化线程Concurrence Refinement Threads</h4>
<p>G1中使用基于Urs Hölzle的快速写栅栏，将栅栏开销缩减到2个额外的指令。栅栏将会更新一个card table type的结构来跟踪代间引用。</p>
<p>当赋值语句发生后，写后栅栏会先通过G1的过滤技术判断是否是跨分区的引用更新，并将跨分区更新对象的卡片加入缓冲区序列，即更新日志缓冲区或脏卡片队列。与SATB类似，一旦日志缓冲区用尽，则分配一个新的日志缓冲区，并将原来的缓冲区加入全局列表中。</p>
<p>并发优化线程(Concurrence Refinement Threads)，只专注扫描日志缓冲区记录的卡片来维护更新RSet，线程最大数目可通过<code>-XX:G1ConcRefinementThreads</code>(默认等于<code>-XX:ParellelGCThreads</code>)设置。并发优化线程永远是活跃的，一旦发现全局列表有记录存在，就开始并发处理。如果记录增长很快或者来不及处理，那么通过阈值<code>-X:G1ConcRefinementGreenZone/-XX:G1ConcRefinementYellowZone/-XX:G1ConcRefinementRedZone</code>，G1会用分层的方式调度，使更多的线程处理全局列表。如果并发优化线程也不能跟上缓冲区数量，则Mutator线程(Java应用线程)会挂起应用并被加进来帮助处理，直到全部处理完。因此，必须避免此类场景出现。</p>
<h3 id=并发标记周期-concurrent-marking-cycle>并发标记周期 Concurrent Marking Cycle</h3>
<p>并发标记周期是G1中非常重要的阶段，这个阶段将会为混合收集周期识别垃圾最多的老年代分区。整个周期完成根标记、识别所有(可能)存活对象，并计算每个分区的活跃度，从而确定GC效率等级。</p>
<p>当达到IHOP阈值<code>-XX:InitiatingHeapOccupancyPercent</code>(老年代占整堆比，默认45%)时，便会触发并发标记周期。整个并发标记周期将由初始标记(Initial Mark)、根分区扫描(Root Region Scanning)、并发标记(Concurrent Marking)、重新标记(Remark)、清除(Cleanup)几个阶段组成。其中，初始标记(随年轻代收集一起活动)、重新标记、清除是STW的，而并发标记如果来不及标记存活对象，则可能在并发标记过程中，G1又触发了几次年轻代收集。</p>
<h4 id=并发标记线程-concurrent-marking-threads>并发标记线程 Concurrent Marking Threads</h4>
<div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210501163119.png style=display:block;width:80% alt=NAME align=center> </div>
<p>要标记存活的对象，每个分区都需要创建位图(Bitmap)信息来存储标记数据，来确定标记周期内被分配的对象。G1采用了两个位图Previous Bitmap、Next Bitmap，来存储标记数据，Previous位图存储上次的标记数据，Next位图在标记周期内不断变化更新，同时Previous位图的标记数据也越来越过时，当标记周期结束后Next位图便替换Previous位图，成为上次标记的位图。同时，每个分区通过顶部开始标记(TAMS)，来记录已标记过的内存范围。同样的，G1使用了两个顶部开始标记Previous TAMS(PTAMS)、Next TAMS(NTAMS)，记录已标记的范围。</p>
<p>在并发标记阶段，G1会根据参数<code>-XX:ConcGCThreads</code>(默认GC线程数的1/4，即<code>-XX:ParallelGCThreads/4</code>)，分配并发标记线程(Concurrent Marking Threads)，进行标记活动。每个并发线程一次只扫描一个分区，并通过"手指"指针的方式优化获取分区。并发标记线程是爆发式的，在给定的时间段拼命干活，然后休息一段时间，再拼命干活。</p>
<p>每个并发标记周期，在初始标记STW的最后，G1会分配一个空的Next位图和一个指向分区顶部(Top)的NTAMS标记。Previous位图记录的上次标记数据，上次的标记位置，即PTAMS，在PTAMS与分区底部(Bottom)的范围内，所有的存活对象都已被标记。那么，在PTAMS与Top之间的对象都将是隐式存活(Implicitly Live)对象。在并发标记阶段，Next位图吸收了Previous位图的标记数据，同时每个分区都会有新的对象分配，则Top与NTAMS分离，前往更高的地址空间。在并发标记的一次标记中，并发标记线程将找出NTAMS与PTAMS之间的所有存活对象，将标记数据存储在Next位图中。同时，在NTAMS与Top之间的对象即成为已标记对象。如此不断地更新Next位图信息，并在清除阶段与Previous位图交换角色。</p>
<h4 id=初始标记-initial-mark>初始标记 Initial Mark</h4>
<p>初始标记(Initial Mark)负责标记所有能被直接可达的根对象(原生栈对象、全局对象、JNI对象)，根是对象图的起点，因此初始标记需要将Mutator线程(Java应用线程)暂停掉，也就是需要一个STW的时间段。事实上，当达到IHOP阈值时，G1并不会立即发起并发标记周期，而是等待下一次年轻代收集，利用年轻代收集的STW时间段，完成初始标记，这种方式称为借道(Piggybacking)。在初始标记暂停中，分区的NTAMS都被设置到分区顶部Top，初始标记是并发执行，直到所有的分区处理完。</p>
<h4 id=根分区扫描-root-region-scanning>根分区扫描 Root Region Scanning</h4>
<p>在初始标记暂停结束后，年轻代收集也完成的对象复制到Survivor的工作，应用线程开始活跃起来。此时为了保证标记算法的正确性，所有新复制到Survivor分区的对象，都需要被扫描并标记成根，这个过程称为根分区扫描(Root Region Scanning)，同时扫描的Suvivor分区也被称为根分区(Root Region)。根分区扫描必须在下一次年轻代垃圾收集启动前完成(并发标记的过程中，可能会被若干次年轻代垃圾收集打断)，因为每次GC会产生新的存活对象集合。</p>
<h4 id=并发标记-concurrent-marking>并发标记 Concurrent Marking</h4>
<p>和应用线程并发执行，并发标记线程在并发标记阶段启动，由参数<code>-XX:ConcGCThreads</code>(默认GC线程数的1/4，即<code>-XX:ParallelGCThreads/4</code>)控制启动数量，每个线程每次只扫描一个分区，从而标记出存活对象图。在这一阶段会处理Previous/Next标记位图，扫描标记对象的引用字段。同时，并发标记线程还会定期检查和处理STAB全局缓冲区列表的记录，更新对象引用信息。参数<code>-XX:+ClassUnloadingWithConcurrentMark</code>会开启一个优化，如果一个类不可达(不是对象不可达)，则在重新标记阶段，这个类就会被直接卸载。所有的标记任务必须在堆满前就完成扫描，如果并发标记耗时很长，那么有可能在并发标记过程中，又经历了几次年轻代收集。如果堆满前没有完成标记任务，则会触发担保机制，经历一次长时间的串行Full GC。</p>
<h4 id=存活数据计算-live-data-accounting>存活数据计算 Live Data Accounting</h4>
<p>存活数据计算(Live Data Accounting)是标记操作的附加产物，只要一个对象被标记，同时会被计算字节数，并计入分区空间。只有NTAMS以下的对象会被标记和计算，在标记周期的最后，Next位图将被清空，等待下次标记周期。</p>
<h4 id=重新标记-remark>重新标记 Remark</h4>
<p>重新标记(Remark)是最后一个标记阶段。在该阶段中，G1需要一个暂停的时间，去处理剩下的SATB日志缓冲区和所有更新，找出所有未被访问的存活对象，同时安全完成存活数据计算。这个阶段也是并行执行的，通过参数-XX:ParallelGCThread可设置GC暂停时可用的GC线程数。同时，引用处理也是重新标记阶段的一部分，所有重度使用引用对象(弱引用、软引用、虚引用、最终引用)的应用都会在引用处理上产生开销。</p>
<h4 id=清除-cleanup>清除 Cleanup</h4>
<p>紧挨着重新标记阶段的清除(Clean)阶段也是STW的。Previous/Next标记位图、以及PTAMS/NTAMS，都会在清除阶段交换角色。清除阶段主要执行以下操作：</p>
<ul>
<li><strong>RSet梳理</strong>，启发式算法会根据活跃度和RSet尺寸对分区定义不同等级，同时RSet数理也有助于发现无用的引用。参数<code>-XX:+PrintAdaptiveSizePolicy</code>可以开启打印启发式算法决策细节；</li>
<li><strong>整理堆分区</strong>，为混合收集周期识别回收收益高(基于释放空间和暂停目标)的老年代分区集合；</li>
<li><strong>识别所有空闲分区</strong>，即发现无存活对象的分区。该分区可在清除阶段直接回收，无需等待下次收集周期。</li>
</ul>
<h3 id=年轻代收集混合收集周期>年轻代收集/混合收集周期</h3>
<p>年轻代收集和混合收集周期，是G1回收空间的主要活动。当应用运行开始时，堆内存可用空间还比较大，只会在年轻代满时，触发年轻代收集；随着老年代内存增长，当到达IHOP阈值<code>-XX:InitiatingHeapOccupancyPercent</code>(老年代占整堆比，默认45%)时，G1开始着手准备收集老年代空间。首先经历并发标记周期，识别出高收益的老年代分区，前文已述。但随后G1并不会马上开始一次混合收集，而是让应用线程先运行一段时间，等待触发一次年轻代收集。在这次STW中，G1将保准整理混合收集周期。接着再次让应用线程运行，当接下来的几次年轻代收集时，将会有老年代分区加入到CSet中，即触发混合收集，这些连续多次的混合收集称为混合收集周期(Mixed Collection Cycle)。</p>
<h4 id=gc工作线程数>GC工作线程数</h4>
<p>GC工作线程数 <code>-XX:ParallelGCThreads</code></p>
<p>JVM可以通过参数<code>-XX:ParallelGCThreads</code>进行指定GC工作的线程数量。参数<code>-XX:ParallelGCThreads</code>默认值并不是固定的，而是根据当前的CPU资源进行计算。如果用户没有指定，且CPU小于等于8，则默认与CPU核数相等；若CPU大于8，则默认JVM会经过计算得到一个小于CPU核数的线程数；当然也可以人工指定与CPU核数相等。</p>
<h4 id=年轻代收集-young-collection>年轻代收集 Young Collection</h4>
<p>每次收集过程中，既有并行执行的活动，也有串行执行的活动，但都可以是多线程的。在并行执行的任务中，如果某个任务过重，会导致其他线程在等待某项任务的处理，需要对这些地方进行优化。</p>
<p><strong>并行活动</strong></p>
<ul>
<li><code>外部根分区扫描 Ext Root Scanning</code>：此活动对堆外的根(JVM系统目录、VM数据结构、JNI线程句柄、硬件寄存器、全局变量、线程对栈根)进行扫描，发现那些没有加入到暂停收集集合CSet中的对象。如果系统目录(单根)拥有大量加载的类，最终可能其他并行活动结束后，该活动依然没有结束而带来的等待时间。</li>
<li><code>更新已记忆集合 Update RS</code>：并发优化线程会对脏卡片的分区进行扫描更新日志缓冲区来更新RSet，但只会处理全局缓冲列表。作为补充，所有被记录但是还没有被优化线程处理的剩余缓冲区，会在该阶段处理，变成已处理缓冲区(Processed Buffers)。为了限制花在更新RSet的时间，可以设置暂停占用百分比-XX:G1RSetUpdatingPauseTimePercent(默认10%，即-XX:MaxGCPauseMills/10)。值得注意的是，如果更新日志缓冲区更新的任务不降低，单纯地减少RSet的更新时间，会导致暂停中被处理的缓冲区减少，将日志缓冲区更新工作推到并发优化线程上，从而增加对Java应用线程资源的争夺。</li>
<li><code>RSet扫描 Scan RS</code>：在收集当前CSet之前，考虑到分区外的引用，必须扫描CSet分区的RSet。如果RSet发生粗化，则会增加RSet的扫描时间。开启诊断模式-XX:UnlockDiagnosticVMOptions后，通过参数-XX:+G1SummarizeRSetStats可以确定并发优化线程是否能够及时处理更新日志缓冲区，并提供更多的信息，来帮助为RSet粗化总数提供窗口。参数-XX：G1SummarizeRSetStatsPeriod=n可设置RSet的统计周期，即经历多少此GC后进行一次统计</li>
<li><code>代码根扫描 Code Root Scanning</code>：对代码根集合进行扫描，扫描JVM编译后代码Native Method的引用信息(nmethod扫描)，进行RSet扫描。事实上，只有CSet分区中的RSet有强代码根时，才会做nmethod扫描，查找对CSet的引用。</li>
<li><code>转移和回收 Object Copy</code>：通过选定的CSet以及CSet分区完整的引用集，将执行暂停时间的主要部分：CSet分区存活对象的转移、CSet分区空间的回收。通过工作窃取机制来负载均衡地选定复制对象的线程，并且复制和扫描对象被转移的存活对象将拷贝到每个GC线程分配缓冲区GCLAB。G1会通过计算，预测分区复制所花费的时间，从而调整年轻代的尺寸。</li>
<li><code>终止 Termination</code>：完成上述任务后，如果任务队列已空，则工作线程会发起终止要求。如果还有其他线程继续工作，空闲的线程会通过工作窃取机制尝试帮助其他线程处理。而单独执行根分区扫描的线程，如果任务过重，最终会晚于终止。</li>
<li><code>GC外部的并行活动 GC Worker Other</code>：该部分并非GC的活动，而是JVM的活动导致占用了GC暂停时间(例如JNI编译)。</li>
</ul>
<p><strong>串行活动</strong></p>
<ul>
<li><code>代码根更新 Code Root Fixup</code>：根据转移对象更新代码根。</li>
<li><code>代码根清理 Code Root Purge</code>：清理代码根集合表。</li>
<li><code>清除全局卡片标记 Clear CT</code>：在任意收集周期会扫描CSet与RSet记录的PRT，扫描时会在全局卡片表中进行标记，防止重复扫描。在收集周期的最后将会清除全局卡片表中的已扫描标志。</li>
<li><code>选择下次收集集合 Choose CSet</code>：该部分主要用于并发标记周期后的年轻代收集、以及混合收集中，在这些收集过程中，由于有老年代候选分区的加入，往往需要对下次收集的范围做出界定；但单纯的年轻代收集中，所有收集的分区都会被收集，不存在选择。</li>
<li><code>引用处理 Ref Proc</code>：主要针对软引用、弱引用、虚引用、final引用、JNI引用。当Ref Proc占用时间过多时，可选择使用参数<code>-XX:ParallelRefProcEnabled</code>激活多线程引用处理。G1希望应用能小心使用软引用，因为软引用会一直占据内存空间直到空间耗尽时被Full GC回收掉；即使未发生Full GC，软引用对内存的占用，也会导致GC次数的增加。</li>
<li><code>引用排队 Ref Enq</code>：此项活动可能会导致RSet的更新，此时会通过记录日志，将关联的卡片标记为脏卡片。</li>
<li><code>卡片重新脏化 Redirty Cards</code>：重新脏化卡片。</li>
<li><code>回收空闲巨型分区 Humongous Reclaim</code>：G1做了一个优化：通过查看所有根对象以及年轻代分区的RSet，如果确定RSet中巨型对象没有任何引用，则说明G1发现了一个不可达的巨型对象，该对象分区会被回收。</li>
<li><code>释放分区 Free CSet</code>：回收CSet分区的所有空间，并加入到空闲分区中。</li>
<li><code>其他活动 Other</code>：GC中可能还会经历其他耗时很小的活动，如修复JNI句柄等。</li>
</ul>
<h3 id=并发标记周期后的年轻代收集-young-collection-following-concurrent-marking-cycle>并发标记周期后的年轻代收集 Young Collection Following Concurrent Marking Cycle</h3>
<p>当G1发起并发标记周期之后，并不会马上开始混合收集。G1会先等待下一次年轻代收集，然后在该收集阶段中，确定下次混合收集的CSet(Choose CSet)。</p>
<h4 id=混合收集周期-mixed-collection-cycle>混合收集周期 Mixed Collection Cycle</h4>
<p>单次的混合收集与年轻代收集并无二致。根据暂停目标，老年代的分区可能不能一次暂停收集中被处理完，G1会发起连续多次的混合收集，称为混合收集周期(Mixed Collection Cycle)。G1会计算每次加入到CSet中的分区数量、混合收集进行次数，并且在上次的年轻代收集、以及接下来的混合收集中，G1会确定下次加入CSet的分区集(Choose CSet)，并且确定是否结束混合收集周期。</p>
<h4 id=转移失败的担保机制-full-gc>转移失败的担保机制 Full GC</h4>
<p>转移失败(Evacuation Failure)是指当G1无法在堆空间中申请新的分区时，G1便会触发担保机制，执行一次STW式的、单线程的Full GC。Full GC会对整堆做标记清除和压缩，最后将只包含纯粹的存活对象。参数-XX:G1ReservePercent(默认10%)可以保留空间，来应对晋升模式下的异常情况，最大占用整堆50%，更大也无意义。</p>
<p>G1在以下场景中会触发Full GC，同时会在日志中记录to-space-exhausted以及Evacuation Failure：</p>
<ul>
<li>从年轻代分区拷贝存活对象时，无法找到可用的空闲分区</li>
<li>从老年代分区转移存活对象时，无法找到可用的空闲分区</li>
<li>分配巨型对象时在老年代无法找到足够的连续分区</li>
</ul>
<p>由于G1的应用场合往往堆内存都比较大，所以Full GC的收集代价非常昂贵，应该避免Full GC的发生。</p>
<h2 id=总结>总结</h2>
<p>G1是一款非常优秀的垃圾收集器，不仅适合堆内存大的应用，同时也简化了调优的工作。通过主要的参数初始和最大堆空间、以及最大容忍的GC暂停目标，就能得到不错的性能；同时，我们也看到G1对内存空间的浪费较高，但通过<strong>首先收集尽可能多的垃圾</strong>(Garbage First)的设计原则，可以及时发现过期对象，从而让内存占用处于合理的水平。</p>
<p>虽然G1也有类似CMS的收集动作：初始标记、并发标记、重新标记、清除、转移回收，并且也以一个串行收集器做担保机制，但单纯地以类似前三种的过程描述显得并不是很妥当。</p>
<ul>
<li>G1的设计原则是"<strong>首先收集尽可能多的垃圾</strong>(Garbage First)"。因此，G1并不会等内存耗尽(串行、并行)或者快耗尽(CMS)的时候开始垃圾收集，而是在内部采用了启发式算法，在老年代找出具有高收集收益的分区进行收集。同时G1可以根据用户设置的暂停时间目标自动调整年轻代和总堆大小，暂停目标越短年轻代空间越小、总空间就越大；</li>
<li>G1采用内存分区(Region)的思路，将内存划分为一个个相等大小的内存分区，回收时则以分区为单位进行回收，存活的对象复制到另一个空闲分区中。由于都是以相等大小的分区为单位进行操作，因此G1天然就是一种压缩方案(局部压缩)；</li>
<li>G1虽然也是分代收集器，但整个内存分区不存在物理上的年轻代与老年代的区别，也不需要完全独立的survivor(to space)堆做复制准备。G1只有逻辑上的分代概念，或者说每个分区都可能随G1的运行在不同代之间前后切换；</li>
<li>G1的收集都是STW的，但年轻代和老年代的收集界限比较模糊，采用了混合(mixed)收集的方式。即每次收集既可能只收集年轻代分区(年轻代收集)，也可能在收集年轻代的同时，包含部分老年代分区(混合收集)，这样即使堆内存很大时，也可以限制收集范围，从而降低停顿。</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-6983a235393b24ffee7070ac7d663d23>9 - CH09-JVM-ZGC</h1>
<ul>
<li><a href=https://tech.meituan.com/2020/08/06/new-zgc-practice-in-meituan.html>https://tech.meituan.com/2020/08/06/new-zgc-practice-in-meituan.html</a></li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-f194418061ea5558c2acd97b857a5023>10 - CH10-JVM调优参数</h1>
<h2 id=jvm-参数>JVM 参数</h2>
<ul>
<li><code>-Xms</code>：堆的最小值</li>
<li><code>-Xmx</code>：堆的最大值
<ul>
<li>通常与 <code>-Xms</code> 相同以避免空间不足时动态扩容带来的影响</li>
</ul>
</li>
<li><code>-Xmn</code>：新生代大小</li>
<li><code>-Xss</code>：每个线程的堆栈大小
<ul>
<li>JDK 5 以上每个每个线程堆栈为 1M，之前是 256KB</li>
<li>相同物理内存下，减少该值可以增加线程数量，但仍受 OS 限制</li>
</ul>
</li>
<li><code>-XX:NewRatio</code>：新生代与老年代比值
<ul>
<li>4 表示新生代比老年代为 <code>1:4</code>，新生代占堆的 1/5，与 <code>-Xmn</code> 作用类似</li>
</ul>
</li>
<li><code>-XX:Persize</code>：元空间初始值，默认是物理空间的 1/64</li>
<li><code>-XX:MaxPermSize</code>：元空间最大值，默认是物理空间 1/4</li>
<li><code>-XX:MaxTenuringThreshold</code>：新生代对象年龄，默认 15
<ul>
<li>若对象在伊甸园，经过 Minor GC 还活着，则年龄 +1，移动到幸存区</li>
<li>如果在幸存区，每次 Minor GC 还活着，年龄+1</li>
<li>到达 15 或移动到老年代</li>
</ul>
</li>
<li><code>-XX:SurvivorRatio</code>：伊甸园与幸存区的比值，默认为 8
<ul>
<li>两个幸存区与一个伊甸园的比值为 <code>2:8</code></li>
<li>每个幸存区占新生代的 1/10</li>
</ul>
</li>
<li><code>-XX:+UseFastAccessorMethods</code>：原始类型快速优化</li>
<li><code>-XX:+AggressiveOpts</code>：编译速度加快</li>
<li><code>-XX:PretenureSizeThreshold</code>：大对象直接分配在老年代的阈值</li>
</ul>
<h3 id=实践>实践</h3>
<ul>
<li>整个堆大小的计算公式: JVM 堆大小 ＝ 年轻代大小＋年老代大小＋元空间大小。</li>
<li>增大新生代大小就会减少对应的年老代大小，设置-Xmn值对系统性能影响较大，所以如果设置新生代大小的调整，则需要严格的测试调整。而新生代是用来存放新创建的对象，大小是随着堆大小增大和减少而有相应的变化，默认值是保持堆大小的十五分之一，-Xmn参数就是设置新生代的大小，也可以通过-XX:NewRatio来设置新生代与年老代的比例，java 官方推荐配置为3:8。</li>
<li>新生代的特点就是内存中的对象更新速度快，在短时间内容易产生大量的无用对象，如果在这个参数时就需要考虑垃圾回收器设置参数也需要调整。
<ul>
<li>推荐使用: 复制清除算法和并行收集器进行垃圾回收，而新生代的垃圾回收叫做初级回收。</li>
</ul>
</li>
<li>StackOverflowError和OutOfMemoryException。
<ul>
<li>当线程中的请求的栈的深度大于最大可用深度，就会抛出前者；</li>
<li>若内存空间不够，无法创建新的线程，则会抛出后者。</li>
<li>栈的大小直接决定了函数的调用最大深度，栈越大，函数嵌套可调用次数就越多。</li>
</ul>
</li>
</ul>
<h3 id=经验值>经验值</h3>
<ol>
<li>Xmn用于设置新生代的大小。过小会增加Minor GC频率，过大会减小老年代的大小。一般设为整个堆空间的1/4或1/3.</li>
<li>XX:SurvivorRatio用于设置新生代中survivor空间(from/to)和eden空间的大小比例； XX:TargetSurvivorRatio表示，当经历Minor GC后，survivor空间占有量(百分比)超过它的时候，就会压缩进入老年代(当然，如果survivor空间不够，则直接进入老年代)。默认值为50%。</li>
<li>为了性能考虑，一开始尽量将新生代对象留在新生代，避免新生的大对象直接进入老年代。因为新生对象大部分都是短期的，这就造成了老年代的内存浪费，并且回收代价也高(Full GC发生在老年代和方法区Perm).</li>
<li>当Xms=Xmx，可以使得堆相对稳定，避免不停震荡</li>
<li>一般来说，MaxPermSize设为64MB可以满足绝大多数的应用了。若依然出现方法区溢出，则可以设为128MB。若128MB还不能满足需求，那么就应该考虑程序优化了，减少<strong>动态类</strong>的产生。</li>
</ol>
<h2 id=垃圾回收>垃圾回收</h2>
<p><strong>垃圾回收算法</strong> :</p>
<ul>
<li>引用计数法: 会有循环引用的问题，古老的方法；</li>
<li>Mark-Sweep: 标记清除。根可达判断，最大的问题是空间碎片(清除垃圾之后剩下不连续的内存空间)；</li>
<li>Copying: 复制算法。对于短命对象来说有用，否则需要复制大量的对象，效率低。<strong>如Java的新生代堆空间中就是使用了它(survivor空间的from和to区)；</strong></li>
<li>Mark-Compact: 标记整理。对于老年对象来说有用，无需复制，不会产生内存碎片</li>
</ul>
<p><strong>GC考虑的指标</strong></p>
<ul>
<li>吞吐量: 应用耗时和实际耗时的比值；</li>
<li>停顿时间: 垃圾回收的时候，由于Stop the World，应用程序的所有线程会挂起，造成应用停顿。</li>
</ul>
<blockquote>
<ul>
<li>吞吐量和停顿时间是互斥的。</li>
<li>对于后端服务(比如后台计算任务)，吞吐量优先考虑(并行垃圾回收)；</li>
<li>对于前端应用，RT响应时间优先考虑，减少垃圾收集时的停顿时间，适用场景是Web系统(并发垃圾回收)</li>
</ul>
</blockquote>
<h3 id=垃圾收集器参数>垃圾收集器参数</h3>
<ul>
<li><code>-XX:+UseSerialGC</code>：串行垃圾回收，现在基本很少使用。</li>
<li><code>-XX:+UseParNewGC</code>：新生代使用并行，老年代使用串行；</li>
<li><code>-XX:+UseConcMarkSweepGC</code>：新生代使用并行，老年代使用CMS
<ul>
<li>CMS是Concurrent Mark Sweep的缩写，并发标记清除，一看就是老年代的算法，所以，它可以作为老年代的垃圾回收器。</li>
<li>CMS不是独占式的，它关注停顿时间</li>
</ul>
</li>
<li><code>-XX:ParallelGCThreads</code>：指定并行的垃圾回收线程的数量，最好等于CPU数量</li>
<li><code>-XX:+DisableExplicitGC</code>：禁用System.gc()，因为它会触发Full GC，这是很浪费性能的，JVM会在需要GC的时候自己触发GC。</li>
<li><code>-XX:CMSFullGCsBeforeCompaction</code>：在多少次GC后进行内存压缩，这个是因为并行收集器不对内存空间进行压缩的，所以运行一段时间后会产生很多碎片，使得运行效率降低。</li>
<li><code>-XX:+CMSParallelRemarkEnabled</code>：降低标记停顿</li>
<li><code>-XX:+UseCMSCompactAtFullCollection</code>：在每一次Full GC时对老年代区域碎片整理，因为CMS是不会移动内存的，因此会非常容易出现碎片导致内存不够用的</li>
<li><code>-XX:+UseCmsInitiatingOccupancyOnly</code>：使用手动触发或者自定义触发cms 收集，同时也会禁止hostspot 自行触发CMS GC</li>
<li><code>-XX:CMSInitiatingOccupancyFraction</code>：使用CMS作为垃圾回收，使用70%后开始CMS收集</li>
<li><code>-XX:CMSInitiatingPermOccupancyFraction</code>：设置perm gen使用达到多少％比时触发垃圾回收，默认是92%</li>
<li><code>-XX:+CMSIncrementalMode</code>：设置为增量模式</li>
<li><code>-XX:+CmsClassUnloadingEnabled</code>：CMS是不会默认对永久代进行垃圾回收的，设置此参数则是开启</li>
<li><code>-XX:+PrintGCDetails</code>：开启详细GC日志模式，日志的格式是和所使用的算法有关</li>
<li><code>-XX:+PrintGCDateStamps</code>将时间和日期也加入到GC日志中</li>
</ul>
<h2 id=jdk-默认收集器>JDK 默认收集器</h2>
<blockquote>
<p><code>java -XX:+PrintCommandLineFlags -version</code> 查看当前 Java 的启动参数</p>
</blockquote>
<ul>
<li>Java 7 - Parallel GC</li>
<li>Java 8 - Parallel GC
<ul>
<li>年轻代：Parallel Scavenge</li>
<li>老年代：Parellel Old</li>
</ul>
</li>
<li>Java 9 - G1 GC</li>
<li>Java 10 - G1 GC</li>
<li>Java 11 - G1 GC</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-e19d55b8cead9eccdf89a99ddc2a0c6b>11 - CH11-JVM-OOM</h1>
<h2 id=堆内存溢出>堆内存溢出</h2>
<ul>
<li>
<p>在 Java 堆中只要不断的创建对象，并且 <code>GC-Roots</code> 到对象之间存在引用链，这样 <code>JVM</code> 就不会回收对象。</p>
</li>
<li>
<p>只要将<code>-Xms(最小堆)</code>,<code>-Xmx(最大堆)</code> 设置为一样禁止自动扩展堆内存。</p>
</li>
<li>
<p>当使用一个 <code>while(true)</code> 循环来不断创建对象就会发生 <code>OutOfMemory</code>，还可以使用 <code>-XX:+HeapDumpOutofMemoryErorr</code> 当发生 OOM 时会自动 dump 堆栈到文件中。</p>
</li>
<li>
<p>当出现 OOM 时可以通过工具(如 JProfiler)来分析 <code>GC-Roots</code> ，查看对象和 <code>GC-Roots</code> 是如何进行关联的，是否存在对象的生命周期过长，或者是这些对象确实改存在的，那就要考虑将堆内存调大了。</p>
</li>
</ul>
<h2 id=元空间溢出>元空间溢出</h2>
<blockquote>
<p><code>JDK8</code> 中将永久代移除，使用 <code>MetaSpace</code> 来保存类加载之后的类信息，字符串常量池也被移动到 Java 堆。</p>
</blockquote>
<ul>
<li>JDK 8 中将类信息移到到了本地堆内存(Native Heap)中，将原有的永久代移动到了本地堆中成为 <code>MetaSpace</code> ,如果不指定该区域的大小，JVM 将会动态的调整。</li>
<li>可以使用 <code>-XX:MaxMetaspaceSize=10M</code> 来限制最大元数据。这样当不停的创建类时将会占满该区域并出现 <code>OOM</code>。</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-fe6406617d166593ccc3396d0d3c028a>12 - CH12-JVM线程Dump</h1>
<h2 id=概览>概览</h2>
<h3 id=什么是thread-dump>什么是Thread Dump</h3>
<p>每一个Java虚拟机都有及时生成所有线程在某一点状态的thread-dump的能力，虽然各个 Java虚拟机打印的thread dump略有不同，但是 大多都提供了当前活动线程的快照，及JVM中所有Java线程的堆栈跟踪信息，堆栈信息一般包含完整的类名及所执行的方法，如果可能的话还有源代码的行数。</p>
<h3 id=thread-dump特点>Thread Dump特点</h3>
<ul>
<li>能在各种操作系统下使用；</li>
<li>能在各种Java应用服务器下使用；</li>
<li>能在生产环境下使用而不影响系统的性能；</li>
<li>能将问题直接定位到应用程序的代码行上；</li>
</ul>
<h3 id=thread-dump-抓取>Thread Dump 抓取</h3>
<p>一般当服务器挂起，崩溃或者性能低下时，就需要抓取服务器的线程堆栈（Thread Dump）用于后续的分析。在实际运行中，往往一次 dump的信息，还不足以确认问题。为了反映线程状态的动态变化，需要接连多次做thread dump，每次间隔10-20s，建议至少产生三次 dump信息，如果每次 dump都指向同一个问题，我们才确定问题的典型性。</p>
<ul>
<li>获取 Java 进程 PID：<code>jps -l</code></li>
<li>获取 Java 进程 Thread Dump：<code>jstack [-l] &lt;pid> | tee -a jstack.log</code></li>
</ul>
<h2 id=thread-dump-分析>Thread Dump 分析</h2>
<h3 id=信息结构>信息结构</h3>
<ul>
<li>头部信息：时间，JVM信息</li>
</ul>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>2011-11-02 19:05:06  
Full thread dump Java HotSpot<span style=color:#ce5c00;font-weight:700>(</span>TM<span style=color:#ce5c00;font-weight:700>)</span> Server VM <span style=color:#ce5c00;font-weight:700>(</span>16.3-b01 mixed mode<span style=color:#ce5c00;font-weight:700>)</span>: 
</code></pre></div><ul>
<li>线程INFO信息块：</li>
</ul>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>1. <span style=color:#4e9a06>&#34;Timer-0&#34;</span> daemon <span style=color:#000>prio</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#0000cf;font-weight:700>10</span> <span style=color:#000>tid</span><span style=color:#ce5c00;font-weight:700>=</span>0xac190c00 <span style=color:#000>nid</span><span style=color:#ce5c00;font-weight:700>=</span>0xaef in Object.wait<span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>[</span>0xae77d000<span style=color:#ce5c00;font-weight:700>]</span> 
<span style=color:#8f5902;font-style:italic># 线程名称：Timer-0；线程类型：daemon；优先级: 10，默认是5；</span>
<span style=color:#8f5902;font-style:italic># JVM线程id：tid=0xac190c00，JVM内部线程的唯一标识（通过java.lang.Thread.getId()获取，通常用自增方式实现）。</span>
<span style=color:#8f5902;font-style:italic># 对应系统线程id（NativeThread ID）：nid=0xaef，和top命令查看的线程pid对应，不过一个是10进制，一个是16进制。（通过命令：top -H -p pid，可以查看该进程的所有线程信息）</span>
<span style=color:#8f5902;font-style:italic># 线程状态：in Object.wait()；</span>
<span style=color:#8f5902;font-style:italic># 起始栈地址：[0xae77d000]，对象的内存地址，通过JVM内存查看工具，能够看出线程是在哪儿个对象上等待；</span>
2.  java.lang.Thread.State: TIMED_WAITING <span style=color:#ce5c00;font-weight:700>(</span>on object monitor<span style=color:#ce5c00;font-weight:700>)</span>
3.  at java.lang.Object.wait<span style=color:#ce5c00;font-weight:700>(</span>Native Method<span style=color:#ce5c00;font-weight:700>)</span>
4.  -waiting on &lt;0xb3885f60&gt; <span style=color:#ce5c00;font-weight:700>(</span>a java.util.TaskQueue<span style=color:#ce5c00;font-weight:700>)</span>     <span style=color:#8f5902;font-style:italic># 继续wait </span>
5.  at java.util.TimerThread.mainLoop<span style=color:#ce5c00;font-weight:700>(</span>Timer.java:509<span style=color:#ce5c00;font-weight:700>)</span>
6.  -locked &lt;0xb3885f60&gt; <span style=color:#ce5c00;font-weight:700>(</span>a java.util.TaskQueue<span style=color:#ce5c00;font-weight:700>)</span>         <span style=color:#8f5902;font-style:italic># 已经locked</span>
7.  at java.util.TimerThread.run<span style=color:#ce5c00;font-weight:700>(</span>Timer.java:462<span style=color:#ce5c00;font-weight:700>)</span>
Java thread statck trace：是上面2-7行的信息。到目前为止这是最重要的数据，Java stack trace提供了大部分信息来精确定位问题根源。
</code></pre></div><p><strong>堆栈信息应该逆向解读</strong>：程序先执行的是第7行，然后是第6行，依次类推。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback>- locked &lt;0xb3885f60&gt; (a java.util.ArrayList)
- waiting on &lt;0xb3885f60&gt; (a java.util.ArrayList) 
</code></pre></div><p><strong>也就是说对象先上锁，锁住对象0xb3885f60，然后释放该对象锁，进入waiting状态</strong>。为啥会出现这样的情况呢？看看下面的java代码示例，就会明白：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback>synchronized(obj) {  
   .........  
   obj.wait();  
   .........  
}
</code></pre></div><p>如上，线程的执行过程，先用 <code>synchronized</code> 获得了这个对象的 Monitor（对应于 <code>locked &lt;0xb3885f60></code> ）。当执行到 <code>obj.wait()</code>，线程即放弃了 Monitor的所有权，进入 “wait set”队列（对应于 <code>waiting on &lt;0xb3885f60></code> ）。</p>
<p><strong>在堆栈的第一行信息中，进一步标明了线程在代码级的状态</strong>，例如：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback>java.lang.Thread.State: TIMED_WAITING (parking)
</code></pre></div><p>参考线程的状态说明：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback>|blocked|

&gt; This thread tried to enter asynchronized block, but the lock was taken by another thread. This thread isblocked until the lock gets released.

|blocked (on thin lock)|

&gt; This is the same state asblocked, but the lock in question is a thin lock.

|waiting|

&gt; This thread calledObject.wait() on an object. The thread will remain there until some otherthread sends a notification to that object.

|sleeping|

&gt; This thread calledjava.lang.Thread.sleep().

|parked|

&gt; This thread calledjava.util.concurrent.locks.LockSupport.park().

|suspended|

&gt; The thread&#39;s execution wassuspended by java.lang.Thread.suspend() or a JVMTI agent call.
</code></pre></div><h3 id=thread-状态分析>Thread 状态分析</h3>
<p>线程的状态是一个很重要的东西，因此thread dump中会显示这些状态，通过对这些状态的分析，能够得出线程的运行状况，进而发现可能存在的问题。<strong>线程的状态在Thread.State这个枚举类型中定义</strong>：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>enum</span> <span style=color:#000>State</span>   
<span style=color:#ce5c00;font-weight:700>{</span>  
     <span style=color:#8f5902;font-style:italic>/** 
</span><span style=color:#8f5902;font-style:italic>      * Thread state for a thread which has not yet started. 
</span><span style=color:#8f5902;font-style:italic>      */</span>  
     <span style=color:#000>NEW</span><span style=color:#ce5c00;font-weight:700>,</span>  

     <span style=color:#8f5902;font-style:italic>/** 
</span><span style=color:#8f5902;font-style:italic>      * Thread state for a runnable thread.  A thread in the runnable 
</span><span style=color:#8f5902;font-style:italic>      * state is executing in the Java virtual machine but it may 
</span><span style=color:#8f5902;font-style:italic>      * be waiting for other resources from the operating system 
</span><span style=color:#8f5902;font-style:italic>      * such as processor. 
</span><span style=color:#8f5902;font-style:italic>      */</span>  
     <span style=color:#000>RUNNABLE</span><span style=color:#ce5c00;font-weight:700>,</span>  

     <span style=color:#8f5902;font-style:italic>/** 
</span><span style=color:#8f5902;font-style:italic>      * Thread state for a thread blocked waiting for a monitor lock. 
</span><span style=color:#8f5902;font-style:italic>      * A thread in the blocked state is waiting for a monitor lock 
</span><span style=color:#8f5902;font-style:italic>      * to enter a synchronized block/method or  
</span><span style=color:#8f5902;font-style:italic>      * reenter a synchronized block/method after calling 
</span><span style=color:#8f5902;font-style:italic>      * {@link Object#wait() Object.wait}. 
</span><span style=color:#8f5902;font-style:italic>      */</span>  
     <span style=color:#000>BLOCKED</span><span style=color:#ce5c00;font-weight:700>,</span>  

     <span style=color:#8f5902;font-style:italic>/** 
</span><span style=color:#8f5902;font-style:italic>      * Thread state for a waiting thread. 
</span><span style=color:#8f5902;font-style:italic>      * A thread is in the waiting state due to calling one of the  
</span><span style=color:#8f5902;font-style:italic>      * following methods: 
</span><span style=color:#8f5902;font-style:italic>      * &lt;ul&gt; 
</span><span style=color:#8f5902;font-style:italic>      *   &lt;li&gt;{@link Object#wait() Object.wait} with no timeout&lt;/li&gt; 
</span><span style=color:#8f5902;font-style:italic>      *   &lt;li&gt;{@link #join() Thread.join} with no timeout&lt;/li&gt; 
</span><span style=color:#8f5902;font-style:italic>      *   &lt;li&gt;{@link LockSupport#park() LockSupport.park}&lt;/li&gt; 
</span><span style=color:#8f5902;font-style:italic>      * &lt;/ul&gt; 
</span><span style=color:#8f5902;font-style:italic>      *  
</span><span style=color:#8f5902;font-style:italic>      * &lt;p&gt;A thread in the waiting state is waiting for another thread to 
</span><span style=color:#8f5902;font-style:italic>      * perform a particular action.   
</span><span style=color:#8f5902;font-style:italic>      * 
</span><span style=color:#8f5902;font-style:italic>      * For example, a thread that has called &lt;tt&gt;Object.wait()&lt;/tt&gt; 
</span><span style=color:#8f5902;font-style:italic>      * on an object is waiting for another thread to call  
</span><span style=color:#8f5902;font-style:italic>      * &lt;tt&gt;Object.notify()&lt;/tt&gt; or &lt;tt&gt;Object.notifyAll()&lt;/tt&gt; on  
</span><span style=color:#8f5902;font-style:italic>      * that object. A thread that has called &lt;tt&gt;Thread.join()&lt;/tt&gt;  
</span><span style=color:#8f5902;font-style:italic>      * is waiting for a specified thread to terminate. 
</span><span style=color:#8f5902;font-style:italic>      */</span>  
     <span style=color:#000>WAITING</span><span style=color:#ce5c00;font-weight:700>,</span>  

     <span style=color:#8f5902;font-style:italic>/** 
</span><span style=color:#8f5902;font-style:italic>      * Thread state for a waiting thread with a specified waiting time. 
</span><span style=color:#8f5902;font-style:italic>      * A thread is in the timed waiting state due to calling one of  
</span><span style=color:#8f5902;font-style:italic>      * the following methods with a specified positive waiting time: 
</span><span style=color:#8f5902;font-style:italic>      * &lt;ul&gt; 
</span><span style=color:#8f5902;font-style:italic>      *   &lt;li&gt;{@link #sleep Thread.sleep}&lt;/li&gt; 
</span><span style=color:#8f5902;font-style:italic>      *   &lt;li&gt;{@link Object#wait(long) Object.wait} with timeout&lt;/li&gt; 
</span><span style=color:#8f5902;font-style:italic>      *   &lt;li&gt;{@link #join(long) Thread.join} with timeout&lt;/li&gt; 
</span><span style=color:#8f5902;font-style:italic>      *   &lt;li&gt;{@link LockSupport#parkNanos LockSupport.parkNanos}&lt;/li&gt;  
</span><span style=color:#8f5902;font-style:italic>      *   &lt;li&gt;{@link LockSupport#parkUntil LockSupport.parkUntil}&lt;/li&gt; 
</span><span style=color:#8f5902;font-style:italic>      * &lt;/ul&gt; 
</span><span style=color:#8f5902;font-style:italic>      */</span>  
     <span style=color:#000>TIMED_WAITING</span><span style=color:#ce5c00;font-weight:700>,</span>  

     <span style=color:#8f5902;font-style:italic>/** 
</span><span style=color:#8f5902;font-style:italic>      * Thread state for a terminated thread. 
</span><span style=color:#8f5902;font-style:italic>      * The thread has completed execution. 
</span><span style=color:#8f5902;font-style:italic>      */</span>  
     <span style=color:#000>TERMINATED</span><span style=color:#ce5c00;font-weight:700>;</span>  
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><ul>
<li>
<p>NEW：</p>
<p>每一个线程，在堆内存中都有一个对应的Thread对象。Thread t = new Thread();当刚刚在堆内存中创建Thread对象，还没有调用t.start()方法之前，线程就处在NEW状态。在这个状态上，线程与普通的java对象没有什么区别，就仅仅是一个堆内存中的对象。</p>
</li>
<li>
<p>RUNNABLE：</p>
<p>该状态表示线程具备所有运行条件，在运行队列中准备操作系统的调度，或者正在运行。 这个状态的线程比较正常，但如果线程长时间停留在在这个状态就不正常了，这说明线程运行的时间很长（存在性能问题），或者是线程一直得不得执行的机会（存在线程饥饿的问题）。</p>
</li>
<li>
<p>BLOCKED：</p>
<p>线程正在等待获取java对象的监视器(也叫内置锁)，即线程正在等待进入由synchronized保护的方法或者代码块。synchronized用来保证原子性，任意时刻最多只能由一个线程进入该临界区域，其他线程只能排队等待。</p>
</li>
<li>
<p>WAITING：</p>
<p>处在该线程的状态，正在等待某个事件的发生，只有特定的条件满足，才能获得执行机会。而产生这个特定的事件，通常都是另一个线程。也就是说，如果不发生特定的事件，那么处在该状态的线程一直等待，不能获取执行的机会。比如：</p>
<p>A线程调用了obj对象的obj.wait()方法，如果没有线程调用obj.notify或obj.notifyAll，那么A线程就没有办法恢复运行； 如果A线程调用了LockSupport.park()，没有别的线程调用LockSupport.unpark(A)，那么A没有办法恢复运行。 TIMED_WAITING：</p>
<p>J.U.C中很多与线程相关类，都提供了限时版本和不限时版本的API。TIMED_WAITING意味着线程调用了限时版本的API，正在等待时间流逝。当等待时间过去后，线程一样可以恢复运行。如果线程进入了WAITING状态，一定要特定的事件发生才能恢复运行；而处在TIMED_WAITING的线程，如果特定的事件发生或者是时间流逝完毕，都会恢复运行。</p>
</li>
<li>
<p>TERMINATED：</p>
<p>线程执行完毕，执行完run方法正常返回，或者抛出了运行时异常而结束，线程都会停留在这个状态。这个时候线程只剩下Thread对象了，没有什么用了。</p>
</li>
</ul>
<h3 id=关键状态分析>关键状态分析</h3>
<h4 id=wait-on-conditionthe-thread-is-either-sleeping-or-waiting-to-be-notified-by-another-thread><strong>Wait on condition</strong>：The thread is either sleeping or waiting to be notified by another thread.</h4>
<p>该状态说明它在等待另一个条件的发生，来把自己唤醒，或者干脆它是调用了 sleep(n)。</p>
<p>此时线程状态大致为以下几种：</p>
<blockquote>
<ul>
<li>java.lang.Thread.State: WAITING (parking)：一直等那个条件发生；</li>
<li>java.lang.Thread.State: TIMED_WAITING (parking或sleeping)：定时的，那个条件不到来，也将定时唤醒自己。</li>
</ul>
</blockquote>
<h4 id=waiting-for-monitor-entry-和-in-objectwait><strong>Waiting for Monitor Entry 和 in Object.wait()</strong></h4>
<blockquote>
<p>：The thread is waiting to get the lock for an object (some other thread may be holding the lock). This happens if two or more threads try to execute synchronized code. Note that the lock is always for an object and not for individual methods.</p>
</blockquote>
<p>在多线程的JAVA程序中，实现线程之间的同步，就要说说 Monitor。<strong>Monitor是Java中用以实现线程之间的互斥与协作的主要手段，它可以看成是对象或者Class的锁。每一个对象都有，也仅有一个 Monitor</strong> 。下面这个图，描述了线程和 Monitor之间关系，以及线程的状态转换图：</p>
<div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210501174012.png style=display:block;width:50% alt=NAME align=center> </div>
<p>如上图，每个Monitor在某个时刻，只能被一个线程拥有，<strong>该线程就是 “ActiveThread”，而其它线程都是 “Waiting Thread”，分别在两个队列“Entry Set”和“Wait Set”里等候</strong>。在“Entry Set”中等待的线程状态是“Waiting for monitor entry”，而在“Wait Set”中等待的线程状态是“in Object.wait()”。</p>
<p>先看“Entry Set”里面的线程。我们称被 synchronized保护起来的代码段为临界区。<strong>当一个线程申请进入临界区时，它就进入了“Entry Set”队列</strong>。对应的 code就像：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback>synchronized(obj) {
   .........
}
</code></pre></div><p>这时有两种可能性：</p>
<ul>
<li>该 monitor不被其它线程拥有， Entry Set里面也没有其它等待线程。本线程即成为相应类或者对象的 Monitor的 Owner，执行临界区的代码。</li>
<li>该 monitor被其它线程拥有，本线程在 Entry Set队列中等待。</li>
</ul>
<p>在第一种情况下，线程将处于 “Runnable”的状态，而第二种情况下，线程 DUMP会显示处于 “waiting for monitor entry”。如下：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=color:#4e9a06>&#34;Thread-0&#34;</span> <span style=color:#000>prio</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#0000cf;font-weight:700>10</span> <span style=color:#000>tid</span><span style=color:#ce5c00;font-weight:700>=</span>0x08222eb0 <span style=color:#000>nid</span><span style=color:#ce5c00;font-weight:700>=</span>0x9 waiting <span style=color:#204a87;font-weight:700>for</span> monitor entry <span style=color:#ce5c00;font-weight:700>[</span>0xf927b000..0xf927bdb8<span style=color:#ce5c00;font-weight:700>]</span> 
at testthread.WaitThread.run<span style=color:#ce5c00;font-weight:700>(</span>WaitThread.java:39<span style=color:#ce5c00;font-weight:700>)</span> 
- waiting to lock &lt;0xef63bf08&gt; <span style=color:#ce5c00;font-weight:700>(</span>a java.lang.Object<span style=color:#ce5c00;font-weight:700>)</span> 
- locked &lt;0xef63beb8&gt; <span style=color:#ce5c00;font-weight:700>(</span>a java.util.ArrayList<span style=color:#ce5c00;font-weight:700>)</span> 
at java.lang.Thread.run<span style=color:#ce5c00;font-weight:700>(</span>Thread.java:595<span style=color:#ce5c00;font-weight:700>)</span> 
</code></pre></div><p><strong>临界区的设置，是为了保证其内部的代码执行的原子性和完整性</strong>。但是因为临界区在任何时间只允许线程串行通过，这和我们多线程的程序的初衷是相反的。<strong>如果在多线程的程序中，大量使用 synchronized，或者不适当的使用了它，会造成大量线程在临界区的入口等待，造成系统的性能大幅下降</strong>。如果在线程 DUMP中发现了这个情况，应该审查源码，改进程序。</p>
<p>再看“Wait Set”里面的线程。<strong>当线程获得了 Monitor，进入了临界区之后，如果发现线程继续运行的条件没有满足，它则调用对象（一般就是被 synchronized 的对象）的 wait() 方法，放弃 Monitor，进入 “Wait Set”队列。只有当别的线程在该对象上调用了 notify() 或者 notifyAll()，“Wait Set”队列中线程才得到机会去竞争</strong>，但是只有一个线程获得对象的Monitor，恢复到运行态。在 “Wait Set”中的线程， DUMP中表现为： in Object.wait()。如下：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=color:#4e9a06>&#34;Thread-1&#34;</span> <span style=color:#000>prio</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#0000cf;font-weight:700>10</span> <span style=color:#000>tid</span><span style=color:#ce5c00;font-weight:700>=</span>0x08223250 <span style=color:#000>nid</span><span style=color:#ce5c00;font-weight:700>=</span>0xa in Object.wait<span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>[</span>0xef47a000..0xef47aa38<span style=color:#ce5c00;font-weight:700>]</span> 
 at java.lang.Object.wait<span style=color:#ce5c00;font-weight:700>(</span>Native Method<span style=color:#ce5c00;font-weight:700>)</span> 
 - waiting on &lt;0xef63beb8&gt; <span style=color:#ce5c00;font-weight:700>(</span>a java.util.ArrayList<span style=color:#ce5c00;font-weight:700>)</span> 
 at java.lang.Object.wait<span style=color:#ce5c00;font-weight:700>(</span>Object.java:474<span style=color:#ce5c00;font-weight:700>)</span> 
 at testthread.MyWaitThread.run<span style=color:#ce5c00;font-weight:700>(</span>MyWaitThread.java:40<span style=color:#ce5c00;font-weight:700>)</span> 
 - locked &lt;0xef63beb8&gt; <span style=color:#ce5c00;font-weight:700>(</span>a java.util.ArrayList<span style=color:#ce5c00;font-weight:700>)</span> 
 at java.lang.Thread.run<span style=color:#ce5c00;font-weight:700>(</span>Thread.java:595<span style=color:#ce5c00;font-weight:700>)</span> 
综上，一般CPU很忙时，则关注runnable的线程，CPU很闲时，则关注waiting <span style=color:#204a87;font-weight:700>for</span> monitor entry的线程。
</code></pre></div><h4 id=jdk-50-的-lock><strong>JDK 5.0 的 Lock</strong></h4>
<p>上面提到如果 synchronized和 monitor机制运用不当，可能会造成多线程程序的性能问题。在 JDK 5.0中，引入了 Lock机制，从而使开发者能更灵活的开发高性能的并发多线程程序，可以替代以往 JDK中的 synchronized和 Monitor的 机制。但是，<strong>要注意的是，因为 Lock类只是一个普通类，JVM无从得知 Lock对象的占用情况，所以在线程 DUMP中，也不会包含关于 Lock的信息</strong>， 关于死锁等问题，就不如用 synchronized的编程方式容易识别。</p>
<h3 id=关键状态示例>关键状态示例</h3>
<h4 id=显示blocked状态><strong>显示BLOCKED状态</strong></h4>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#204a87;font-weight:700>package</span> <span style=color:#000>jstack</span><span style=color:#ce5c00;font-weight:700>;</span>  

<span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>BlockedState</span>  
<span style=color:#ce5c00;font-weight:700>{</span>  
    <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>static</span> <span style=color:#000>Object</span> <span style=color:#000>object</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>Object</span><span style=color:#ce5c00;font-weight:700>();</span>  
    
    <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>static</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>main</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>String</span><span style=color:#ce5c00;font-weight:700>[]</span> <span style=color:#000>args</span><span style=color:#ce5c00;font-weight:700>)</span>  
    <span style=color:#ce5c00;font-weight:700>{</span>  
        <span style=color:#000>Runnable</span> <span style=color:#000>task</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>Runnable</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span>  

            <span style=color:#5c35cc;font-weight:700>@Override</span>  
            <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>run</span><span style=color:#ce5c00;font-weight:700>()</span>  
            <span style=color:#ce5c00;font-weight:700>{</span>  
                <span style=color:#204a87;font-weight:700>synchronized</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>object</span><span style=color:#ce5c00;font-weight:700>)</span>  
                <span style=color:#ce5c00;font-weight:700>{</span>  
                    <span style=color:#204a87;font-weight:700>long</span> <span style=color:#000>begin</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>System</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>currentTimeMillis</span><span style=color:#ce5c00;font-weight:700>();</span>  
  
                    <span style=color:#204a87;font-weight:700>long</span> <span style=color:#000>end</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>System</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>currentTimeMillis</span><span style=color:#ce5c00;font-weight:700>();</span>  

                    <span style=color:#8f5902;font-style:italic>// 让线程运行5分钟,会一直持有object的监视器  
</span><span style=color:#8f5902;font-style:italic></span>                    <span style=color:#204a87;font-weight:700>while</span> <span style=color:#ce5c00;font-weight:700>((</span><span style=color:#000>end</span> <span style=color:#ce5c00;font-weight:700>-</span> <span style=color:#000>begin</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>&lt;=</span> <span style=color:#000>5</span> <span style=color:#ce5c00;font-weight:700>*</span> <span style=color:#000>60</span> <span style=color:#ce5c00;font-weight:700>*</span> <span style=color:#000>1000</span><span style=color:#ce5c00;font-weight:700>)</span>  
                    <span style=color:#ce5c00;font-weight:700>{</span>  
  
                    <span style=color:#ce5c00;font-weight:700>}</span>  
                <span style=color:#ce5c00;font-weight:700>}</span>  
            <span style=color:#ce5c00;font-weight:700>}</span>  
        <span style=color:#ce5c00;font-weight:700>};</span>  

        <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>Thread</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>task</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#4e9a06>&#34;t1&#34;</span><span style=color:#ce5c00;font-weight:700>).</span><span style=color:#c4a000>start</span><span style=color:#ce5c00;font-weight:700>();</span>  
        <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>Thread</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>task</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#4e9a06>&#34;t2&#34;</span><span style=color:#ce5c00;font-weight:700>).</span><span style=color:#c4a000>start</span><span style=color:#ce5c00;font-weight:700>();</span>  
    <span style=color:#ce5c00;font-weight:700>}</span>  
<span style=color:#ce5c00;font-weight:700>}</span> 
</code></pre></div><p>先获取object的线程会执行5分钟，<strong>这5分钟内会一直持有object的监视器，另一个线程无法执行处在BLOCKED状态</strong>：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>Full thread dump Java HotSpot<span style=color:#ce5c00;font-weight:700>(</span>TM<span style=color:#ce5c00;font-weight:700>)</span> Server VM <span style=color:#ce5c00;font-weight:700>(</span>20.12-b01 mixed mode<span style=color:#ce5c00;font-weight:700>)</span>:  
  
<span style=color:#4e9a06>&#34;DestroyJavaVM&#34;</span> <span style=color:#000>prio</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#0000cf;font-weight:700>6</span> <span style=color:#000>tid</span><span style=color:#ce5c00;font-weight:700>=</span>0x00856c00 <span style=color:#000>nid</span><span style=color:#ce5c00;font-weight:700>=</span>0x1314 waiting on condition <span style=color:#ce5c00;font-weight:700>[</span>0x00000000<span style=color:#ce5c00;font-weight:700>]</span>  
java.lang.Thread.State: RUNNABLE  

<span style=color:#4e9a06>&#34;t2&#34;</span> <span style=color:#000>prio</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#0000cf;font-weight:700>6</span> <span style=color:#000>tid</span><span style=color:#ce5c00;font-weight:700>=</span>0x27d7a800 <span style=color:#000>nid</span><span style=color:#ce5c00;font-weight:700>=</span>0x1350 waiting <span style=color:#204a87;font-weight:700>for</span> monitor entry <span style=color:#ce5c00;font-weight:700>[</span>0x2833f000<span style=color:#ce5c00;font-weight:700>]</span>  
java.lang.Thread.State: BLOCKED <span style=color:#ce5c00;font-weight:700>(</span>on object monitor<span style=color:#ce5c00;font-weight:700>)</span>  
     at jstack.BlockedState<span style=color:#000>$1</span>.run<span style=color:#ce5c00;font-weight:700>(</span>BlockedState.java:17<span style=color:#ce5c00;font-weight:700>)</span>  
     - waiting to lock &lt;0x1cfcdc00&gt; <span style=color:#ce5c00;font-weight:700>(</span>a java.lang.Object<span style=color:#ce5c00;font-weight:700>)</span>  
     at java.lang.Thread.run<span style=color:#ce5c00;font-weight:700>(</span>Thread.java:662<span style=color:#ce5c00;font-weight:700>)</span>  

<span style=color:#4e9a06>&#34;t1&#34;</span> <span style=color:#000>prio</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#0000cf;font-weight:700>6</span> <span style=color:#000>tid</span><span style=color:#ce5c00;font-weight:700>=</span>0x27d79400 <span style=color:#000>nid</span><span style=color:#ce5c00;font-weight:700>=</span>0x1338 runnable <span style=color:#ce5c00;font-weight:700>[</span>0x282ef000<span style=color:#ce5c00;font-weight:700>]</span>  
 java.lang.Thread.State: RUNNABLE  
     at jstack.BlockedState<span style=color:#000>$1</span>.run<span style=color:#ce5c00;font-weight:700>(</span>BlockedState.java:22<span style=color:#ce5c00;font-weight:700>)</span>  
     - locked &lt;0x1cfcdc00&gt; <span style=color:#ce5c00;font-weight:700>(</span>a java.lang.Object<span style=color:#ce5c00;font-weight:700>)</span>  
     at java.lang.Thread.run<span style=color:#ce5c00;font-weight:700>(</span>Thread.java:662<span style=color:#ce5c00;font-weight:700>)</span>
</code></pre></div><p>通过thread dump可以看到：<strong>t2线程确实处在BLOCKED (on object monitor)。waiting for monitor entry 等待进入synchronized保护的区域</strong>。</p>
<h4 id=显示waiting状态><strong>显示WAITING状态</strong></h4>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#204a87;font-weight:700>package</span> <span style=color:#000>jstack</span><span style=color:#ce5c00;font-weight:700>;</span>  
  
<span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>WaitingState</span>  
<span style=color:#ce5c00;font-weight:700>{</span>  
    <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>static</span> <span style=color:#000>Object</span> <span style=color:#000>object</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>Object</span><span style=color:#ce5c00;font-weight:700>();</span>  

    <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>static</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>main</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>String</span><span style=color:#ce5c00;font-weight:700>[]</span> <span style=color:#000>args</span><span style=color:#ce5c00;font-weight:700>)</span>  
    <span style=color:#ce5c00;font-weight:700>{</span>  
        <span style=color:#000>Runnable</span> <span style=color:#000>task</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>Runnable</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span>  

            <span style=color:#5c35cc;font-weight:700>@Override</span>  
            <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>run</span><span style=color:#ce5c00;font-weight:700>()</span>  
            <span style=color:#ce5c00;font-weight:700>{</span>  
                <span style=color:#204a87;font-weight:700>synchronized</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>object</span><span style=color:#ce5c00;font-weight:700>)</span>  
                <span style=color:#ce5c00;font-weight:700>{</span>  
                    <span style=color:#204a87;font-weight:700>long</span> <span style=color:#000>begin</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>System</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>currentTimeMillis</span><span style=color:#ce5c00;font-weight:700>();</span>  
                    <span style=color:#204a87;font-weight:700>long</span> <span style=color:#000>end</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>System</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>currentTimeMillis</span><span style=color:#ce5c00;font-weight:700>();</span>  

                    <span style=color:#8f5902;font-style:italic>// 让线程运行5分钟,会一直持有object的监视器  
</span><span style=color:#8f5902;font-style:italic></span>                    <span style=color:#204a87;font-weight:700>while</span> <span style=color:#ce5c00;font-weight:700>((</span><span style=color:#000>end</span> <span style=color:#ce5c00;font-weight:700>-</span> <span style=color:#000>begin</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>&lt;=</span> <span style=color:#000>5</span> <span style=color:#ce5c00;font-weight:700>*</span> <span style=color:#000>60</span> <span style=color:#ce5c00;font-weight:700>*</span> <span style=color:#000>1000</span><span style=color:#ce5c00;font-weight:700>)</span>  
                    <span style=color:#ce5c00;font-weight:700>{</span>  
                        <span style=color:#204a87;font-weight:700>try</span>  
                        <span style=color:#ce5c00;font-weight:700>{</span>  
                            <span style=color:#8f5902;font-style:italic>// 进入等待的同时,会进入释放监视器  
</span><span style=color:#8f5902;font-style:italic></span>                            <span style=color:#000>object</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>wait</span><span style=color:#ce5c00;font-weight:700>();</span>  
                        <span style=color:#ce5c00;font-weight:700>}</span> <span style=color:#204a87;font-weight:700>catch</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>InterruptedException</span> <span style=color:#000>e</span><span style=color:#ce5c00;font-weight:700>)</span>  
                        <span style=color:#ce5c00;font-weight:700>{</span>  
                            <span style=color:#000>e</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>printStackTrace</span><span style=color:#ce5c00;font-weight:700>();</span>  
                        <span style=color:#ce5c00;font-weight:700>}</span>  
                    <span style=color:#ce5c00;font-weight:700>}</span>  
                <span style=color:#ce5c00;font-weight:700>}</span>  
            <span style=color:#ce5c00;font-weight:700>}</span>  
        <span style=color:#ce5c00;font-weight:700>};</span>  

        <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>Thread</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>task</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#4e9a06>&#34;t1&#34;</span><span style=color:#ce5c00;font-weight:700>).</span><span style=color:#c4a000>start</span><span style=color:#ce5c00;font-weight:700>();</span>  
        <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>Thread</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>task</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#4e9a06>&#34;t2&#34;</span><span style=color:#ce5c00;font-weight:700>).</span><span style=color:#c4a000>start</span><span style=color:#ce5c00;font-weight:700>();</span>  
    <span style=color:#ce5c00;font-weight:700>}</span>  
<span style=color:#ce5c00;font-weight:700>}</span>  
</code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>Full thread dump Java HotSpot<span style=color:#ce5c00;font-weight:700>(</span>TM<span style=color:#ce5c00;font-weight:700>)</span> Server VM <span style=color:#ce5c00;font-weight:700>(</span>20.12-b01 mixed mode<span style=color:#ce5c00;font-weight:700>)</span>:  

<span style=color:#4e9a06>&#34;DestroyJavaVM&#34;</span> <span style=color:#000>prio</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#0000cf;font-weight:700>6</span> <span style=color:#000>tid</span><span style=color:#ce5c00;font-weight:700>=</span>0x00856c00 <span style=color:#000>nid</span><span style=color:#ce5c00;font-weight:700>=</span>0x1734 waiting on condition <span style=color:#ce5c00;font-weight:700>[</span>0x00000000<span style=color:#ce5c00;font-weight:700>]</span>  
java.lang.Thread.State: RUNNABLE  

<span style=color:#4e9a06>&#34;t2&#34;</span> <span style=color:#000>prio</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#0000cf;font-weight:700>6</span> <span style=color:#000>tid</span><span style=color:#ce5c00;font-weight:700>=</span>0x27d7e000 <span style=color:#000>nid</span><span style=color:#ce5c00;font-weight:700>=</span>0x17f4 in Object.wait<span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>[</span>0x2833f000<span style=color:#ce5c00;font-weight:700>]</span>  
java.lang.Thread.State: WAITING <span style=color:#ce5c00;font-weight:700>(</span>on object monitor<span style=color:#ce5c00;font-weight:700>)</span>  
     at java.lang.Object.wait<span style=color:#ce5c00;font-weight:700>(</span>Native Method<span style=color:#ce5c00;font-weight:700>)</span>  
     - waiting on &lt;0x1cfcdc00&gt; <span style=color:#ce5c00;font-weight:700>(</span>a java.lang.Object<span style=color:#ce5c00;font-weight:700>)</span>  
     at java.lang.Object.wait<span style=color:#ce5c00;font-weight:700>(</span>Object.java:485<span style=color:#ce5c00;font-weight:700>)</span>  
     at jstack.WaitingState<span style=color:#000>$1</span>.run<span style=color:#ce5c00;font-weight:700>(</span>WaitingState.java:26<span style=color:#ce5c00;font-weight:700>)</span>  
     - locked &lt;0x1cfcdc00&gt; <span style=color:#ce5c00;font-weight:700>(</span>a java.lang.Object<span style=color:#ce5c00;font-weight:700>)</span>  
     at java.lang.Thread.run<span style=color:#ce5c00;font-weight:700>(</span>Thread.java:662<span style=color:#ce5c00;font-weight:700>)</span>  

<span style=color:#4e9a06>&#34;t1&#34;</span> <span style=color:#000>prio</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#0000cf;font-weight:700>6</span> <span style=color:#000>tid</span><span style=color:#ce5c00;font-weight:700>=</span>0x27d7d400 <span style=color:#000>nid</span><span style=color:#ce5c00;font-weight:700>=</span>0x17f0 in Object.wait<span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>[</span>0x282ef000<span style=color:#ce5c00;font-weight:700>]</span>  
java.lang.Thread.State: WAITING <span style=color:#ce5c00;font-weight:700>(</span>on object monitor<span style=color:#ce5c00;font-weight:700>)</span>  
     at java.lang.Object.wait<span style=color:#ce5c00;font-weight:700>(</span>Native Method<span style=color:#ce5c00;font-weight:700>)</span>  
     - waiting on &lt;0x1cfcdc00&gt; <span style=color:#ce5c00;font-weight:700>(</span>a java.lang.Object<span style=color:#ce5c00;font-weight:700>)</span>  
     at java.lang.Object.wait<span style=color:#ce5c00;font-weight:700>(</span>Object.java:485<span style=color:#ce5c00;font-weight:700>)</span>  
     at jstack.WaitingState<span style=color:#000>$1</span>.run<span style=color:#ce5c00;font-weight:700>(</span>WaitingState.java:26<span style=color:#ce5c00;font-weight:700>)</span>  
     - locked &lt;0x1cfcdc00&gt; <span style=color:#ce5c00;font-weight:700>(</span>a java.lang.Object<span style=color:#ce5c00;font-weight:700>)</span>  
     at java.lang.Thread.run<span style=color:#ce5c00;font-weight:700>(</span>Thread.java:662<span style=color:#ce5c00;font-weight:700>)</span>  
</code></pre></div><p>可以发现t1和t2都处在WAITING (on object monitor)，进入等待状态的原因是调用了in Object.wait()。通过J.U.C包下的锁和条件队列，也是这个效果，大家可以自己实践下。</p>
<h4 id=显示timed_waiting状态><strong>显示TIMED_WAITING状态</strong></h4>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#204a87;font-weight:700>package</span> <span style=color:#000>jstack</span><span style=color:#ce5c00;font-weight:700>;</span>  

<span style=color:#204a87;font-weight:700>import</span> <span style=color:#000>java.util.concurrent.TimeUnit</span><span style=color:#ce5c00;font-weight:700>;</span>  
<span style=color:#204a87;font-weight:700>import</span> <span style=color:#000>java.util.concurrent.locks.Condition</span><span style=color:#ce5c00;font-weight:700>;</span>  
<span style=color:#204a87;font-weight:700>import</span> <span style=color:#000>java.util.concurrent.locks.Lock</span><span style=color:#ce5c00;font-weight:700>;</span>  
<span style=color:#204a87;font-weight:700>import</span> <span style=color:#000>java.util.concurrent.locks.ReentrantLock</span><span style=color:#ce5c00;font-weight:700>;</span>  
  
<span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>TimedWaitingState</span>  
<span style=color:#ce5c00;font-weight:700>{</span>  
    <span style=color:#8f5902;font-style:italic>// java的显示锁,类似java对象内置的监视器  
</span><span style=color:#8f5902;font-style:italic></span>    <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>static</span> <span style=color:#000>Lock</span> <span style=color:#000>lock</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>ReentrantLock</span><span style=color:#ce5c00;font-weight:700>();</span>  
  
    <span style=color:#8f5902;font-style:italic>// 锁关联的条件队列(类似于object.wait)  
</span><span style=color:#8f5902;font-style:italic></span>    <span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>static</span> <span style=color:#000>Condition</span> <span style=color:#000>condition</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>lock</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>newCondition</span><span style=color:#ce5c00;font-weight:700>();</span>  

    <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>static</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>main</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>String</span><span style=color:#ce5c00;font-weight:700>[]</span> <span style=color:#000>args</span><span style=color:#ce5c00;font-weight:700>)</span>  
    <span style=color:#ce5c00;font-weight:700>{</span>  
        <span style=color:#000>Runnable</span> <span style=color:#000>task</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>Runnable</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span>  

            <span style=color:#5c35cc;font-weight:700>@Override</span>  
            <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>run</span><span style=color:#ce5c00;font-weight:700>()</span>  
            <span style=color:#ce5c00;font-weight:700>{</span>  
                <span style=color:#8f5902;font-style:italic>// 加锁,进入临界区  
</span><span style=color:#8f5902;font-style:italic></span>                <span style=color:#000>lock</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>lock</span><span style=color:#ce5c00;font-weight:700>();</span>  
  
                <span style=color:#204a87;font-weight:700>try</span>  
                <span style=color:#ce5c00;font-weight:700>{</span>  
                    <span style=color:#000>condition</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>await</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>5</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>TimeUnit</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>MINUTES</span><span style=color:#ce5c00;font-weight:700>);</span>  
                <span style=color:#ce5c00;font-weight:700>}</span> <span style=color:#204a87;font-weight:700>catch</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>InterruptedException</span> <span style=color:#000>e</span><span style=color:#ce5c00;font-weight:700>)</span>  
                <span style=color:#ce5c00;font-weight:700>{</span>  
                    <span style=color:#000>e</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>printStackTrace</span><span style=color:#ce5c00;font-weight:700>();</span>  
                <span style=color:#ce5c00;font-weight:700>}</span>  
  
                <span style=color:#8f5902;font-style:italic>// 解锁,退出临界区  
</span><span style=color:#8f5902;font-style:italic></span>                <span style=color:#000>lock</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>unlock</span><span style=color:#ce5c00;font-weight:700>();</span>  
            <span style=color:#ce5c00;font-weight:700>}</span>  
        <span style=color:#ce5c00;font-weight:700>};</span>  
  
        <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>Thread</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>task</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#4e9a06>&#34;t1&#34;</span><span style=color:#ce5c00;font-weight:700>).</span><span style=color:#c4a000>start</span><span style=color:#ce5c00;font-weight:700>();</span>  
        <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>Thread</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>task</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#4e9a06>&#34;t2&#34;</span><span style=color:#ce5c00;font-weight:700>).</span><span style=color:#c4a000>start</span><span style=color:#ce5c00;font-weight:700>();</span>  
    <span style=color:#ce5c00;font-weight:700>}</span>  
<span style=color:#ce5c00;font-weight:700>}</span> 
</code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>Full thread dump Java HotSpot<span style=color:#ce5c00;font-weight:700>(</span>TM<span style=color:#ce5c00;font-weight:700>)</span> Server VM <span style=color:#ce5c00;font-weight:700>(</span>20.12-b01 mixed mode<span style=color:#ce5c00;font-weight:700>)</span>:  

<span style=color:#4e9a06>&#34;DestroyJavaVM&#34;</span> <span style=color:#000>prio</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#0000cf;font-weight:700>6</span> <span style=color:#000>tid</span><span style=color:#ce5c00;font-weight:700>=</span>0x00856c00 <span style=color:#000>nid</span><span style=color:#ce5c00;font-weight:700>=</span>0x169c waiting on condition <span style=color:#ce5c00;font-weight:700>[</span>0x00000000<span style=color:#ce5c00;font-weight:700>]</span>  
java.lang.Thread.State: RUNNABLE  

<span style=color:#4e9a06>&#34;t2&#34;</span> <span style=color:#000>prio</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#0000cf;font-weight:700>6</span> <span style=color:#000>tid</span><span style=color:#ce5c00;font-weight:700>=</span>0x27d7d800 <span style=color:#000>nid</span><span style=color:#ce5c00;font-weight:700>=</span>0xc30 waiting on condition <span style=color:#ce5c00;font-weight:700>[</span>0x2833f000<span style=color:#ce5c00;font-weight:700>]</span>  
java.lang.Thread.State: TIMED_WAITING <span style=color:#ce5c00;font-weight:700>(</span>parking<span style=color:#ce5c00;font-weight:700>)</span>  
     at sun.misc.Unsafe.park<span style=color:#ce5c00;font-weight:700>(</span>Native Method<span style=color:#ce5c00;font-weight:700>)</span>  
     - parking to <span style=color:#204a87>wait</span> <span style=color:#204a87;font-weight:700>for</span>  &lt;0x1cfce5b8&gt; <span style=color:#ce5c00;font-weight:700>(</span>a java.util.concurrent.locks.AbstractQueuedSynchronizer<span style=color:#000>$ConditionObject</span><span style=color:#ce5c00;font-weight:700>)</span>  
     at java.util.concurrent.locks.LockSupport.parkNanos<span style=color:#ce5c00;font-weight:700>(</span>LockSupport.java:196<span style=color:#ce5c00;font-weight:700>)</span>  
     at java.util.concurrent.locks.AbstractQueuedSynchronizer<span style=color:#000>$ConditionObject</span>.await<span style=color:#ce5c00;font-weight:700>(</span>AbstractQueuedSynchronizer.java:2116<span style=color:#ce5c00;font-weight:700>)</span>  
     at jstack.TimedWaitingState<span style=color:#000>$1</span>.run<span style=color:#ce5c00;font-weight:700>(</span>TimedWaitingState.java:28<span style=color:#ce5c00;font-weight:700>)</span>  
     at java.lang.Thread.run<span style=color:#ce5c00;font-weight:700>(</span>Thread.java:662<span style=color:#ce5c00;font-weight:700>)</span>  

<span style=color:#4e9a06>&#34;t1&#34;</span> <span style=color:#000>prio</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#0000cf;font-weight:700>6</span> <span style=color:#000>tid</span><span style=color:#ce5c00;font-weight:700>=</span>0x280d0c00 <span style=color:#000>nid</span><span style=color:#ce5c00;font-weight:700>=</span>0x16e0 waiting on condition <span style=color:#ce5c00;font-weight:700>[</span>0x282ef000<span style=color:#ce5c00;font-weight:700>]</span>  
java.lang.Thread.State: TIMED_WAITING <span style=color:#ce5c00;font-weight:700>(</span>parking<span style=color:#ce5c00;font-weight:700>)</span>  
     at sun.misc.Unsafe.park<span style=color:#ce5c00;font-weight:700>(</span>Native Method<span style=color:#ce5c00;font-weight:700>)</span>  
     - parking to <span style=color:#204a87>wait</span> <span style=color:#204a87;font-weight:700>for</span>  &lt;0x1cfce5b8&gt; <span style=color:#ce5c00;font-weight:700>(</span>a java.util.concurrent.locks.AbstractQueuedSynchronizer<span style=color:#000>$ConditionObject</span><span style=color:#ce5c00;font-weight:700>)</span>  
     at java.util.concurrent.locks.LockSupport.parkNanos<span style=color:#ce5c00;font-weight:700>(</span>LockSupport.java:196<span style=color:#ce5c00;font-weight:700>)</span>  
     at java.util.concurrent.locks.AbstractQueuedSynchronizer<span style=color:#000>$ConditionObject</span>.await<span style=color:#ce5c00;font-weight:700>(</span>AbstractQueuedSynchronizer.java:2116<span style=color:#ce5c00;font-weight:700>)</span>  
     at jstack.TimedWaitingState<span style=color:#000>$1</span>.run<span style=color:#ce5c00;font-weight:700>(</span>TimedWaitingState.java:28<span style=color:#ce5c00;font-weight:700>)</span>  
     at java.lang.Thread.run<span style=color:#ce5c00;font-weight:700>(</span>Thread.java:662<span style=color:#ce5c00;font-weight:700>)</span>  
</code></pre></div><p>可以看到t1和t2线程都处在java.lang.Thread.State: TIMED_WAITING (parking)，这个parking代表是调用的JUC下的工具类，而不是java默认的监视器。</p>
<h2 id=案例分析>案例分析</h2>
<h3 id=cpu飙高load高响应很慢><strong>CPU飙高，load高，响应很慢</strong></h3>
<ul>
<li>一个请求过程中多次dump；</li>
<li>对比多次dump文件的runnable线程，如果执行的方法有比较大变化，说明比较正常。如果在执行同一个方法，就有一些问题了；</li>
</ul>
<h3 id=查找占用cpu最多的线程><strong>查找占用CPU最多的线程</strong></h3>
<ul>
<li>
<p>用命令：top -H -p pid（pid为被测系统的进程号），找到导致CPU高的线程ID，对应thread dump信息中线程的nid，只不过一个是十进制，一个是十六进制；</p>
</li>
<li>
<p>在thread dump中，根据top命令查找的线程id，查找对应的线程堆栈信息；</p>
</li>
</ul>
<h3 id=cpu使用率不高但是响应很慢><strong>CPU使用率不高但是响应很慢</strong></h3>
<p>进行dump，查看是否有很多thread struck在了i/o、数据库等地方，定位瓶颈原因；</p>
<h3 id=请求无法响应><strong>请求无法响应</strong></h3>
<p>多次dump，对比是否所有的runnable线程都一直在执行相同的方法，是则有可能出现了死锁。</p>
<h3 id=死锁>死锁</h3>
<p>死锁经常表现为程序的停顿，或者不再响应用户的请求。从操作系统上观察，对应进程的CPU占用率为零，很快会从top或prstat的输出中消失。</p>
<p>比如在下面这个示例中，是个较为典型的死锁情况：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=color:#4e9a06>&#34;Thread-1&#34;</span> <span style=color:#000>prio</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#0000cf;font-weight:700>5</span> <span style=color:#000>tid</span><span style=color:#ce5c00;font-weight:700>=</span>0x00acc490 <span style=color:#000>nid</span><span style=color:#ce5c00;font-weight:700>=</span>0xe50 waiting <span style=color:#204a87;font-weight:700>for</span> monitor entry <span style=color:#ce5c00;font-weight:700>[</span>0x02d3f000 
..0x02d3fd68<span style=color:#ce5c00;font-weight:700>]</span> 
at deadlockthreads.TestThread.run<span style=color:#ce5c00;font-weight:700>(</span>TestThread.java:31<span style=color:#ce5c00;font-weight:700>)</span> 
- waiting to lock &lt;0x22c19f18&gt; <span style=color:#ce5c00;font-weight:700>(</span>a java.lang.Object<span style=color:#ce5c00;font-weight:700>)</span> 
- locked &lt;0x22c19f20&gt; <span style=color:#ce5c00;font-weight:700>(</span>a java.lang.Object<span style=color:#ce5c00;font-weight:700>)</span> 

<span style=color:#4e9a06>&#34;Thread-0&#34;</span> <span style=color:#000>prio</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#0000cf;font-weight:700>5</span> <span style=color:#000>tid</span><span style=color:#ce5c00;font-weight:700>=</span>0x00accdb0 <span style=color:#000>nid</span><span style=color:#ce5c00;font-weight:700>=</span>0xdec waiting <span style=color:#204a87;font-weight:700>for</span> monitor entry <span style=color:#ce5c00;font-weight:700>[</span>0x02cff000 
..0x02cff9e8<span style=color:#ce5c00;font-weight:700>]</span> 
at deadlockthreads.TestThread.run<span style=color:#ce5c00;font-weight:700>(</span>TestThread.java:31<span style=color:#ce5c00;font-weight:700>)</span> 
- waiting to lock &lt;0x22c19f20&gt; <span style=color:#ce5c00;font-weight:700>(</span>a java.lang.Object<span style=color:#ce5c00;font-weight:700>)</span> 
- locked &lt;0x22c19f18&gt; <span style=color:#ce5c00;font-weight:700>(</span>a java.lang.Object<span style=color:#ce5c00;font-weight:700>)</span> 
</code></pre></div><p>在 JAVA 5中加强了对死锁的检测。<strong>线程 Dump中可以直接报告出 Java级别的死锁</strong>，如下所示：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>Found one Java-level deadlock: 
<span style=color:#ce5c00;font-weight:700>=============================</span> 
<span style=color:#4e9a06>&#34;Thread-1&#34;</span>: 
waiting to lock monitor 0x0003f334 <span style=color:#ce5c00;font-weight:700>(</span>object 0x22c19f18, a java.lang.Object<span style=color:#ce5c00;font-weight:700>)</span>, 
which is held by <span style=color:#4e9a06>&#34;Thread-0&#34;</span> 

<span style=color:#4e9a06>&#34;Thread-0&#34;</span>: 
waiting to lock monitor 0x0003f314 <span style=color:#ce5c00;font-weight:700>(</span>object 0x22c19f20, a java.lang.Object<span style=color:#ce5c00;font-weight:700>)</span>, 
which is held by <span style=color:#4e9a06>&#34;Thread-1&#34;</span>
</code></pre></div><h3 id=热锁>热锁</h3>
<p>热锁，也往往是导致系统性能瓶颈的主要因素。其表现特征为：<strong>由于多个线程对临界区，或者锁的竞争</strong>，可能出现：</p>
<ul>
<li><strong>频繁的线程的上下文切换</strong>：从操作系统对线程的调度来看，当线程在等待资源而阻塞的时候，操作系统会将之切换出来，放到等待的队列，当线程获得资源之后，调度算法会将这个线程切换进去，放到执行队列中。</li>
<li><strong>大量的系统调用</strong>：因为线程的上下文切换，以及热锁的竞争，或者临界区的频繁的进出，都可能导致大量的系统调用。</li>
<li><strong>大部分CPU开销用在“系统态”</strong>：线程上下文切换，和系统调用，都会导致 CPU在 “系统态 ”运行，换而言之，虽然系统很忙碌，但是CPU用在 “用户态 ”的比例较小，应用程序得不到充分的 CPU资源。</li>
<li><strong>随着CPU数目的增多，系统的性能反而下降</strong>。因为CPU数目多，同时运行的线程就越多，可能就会造成更频繁的线程上下文切换和系统态的CPU开销，从而导致更糟糕的性能。</li>
</ul>
<p>上面的描述，都是一个 scalability（可扩展性）很差的系统的表现。从整体的性能指标看，由于线程热锁的存在，程序的响应时间会变长，吞吐量会降低。</p>
<p><strong>那么，怎么去了解 “热锁 ”出现在什么地方呢</strong>？</p>
<p>一个重要的方法是 结合操作系统的各种工具观察系统资源使用状况，以及收集Java线程的DUMP信息，看线程都阻塞在什么方法上，了解原因，才能找到对应的解决方法。</p>
<h2 id=jvm-重要线程>JVM 重要线程</h2>
<h3 id=attach-listener>Attach Listener</h3>
<p>Attach Listener 线程是负责接收到外部的命令，而对该命令进行执行的并把结果返回给发送者。通常我们会用一些命令去要求JVM给我们一些反馈信息，如：java -version、jmap、jstack等等。 如果该线程在JVM启动的时候没有初始化，那么，则会在用户第一次执行JVM命令时，得到启动。</p>
<h3 id=signal-dispatcher>Signal Dispatcher</h3>
<p>前面提到Attach Listener线程的职责是接收外部JVM命令，当命令接收成功后，会交给signal dispather线程去进行分发到各个不同的模块处理命令，并且返回处理结果。signal dispather线程也是在第一次接收外部JVM命令时，进行初始化工作。</p>
<h3 id=compilerthread0>CompilerThread0</h3>
<p>用来调用JITing，实时编译装卸class 。 通常，JVM会启动多个线程来处理这部分工作，线程名称后面的数字也会累加，例如：CompilerThread1。</p>
<h3 id=concurrent-mark-sweep-gc-thread>Concurrent Mark-Sweep GC Thread</h3>
<p>并发标记清除垃圾回收器（就是通常所说的CMS GC）线程， 该线程主要针对于老年代垃圾回收。ps：启用该垃圾回收器，需要在JVM启动参数中加上：-XX:+UseConcMarkSweepGC。</p>
<h3 id=destroyjavavm>DestroyJavaVM</h3>
<p>执行main()的线程，在main执行完后调用JNI中的 jni_DestroyJavaVM() 方法唤起DestroyJavaVM 线程，处于等待状态，等待其它线程（Java线程和Native线程）退出时通知它卸载JVM。每个线程退出时，都会判断自己当前是否是整个JVM中最后一个非deamon线程，如果是，则通知DestroyJavaVM 线程卸载JVM。</p>
<h3 id=finalizer-thread>Finalizer Thread</h3>
<p>这个线程也是在main线程之后创建的，其优先级为10，主要用于在垃圾收集前，调用对象的finalize()方法；关于Finalizer线程的几点：1) 只有当开始一轮垃圾收集时，才会开始调用finalize()方法；因此并不是所有对象的finalize()方法都会被执行；2) 该线程也是daemon线程，因此如果虚拟机中没有其他非daemon线程，不管该线程有没有执行完finalize()方法，JVM也会退出；3) JVM在垃圾收集时会将失去引用的对象包装成Finalizer对象（Reference的实现），并放入ReferenceQueue，由Finalizer线程来处理；最后将该Finalizer对象的引用置为null，由垃圾收集器来回收；4) JVM为什么要单独用一个线程来执行finalize()方法呢？如果JVM的垃圾收集线程自己来做，很有可能由于在finalize()方法中误操作导致GC线程停止或不可控，这对GC线程来说是一种灾难；</p>
<h3 id=low-memory-detector>Low Memory Detector</h3>
<p>这个线程是负责对可使用内存进行检测，如果发现可用内存低，分配新的内存空间。</p>
<h3 id=reference-handler>Reference Handler</h3>
<p>JVM在创建main线程后就创建Reference Handler线程，其优先级最高，为10，它主要用于处理引用对象本身（软引用、弱引用、虚引用）的垃圾回收问题 。</p>
<h3 id=vm-thread>VM Thread</h3>
<p>这个线程就比较牛b了，是JVM里面的线程母体，根据hotspot源码（vmThread.hpp）里面的注释，它是一个单个的对象（最原始的线程）会产生或触发所有其他的线程，这个单个的VM线程是会被其他线程所使用来做一些VM操作（如：清扫垃圾等）。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-efaf97ffa8b43d339724810fdd828778>13 - CH13-JVM调试命令</h1>
<h2 id=文本操作>文本操作</h2>
<h3 id=文本查找grep>文本查找：grep</h3>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=color:#8f5902;font-style:italic># 基本使用</span>
grep yoursearchkeyword f.txt     <span style=color:#8f5902;font-style:italic>#文件查找</span>
grep <span style=color:#4e9a06>&#39;KeyWord otherKeyWord&#39;</span> f.txt cpf.txt <span style=color:#8f5902;font-style:italic>#多文件查找, 含空格加引号</span>
grep <span style=color:#4e9a06>&#39;KeyWord&#39;</span> /home/admin -r -n <span style=color:#8f5902;font-style:italic>#目录下查找所有符合关键字的文件</span>
grep <span style=color:#4e9a06>&#39;keyword&#39;</span> /home/admin -r -n -i <span style=color:#8f5902;font-style:italic># -i 忽略大小写</span>
grep <span style=color:#4e9a06>&#39;KeyWord&#39;</span> /home/admin -r -n --include *.<span style=color:#ce5c00;font-weight:700>{</span>vm,java<span style=color:#ce5c00;font-weight:700>}</span> <span style=color:#8f5902;font-style:italic>#指定文件后缀</span>
grep <span style=color:#4e9a06>&#39;KeyWord&#39;</span> /home/admin -r -n --exclude *.<span style=color:#ce5c00;font-weight:700>{</span>vm,java<span style=color:#ce5c00;font-weight:700>}</span> <span style=color:#8f5902;font-style:italic>#反匹配</span>

<span style=color:#8f5902;font-style:italic># cat + grep</span>
cat f.txt <span style=color:#000;font-weight:700>|</span> grep -i keyword <span style=color:#8f5902;font-style:italic># 查找所有keyword且不分大小写  </span>
cat f.txt <span style=color:#000;font-weight:700>|</span> grep -c <span style=color:#4e9a06>&#39;KeyWord&#39;</span> <span style=color:#8f5902;font-style:italic># 统计Keyword次数</span>

<span style=color:#8f5902;font-style:italic># seq + grep</span>
seq <span style=color:#0000cf;font-weight:700>10</span> <span style=color:#000;font-weight:700>|</span> grep <span style=color:#0000cf;font-weight:700>5</span> -A <span style=color:#0000cf;font-weight:700>3</span>    <span style=color:#8f5902;font-style:italic>#上匹配</span>
seq <span style=color:#0000cf;font-weight:700>10</span> <span style=color:#000;font-weight:700>|</span> grep <span style=color:#0000cf;font-weight:700>5</span> -B <span style=color:#0000cf;font-weight:700>3</span>    <span style=color:#8f5902;font-style:italic>#下匹配</span>
seq <span style=color:#0000cf;font-weight:700>10</span> <span style=color:#000;font-weight:700>|</span> grep <span style=color:#0000cf;font-weight:700>5</span> -C <span style=color:#0000cf;font-weight:700>3</span>    <span style=color:#8f5902;font-style:italic>#上下匹配，平时用这个就妥了</span>
</code></pre></div><p>参数解释：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>--color<span style=color:#ce5c00;font-weight:700>=</span>auto：显示颜色<span style=color:#000;font-weight:700>;</span>
-i, --ignore-case：忽略字符大小写<span style=color:#000;font-weight:700>;</span>
-o, --only-matching：只显示匹配到的部分<span style=color:#000;font-weight:700>;</span>
-n, --line-number：显示行号<span style=color:#000;font-weight:700>;</span>
-v, --invert-match：反向显示,显示未匹配到的行<span style=color:#000;font-weight:700>;</span>
-E, --extended-regexp：支持使用扩展的正则表达式<span style=color:#000;font-weight:700>;</span>
-q, --quiet, --silent：静默模式,即不输出任何信息<span style=color:#000;font-weight:700>;</span>
-w, --word-regexp：整行匹配整个单词<span style=color:#000;font-weight:700>;</span>
-c, --count：统计匹配到的行数<span style=color:#000;font-weight:700>;</span> print a count of matching lines<span style=color:#000;font-weight:700>;</span>

-B, --before-context<span style=color:#ce5c00;font-weight:700>=</span>NUM：print NUM lines of leading context   后#行 
-A, --after-context<span style=color:#ce5c00;font-weight:700>=</span>NUM：print NUM lines of trailing context   前#行 
-C, --context<span style=color:#ce5c00;font-weight:700>=</span>NUM：print NUM lines of output context           前后各#行 
</code></pre></div><h3 id=文本分析awk>文本分析：awk</h3>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=color:#8f5902;font-style:italic># 基本使用</span>
awk <span style=color:#4e9a06>&#39;{print $4,$6}&#39;</span> f.txt
awk <span style=color:#4e9a06>&#39;{print NR,$0}&#39;</span> f.txt cpf.txt    
awk <span style=color:#4e9a06>&#39;{print FNR,$0}&#39;</span> f.txt cpf.txt
awk <span style=color:#4e9a06>&#39;{print FNR,FILENAME,$0}&#39;</span> f.txt cpf.txt
awk <span style=color:#4e9a06>&#39;{print FILENAME,&#34;NR=&#34;NR,&#34;FNR=&#34;FNR,&#34;$&#34;NF&#34;=&#34;$NF}&#39;</span> f.txt cpf.txt
<span style=color:#204a87>echo</span> 1:2:3:4 <span style=color:#000;font-weight:700>|</span> awk -F: <span style=color:#4e9a06>&#39;{print $1,$2,$3,$4}&#39;</span>

<span style=color:#8f5902;font-style:italic># 匹配</span>
awk <span style=color:#4e9a06>&#39;/ldb/ {print}&#39;</span> f.txt   <span style=color:#8f5902;font-style:italic>#匹配ldb</span>
awk <span style=color:#4e9a06>&#39;!/ldb/ {print}&#39;</span> f.txt  <span style=color:#8f5902;font-style:italic>#不匹配ldb</span>
awk <span style=color:#4e9a06>&#39;/ldb/ &amp;&amp; /LISTEN/ {print}&#39;</span> f.txt   <span style=color:#8f5902;font-style:italic>#匹配ldb和LISTEN</span>
awk <span style=color:#4e9a06>&#39;$5 ~ /ldb/ {print}&#39;</span> f.txt <span style=color:#8f5902;font-style:italic>#第五列匹配ldb</span>
</code></pre></div><p>内建变量：</p>
<ul>
<li>
<p><code>NR</code>: NR表示从awk开始执行后，按照记录分隔符读取的数据次数，默认的记录分隔符为换行符，因此默认的就是读取的数据行数，NR可以理解为Number of Record的缩写。</p>
</li>
<li>
<p><code>FNR</code>: 在awk处理多个输入文件的时候，在处理完第一个文件后，NR并不会从1开始，而是继续累加，因此就出现了FNR，每当处理一个新文件的时候，FNR就从1开始计数，FNR可以理解为File Number of Record。</p>
</li>
<li>
<p><code>NF</code>: NF表示目前的记录被分割的字段的数目，NF可以理解为Number of Field。</p>
</li>
</ul>
<h3 id=文本处理sed>文本处理：sed</h3>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=color:#8f5902;font-style:italic># 文本打印</span>
sed -n <span style=color:#4e9a06>&#39;3p&#39;</span> xxx.log <span style=color:#8f5902;font-style:italic>#只打印第三行</span>
sed -n <span style=color:#4e9a06>&#39;$p&#39;</span> xxx.log <span style=color:#8f5902;font-style:italic>#只打印最后一行</span>
sed -n <span style=color:#4e9a06>&#39;3,9p&#39;</span> xxx.log <span style=color:#8f5902;font-style:italic>#只查看文件的第3行到第9行</span>
sed -n -e <span style=color:#4e9a06>&#39;3,9p&#39;</span> -e <span style=color:#4e9a06>&#39;=&#39;</span> xxx.log <span style=color:#8f5902;font-style:italic>#打印3-9行，并显示行号</span>
sed -n <span style=color:#4e9a06>&#39;/root/p&#39;</span> xxx.log <span style=color:#8f5902;font-style:italic>#显示包含root的行</span>
sed -n <span style=color:#4e9a06>&#39;/hhh/,/omc/p&#39;</span> xxx.log <span style=color:#8f5902;font-style:italic># 显示包含&#34;hhh&#34;的行到包含&#34;omc&#34;的行之间的行</span>

<span style=color:#8f5902;font-style:italic># 文本替换</span>
sed -i <span style=color:#4e9a06>&#39;s/root/world/g&#39;</span> xxx.log <span style=color:#8f5902;font-style:italic># 用world 替换xxx.log文件中的root; s==search  查找并替换, g==global  全部替换, -i: implace</span>

<span style=color:#8f5902;font-style:italic># 文本插入</span>
sed <span style=color:#4e9a06>&#39;1,4i hahaha&#39;</span> xxx.log <span style=color:#8f5902;font-style:italic># 在文件第一行和第四行的每行下面添加hahaha</span>
sed -e <span style=color:#4e9a06>&#39;1i happy&#39;</span> -e <span style=color:#4e9a06>&#39;$a new year&#39;</span> xxx.log  <span style=color:#8f5902;font-style:italic>#【界面显示】在文件第一行添加happy,文件结尾添加new year</span>
sed -i -e <span style=color:#4e9a06>&#39;1i happy&#39;</span> -e <span style=color:#4e9a06>&#39;$a new year&#39;</span> xxx.log <span style=color:#8f5902;font-style:italic>#【真实写入文件】在文件第一行添加happy,文件结尾添加new year</span>

<span style=color:#8f5902;font-style:italic># 文本删除</span>
sed  <span style=color:#4e9a06>&#39;3,9d&#39;</span> xxx.log <span style=color:#8f5902;font-style:italic># 删除第3到第9行,只是不显示而已</span>
sed <span style=color:#4e9a06>&#39;/hhh/,/omc/d&#39;</span> xxx.log <span style=color:#8f5902;font-style:italic># 删除包含&#34;hhh&#34;的行到包含&#34;omc&#34;的行之间的行</span>
sed <span style=color:#4e9a06>&#39;/omc/,10d&#39;</span> xxx.log <span style=color:#8f5902;font-style:italic># 删除包含&#34;omc&#34;的行到第十行的内容</span>

<span style=color:#8f5902;font-style:italic># 与find结合</span>
find . -name  <span style=color:#4e9a06>&#34;*.txt&#34;</span> <span style=color:#000;font-weight:700>|</span>xargs   sed -i <span style=color:#4e9a06>&#39;s/hhhh/\hHHh/g&#39;</span>
find . -name  <span style=color:#4e9a06>&#34;*.txt&#34;</span> <span style=color:#000;font-weight:700>|</span>xargs   sed -i <span style=color:#4e9a06>&#39;s#hhhh#hHHh#g&#39;</span>
find . -name  <span style=color:#4e9a06>&#34;*.txt&#34;</span> -exec sed -i <span style=color:#4e9a06>&#39;s/hhhh/\hHHh/g&#39;</span> <span style=color:#ce5c00;font-weight:700>{}</span> <span style=color:#4e9a06>\;</span>
find . -name  <span style=color:#4e9a06>&#34;*.txt&#34;</span> <span style=color:#000;font-weight:700>|</span>xargs cat
</code></pre></div><h2 id=文件操作>文件操作</h2>
<h3 id=文件监听tail>文件监听：tail</h3>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=color:#8f5902;font-style:italic># 基本使用</span>
tail -f xxx.log <span style=color:#8f5902;font-style:italic># 循环监听文件</span>
tail -300f xxx.log <span style=color:#8f5902;font-style:italic>#倒数300行并追踪文件</span>
tail +20 xxx.log <span style=color:#8f5902;font-style:italic>#从第 20 行至文件末尾显示文件内容</span>

<span style=color:#8f5902;font-style:italic># tailf使用</span>
tailf xxx.log <span style=color:#8f5902;font-style:italic>#等同于tail -f -n 10 打印最后10行，然后追踪文件</span>
</code></pre></div><p>tail -f 与 tail F 与 tailf 三者区别：</p>
<ul>
<li>
<p><code>tail -f </code> 等于&ndash;follow=descriptor，根据文件描述进行追踪，当文件改名或删除后，停止追踪。</p>
</li>
<li>
<p><code>tail -F</code> 等于 &ndash;follow=name ==retry，根据文件名字进行追踪，当文件改名或删除后，保持重试，当有新的文件和他同名时，继续追踪</p>
</li>
<li>
<p><code>tailf</code> 等于tail -f -n 10（tail -f或-F默认也是打印最后10行，然后追踪文件），与tail -f不同的是，如果文件不增长，它不会去访问磁盘文件，所以tailf特别适合那些便携机上跟踪日志文件，因为它减少了磁盘访问，可以省电。</p>
</li>
</ul>
<p>参数解释：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>-f 循环读取
-q 不显示处理信息
-v 显示详细的处理信息
-c&lt;数目&gt; 显示的字节数
-n&lt;行数&gt; 显示文件的尾部 n 行内容
--pid<span style=color:#ce5c00;font-weight:700>=</span>PID 与-f合用,表示在进程ID,PID死掉之后结束
-q, --quiet, --silent 从不输出给出文件名的首部
-s, --sleep-interval<span style=color:#ce5c00;font-weight:700>=</span>S 与-f合用,表示在每次反复的间隔休眠S秒
</code></pre></div><h3 id=文件查找find>文件查找：find</h3>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>sudo -u admin find /home/admin /tmp /usr -name <span style=color:#4e9a06>\*</span>.log<span style=color:#ce5c00;font-weight:700>(</span>多个目录去找<span style=color:#ce5c00;font-weight:700>)</span>
find . -iname <span style=color:#4e9a06>\*</span>.txt<span style=color:#ce5c00;font-weight:700>(</span>大小写都匹配<span style=color:#ce5c00;font-weight:700>)</span>
find . -type d<span style=color:#ce5c00;font-weight:700>(</span>当前目录下的所有子目录<span style=color:#ce5c00;font-weight:700>)</span>
find /usr -type l<span style=color:#ce5c00;font-weight:700>(</span>当前目录下所有的符号链接<span style=color:#ce5c00;font-weight:700>)</span>
find /usr -type l -name <span style=color:#4e9a06>&#34;z*&#34;</span> -ls<span style=color:#ce5c00;font-weight:700>(</span>符号链接的详细信息 eg:inode,目录<span style=color:#ce5c00;font-weight:700>)</span>
find /home/admin -size +250000k<span style=color:#ce5c00;font-weight:700>(</span>超过250000k的文件，当然+改成-就是小于了<span style=color:#ce5c00;font-weight:700>)</span>
find /home/admin f -perm <span style=color:#0000cf;font-weight:700>777</span> -exec ls -l <span style=color:#ce5c00;font-weight:700>{}</span> <span style=color:#4e9a06>\;</span> <span style=color:#ce5c00;font-weight:700>(</span>按照权限查询文件<span style=color:#ce5c00;font-weight:700>)</span>
find /home/admin -atime -1  1天内访问过的文件
find /home/admin -ctime -1  1天内状态改变过的文件    
find /home/admin -mtime -1  1天内修改过的文件
find /home/admin -amin -1  1分钟内访问过的文件
find /home/admin -cmin -1  1分钟内状态改变过的文件    
find /home/admin -mmin -1  1分钟内修改过的文件
</code></pre></div><h4 id=pgm>pgm</h4>
<p>批量查询vm-shopbase满足条件的日志：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>pgm -A -f vm-shopbase <span style=color:#4e9a06>&#39;cat /home/admin/shopbase/logs/shopbase.log.2017-01-17|grep 2069861630&#39;</span>
</code></pre></div><h2 id=网络>网络</h2>
<h3 id=查看所有网络接口的属性>查看所有网络接口的属性</h3>
<p><code>ifconfig</code></p>
<h3 id=查看防火墙设置>查看防火墙设置</h3>
<p><code>iptables -L</code></p>
<h3 id=查看路由表>查看路由表</h3>
<p><code>route -n</code></p>
<h3 id=netstat>netstat</h3>
<ul>
<li>查看所有监听端口：<code>netstat -lntp</code></li>
<li>查看所有已经建立的连接：<code>netstat -antp</code></li>
<li>查看当前连接：<code>netstat -nat|awk '{print $6}'|sort|uniq -c|sort -rn</code></li>
<li>查看网络统计信息进程：<code>netstat -s</code></li>
</ul>
<h2 id=进程>进程</h2>
<h3 id=查看所有进程>查看所有进程</h3>
<p><code>ps -ef | grep java</code></p>
<h3 id=top>top</h3>
<p><code>top -H -p pid</code></p>
<h2 id=存储>存储</h2>
<h3 id=内存用量>内存用量</h3>
<p><code>free -m</code></p>
<h3 id=磁盘用量>磁盘用量</h3>
<p><code>df -h</code></p>
<h3 id=目录大小>目录大小</h3>
<p><code>du -sh</code></p>
<h3 id=内存总量>内存总量</h3>
<p><code>grep MemTotal /proc/meminfo</code></p>
<h3 id=内存空闲>内存空闲</h3>
<p><code>grep MemFree /proc/meminfo</code></p>
<h3 id=系统负载>系统负载</h3>
<p><code>cat /proc/loadavg</code></p>
<h3 id=挂载分区状态>挂载分区状态</h3>
<p><code>mount | column -t</code></p>
<h3 id=所有分区>所有分区</h3>
<p><code>fdisk -l</code></p>
<h3 id=所有交换分区>所有交换分区</h3>
<p><code>swapon -s</code></p>
<h3 id=硬盘大小>硬盘大小</h3>
<p><code>fdisk -l | grep Disk</code></p>
<h2 id=用户>用户</h2>
<h3 id=活动用户>活动用户</h3>
<p><code>w</code></p>
<h3 id=指定用户>指定用户</h3>
<p><code>id</code></p>
<h3 id=登录日志>登录日志</h3>
<p><code>last</code></p>
<h3 id=所有用户>所有用户</h3>
<p><code>cut -d: -f1 /etc/passwd</code></p>
<h3 id=所有用户组>所有用户组</h3>
<p><code>cut -d: f1 /etc/group</code></p>
<h3 id=查看服务>查看服务</h3>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=color:#8f5902;font-style:italic># 查看当前用户的计划任务服务</span>
crontab -l 

<span style=color:#8f5902;font-style:italic># 列出所有系统服务</span>
chkconfig –list 

<span style=color:#8f5902;font-style:italic># 列出所有启动的系统服务程序</span>
chkconfig –list <span style=color:#000;font-weight:700>|</span> grep on 

<span style=color:#8f5902;font-style:italic># 查看所有安装的软件包</span>
rpm -qa 

<span style=color:#8f5902;font-style:italic># 列出加载的内核模块</span>
lsmod 
</code></pre></div><h3 id=查看系统>查看系统</h3>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=color:#8f5902;font-style:italic># 常用</span>
env <span style=color:#8f5902;font-style:italic># 查看环境变量资源</span>
uptime <span style=color:#8f5902;font-style:italic># 查看系统运行时间、用户数、负载</span>
lsusb -tv <span style=color:#8f5902;font-style:italic># 列出所有USB设备的linux系统信息命令</span>
lspci -tv <span style=color:#8f5902;font-style:italic># 列出所有PCI设备</span>
head -n <span style=color:#0000cf;font-weight:700>1</span> /etc/issue <span style=color:#8f5902;font-style:italic># 查看操作系统版本，是数字1不是字母L</span>
uname -a <span style=color:#8f5902;font-style:italic># 查看内核/操作系统/CPU信息的linux系统信息命令</span>

<span style=color:#8f5902;font-style:italic># /proc/</span>
cat /proc/cpuinfo ：查看CPU相关参数的linux系统命令
cat /proc/partitions ：查看linux硬盘和分区信息的系统信息命令
cat /proc/meminfo ：查看linux系统内存信息的linux系统命令
cat /proc/version ：查看版本，类似uname -r
cat /proc/ioports ：查看设备io端口
cat /proc/interrupts ：查看中断
cat /proc/pci ：查看pci设备的信息
cat /proc/swaps ：查看所有swap分区的信息
cat /proc/cpuinfo <span style=color:#000;font-weight:700>|</span>grep <span style=color:#4e9a06>&#34;model name&#34;</span> <span style=color:#ce5c00;font-weight:700>&amp;&amp;</span> cat /proc/cpuinfo <span style=color:#000;font-weight:700>|</span>grep <span style=color:#4e9a06>&#34;physical id&#34;</span>
</code></pre></div><h3 id=tsar>tsar</h3>
<p>tsar是淘宝开源的的采集工具。很好用, 将历史收集到的数据持久化在磁盘上，所以我们快速来查询历史的系统数据。当然实时的应用情况也是可以查询的啦。大部分机器上都有安装。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>tsar  <span style=color:#8f5902;font-style:italic>##可以查看最近一天的各项指标</span>
tsar --live <span style=color:#8f5902;font-style:italic>##可以查看实时指标，默认五秒一刷</span>
tsar -d <span style=color:#0000cf;font-weight:700>20161218</span> <span style=color:#8f5902;font-style:italic>##指定查看某天的数据，貌似最多只能看四个月的数据</span>
tsar --mem
tsar --load
tsar --cpu <span style=color:#8f5902;font-style:italic>##当然这个也可以和-d参数配合来查询某天的单个指标的情况 </span>
</code></pre></div>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-738f442a261896462d3e74cf97e8d132>14 - CH14-JVM调试工具</h1>
<h3 id=基本工具>基本工具</h3>
<h3 id=jps>jps</h3>
<p>jps是jdk提供的一个查看当前java进程的小工具， 可以看做是JavaVirtual Machine Process Status Tool的缩写。</p>
<p>常用命令：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>jps <span style=color:#8f5902;font-style:italic># 显示进程的ID 和 类的名称</span>
jps –l <span style=color:#8f5902;font-style:italic># 输出输出完全的包名，应用主类名，jar的完全路径名 </span>
jps –v <span style=color:#8f5902;font-style:italic># 输出jvm参数</span>
jps –q <span style=color:#8f5902;font-style:italic># 显示java进程号</span>
jps -m <span style=color:#8f5902;font-style:italic># main 方法</span>
jps -l xxx.xxx.xx.xx <span style=color:#8f5902;font-style:italic># 远程查看 </span>
</code></pre></div><p>参数解释：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>-q：仅输出VM标识符，不包括classname,jar name,arguments in main method 
-m：输出main method的参数 
-l：输出完全的包名，应用主类名，jar的完全路径名 
-v：输出jvm参数 
-V：输出通过flag文件传递到JVM中的参数<span style=color:#ce5c00;font-weight:700>(</span>.hotspotrc文件或-XX:Flags<span style=color:#ce5c00;font-weight:700>=</span>所指定的文件 
-Joption：传递参数到vm,例如:-J-Xms512m
</code></pre></div><p>实现原理：</p>
<p>java程序在启动以后，会在java.io.tmpdir指定的目录下，就是临时文件夹里，生成一个类似于hsperfdata_User的文件夹，这个文件夹里（在Linux中为/tmp/hsperfdata_{userName}/），有几个文件，名字就是java进程的pid，因此列出当前运行的java进程，只是把这个目录里的文件名列一下而已。 至于系统的参数什么，就可以解析这几个文件获得。</p>
<h3 id=jstack>jstack</h3>
<p>jstack是jdk自带的线程堆栈分析工具，使用该命令可以查看或导出 Java 应用程序中线程堆栈信息。</p>
<p>jstack常用命令:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#8f5902;font-style:italic># 基本</span>
jstack <span style=color:#0000cf;font-weight:700>2815</span>

<span style=color:#8f5902;font-style:italic># java和native c/c++框架的所有栈信息</span>
jstack -m <span style=color:#0000cf;font-weight:700>2815</span>

<span style=color:#8f5902;font-style:italic># 额外的锁信息列表，查看是否死锁</span>
jstack -l <span style=color:#0000cf;font-weight:700>2815</span>
</code></pre></div><p>jstack参数：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>-l 长列表. 打印关于锁的附加信息,例如属于java.util.concurrent 的 ownable synchronizers列表.

-F 当’jstack <span style=color:#ce5c00;font-weight:700>[</span>-l<span style=color:#ce5c00;font-weight:700>]</span> pid’没有相应的时候强制打印栈信息

-m 打印java和native c/c++框架的所有栈信息.

-h <span style=color:#000;font-weight:700>|</span> -help 打印帮助信息
</code></pre></div><h3 id=jinfo>jinfo</h3>
<p>jinfo 是 JDK 自带的命令，可以用来查看正在运行的 java 应用程序的扩展参数，包括Java System属性和JVM命令行参数；也可以动态的修改正在运行的 JVM 一些参数。当系统崩溃时，jinfo可以从core文件里面知道崩溃的Java应用程序的配置信息。</p>
<p>jinfo常用命令:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#8f5902;font-style:italic># 输出当前 jvm 进程的全部参数和系统属性</span>
jinfo <span style=color:#0000cf;font-weight:700>2815</span>

<span style=color:#8f5902;font-style:italic># 输出所有的参数</span>
jinfo -flags <span style=color:#0000cf;font-weight:700>2815</span>

<span style=color:#8f5902;font-style:italic># 查看指定的 jvm 参数的值</span>
jinfo -flag PrintGC <span style=color:#0000cf;font-weight:700>2815</span>

<span style=color:#8f5902;font-style:italic># 开启/关闭指定的JVM参数</span>
jinfo -flag +PrintGC <span style=color:#0000cf;font-weight:700>2815</span>

<span style=color:#8f5902;font-style:italic># 设置flag的参数</span>
jinfo -flag <span style=color:#000>name</span><span style=color:#ce5c00;font-weight:700>=</span>value <span style=color:#0000cf;font-weight:700>2815</span>

<span style=color:#8f5902;font-style:italic># 输出当前 jvm 进行的全部的系统属性</span>
jinfo -sysprops <span style=color:#0000cf;font-weight:700>2815</span>    
</code></pre></div><p>jinfo参数：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>no option 输出全部的参数和系统属性
-flag name 输出对应名称的参数
-flag <span style=color:#ce5c00;font-weight:700>[</span>+<span style=color:#000;font-weight:700>|</span>-<span style=color:#ce5c00;font-weight:700>]</span>name 开启或者关闭对应名称的参数
-flag <span style=color:#000>name</span><span style=color:#ce5c00;font-weight:700>=</span>value 设定对应名称的参数
-flags 输出全部的参数
-sysprops 输出系统属性
</code></pre></div><h3 id=jmap>jmap</h3>
<p>命令jmap是一个多功能的命令。它可以生成 java 程序的 dump 文件， 也可以查看堆内对象示例的统计信息、查看 ClassLoader 的信息以及 finalizer 队列。</p>
<p>两个用途</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#8f5902;font-style:italic># 查看堆的情况</span>
jmap -heap <span style=color:#0000cf;font-weight:700>2815</span>

<span style=color:#8f5902;font-style:italic># dump</span>
jmap -dump:live,format<span style=color:#ce5c00;font-weight:700>=</span>b,file<span style=color:#ce5c00;font-weight:700>=</span>/tmp/heap2.bin <span style=color:#0000cf;font-weight:700>2815</span>
jmap -dump:format<span style=color:#ce5c00;font-weight:700>=</span>b,file<span style=color:#ce5c00;font-weight:700>=</span>/tmp/heap3.bin <span style=color:#0000cf;font-weight:700>2815</span>

<span style=color:#8f5902;font-style:italic># 查看堆的占用</span>
jmap -histo <span style=color:#0000cf;font-weight:700>2815</span> <span style=color:#000;font-weight:700>|</span> head -10    
</code></pre></div><p>jmap参数</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>no option： 查看进程的内存映像信息,类似 Solaris pmap 命令。
heap： 显示Java堆详细信息
histo<span style=color:#ce5c00;font-weight:700>[</span>:live<span style=color:#ce5c00;font-weight:700>]</span>： 显示堆中对象的统计信息
clstats：打印类加载器信息
finalizerinfo： 显示在F-Queue队列等待Finalizer线程执行finalizer方法的对象
dump:&lt;dump-options&gt;：生成堆转储快照
F： 当-dump没有响应时，使用-dump或者-histo参数. 在这个模式下,live子参数无效.
help：打印帮助信息
J&lt;flag&gt;：指定传递给运行jmap的JVM的参数
</code></pre></div><h3 id=jstat>jstat</h3>
<p><code>jstat -gcutil 2815 1000 </code></p>
<h3 id=jdb>jdb</h3>
<p>jdb可以用来预发debug,假设你预发的java_home是/opt/java/，远程调试端口是8000.那么</p>
<p><code>jdb -attach 8000</code></p>
<p>出现以上代表jdb启动成功。后续可以进行设置断点进行调试。</p>
<h2 id=chlsdb>CHLSDB</h2>
<p>实现 jstack和jmap的基础。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>java -classpath /opt/taobao/java/lib/sa-jdi.jar sun.jvm.hotspot.CLHSDB
</code></pre></div><h2 id=进阶工具>进阶工具</h2>
<ul>
<li>btrace</li>
<li>greys</li>
<li>arthas</li>
<li>javOSize</li>
<li>JProfiler</li>
<li>dmesg</li>
<li>IDEA remote debugger</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-79c89a1a04f19d45ae69a0cc19e2363d>15 - CH15-JVM动态调试</h1>
<h2 id=动态调试要解决的问题>动态调试要解决的问题</h2>
<p>断点调试是我们最常使用的调试手段，它可以获取到方法执行过程中的变量信息，并可以观察到方法的执行路径。但断点调试会在断点位置停顿，使得整个应用停止响应。在线上停顿应用是致命的，动态调试技术给了我们创造新的调试模式的想象空间。本文将研究Java语言中的动态调试技术，首先概括Java动态调试所涉及的技术基础，接着介绍我们在Java动态调试领域的思考及实践，通过结合实际业务场景，设计并实现了一种具备动态性的断点调试工具Java-debug-tool，显著提高了故障排查效率。</p>
<h2 id=java-agent技术>Java Agent技术</h2>
<p>JVMTI （JVM Tool Interface）是Java虚拟机对外提供的Native编程接口，通过JVMTI，外部进程可以获取到运行时JVM的诸多信息，比如线程、GC等。Agent是一个运行在目标JVM的特定程序，它的职责是负责从目标JVM中获取数据，然后将数据传递给外部进程。加载Agent的时机可以是目标JVM启动之时，也可以是在目标JVM运行时进行加载，而在目标JVM运行时进行Agent加载具备动态性，对于时机未知的Debug场景来说非常实用。下面将详细分析Java Agent技术的实现细节。</p>
<h3 id=agent的实现模式>Agent的实现模式</h3>
<p>JVMTI是一套Native接口，在Java SE 5之前，要实现一个Agent只能通过编写Native代码来实现。从Java SE 5开始，可以使用Java的Instrumentation接口（java.lang.instrument）来编写Agent。无论是通过Native的方式还是通过Java Instrumentation接口的方式来编写Agent，它们的工作都是借助JVMTI来进行完成，下面介绍通过Java Instrumentation接口编写Agent的方法。</p>
<h4 id=通过java-instrumentation-api>通过Java Instrumentation API</h4>
<ul>
<li>实现Agent启动方法</li>
</ul>
<p>Java Agent支持目标JVM启动时加载，也支持在目标JVM运行时加载，这两种不同的加载模式会使用不同的入口函数，如果需要在目标JVM启动的同时加载Agent，那么可以选择实现下面的方法：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#ce5c00;font-weight:700>[</span><span style=color:#000>1</span><span style=color:#ce5c00;font-weight:700>]</span> <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>static</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>premain</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>String</span> <span style=color:#000>agentArgs</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>Instrumentation</span> <span style=color:#000>inst</span><span style=color:#ce5c00;font-weight:700>);</span>
<span style=color:#ce5c00;font-weight:700>[</span><span style=color:#000>2</span><span style=color:#ce5c00;font-weight:700>]</span> <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>static</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>premain</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>String</span> <span style=color:#000>agentArgs</span><span style=color:#ce5c00;font-weight:700>);</span>
</code></pre></div><p>JVM将首先寻找 1，如果没有发现 1，再寻找 2。如果希望在目标JVM运行时加载Agent，则需要实现下面的方法：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#ce5c00;font-weight:700>[</span><span style=color:#000>1</span><span style=color:#ce5c00;font-weight:700>]</span> <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>static</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>agentmain</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>String</span> <span style=color:#000>agentArgs</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>Instrumentation</span> <span style=color:#000>inst</span><span style=color:#ce5c00;font-weight:700>);</span>
<span style=color:#ce5c00;font-weight:700>[</span><span style=color:#000>2</span><span style=color:#ce5c00;font-weight:700>]</span> <span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>static</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>agentmain</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>String</span> <span style=color:#000>agentArgs</span><span style=color:#ce5c00;font-weight:700>);</span>
</code></pre></div><p>这两组方法的第一个参数AgentArgs是随同 “– javaagent”一起传入的程序参数，如果这个字符串代表了多个参数，就需要自己解析这些参数。inst是Instrumentation类型的对象，是JVM自动传入的，我们可以拿这个参数进行类增强等操作。</p>
<ul>
<li>指定Main-Class</li>
</ul>
<p>Agent需要打包成一个jar包，在ManiFest属性中指定“Premain-Class”或者“Agent-Class”：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#000>Premain</span><span style=color:#ce5c00;font-weight:700>-</span><span style=color:#000>Class</span><span style=color:#ce5c00;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>class</span>
<span style=color:#000>Agent</span><span style=color:#ce5c00;font-weight:700>-</span><span style=color:#000>Class</span><span style=color:#ce5c00;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>class</span>
</code></pre></div><ul>
<li>挂载到目标JVM</li>
</ul>
<p>将编写的Agent打成jar包后，就可以挂载到目标JVM上去了。如果选择在目标JVM启动时加载Agent，则可以使用 “-javaagent:[=</p>
<p>com.sun.tools.attach.VirtualMachine 这个类代表一个JVM抽象，可以通过这个类找到目标JVM，并且将Agent挂载到目标JVM上。下面是使用com.sun.tools.attach.VirtualMachine进行动态挂载Agent的一般实现：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#204a87;font-weight:700>private</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>attachAgentToTargetJVM</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#204a87;font-weight:700>throws</span> <span style=color:#000>Exception</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#000>List</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>VirtualMachineDescriptor</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>virtualMachineDescriptors</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>VirtualMachine</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>list</span><span style=color:#ce5c00;font-weight:700>();</span>
    <span style=color:#000>VirtualMachineDescriptor</span> <span style=color:#000>targetVM</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>null</span><span style=color:#ce5c00;font-weight:700>;</span>
    <span style=color:#204a87;font-weight:700>for</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>VirtualMachineDescriptor</span> <span style=color:#000>descriptor</span> <span style=color:#ce5c00;font-weight:700>:</span> <span style=color:#000>virtualMachineDescriptors</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
        <span style=color:#204a87;font-weight:700>if</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>descriptor</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>id</span><span style=color:#ce5c00;font-weight:700>().</span><span style=color:#c4a000>equals</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>configure</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>getPid</span><span style=color:#ce5c00;font-weight:700>()))</span> <span style=color:#ce5c00;font-weight:700>{</span>
            <span style=color:#000>targetVM</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>descriptor</span><span style=color:#ce5c00;font-weight:700>;</span>
            <span style=color:#204a87;font-weight:700>break</span><span style=color:#ce5c00;font-weight:700>;</span>
        <span style=color:#ce5c00;font-weight:700>}</span>
    <span style=color:#ce5c00;font-weight:700>}</span>
    <span style=color:#204a87;font-weight:700>if</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>targetVM</span> <span style=color:#ce5c00;font-weight:700>==</span> <span style=color:#204a87;font-weight:700>null</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
        <span style=color:#204a87;font-weight:700>throw</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>IllegalArgumentException</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#4e9a06>&#34;could not find the target jvm by process id:&#34;</span> <span style=color:#ce5c00;font-weight:700>+</span> <span style=color:#000>configure</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>getPid</span><span style=color:#ce5c00;font-weight:700>());</span>
    <span style=color:#ce5c00;font-weight:700>}</span>
    <span style=color:#000>VirtualMachine</span> <span style=color:#000>virtualMachine</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>null</span><span style=color:#ce5c00;font-weight:700>;</span>
    <span style=color:#204a87;font-weight:700>try</span> <span style=color:#ce5c00;font-weight:700>{</span>
        <span style=color:#000>virtualMachine</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>VirtualMachine</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>attach</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>targetVM</span><span style=color:#ce5c00;font-weight:700>);</span>
        <span style=color:#000>virtualMachine</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>loadAgent</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#4e9a06>&#34;{agent}&#34;</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#4e9a06>&#34;{params}&#34;</span><span style=color:#ce5c00;font-weight:700>);</span>
    <span style=color:#ce5c00;font-weight:700>}</span> <span style=color:#204a87;font-weight:700>catch</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>Exception</span> <span style=color:#000>e</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
        <span style=color:#204a87;font-weight:700>if</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>virtualMachine</span> <span style=color:#ce5c00;font-weight:700>!=</span> <span style=color:#204a87;font-weight:700>null</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
            <span style=color:#000>virtualMachine</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>detach</span><span style=color:#ce5c00;font-weight:700>();</span>
        <span style=color:#ce5c00;font-weight:700>}</span>
    <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>首先通过指定的进程ID找到目标JVM，然后通过Attach挂载到目标JVM上，执行加载Agent操作。VirtualMachine的Attach方法就是用来将Agent挂载到目标JVM上去的，而Detach则是将Agent从目标JVM卸载。关于Agent是如何挂载到目标JVM上的具体技术细节，将在下文中进行分析。</p>
<h3 id=启动时加载agent>启动时加载Agent</h3>
<h4 id=参数解析>参数解析</h4>
<p>创建JVM时，JVM会进行参数解析，即解析那些用来配置JVM启动的参数，比如堆大小、GC等；本文主要关注解析的参数为-agentlib、 -agentpath、 -javaagent，这几个参数用来指定Agent，JVM会根据这几个参数加载Agent。下面来分析一下JVM是如何解析这几个参数的。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java>  <span style=color:#8f5902;font-style:italic>// -agentlib and -agentpath
</span><span style=color:#8f5902;font-style:italic></span>  <span style=color:#204a87;font-weight:700>if</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>match_option</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>option</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#4e9a06>&#34;-agentlib:&#34;</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#ce5c00;font-weight:700>&amp;</span><span style=color:#000>tail</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>||</span>
          <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>is_absolute_path</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>match_option</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>option</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#4e9a06>&#34;-agentpath:&#34;</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#ce5c00;font-weight:700>&amp;</span><span style=color:#000>tail</span><span style=color:#ce5c00;font-weight:700>)))</span> <span style=color:#ce5c00;font-weight:700>{</span>
      <span style=color:#204a87;font-weight:700>if</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>tail</span> <span style=color:#ce5c00;font-weight:700>!=</span> <span style=color:#000>NULL</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
        <span style=color:#204a87;font-weight:700>const</span> <span style=color:#204a87;font-weight:700>char</span><span style=color:#ce5c00;font-weight:700>*</span> <span style=color:#000>pos</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>strchr</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>tail</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#4e9a06>&#39;=&#39;</span><span style=color:#ce5c00;font-weight:700>);</span>
        <span style=color:#000>size_t</span> <span style=color:#000>len</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>pos</span> <span style=color:#ce5c00;font-weight:700>==</span> <span style=color:#000>NULL</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>?</span> <span style=color:#000>strlen</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>tail</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>:</span> <span style=color:#000>pos</span> <span style=color:#ce5c00;font-weight:700>-</span> <span style=color:#000>tail</span><span style=color:#ce5c00;font-weight:700>;</span>
        <span style=color:#204a87;font-weight:700>char</span><span style=color:#ce5c00;font-weight:700>*</span> <span style=color:#000>name</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>strncpy</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>NEW_C_HEAP_ARRAY</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>char</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>len</span> <span style=color:#ce5c00;font-weight:700>+</span> <span style=color:#000>1</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>mtArguments</span><span style=color:#ce5c00;font-weight:700>),</span> <span style=color:#000>tail</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>len</span><span style=color:#ce5c00;font-weight:700>);</span>
        <span style=color:#000>name</span><span style=color:#ce5c00;font-weight:700>[</span><span style=color:#000>len</span><span style=color:#ce5c00;font-weight:700>]</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#4e9a06>&#39;\0&#39;</span><span style=color:#ce5c00;font-weight:700>;</span>
        <span style=color:#204a87;font-weight:700>char</span> <span style=color:#ce5c00;font-weight:700>*</span><span style=color:#000>options</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>NULL</span><span style=color:#ce5c00;font-weight:700>;</span>
        <span style=color:#204a87;font-weight:700>if</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>pos</span> <span style=color:#ce5c00;font-weight:700>!=</span> <span style=color:#000>NULL</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
          <span style=color:#000>options</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>os</span><span style=color:#ce5c00;font-weight:700>::</span><span style=color:#000>strdup_check_oom</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>pos</span> <span style=color:#ce5c00;font-weight:700>+</span> <span style=color:#000>1</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>mtArguments</span><span style=color:#ce5c00;font-weight:700>);</span>
        <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#a40000>#</span><span style=color:#204a87;font-weight:700>if</span> <span style=color:#ce5c00;font-weight:700>!</span><span style=color:#000>INCLUDE_JVMTI</span>
        <span style=color:#000>if</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>valid_jdwp_agent</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>name</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>is_absolute_path</span><span style=color:#ce5c00;font-weight:700>))</span> <span style=color:#ce5c00;font-weight:700>{</span>
          <span style=color:#000>jio_fprintf</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>defaultStream</span><span style=color:#ce5c00;font-weight:700>::</span><span style=color:#000>error_stream</span><span style=color:#ce5c00;font-weight:700>(),</span>
            <span style=color:#4e9a06>&#34;Debugging agents are not supported in this VM\n&#34;</span><span style=color:#ce5c00;font-weight:700>);</span>
          <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>JNI_ERR</span><span style=color:#ce5c00;font-weight:700>;</span>
        <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#a40000>#</span><span style=color:#000>endif</span> <span style=color:#8f5902;font-style:italic>// !INCLUDE_JVMTI
</span><span style=color:#8f5902;font-style:italic></span>        <span style=color:#000>add_init_agent</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>name</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>options</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>is_absolute_path</span><span style=color:#ce5c00;font-weight:700>);</span>
      <span style=color:#ce5c00;font-weight:700>}</span>
    <span style=color:#8f5902;font-style:italic>// -javaagent
</span><span style=color:#8f5902;font-style:italic></span>    <span style=color:#ce5c00;font-weight:700>}</span> <span style=color:#204a87;font-weight:700>else</span> <span style=color:#204a87;font-weight:700>if</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>match_option</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>option</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#4e9a06>&#34;-javaagent:&#34;</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#ce5c00;font-weight:700>&amp;</span><span style=color:#000>tail</span><span style=color:#ce5c00;font-weight:700>))</span> <span style=color:#ce5c00;font-weight:700>{</span>
<span style=color:#a40000>#</span><span style=color:#204a87;font-weight:700>if</span> <span style=color:#ce5c00;font-weight:700>!</span><span style=color:#000>INCLUDE_JVMTI</span>
      <span style=color:#000>jio_fprintf</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>defaultStream</span><span style=color:#ce5c00;font-weight:700>::</span><span style=color:#000>error_stream</span><span style=color:#ce5c00;font-weight:700>(),</span>
        <span style=color:#4e9a06>&#34;Instrumentation agents are not supported in this VM\n&#34;</span><span style=color:#ce5c00;font-weight:700>);</span>
      <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>JNI_ERR</span><span style=color:#ce5c00;font-weight:700>;</span>
<span style=color:#a40000>#</span><span style=color:#204a87;font-weight:700>else</span>
      <span style=color:#204a87;font-weight:700>if</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>tail</span> <span style=color:#ce5c00;font-weight:700>!=</span> <span style=color:#000>NULL</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
        <span style=color:#000>size_t</span> <span style=color:#000>length</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>strlen</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>tail</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>+</span> <span style=color:#000>1</span><span style=color:#ce5c00;font-weight:700>;</span>
        <span style=color:#204a87;font-weight:700>char</span> <span style=color:#ce5c00;font-weight:700>*</span><span style=color:#000>options</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>NEW_C_HEAP_ARRAY</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>char</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>length</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>mtArguments</span><span style=color:#ce5c00;font-weight:700>);</span>
        <span style=color:#000>jio_snprintf</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>options</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>length</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#4e9a06>&#34;%s&#34;</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>tail</span><span style=color:#ce5c00;font-weight:700>);</span>
        <span style=color:#000>add_init_agent</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#4e9a06>&#34;instrument&#34;</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>options</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#204a87;font-weight:700>false</span><span style=color:#ce5c00;font-weight:700>);</span>
        <span style=color:#8f5902;font-style:italic>// java agents need module java.instrument
</span><span style=color:#8f5902;font-style:italic></span>        <span style=color:#204a87;font-weight:700>if</span> <span style=color:#ce5c00;font-weight:700>(!</span><span style=color:#000>create_numbered_property</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#4e9a06>&#34;jdk.module.addmods&#34;</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#4e9a06>&#34;java.instrument&#34;</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>addmods_count</span><span style=color:#ce5c00;font-weight:700>++))</span> <span style=color:#ce5c00;font-weight:700>{</span>
          <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>JNI_ENOMEM</span><span style=color:#ce5c00;font-weight:700>;</span>
        <span style=color:#ce5c00;font-weight:700>}</span>
      <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#a40000>#</span><span style=color:#000>endif</span> <span style=color:#8f5902;font-style:italic>// !INCLUDE_JVMTI
</span><span style=color:#8f5902;font-style:italic></span>    <span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>上面的代码片段截取自hotspot/src/share/vm/runtime/arguments.cpp中的 Arguments::parse_each_vm_init_arg(const JavaVMInitArgs* args, bool* patch_mod_javabase, Flag::Flags origin) 函数，该函数用来解析一个具体的JVM参数。这段代码的主要功能是解析出需要加载的Agent路径，然后调用add_init_agent函数进行解析结果的存储。下面先看一下add_init_agent函数的具体实现：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java> <span style=color:#8f5902;font-style:italic>// -agentlib and -agentpath arguments
</span><span style=color:#8f5902;font-style:italic></span>  <span style=color:#204a87;font-weight:700>static</span> <span style=color:#000>AgentLibraryList</span> <span style=color:#000>_agentList</span><span style=color:#ce5c00;font-weight:700>;</span>
  <span style=color:#204a87;font-weight:700>static</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>add_init_agent</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>const</span> <span style=color:#204a87;font-weight:700>char</span><span style=color:#ce5c00;font-weight:700>*</span> <span style=color:#000>name</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#204a87;font-weight:700>char</span><span style=color:#ce5c00;font-weight:700>*</span> <span style=color:#000>options</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>bool</span> <span style=color:#000>absolute_path</span><span style=color:#ce5c00;font-weight:700>)</span>
    <span style=color:#ce5c00;font-weight:700>{</span> <span style=color:#000>_agentList</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>add</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>AgentLibrary</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>name</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>options</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>absolute_path</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>NULL</span><span style=color:#ce5c00;font-weight:700>));</span> <span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>AgentLibraryList是一个简单的链表结构，add_init_agent函数将解析好的、需要加载的Agent添加到这个链表中，等待后续的处理。</p>
<p>这里需要注意，解析-javaagent参数有一些特别之处，这个参数用来指定一个我们通过Java Instrumentation API来编写的Agent，Java Instrumentation API底层依赖的是JVMTI，对-JavaAgent的处理也说明了这一点，在调用add_init_agent函数时第一个参数是“instrument”，关于加载Agent这个问题在下一小节进行展开。到此，我们知道在启动JVM时指定的Agent已经被JVM解析完存放在了一个链表结构中。下面来分析一下JVM是如何加载这些Agent的。</p>
<h4 id=执行加载操作>执行加载操作</h4>
<p>在创建JVM进程的函数中，解析完JVM参数之后，下面的这段代码和加载Agent相关：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java>  <span style=color:#8f5902;font-style:italic>// Launch -agentlib/-agentpath and converted -Xrun agents
</span><span style=color:#8f5902;font-style:italic></span>  <span style=color:#204a87;font-weight:700>if</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>Arguments</span><span style=color:#ce5c00;font-weight:700>::</span><span style=color:#000>init_agents_at_startup</span><span style=color:#ce5c00;font-weight:700>())</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#000>create_vm_init_agents</span><span style=color:#ce5c00;font-weight:700>();</span>
  <span style=color:#ce5c00;font-weight:700>}</span>
  <span style=color:#204a87;font-weight:700>static</span> <span style=color:#000>bool</span> <span style=color:#000>init_agents_at_startup</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#204a87;font-weight:700>return</span> <span style=color:#ce5c00;font-weight:700>!</span><span style=color:#000>_agentList</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>is_empty</span><span style=color:#ce5c00;font-weight:700>();</span> 
  <span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>当JVM判断出上一小节中解析出来的Agent不为空的时候，就要去调用函数create_vm_init_agents来加载Agent，下面来分析一下create_vm_init_agents函数是如何加载Agent的。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>Threads</span><span style=color:#ce5c00;font-weight:700>::</span><span style=color:#000>create_vm_init_agents</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span>
  <span style=color:#000>AgentLibrary</span><span style=color:#ce5c00;font-weight:700>*</span> <span style=color:#000>agent</span><span style=color:#ce5c00;font-weight:700>;</span>
  <span style=color:#204a87;font-weight:700>for</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>agent</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>Arguments</span><span style=color:#ce5c00;font-weight:700>::</span><span style=color:#000>agents</span><span style=color:#ce5c00;font-weight:700>();</span> <span style=color:#000>agent</span> <span style=color:#ce5c00;font-weight:700>!=</span> <span style=color:#000>NULL</span><span style=color:#ce5c00;font-weight:700>;</span> <span style=color:#000>agent</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>agent</span><span style=color:#ce5c00;font-weight:700>-&gt;</span><span style=color:#000>next</span><span style=color:#ce5c00;font-weight:700>())</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#000>OnLoadEntry_t</span>  <span style=color:#000>on_load_entry</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>lookup_agent_on_load</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>agent</span><span style=color:#ce5c00;font-weight:700>);</span>
    <span style=color:#204a87;font-weight:700>if</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>on_load_entry</span> <span style=color:#ce5c00;font-weight:700>!=</span> <span style=color:#000>NULL</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
      <span style=color:#8f5902;font-style:italic>// Invoke the Agent_OnLoad function
</span><span style=color:#8f5902;font-style:italic></span>      <span style=color:#000>jint</span> <span style=color:#000>err</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#ce5c00;font-weight:700>(*</span><span style=color:#000>on_load_entry</span><span style=color:#ce5c00;font-weight:700>)(&amp;</span><span style=color:#000>main_vm</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>agent</span><span style=color:#ce5c00;font-weight:700>-&gt;</span><span style=color:#000>options</span><span style=color:#ce5c00;font-weight:700>(),</span> <span style=color:#000>NULL</span><span style=color:#ce5c00;font-weight:700>);</span>
    <span style=color:#ce5c00;font-weight:700>}</span>
  <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>create_vm_init_agents这个函数通过遍历Agent链表来逐个加载Agent。通过这段代码可以看出，首先通过lookup_agent_on_load来加载Agent并且找到Agent_OnLoad函数，这个函数是Agent的入口函数。如果没找到这个函数，则认为是加载了一个不合法的Agent，则什么也不做，否则调用这个函数，这样Agent的代码就开始执行起来了。对于使用Java Instrumentation API来编写Agent的方式来说，在解析阶段观察到在add_init_agent函数里面传递进去的是一个叫做”instrument”的字符串，其实这是一个动态链接库。在Linux里面，这个库叫做libinstrument.so，在BSD系统中叫做libinstrument.dylib，该动态链接库在{JAVA_HOME}/jre/lib/目录下。</p>
<h4 id=instrument动态链接库>instrument动态链接库</h4>
<p>libinstrument用来支持使用Java Instrumentation API来编写Agent，在libinstrument中有一个非常重要的类称为：JPLISAgent（Java Programming Language Instrumentation Services Agent），它的作用是初始化所有通过Java Instrumentation API编写的Agent，并且也承担着通过JVMTI实现Java Instrumentation中暴露API的责任。</p>
<p>我们已经知道，在JVM启动的时候，JVM会通过-javaagent参数加载Agent。最开始加载的是libinstrument动态链接库，然后在动态链接库里面找到JVMTI的入口方法：Agent_OnLoad。下面就来分析一下在libinstrument动态链接库中，Agent_OnLoad函数是怎么实现的。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#000>JNIEXPORT</span> <span style=color:#000>jint</span> <span style=color:#000>JNICALL</span>
<span style=color:#000>DEF_Agent_OnLoad</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>JavaVM</span> <span style=color:#ce5c00;font-weight:700>*</span><span style=color:#000>vm</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#204a87;font-weight:700>char</span> <span style=color:#ce5c00;font-weight:700>*</span><span style=color:#000>tail</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#ce5c00;font-weight:700>*</span> <span style=color:#000>reserved</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#000>initerror</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>createNewJPLISAgent</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>vm</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#ce5c00;font-weight:700>&amp;</span><span style=color:#000>agent</span><span style=color:#ce5c00;font-weight:700>);</span>
    <span style=color:#204a87;font-weight:700>if</span> <span style=color:#ce5c00;font-weight:700>(</span> <span style=color:#000>initerror</span> <span style=color:#ce5c00;font-weight:700>==</span> <span style=color:#000>JPLIS_INIT_ERROR_NONE</span> <span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
        <span style=color:#204a87;font-weight:700>if</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>parseArgumentTail</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>tail</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#ce5c00;font-weight:700>&amp;</span><span style=color:#000>jarfile</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#ce5c00;font-weight:700>&amp;</span><span style=color:#000>options</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>!=</span> <span style=color:#000>0</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
            <span style=color:#000>fprintf</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>stderr</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#4e9a06>&#34;-javaagent: memory allocation failure.\n&#34;</span><span style=color:#ce5c00;font-weight:700>);</span>
            <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>JNI_ERR</span><span style=color:#ce5c00;font-weight:700>;</span>
        <span style=color:#ce5c00;font-weight:700>}</span>
        <span style=color:#000>attributes</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>readAttributes</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>jarfile</span><span style=color:#ce5c00;font-weight:700>);</span>
        <span style=color:#000>premainClass</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>getAttribute</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>attributes</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#4e9a06>&#34;Premain-Class&#34;</span><span style=color:#ce5c00;font-weight:700>);</span>
        <span style=color:#8f5902;font-style:italic>/* Save the jarfile name */</span>
        <span style=color:#000>agent</span><span style=color:#ce5c00;font-weight:700>-&gt;</span><span style=color:#000>mJarfile</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>jarfile</span><span style=color:#ce5c00;font-weight:700>;</span>
        <span style=color:#8f5902;font-style:italic>/*
</span><span style=color:#8f5902;font-style:italic>         * Convert JAR attributes into agent capabilities
</span><span style=color:#8f5902;font-style:italic>         */</span>
        <span style=color:#000>convertCapabilityAttributes</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>attributes</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>agent</span><span style=color:#ce5c00;font-weight:700>);</span>
        <span style=color:#8f5902;font-style:italic>/*
</span><span style=color:#8f5902;font-style:italic>         * Track (record) the agent class name and options data
</span><span style=color:#8f5902;font-style:italic>         */</span>
        <span style=color:#000>initerror</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>recordCommandLineData</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>agent</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>premainClass</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>options</span><span style=color:#ce5c00;font-weight:700>);</span>
    <span style=color:#ce5c00;font-weight:700>}</span>
    <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>result</span><span style=color:#ce5c00;font-weight:700>;</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>上述代码片段是经过精简的libinstrument中Agent_OnLoad实现的，大概的流程就是：先创建一个JPLISAgent，然后将ManiFest中设定的一些参数解析出来， 比如（Premain-Class）等。创建了JPLISAgent之后，调用initializeJPLISAgent对这个Agent进行初始化操作。跟进initializeJPLISAgent看一下是如何初始化的：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#000>JPLISInitializationError</span> <span style=color:#000>initializeJPLISAgent</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>JPLISAgent</span> <span style=color:#ce5c00;font-weight:700>*</span><span style=color:#000>agent</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>JavaVM</span> <span style=color:#ce5c00;font-weight:700>*</span><span style=color:#000>vm</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>jvmtiEnv</span> <span style=color:#ce5c00;font-weight:700>*</span><span style=color:#000>jvmtienv</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#8f5902;font-style:italic>/* check what capabilities are available */</span>
    <span style=color:#000>checkCapabilities</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>agent</span><span style=color:#ce5c00;font-weight:700>);</span>
    <span style=color:#8f5902;font-style:italic>/* check phase - if live phase then we don&#39;t need the VMInit event */</span>
    <span style=color:#000>jvmtierror</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#ce5c00;font-weight:700>(*</span><span style=color:#000>jvmtienv</span><span style=color:#ce5c00;font-weight:700>)-&gt;</span><span style=color:#000>GetPhase</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>jvmtienv</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#ce5c00;font-weight:700>&amp;</span><span style=color:#000>phase</span><span style=color:#ce5c00;font-weight:700>);</span>
    <span style=color:#8f5902;font-style:italic>/* now turn on the VMInit event */</span>
    <span style=color:#204a87;font-weight:700>if</span> <span style=color:#ce5c00;font-weight:700>(</span> <span style=color:#000>jvmtierror</span> <span style=color:#ce5c00;font-weight:700>==</span> <span style=color:#000>JVMTI_ERROR_NONE</span> <span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
        <span style=color:#000>jvmtiEventCallbacks</span> <span style=color:#000>callbacks</span><span style=color:#ce5c00;font-weight:700>;</span>
        <span style=color:#000>memset</span><span style=color:#ce5c00;font-weight:700>(&amp;</span><span style=color:#000>callbacks</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>0</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>sizeof</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>callbacks</span><span style=color:#ce5c00;font-weight:700>));</span>
        <span style=color:#000>callbacks</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>VMInit</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#ce5c00;font-weight:700>&amp;</span><span style=color:#000>eventHandlerVMInit</span><span style=color:#ce5c00;font-weight:700>;</span>
        <span style=color:#000>jvmtierror</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#ce5c00;font-weight:700>(*</span><span style=color:#000>jvmtienv</span><span style=color:#ce5c00;font-weight:700>)-&gt;</span><span style=color:#000>SetEventCallbacks</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>jvmtienv</span><span style=color:#ce5c00;font-weight:700>,&amp;</span><span style=color:#000>callbacks</span><span style=color:#ce5c00;font-weight:700>,</span><span style=color:#000>sizeof</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>callbacks</span><span style=color:#ce5c00;font-weight:700>));</span>
    <span style=color:#ce5c00;font-weight:700>}</span>
    <span style=color:#204a87;font-weight:700>if</span> <span style=color:#ce5c00;font-weight:700>(</span> <span style=color:#000>jvmtierror</span> <span style=color:#ce5c00;font-weight:700>==</span> <span style=color:#000>JVMTI_ERROR_NONE</span> <span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
        <span style=color:#000>jvmtierror</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#ce5c00;font-weight:700>(*</span><span style=color:#000>jvmtienv</span><span style=color:#ce5c00;font-weight:700>)-&gt;</span><span style=color:#000>SetEventNotificationMode</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>jvmtienv</span><span style=color:#ce5c00;font-weight:700>,</span><span style=color:#000>JVMTI_ENABLE</span><span style=color:#ce5c00;font-weight:700>,</span><span style=color:#000>JVMTI_EVENT_VM_INIT</span><span style=color:#ce5c00;font-weight:700>,</span><span style=color:#000>NULL</span><span style=color:#ce5c00;font-weight:700>);</span>
    <span style=color:#ce5c00;font-weight:700>}</span>
    <span style=color:#204a87;font-weight:700>return</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>jvmtierror</span> <span style=color:#ce5c00;font-weight:700>==</span> <span style=color:#000>JVMTI_ERROR_NONE</span><span style=color:#ce5c00;font-weight:700>)?</span> <span style=color:#000>JPLIS_INIT_ERROR_NONE</span> <span style=color:#ce5c00;font-weight:700>:</span> <span style=color:#000>JPLIS_INIT_ERROR_FAILURE</span><span style=color:#ce5c00;font-weight:700>;</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>这里，我们关注callbacks.VMInit = &amp;eventHandlerVMInit;这行代码，这里设置了一个VMInit事件的回调函数，表示在JVM初始化的时候会回调eventHandlerVMInit函数。下面来看一下这个函数的实现细节，猜测就是在这里调用了Premain方法：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>JNICALL</span>  <span style=color:#000>eventHandlerVMInit</span><span style=color:#ce5c00;font-weight:700>(</span> <span style=color:#000>jvmtiEnv</span> <span style=color:#ce5c00;font-weight:700>*</span><span style=color:#000>jvmtienv</span><span style=color:#ce5c00;font-weight:700>,</span><span style=color:#000>JNIEnv</span> <span style=color:#ce5c00;font-weight:700>*</span><span style=color:#000>jnienv</span><span style=color:#ce5c00;font-weight:700>,</span><span style=color:#000>jthread</span> <span style=color:#000>thread</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
   <span style=color:#8f5902;font-style:italic>// ...
</span><span style=color:#8f5902;font-style:italic></span>   <span style=color:#000>success</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>processJavaStart</span><span style=color:#ce5c00;font-weight:700>(</span> <span style=color:#000>environment</span><span style=color:#ce5c00;font-weight:700>-&gt;</span><span style=color:#000>mAgent</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>jnienv</span><span style=color:#ce5c00;font-weight:700>);</span>
  <span style=color:#8f5902;font-style:italic>// ...
</span><span style=color:#8f5902;font-style:italic></span><span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#000>jboolean</span>  <span style=color:#000>processJavaStart</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>JPLISAgent</span> <span style=color:#ce5c00;font-weight:700>*</span><span style=color:#000>agent</span><span style=color:#ce5c00;font-weight:700>,</span><span style=color:#000>JNIEnv</span> <span style=color:#ce5c00;font-weight:700>*</span><span style=color:#000>jnienv</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#000>result</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>createInstrumentationImpl</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>jnienv</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>agent</span><span style=color:#ce5c00;font-weight:700>);</span>
    <span style=color:#8f5902;font-style:italic>/*
</span><span style=color:#8f5902;font-style:italic>     *  Load the Java agent, and call the premain.
</span><span style=color:#8f5902;font-style:italic>     */</span>
    <span style=color:#204a87;font-weight:700>if</span> <span style=color:#ce5c00;font-weight:700>(</span> <span style=color:#000>result</span> <span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
        <span style=color:#000>result</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>startJavaAgent</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>agent</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>jnienv</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>agent</span><span style=color:#ce5c00;font-weight:700>-&gt;</span><span style=color:#000>mAgentClassName</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>agent</span><span style=color:#ce5c00;font-weight:700>-&gt;</span><span style=color:#000>mOptionsString</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>agent</span><span style=color:#ce5c00;font-weight:700>-&gt;</span><span style=color:#000>mPremainCaller</span><span style=color:#ce5c00;font-weight:700>);</span>
    <span style=color:#ce5c00;font-weight:700>}</span>
    <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>result</span><span style=color:#ce5c00;font-weight:700>;</span>
<span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#000>jboolean</span> <span style=color:#000>startJavaAgent</span><span style=color:#ce5c00;font-weight:700>(</span> <span style=color:#000>JPLISAgent</span> <span style=color:#ce5c00;font-weight:700>*</span><span style=color:#000>agent</span><span style=color:#ce5c00;font-weight:700>,</span><span style=color:#000>JNIEnv</span> <span style=color:#ce5c00;font-weight:700>*</span><span style=color:#000>jnienv</span><span style=color:#ce5c00;font-weight:700>,</span><span style=color:#204a87;font-weight:700>const</span> <span style=color:#204a87;font-weight:700>char</span> <span style=color:#ce5c00;font-weight:700>*</span><span style=color:#000>classname</span><span style=color:#ce5c00;font-weight:700>,</span><span style=color:#204a87;font-weight:700>const</span> <span style=color:#204a87;font-weight:700>char</span> <span style=color:#ce5c00;font-weight:700>*</span><span style=color:#000>optionsString</span><span style=color:#ce5c00;font-weight:700>,</span><span style=color:#000>jmethodID</span> <span style=color:#000>agentMainMethod</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
  <span style=color:#8f5902;font-style:italic>// ...  
</span><span style=color:#8f5902;font-style:italic></span>  <span style=color:#000>invokeJavaAgentMainMethod</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>jnienv</span><span style=color:#ce5c00;font-weight:700>,</span><span style=color:#000>agent</span><span style=color:#ce5c00;font-weight:700>-&gt;</span><span style=color:#000>mInstrumentationImpl</span><span style=color:#ce5c00;font-weight:700>,</span><span style=color:#000>agentMainMethod</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>classNameObject</span><span style=color:#ce5c00;font-weight:700>,</span><span style=color:#000>optionsStringObject</span><span style=color:#ce5c00;font-weight:700>);</span>
  <span style=color:#8f5902;font-style:italic>// ...
</span><span style=color:#8f5902;font-style:italic></span><span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>看到这里，Instrument已经实例化，invokeJavaAgentMainMethod这个方法将我们的premain方法执行起来了。接着，我们就可以根据Instrument实例来做我们想要做的事情了。</p>
<h3 id=运行时加载agent>运行时加载Agent</h3>
<p>比起JVM启动时加载Agent，运行时加载Agent就比较有诱惑力了，因为运行时加载Agent的能力给我们提供了很强的动态性，我们可以在需要的时候加载Agent来进行一些工作。因为是动态的，我们可以按照需求来加载所需要的Agent，下面来分析一下动态加载Agent的相关技术细节。</p>
<h4 id=attachlistener>AttachListener</h4>
<p>Attach机制通过Attach Listener线程来进行相关事务的处理，下面来看一下Attach Listener线程是如何初始化的。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback>// Starts the Attach Listener thread
void AttachListener::init() {
  // 创建线程相关部分代码被去掉了
  const char thread_name[] = &#34;Attach Listener&#34;;
  Handle string = java_lang_String::create_from_str(thread_name, THREAD);
  { MutexLocker mu(Threads_lock);
    JavaThread* listener_thread = new JavaThread(&amp;attach_listener_thread_entry);
    // ...
  }
}
</code></pre></div><p>我们知道，一个线程启动之后都需要指定一个入口来执行代码，Attach Listener线程的入口是attach_listener_thread_entry，下面看一下这个函数的具体实现：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback>static void attach_listener_thread_entry(JavaThread* thread, TRAPS) {
  AttachListener::set_initialized();
  for (;;) {
      AttachOperation* op = AttachListener::dequeue();
      // find the function to dispatch too
      AttachOperationFunctionInfo* info = NULL;
      for (int i=0; funcs[i].name != NULL; i++) {
        const char* name = funcs[i].name;
        if (strcmp(op-&gt;name(), name) == 0) {
          info = &amp;(funcs[i]); break;
        }}
       // dispatch to the function that implements this operation
        res = (info-&gt;func)(op, &amp;st);
      //...
    }
}
</code></pre></div><p>整个函数执行逻辑，大概是这样的：</p>
<ul>
<li>拉取一个需要执行的任务：AttachListener::dequeue。</li>
<li>查询匹配的命令处理函数。</li>
<li>执行匹配到的命令执行函数。</li>
</ul>
<p>其中第二步里面存在一个命令函数表，整个表如下：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#204a87;font-weight:700>static</span> <span style=color:#000>AttachOperationFunctionInfo</span> <span style=color:#000>funcs</span><span style=color:#ce5c00;font-weight:700>[]</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#ce5c00;font-weight:700>{</span>
  <span style=color:#ce5c00;font-weight:700>{</span> <span style=color:#4e9a06>&#34;agentProperties&#34;</span><span style=color:#ce5c00;font-weight:700>,</span>  <span style=color:#000>get_agent_properties</span> <span style=color:#ce5c00;font-weight:700>},</span>
  <span style=color:#ce5c00;font-weight:700>{</span> <span style=color:#4e9a06>&#34;datadump&#34;</span><span style=color:#ce5c00;font-weight:700>,</span>         <span style=color:#000>data_dump</span> <span style=color:#ce5c00;font-weight:700>},</span>
  <span style=color:#ce5c00;font-weight:700>{</span> <span style=color:#4e9a06>&#34;dumpheap&#34;</span><span style=color:#ce5c00;font-weight:700>,</span>         <span style=color:#000>dump_heap</span> <span style=color:#ce5c00;font-weight:700>},</span>
  <span style=color:#ce5c00;font-weight:700>{</span> <span style=color:#4e9a06>&#34;load&#34;</span><span style=color:#ce5c00;font-weight:700>,</span>             <span style=color:#000>load_agent</span> <span style=color:#ce5c00;font-weight:700>},</span>
  <span style=color:#ce5c00;font-weight:700>{</span> <span style=color:#4e9a06>&#34;properties&#34;</span><span style=color:#ce5c00;font-weight:700>,</span>       <span style=color:#000>get_system_properties</span> <span style=color:#ce5c00;font-weight:700>},</span>
  <span style=color:#ce5c00;font-weight:700>{</span> <span style=color:#4e9a06>&#34;threaddump&#34;</span><span style=color:#ce5c00;font-weight:700>,</span>       <span style=color:#000>thread_dump</span> <span style=color:#ce5c00;font-weight:700>},</span>
  <span style=color:#ce5c00;font-weight:700>{</span> <span style=color:#4e9a06>&#34;inspectheap&#34;</span><span style=color:#ce5c00;font-weight:700>,</span>      <span style=color:#000>heap_inspection</span> <span style=color:#ce5c00;font-weight:700>},</span>
  <span style=color:#ce5c00;font-weight:700>{</span> <span style=color:#4e9a06>&#34;setflag&#34;</span><span style=color:#ce5c00;font-weight:700>,</span>          <span style=color:#000>set_flag</span> <span style=color:#ce5c00;font-weight:700>},</span>
  <span style=color:#ce5c00;font-weight:700>{</span> <span style=color:#4e9a06>&#34;printflag&#34;</span><span style=color:#ce5c00;font-weight:700>,</span>        <span style=color:#000>print_flag</span> <span style=color:#ce5c00;font-weight:700>},</span>
  <span style=color:#ce5c00;font-weight:700>{</span> <span style=color:#4e9a06>&#34;jcmd&#34;</span><span style=color:#ce5c00;font-weight:700>,</span>             <span style=color:#000>jcmd</span> <span style=color:#ce5c00;font-weight:700>},</span>
  <span style=color:#ce5c00;font-weight:700>{</span> <span style=color:#000>NULL</span><span style=color:#ce5c00;font-weight:700>,</span>               <span style=color:#000>NULL</span> <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#ce5c00;font-weight:700>};</span>
</code></pre></div><p>对于加载Agent来说，命令就是“load”。现在，我们知道了Attach Listener大概的工作模式，但是还是不太清楚任务从哪来，这个秘密就藏在AttachListener::dequeue这行代码里面，接下来我们来分析一下dequeue这个函数：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback>LinuxAttachOperation* LinuxAttachListener::dequeue() {
  for (;;) {
    // wait for client to connect
    struct sockaddr addr;
    socklen_t len = sizeof(addr);
    RESTARTABLE(::accept(listener(), &amp;addr, &amp;len), s);
    // get the credentials of the peer and check the effective uid/guid
    // - check with jeff on this.
    struct ucred cred_info;
    socklen_t optlen = sizeof(cred_info);
    if (::getsockopt(s, SOL_SOCKET, SO_PEERCRED, (void*)&amp;cred_info, &amp;optlen) == -1) {
      ::close(s);
      continue;
    }
    // peer credential look okay so we read the request
    LinuxAttachOperation* op = read_request(s);
    return op;
  }
}
</code></pre></div><p>这是Linux上的实现，不同的操作系统实现方式不太一样。上面的代码表面，Attach Listener在某个端口监听着，通过accept来接收一个连接，然后从这个连接里面将请求读取出来，然后将请求包装成一个AttachOperation类型的对象，之后就会从表里查询对应的处理函数，然后进行处理。</p>
<p>Attach Listener使用一种被称为“懒加载”的策略进行初始化，也就是说，JVM启动的时候Attach Listener并不一定会启动起来。下面我们来分析一下这种“懒加载”策略的具体实现方案。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#8f5902;font-style:italic>// Start Attach Listener if +StartAttachListener or it can&#39;t be started lazily
</span><span style=color:#8f5902;font-style:italic></span>  <span style=color:#204a87;font-weight:700>if</span> <span style=color:#ce5c00;font-weight:700>(!</span><span style=color:#000>DisableAttachMechanism</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#000>AttachListener</span><span style=color:#ce5c00;font-weight:700>::</span><span style=color:#000>vm_start</span><span style=color:#ce5c00;font-weight:700>();</span>
    <span style=color:#204a87;font-weight:700>if</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>StartAttachListener</span> <span style=color:#ce5c00;font-weight:700>||</span> <span style=color:#000>AttachListener</span><span style=color:#ce5c00;font-weight:700>::</span><span style=color:#000>init_at_startup</span><span style=color:#ce5c00;font-weight:700>())</span> <span style=color:#ce5c00;font-weight:700>{</span>
      <span style=color:#000>AttachListener</span><span style=color:#ce5c00;font-weight:700>::</span><span style=color:#000>init</span><span style=color:#ce5c00;font-weight:700>();</span>
    <span style=color:#ce5c00;font-weight:700>}</span>
  <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#8f5902;font-style:italic>// Attach Listener is started lazily except in the case when
</span><span style=color:#8f5902;font-style:italic>// +ReduseSignalUsage is used
</span><span style=color:#8f5902;font-style:italic></span><span style=color:#000>bool</span> <span style=color:#000>AttachListener</span><span style=color:#ce5c00;font-weight:700>::</span><span style=color:#000>init_at_startup</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span>
  <span style=color:#204a87;font-weight:700>if</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>ReduceSignalUsage</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#204a87;font-weight:700>return</span> <span style=color:#204a87;font-weight:700>true</span><span style=color:#ce5c00;font-weight:700>;</span>
  <span style=color:#ce5c00;font-weight:700>}</span> <span style=color:#204a87;font-weight:700>else</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#204a87;font-weight:700>return</span> <span style=color:#204a87;font-weight:700>false</span><span style=color:#ce5c00;font-weight:700>;</span>
  <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>上面的代码截取自create_vm函数，DisableAttachMechanism、StartAttachListener和ReduceSignalUsage这三个变量默认都是false，所以AttachListener::init();这行代码不会在create_vm的时候执行，而vm_start会执行。下面来看一下这个函数的实现细节：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>AttachListener</span><span style=color:#ce5c00;font-weight:700>::</span><span style=color:#000>vm_start</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span>
  <span style=color:#204a87;font-weight:700>char</span> <span style=color:#000>fn</span><span style=color:#ce5c00;font-weight:700>[</span><span style=color:#000>UNIX_PATH_MAX</span><span style=color:#ce5c00;font-weight:700>];</span>
  <span style=color:#000>struct</span> <span style=color:#000>stat64</span> <span style=color:#000>st</span><span style=color:#ce5c00;font-weight:700>;</span>
  <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>ret</span><span style=color:#ce5c00;font-weight:700>;</span>
  <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>n</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>snprintf</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>fn</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>UNIX_PATH_MAX</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#4e9a06>&#34;%s/.java_pid%d&#34;</span><span style=color:#ce5c00;font-weight:700>,</span>
           <span style=color:#000>os</span><span style=color:#ce5c00;font-weight:700>::</span><span style=color:#000>get_temp_directory</span><span style=color:#ce5c00;font-weight:700>(),</span> <span style=color:#000>os</span><span style=color:#ce5c00;font-weight:700>::</span><span style=color:#000>current_process_id</span><span style=color:#ce5c00;font-weight:700>());</span>
  <span style=color:#204a87;font-weight:700>assert</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>n</span> <span style=color:#ce5c00;font-weight:700>&lt;</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>int</span><span style=color:#ce5c00;font-weight:700>)</span><span style=color:#000>UNIX_PATH_MAX</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#4e9a06>&#34;java_pid file name buffer overflow&#34;</span><span style=color:#ce5c00;font-weight:700>);</span>
  <span style=color:#000>RESTARTABLE</span><span style=color:#ce5c00;font-weight:700>(::</span><span style=color:#000>stat64</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>fn</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#ce5c00;font-weight:700>&amp;</span><span style=color:#000>st</span><span style=color:#ce5c00;font-weight:700>),</span> <span style=color:#000>ret</span><span style=color:#ce5c00;font-weight:700>);</span>
  <span style=color:#204a87;font-weight:700>if</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>ret</span> <span style=color:#ce5c00;font-weight:700>==</span> <span style=color:#000>0</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#000>ret</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#ce5c00;font-weight:700>::</span><span style=color:#000>unlink</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>fn</span><span style=color:#ce5c00;font-weight:700>);</span>
    <span style=color:#204a87;font-weight:700>if</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>ret</span> <span style=color:#ce5c00;font-weight:700>==</span> <span style=color:#ce5c00;font-weight:700>-</span><span style=color:#000>1</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
      <span style=color:#000>log_debug</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>attach</span><span style=color:#ce5c00;font-weight:700>)(</span><span style=color:#4e9a06>&#34;Failed to remove stale attach pid file at %s&#34;</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>fn</span><span style=color:#ce5c00;font-weight:700>);</span>
    <span style=color:#ce5c00;font-weight:700>}</span>
  <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>这是在Linux上的实现，是将/tmp/目录下的.java_pid{pid}文件删除，后面在创建Attach Listener线程的时候会创建出来这个文件。上面说到，AttachListener::init()这行代码不会在create_vm的时候执行，这行代码的实现已经在上文中分析了，就是创建Attach Listener线程，并监听其他JVM的命令请求。现在来分析一下这行代码是什么时候被调用的，也就是“懒加载”到底是怎么加载起来的。</p>
<p>// Signal Dispatcher needs to be started before VMInit event is posted
os::signal_init();
这是create_vm中的一段代码，看起来跟信号相关，其实Attach机制就是使用信号来实现“懒加载“的。下面我们来仔细地分析一下这个过程。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>os</span><span style=color:#ce5c00;font-weight:700>::</span><span style=color:#000>signal_init</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span>
  <span style=color:#204a87;font-weight:700>if</span> <span style=color:#ce5c00;font-weight:700>(!</span><span style=color:#000>ReduceSignalUsage</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#8f5902;font-style:italic>// Setup JavaThread for processing signals
</span><span style=color:#8f5902;font-style:italic></span>    <span style=color:#000>EXCEPTION_MARK</span><span style=color:#ce5c00;font-weight:700>;</span>
    <span style=color:#000>Klass</span><span style=color:#ce5c00;font-weight:700>*</span> <span style=color:#000>k</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>SystemDictionary</span><span style=color:#ce5c00;font-weight:700>::</span><span style=color:#000>resolve_or_fail</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>vmSymbols</span><span style=color:#ce5c00;font-weight:700>::</span><span style=color:#000>java_lang_Thread</span><span style=color:#ce5c00;font-weight:700>(),</span> <span style=color:#204a87;font-weight:700>true</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>CHECK</span><span style=color:#ce5c00;font-weight:700>);</span>
    <span style=color:#000>instanceKlassHandle</span> <span style=color:#000>klass</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>THREAD</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>k</span><span style=color:#ce5c00;font-weight:700>);</span>
    <span style=color:#000>instanceHandle</span> <span style=color:#000>thread_oop</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>klass</span><span style=color:#ce5c00;font-weight:700>-&gt;</span><span style=color:#000>allocate_instance_handle</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>CHECK</span><span style=color:#ce5c00;font-weight:700>);</span>
    <span style=color:#204a87;font-weight:700>const</span> <span style=color:#204a87;font-weight:700>char</span> <span style=color:#000>thread_name</span><span style=color:#ce5c00;font-weight:700>[]</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#4e9a06>&#34;Signal Dispatcher&#34;</span><span style=color:#ce5c00;font-weight:700>;</span>
    <span style=color:#000>Handle</span> <span style=color:#000>string</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>java_lang_String</span><span style=color:#ce5c00;font-weight:700>::</span><span style=color:#000>create_from_str</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>thread_name</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>CHECK</span><span style=color:#ce5c00;font-weight:700>);</span>
    <span style=color:#8f5902;font-style:italic>// Initialize thread_oop to put it into the system threadGroup
</span><span style=color:#8f5902;font-style:italic></span>    <span style=color:#000>Handle</span> <span style=color:#000>thread_group</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>THREAD</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>Universe</span><span style=color:#ce5c00;font-weight:700>::</span><span style=color:#000>system_thread_group</span><span style=color:#ce5c00;font-weight:700>());</span>
    <span style=color:#000>JavaValue</span> <span style=color:#000>result</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>T_VOID</span><span style=color:#ce5c00;font-weight:700>);</span>
    <span style=color:#000>JavaCalls</span><span style=color:#ce5c00;font-weight:700>::</span><span style=color:#000>call_special</span><span style=color:#ce5c00;font-weight:700>(&amp;</span><span style=color:#000>result</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>thread_oop</span><span style=color:#ce5c00;font-weight:700>,</span><span style=color:#000>klass</span><span style=color:#ce5c00;font-weight:700>,</span><span style=color:#000>vmSymbols</span><span style=color:#ce5c00;font-weight:700>::</span><span style=color:#000>object_initializer_name</span><span style=color:#ce5c00;font-weight:700>(),</span><span style=color:#000>vmSymbols</span><span style=color:#ce5c00;font-weight:700>::</span><span style=color:#000>threadgroup_string_void_signature</span><span style=color:#ce5c00;font-weight:700>(),</span>
                           <span style=color:#000>thread_group</span><span style=color:#ce5c00;font-weight:700>,</span><span style=color:#000>string</span><span style=color:#ce5c00;font-weight:700>,</span><span style=color:#000>CHECK</span><span style=color:#ce5c00;font-weight:700>);</span>
    <span style=color:#000>KlassHandle</span> <span style=color:#000>group</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>THREAD</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>SystemDictionary</span><span style=color:#ce5c00;font-weight:700>::</span><span style=color:#000>ThreadGroup_klass</span><span style=color:#ce5c00;font-weight:700>());</span>
    <span style=color:#000>JavaCalls</span><span style=color:#ce5c00;font-weight:700>::</span><span style=color:#000>call_special</span><span style=color:#ce5c00;font-weight:700>(&amp;</span><span style=color:#000>result</span><span style=color:#ce5c00;font-weight:700>,</span><span style=color:#000>thread_group</span><span style=color:#ce5c00;font-weight:700>,</span><span style=color:#000>group</span><span style=color:#ce5c00;font-weight:700>,</span><span style=color:#000>vmSymbols</span><span style=color:#ce5c00;font-weight:700>::</span><span style=color:#000>add_method_name</span><span style=color:#ce5c00;font-weight:700>(),</span><span style=color:#000>vmSymbols</span><span style=color:#ce5c00;font-weight:700>::</span><span style=color:#000>thread_void_signature</span><span style=color:#ce5c00;font-weight:700>(),</span><span style=color:#000>thread_oop</span><span style=color:#ce5c00;font-weight:700>,</span><span style=color:#000>CHECK</span><span style=color:#ce5c00;font-weight:700>);</span>
    <span style=color:#000>os</span><span style=color:#ce5c00;font-weight:700>::</span><span style=color:#000>signal_init_pd</span><span style=color:#ce5c00;font-weight:700>();</span>
    <span style=color:#ce5c00;font-weight:700>{</span> <span style=color:#000>MutexLocker</span> <span style=color:#000>mu</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>Threads_lock</span><span style=color:#ce5c00;font-weight:700>);</span>
      <span style=color:#000>JavaThread</span><span style=color:#ce5c00;font-weight:700>*</span> <span style=color:#000>signal_thread</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>JavaThread</span><span style=color:#ce5c00;font-weight:700>(&amp;</span><span style=color:#000>signal_thread_entry</span><span style=color:#ce5c00;font-weight:700>);</span>
     <span style=color:#8f5902;font-style:italic>// ...
</span><span style=color:#8f5902;font-style:italic></span>    <span style=color:#ce5c00;font-weight:700>}</span>
    <span style=color:#8f5902;font-style:italic>// Handle ^BREAK
</span><span style=color:#8f5902;font-style:italic></span>    <span style=color:#000>os</span><span style=color:#ce5c00;font-weight:700>::</span><span style=color:#000>signal</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>SIGBREAK</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>os</span><span style=color:#ce5c00;font-weight:700>::</span><span style=color:#000>user_handler</span><span style=color:#ce5c00;font-weight:700>());</span>
  <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>JVM创建了一个新的进程来实现信号处理，这个线程叫“Signal Dispatcher”，一个线程创建之后需要有一个入口，“Signal Dispatcher”的入口是signal_thread_entry：</p>
<div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210501212135.png style=display:block;width:50% alt=NAME align=center> </div>
<p>这段代码截取自signal_thread_entry函数，截取中的内容是和Attach机制信号处理相关的代码。这段代码的意思是，当接收到“SIGBREAK”信号，就执行接下来的代码，这个信号是需要Attach到JVM上的信号发出来，这个后面会再分析。我们先来看一句关键的代码：AttachListener::is_init_trigger()：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback>bool AttachListener::is_init_trigger() {
  if (init_at_startup() || is_initialized()) {
    return false;               // initialized at startup or already initialized
  }
  char fn[PATH_MAX+1];
  sprintf(fn, &#34;.attach_pid%d&#34;, os::current_process_id());
  int ret;
  struct stat64 st;
  RESTARTABLE(::stat64(fn, &amp;st), ret);
  if (ret == -1) {
    log_trace(attach)(&#34;Failed to find attach file: %s, trying alternate&#34;, fn);
    snprintf(fn, sizeof(fn), &#34;%s/.attach_pid%d&#34;, os::get_temp_directory(), os::current_process_id());
    RESTARTABLE(::stat64(fn, &amp;st), ret);
  }
  if (ret == 0) {
    // simple check to avoid starting the attach mechanism when
    // a bogus user creates the file
    if (st.st_uid == geteuid()) {
      init();
      return true;
    }
  }
  return false;
}
</code></pre></div><p>首先检查了一下是否在JVM启动时启动了Attach Listener，或者是否已经启动过。如果没有，才继续执行，在/tmp目录下创建一个叫做.attach_pid%d的文件，然后执行AttachListener的init函数，这个函数就是用来创建Attach Listener线程的函数，上面已经提到多次并进行了分析。到此，我们知道Attach机制的奥秘所在，也就是Attach Listener线程的创建依靠Signal Dispatcher线程，Signal Dispatcher是用来处理信号的线程，当Signal Dispatcher线程接收到“SIGBREAK”信号之后，就会执行初始化Attach Listener的工作。</p>
<h4 id=运行时加载agent的实现>运行时加载Agent的实现</h4>
<p>我们继续分析，到底是如何将一个Agent挂载到运行着的目标JVM上，在上文中提到了一段代码，用来进行运行时挂载Agent，可以参考上文中展示的关于“attachAgentToTargetJvm”方法的代码。这个方法里面的关键是调用VirtualMachine的attach方法进行Agent挂载的功能。下面我们就来分析一下VirtualMachine的attach方法具体是怎么实现的。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback>    public static VirtualMachine attach(String var0) throws AttachNotSupportedException, IOException {
        if (var0 == null) {
            throw new NullPointerException(&#34;id cannot be null&#34;);
        } else {
            List var1 = AttachProvider.providers();
            if (var1.size() == 0) {
                throw new AttachNotSupportedException(&#34;no providers installed&#34;);
            } else {
                AttachNotSupportedException var2 = null;
                Iterator var3 = var1.iterator();
                while(var3.hasNext()) {
                    AttachProvider var4 = (AttachProvider)var3.next();
                    try {
                        return var4.attachVirtualMachine(var0);
                    } catch (AttachNotSupportedException var6) {
                        var2 = var6;
                    }
                }
                throw var2;
            }
        }
    }
</code></pre></div><p>这个方法通过attachVirtualMachine方法进行attach操作，在MacOS系统中，AttachProvider的实现类是BsdAttachProvider。我们来看一下BsdAttachProvider的attachVirtualMachine方法是如何实现的：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#204a87;font-weight:700>public</span> <span style=color:#000>VirtualMachine</span> <span style=color:#000>attachVirtualMachine</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>String</span> <span style=color:#000>var1</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#204a87;font-weight:700>throws</span> <span style=color:#000>AttachNotSupportedException</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>IOException</span> <span style=color:#ce5c00;font-weight:700>{</span>
        <span style=color:#204a87;font-weight:700>this</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>checkAttachPermission</span><span style=color:#ce5c00;font-weight:700>();</span>
        <span style=color:#204a87;font-weight:700>this</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>testAttachable</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>var1</span><span style=color:#ce5c00;font-weight:700>);</span>
        <span style=color:#204a87;font-weight:700>return</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>BsdVirtualMachine</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>this</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>var1</span><span style=color:#ce5c00;font-weight:700>);</span>
    <span style=color:#ce5c00;font-weight:700>}</span>
<span style=color:#000>BsdVirtualMachine</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>AttachProvider</span> <span style=color:#000>var1</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>String</span> <span style=color:#000>var2</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#204a87;font-weight:700>throws</span> <span style=color:#000>AttachNotSupportedException</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>IOException</span> <span style=color:#ce5c00;font-weight:700>{</span>
        <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>var3</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>Integer</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>parseInt</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>var2</span><span style=color:#ce5c00;font-weight:700>);</span>
        <span style=color:#204a87;font-weight:700>this</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>path</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>this</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>findSocketFile</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>var3</span><span style=color:#ce5c00;font-weight:700>);</span>
        <span style=color:#204a87;font-weight:700>if</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>this</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>path</span> <span style=color:#ce5c00;font-weight:700>==</span> <span style=color:#204a87;font-weight:700>null</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
            <span style=color:#000>File</span> <span style=color:#000>var4</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>File</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>tmpdir</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#4e9a06>&#34;.attach_pid&#34;</span> <span style=color:#ce5c00;font-weight:700>+</span> <span style=color:#000>var3</span><span style=color:#ce5c00;font-weight:700>);</span>
            <span style=color:#000>createAttachFile</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>var4</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>getPath</span><span style=color:#ce5c00;font-weight:700>());</span>
            <span style=color:#204a87;font-weight:700>try</span> <span style=color:#ce5c00;font-weight:700>{</span>
                <span style=color:#000>sendQuitTo</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>var3</span><span style=color:#ce5c00;font-weight:700>);</span>
                <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>var5</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>0</span><span style=color:#ce5c00;font-weight:700>;</span>
                <span style=color:#204a87;font-weight:700>long</span> <span style=color:#000>var6</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>200L</span><span style=color:#ce5c00;font-weight:700>;</span>
                <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>var8</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>int</span><span style=color:#ce5c00;font-weight:700>)(</span><span style=color:#204a87;font-weight:700>this</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>attachTimeout</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>/</span> <span style=color:#000>var6</span><span style=color:#ce5c00;font-weight:700>);</span>
                <span style=color:#204a87;font-weight:700>do</span> <span style=color:#ce5c00;font-weight:700>{</span>
                    <span style=color:#204a87;font-weight:700>try</span> <span style=color:#ce5c00;font-weight:700>{</span>
                        <span style=color:#000>Thread</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>sleep</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>var6</span><span style=color:#ce5c00;font-weight:700>);</span>
                    <span style=color:#ce5c00;font-weight:700>}</span> <span style=color:#204a87;font-weight:700>catch</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>InterruptedException</span> <span style=color:#000>var21</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
                        <span style=color:#ce5c00;font-weight:700>;</span>
                    <span style=color:#ce5c00;font-weight:700>}</span>
                    <span style=color:#204a87;font-weight:700>this</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>path</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>this</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>findSocketFile</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>var3</span><span style=color:#ce5c00;font-weight:700>);</span>
                    <span style=color:#ce5c00;font-weight:700>++</span><span style=color:#000>var5</span><span style=color:#ce5c00;font-weight:700>;</span>
                <span style=color:#ce5c00;font-weight:700>}</span> <span style=color:#204a87;font-weight:700>while</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>var5</span> <span style=color:#ce5c00;font-weight:700>&lt;=</span> <span style=color:#000>var8</span> <span style=color:#ce5c00;font-weight:700>&amp;&amp;</span> <span style=color:#204a87;font-weight:700>this</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>path</span> <span style=color:#ce5c00;font-weight:700>==</span> <span style=color:#204a87;font-weight:700>null</span><span style=color:#ce5c00;font-weight:700>);</span>
            <span style=color:#ce5c00;font-weight:700>}</span> <span style=color:#204a87;font-weight:700>finally</span> <span style=color:#ce5c00;font-weight:700>{</span>
                <span style=color:#000>var4</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>delete</span><span style=color:#ce5c00;font-weight:700>();</span>
            <span style=color:#ce5c00;font-weight:700>}</span>
        <span style=color:#ce5c00;font-weight:700>}</span>
        <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>var24</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>socket</span><span style=color:#ce5c00;font-weight:700>();</span>
        <span style=color:#000>connect</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>var24</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#204a87;font-weight:700>this</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>path</span><span style=color:#ce5c00;font-weight:700>);</span>
    <span style=color:#ce5c00;font-weight:700>}</span>
    <span style=color:#204a87;font-weight:700>private</span> <span style=color:#000>String</span> <span style=color:#000>findSocketFile</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>var1</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
        <span style=color:#000>String</span> <span style=color:#000>var2</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#4e9a06>&#34;.java_pid&#34;</span> <span style=color:#ce5c00;font-weight:700>+</span> <span style=color:#000>var1</span><span style=color:#ce5c00;font-weight:700>;</span>
        <span style=color:#000>File</span> <span style=color:#000>var3</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>File</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>tmpdir</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>var2</span><span style=color:#ce5c00;font-weight:700>);</span>
        <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>var3</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>exists</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>?</span> <span style=color:#000>var3</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>getPath</span><span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>null</span><span style=color:#ce5c00;font-weight:700>;</span>
    <span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>findSocketFile方法用来查询目标JVM上是否已经启动了Attach Listener，它通过检查”tmp/“目录下是否存在java_pid{pid}来进行实现。如果已经存在了，则说明Attach机制已经准备就绪，可以接受客户端的命令了，这个时候客户端就可以通过connect连接到目标JVM进行命令的发送，比如可以发送“load”命令来加载Agent。如果java_pid{pid}文件还不存在，则需要通过sendQuitTo方法向目标JVM发送一个“SIGBREAK”信号，让它初始化Attach Listener线程并准备接受客户端连接。可以看到，发送了信号之后客户端会循环等待java_pid{pid}这个文件，之后再通过connect连接到目标JVM上。</p>
<h4 id=load命令的实现>load命令的实现</h4>
<p>下面来分析一下，“load”命令在JVM层面的实现：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#204a87;font-weight:700>static</span> <span style=color:#000>jint</span> <span style=color:#000>load_agent</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>AttachOperation</span><span style=color:#ce5c00;font-weight:700>*</span> <span style=color:#000>op</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>outputStream</span><span style=color:#ce5c00;font-weight:700>*</span> <span style=color:#000>out</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
  <span style=color:#8f5902;font-style:italic>// get agent name and options
</span><span style=color:#8f5902;font-style:italic></span>  <span style=color:#204a87;font-weight:700>const</span> <span style=color:#204a87;font-weight:700>char</span><span style=color:#ce5c00;font-weight:700>*</span> <span style=color:#000>agent</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>op</span><span style=color:#ce5c00;font-weight:700>-&gt;</span><span style=color:#000>arg</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>0</span><span style=color:#ce5c00;font-weight:700>);</span>
  <span style=color:#204a87;font-weight:700>const</span> <span style=color:#204a87;font-weight:700>char</span><span style=color:#ce5c00;font-weight:700>*</span> <span style=color:#000>absParam</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>op</span><span style=color:#ce5c00;font-weight:700>-&gt;</span><span style=color:#000>arg</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>1</span><span style=color:#ce5c00;font-weight:700>);</span>
  <span style=color:#204a87;font-weight:700>const</span> <span style=color:#204a87;font-weight:700>char</span><span style=color:#ce5c00;font-weight:700>*</span> <span style=color:#000>options</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>op</span><span style=color:#ce5c00;font-weight:700>-&gt;</span><span style=color:#000>arg</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>2</span><span style=color:#ce5c00;font-weight:700>);</span>
  <span style=color:#8f5902;font-style:italic>// If loading a java agent then need to ensure that the java.instrument module is loaded
</span><span style=color:#8f5902;font-style:italic></span>  <span style=color:#204a87;font-weight:700>if</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>strcmp</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>agent</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#4e9a06>&#34;instrument&#34;</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>==</span> <span style=color:#000>0</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#000>Thread</span><span style=color:#ce5c00;font-weight:700>*</span> <span style=color:#000>THREAD</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>Thread</span><span style=color:#ce5c00;font-weight:700>::</span><span style=color:#000>current</span><span style=color:#ce5c00;font-weight:700>();</span>
    <span style=color:#000>ResourceMark</span> <span style=color:#000>rm</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>THREAD</span><span style=color:#ce5c00;font-weight:700>);</span>
    <span style=color:#000>HandleMark</span> <span style=color:#000>hm</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>THREAD</span><span style=color:#ce5c00;font-weight:700>);</span>
    <span style=color:#000>JavaValue</span> <span style=color:#000>result</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>T_OBJECT</span><span style=color:#ce5c00;font-weight:700>);</span>
    <span style=color:#000>Handle</span> <span style=color:#000>h_module_name</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>java_lang_String</span><span style=color:#ce5c00;font-weight:700>::</span><span style=color:#000>create_from_str</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#4e9a06>&#34;java.instrument&#34;</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>THREAD</span><span style=color:#ce5c00;font-weight:700>);</span>
    <span style=color:#000>JavaCalls</span><span style=color:#ce5c00;font-weight:700>::</span><span style=color:#000>call_static</span><span style=color:#ce5c00;font-weight:700>(&amp;</span><span style=color:#000>result</span><span style=color:#ce5c00;font-weight:700>,</span><span style=color:#000>SystemDictionary</span><span style=color:#ce5c00;font-weight:700>::</span><span style=color:#000>module_Modules_klass</span><span style=color:#ce5c00;font-weight:700>(),</span><span style=color:#000>vmSymbols</span><span style=color:#ce5c00;font-weight:700>::</span><span style=color:#000>loadModule_name</span><span style=color:#ce5c00;font-weight:700>(),</span>
                           <span style=color:#000>vmSymbols</span><span style=color:#ce5c00;font-weight:700>::</span><span style=color:#000>loadModule_signature</span><span style=color:#ce5c00;font-weight:700>(),</span><span style=color:#000>h_module_name</span><span style=color:#ce5c00;font-weight:700>,</span><span style=color:#000>THREAD</span><span style=color:#ce5c00;font-weight:700>);</span>
  <span style=color:#ce5c00;font-weight:700>}</span>
  <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>JvmtiExport</span><span style=color:#ce5c00;font-weight:700>::</span><span style=color:#000>load_agent_library</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>agent</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>absParam</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>options</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>out</span><span style=color:#ce5c00;font-weight:700>);</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>这个函数先确保加载了java.instrument模块，之后真正执行Agent加载的函数是 <a href=https://github.com/pandening/openjdk/blob/0301fc792ffd3c7b506ef78887af250e0e3ae09e/src/hotspot/share/prims/jvmtiExport.cpp#L2476>load_agent_library</a> ,这个函数的套路就是加载Agent动态链接库，如果是通过Java instrument API实现的Agent，则加载的是libinstrument动态链接库，然后通过libinstrument里面的代码实现运行agentmain方法的逻辑，这一部分内容和libinstrument实现premain方法运行的逻辑其实差不多，这里不再做分析。至此，我们对Java Agent技术已经有了一个全面而细致的了解。</p>
<h2 id=动态替换类字节码技术>动态替换类字节码技术</h2>
<h3 id=动态字节码修改的限制>动态字节码修改的限制</h3>
<p>上文中已经详细分析了Agent技术的实现，我们使用Java Instrumentation API来完成动态类修改的功能，在Instrumentation接口中，通过addTransformer方法来增加一个类转换器，类转换器由类ClassFileTransformer接口实现。ClassFileTransformer接口中唯一的方法transform用于实现类转换，当类被加载的时候，就会调用transform方法，进行类转换。在运行时，我们可以通过Instrumentation的redefineClasses方法进行类重定义，在方法上有一段注释需要特别注意：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback>     * The redefinition may change method bodies, the constant pool and attributes.
     * The redefinition must not add, remove or rename fields or methods, change the
     * signatures of methods, or change inheritance.  These restrictions maybe be
     * lifted in future versions.  The class file bytes are not checked, verified and installed
     * until after the transformations have been applied, if the resultant bytes are in
     * error this method will throw an exception.
</code></pre></div><p>这里面提到，我们不可以增加、删除或者重命名字段和方法，改变方法的签名或者类的继承关系。认识到这一点很重要，当我们通过ASM获取到增强的字节码之后，如果增强后的字节码没有遵守这些规则，那么调用redefineClasses方法来进行类的重定义就会失败。那redefineClasses方法具体是怎么实现类的重定义的呢？它对运行时的JVM会造成什么样的影响呢？下面来分析redefineClasses的实现细节。</p>
<h3 id=重定义类字节码的实现细节>重定义类字节码的实现细节</h3>
<p>上文中我们提到，libinstrument动态链接库中，JPLISAgent不仅实现了Agent入口代码执行的路由，而且还是Java代码与JVMTI之间的一道桥梁。我们在Java代码中调用Java Instrumentation API的redefineClasses，其实会调用libinstrument中的相关代码，我们来分析一下这条路径。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback>    public void redefineClasses(ClassDefinition... var1) throws ClassNotFoundException {
        if (!this.isRedefineClassesSupported()) {
            throw new UnsupportedOperationException(&#34;redefineClasses is not supported in this environment&#34;);
        } else if (var1 == null) {
            throw new NullPointerException(&#34;null passed as &#39;definitions&#39; in redefineClasses&#34;);
        } else {
            for(int var2 = 0; var2 &lt; var1.length; ++var2) {
                if (var1[var2] == null) {
                    throw new NullPointerException(&#34;element of &#39;definitions&#39; is null in redefineClasses&#34;);
                }
            }
            if (var1.length != 0) {
                this.redefineClasses0(this.mNativeAgent, var1);
            }
        }
    }
    private native void redefineClasses0(long var1, ClassDefinition[] var3) throws ClassNotFoundException;
</code></pre></div><p>这是InstrumentationImpl中的redefineClasses实现，该方法的具体实现依赖一个Native方法redefineClasses()，我们可以在libinstrument中找到这个Native方法的实现：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback>JNIEXPORT void JNICALL Java_sun_instrument_InstrumentationImpl_redefineClasses0
  (JNIEnv * jnienv, jobject implThis, jlong agent, jobjectArray classDefinitions) {
    redefineClasses(jnienv, (JPLISAgent*)(intptr_t)agent, classDefinitions);
}
</code></pre></div><p>redefineClasses这个函数的实现比较复杂，代码很长。下面是一段关键的代码片段：</p>
<div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210501212304.png style=display:block;width:50% alt=NAME align=center> </div>
<p>可以看到，其实是调用了JVMTI的RetransformClasses函数来完成类的重定义细节。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback>// class_count - pre-checked to be greater than or equal to 0
// class_definitions - pre-checked for NULL
jvmtiError JvmtiEnv::RedefineClasses(jint class_count, const jvmtiClassDefinition* class_definitions) {
//TODO: add locking
  VM_RedefineClasses op(class_count, class_definitions, jvmti_class_load_kind_redefine);
  VMThread::execute(&amp;op);
  return (op.check_error());
} /* end RedefineClasses */
</code></pre></div><p>重定义类的请求会被JVM包装成一个VM_RedefineClasses类型的VM_Operation，VM_Operation是JVM内部的一些操作的基类，包括GC操作等。VM_Operation由VMThread来执行，新的VM_Operation操作会被添加到VMThread的运行队列中去，VMThread会不断从队列里面拉取VM_Operation并调用其doit等函数执行具体的操作。VM_RedefineClasses函数的流程较为复杂，下面是VM_RedefineClasses的大致流程：</p>
<ul>
<li>加载新的字节码，合并常量池，并且对新的字节码进行校验工作</li>
</ul>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback>  // Load the caller&#39;s new class definition(s) into _scratch_classes.
  // Constant pool merging work is done here as needed. Also calls
  // compare_and_normalize_class_versions() to verify the class
  // definition(s).
  jvmtiError load_new_class_versions(TRAPS);
</code></pre></div><ul>
<li>清除方法上的断点</li>
</ul>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback>  // Remove all breakpoints in methods of this class
  JvmtiBreakpoints&amp; jvmti_breakpoints = JvmtiCurrentBreakpoints::get_jvmti_breakpoints();
  jvmti_breakpoints.clearall_in_class_at_safepoint(the_class());
</code></pre></div><ul>
<li>JIT逆优化</li>
</ul>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback>  // Deoptimize all compiled code that depends on this class
  flush_dependent_code(the_class, THREAD);
</code></pre></div><ul>
<li>进行字节码替换工作，需要进行更新类itable/vtable等操作</li>
<li>进行类重定义通知</li>
</ul>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback>  SystemDictionary::notice_modification();
</code></pre></div><p>VM_RedefineClasses实现比较复杂的，详细实现可以参考 <a href=https://github.com/pandening/openjdk/blob/0301fc792ffd3c7b506ef78887af250e0e3ae09e/src/hotspot/share/prims/jvmtiEnv.cpp#L456>RedefineClasses的实现</a>。</p>
<h2 id=java-debug-tool设计与实现>Java-debug-tool设计与实现</h2>
<p>Java-debug-tool是一个使用Java Instrument API来实现的动态调试工具，它通过在目标JVM上启动一个TcpServer来和调试客户端通信。调试客户端通过命令行来发送调试命令给TcpServer，TcpServer中有专门用来处理命令的handler，handler处理完命令之后会将结果发送回客户端，客户端通过处理将调试结果展示出来。下面将详细介绍Java-debug-tool的整体设计和实现。</p>
<h3 id=java-debug-tool整体架构>Java-debug-tool整体架构</h3>
<p>Java-debug-tool包括一个Java Agent和一个用于处理调试命令的核心API，核心API通过一个自定义的类加载器加载进来，以保证目标JVM的类不会被污染。整体上Java-debug-tool的设计是一个Client-Server的架构，命令客户端需要完整的完成一个命令之后才能继续执行下一个调试命令。Java-debug-tool支持多人同时进行调试，下面是整体架构图：</p>
<div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210501212345.png style=display:block;width:50% alt=NAME align=center> </div>
<p>下面对每一层做简单介绍：</p>
<ul>
<li>交互层：负责将程序员的输入转换成调试交互协议，并且将调试信息呈现出来。</li>
<li>连接管理层：负责管理客户端连接，从连接中读调试协议数据并解码，对调试结果编码并将其写到连接中去；同时将那些超时未活动的连接关闭。</li>
<li>业务逻辑层：实现调试命令处理，包括命令分发、数据收集、数据处理等过程。</li>
<li>基础实现层：Java-debug-tool实现的底层依赖，通过Java Instrumentation提供的API进行类查找、类重定义等能力，Java Instrumentation底层依赖JVMTI来完成具体的功能。</li>
</ul>
<p>在Agent被挂载到目标JVM上之后，Java-debug-tool会安排一个Spy在目标JVM内活动，这个Spy负责将目标JVM内部的相关调试数据转移到命令处理模块，命令处理模块会处理这些数据，然后给客户端返回调试结果。命令处理模块会增强目标类的字节码来达到数据获取的目的，多个客户端可以共享一份增强过的字节码，无需重复增强。下面从Java-debug-tool的字节码增强方案、命令设计与实现等角度详细说明。</p>
<h3 id=java-debug-tool的字节码增强方案>Java-debug-tool的字节码增强方案</h3>
<p>Java-debug-tool使用字节码增强来获取到方法运行时的信息，比如方法入参、出参等，可以在不同的字节码位置进行增强，这种行为可以称为“插桩”，每个“桩”用于获取数据并将他转储出去。Java-debug-tool具备强大的插桩能力，不同的桩负责获取不同类别的数据，下面是Java-debug-tool目前所支持的“桩”：</p>
<ul>
<li>方法进入点：用于获取方法入参信息。</li>
<li>Fields获取点1：在方法执行前获取到对象的字段信息。</li>
<li>变量存储点：获取局部变量信息。</li>
<li>Fields获取点2：在方法退出前获取到对象的字段信息。</li>
<li>方法退出点：用于获取方法返回值。</li>
<li>抛出异常点：用于获取方法抛出的异常信息。</li>
</ul>
<p>通过上面这些代码桩，Java-debug-tool可以收集到丰富的方法执行信息，经过处理可以返回更加可视化的调试结果。</p>
<h4 id=字节码增强>字节码增强</h4>
<p>Java-debug-tool在实现上使用了ASM工具来进行字节码增强，并且每个插桩点都可以进行配置，如果不想要什么信息，则没必要进行对应的插桩操作。这种可配置的设计是非常有必要的，因为有时候我们仅仅是想要知道方法的入参和出参，但Java-debug-tool却给我们返回了所有的调试信息，这样我们就得在众多的输出中找到我们所关注的内容。如果可以进行配置，则除了入参点和出参点外其他的桩都不插，那么就可以快速看到我们想要的调试数据，这种设计的本质是为了让调试者更加专注。下面是Java-debug-tool的字节码增强工作方式：</p>
<div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210501212408.png style=display:block;width:50% alt=NAME align=center> </div>
<p>如图4-2-1所示，当调试者发出调试命令之后，Java-debug-tool会识别命令并判断是否需要进行字节码增强，如果命令需要增强字节码，则判断当前类+当前方法是否已经被增强过。上文已经提到，字节码替换是有一定损耗的，这种具有损耗的操作发生的次数越少越好，所以字节码替换操作会被记录起来，后续命令直接使用即可，不需要重复进行字节码增强，字节码增强还涉及多个调试客户端的协同工作问题，当一个客户端增强了一个类的字节码之后，这个客户端就锁定了该字节码，其他客户端变成只读，无法对该类进行字节码增强，只有当持有锁的客户端主动释放锁或者断开连接之后，其他客户端才能继续增强该类的字节码。</p>
<p>字节码增强模块收到字节码增强请求之后，会判断每个增强点是否需要插桩，这个判断的根据就是上文提到的插桩配置，之后字节码增强模块会生成新的字节码，Java-debug-tool将执行字节码替换操作，之后就可以进行调试数据收集了。</p>
<p>经过字节码增强之后，原来的方法中会插入收集运行时数据的代码，这些代码在方法被调用的时候执行，获取到诸如方法入参、局部变量等信息，这些信息将传递给数据收集装置进行处理。数据收集的工作通过Advice完成，每个客户端同一时间只能注册一个Advice到Java-debug-tool调试模块上，多个客户端可以同时注册自己的Advice到调试模块上。Advice负责收集数据并进行判断，如果当前数据符合调试命令的要求，Java-debug-tool就会卸载这个Advice，Advice的数据就会被转移到Java-debug-tool的命令结果处理模块进行处理，并将结果发送到客户端。</p>
<h4 id=advice的工作方式>Advice的工作方式</h4>
<p>Advice是调试数据收集器，不同的调试策略会对应不同的Advice。Advice是工作在目标JVM的线程内部的，它需要轻量级和高效，意味着Advice不能做太过于复杂的事情，它的核心接口“match”用来判断本次收集到的调试数据是否满足调试需求。如果满足，那么Java-debug-tool就会将其卸载，否则会继续让他收集调试数据，这种“加载Advice” -> “卸载Advice”的工作模式具备很好的灵活性。</p>
<p>关于Advice，需要说明的另外一点就是线程安全，因为它加载之后会运行在目标JVM的线程中，目标JVM的方法极有可能是多线程访问的，这也就是说，Advice需要有能力处理多个线程同时访问方法的能力，如果Advice处理不当，则可能会收集到杂乱无章的调试数据。下面的图片展示了Advice和Java-debug-tool调试分析模块、目标方法执行以及调试客户端等模块的关系。</p>
<div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210501212431.png style=display:block;width:50% alt=NAME align=center> </div>
<p>Advice的首次挂载由Java-debug-tool的命令处理器完成，当一次调试数据收集完成之后，调试数据处理模块会自动卸载Advice，然后进行判断，如果调试数据符合Advice的策略，则直接将数据交由数据处理模块进行处理，否则会清空调试数据，并再次将Advice挂载到目标方法上去，等待下一次调试数据。非首次挂载由调试数据处理模块进行，它借助Advice按需取数据，如果不符合需求，则继续挂载Advice来获取数据，否则对调试数据进行处理并返回给客户端。</p>
<h3 id=java-debug-tool的命令设计与实现>Java-debug-tool的命令设计与实现</h3>
<h4 id=命令执行>命令执行</h4>
<p>上文已经完整的描述了Java-debug-tool的设计以及核心技术方案，本小节将详细介绍Java-debug-tool的命令设计与实现。首先需要将一个调试命令的执行流程描述清楚，下面是一张用来表示命令请求处理流程的图片：</p>
<div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210501212452.png style=display:block;width:50% alt=NAME align=center> </div>
<p>图4-3-1简单的描述了Java-debug-tool的命令处理方式，客户端连接到服务端之后，会进行一些协议解析、协议认证、协议填充等工作，之后将进行命令分发。服务端如果发现客户端的命令不合法，则会立即返回错误信息，否则再进行命令处理。命令处理属于典型的三段式处理，前置命令处理、命令处理以及后置命令处理，同时会对命令处理过程中的异常信息进行捕获处理，三段式处理的好处是命令处理被拆成了多个阶段，多个阶段负责不同的职责。前置命令处理用来做一些命令权限控制的工作，并填充一些类似命令处理开始时间戳等信息，命令处理就是通过字节码增强，挂载Advice进行数据收集，再经过数据处理来产生命令结果的过程，后置处理则用来处理一些连接关闭、字节码解锁等事项。</p>
<p>Java-debug-tool允许客户端设置一个命令执行超时时间，超过这个时间则认为命令没有结果，如果客户端没有设置自己的超时时间，就使用默认的超时时间进行超时控制。Java-debug-tool通过设计了两阶段的超时检测机制来实现命令执行超时功能：首先，第一阶段超时触发，则Java-debug-tool会友好的警告命令处理模块处理时间已经超时，需要立即停止命令执行，这允许命令自己做一些现场清理工作，当然需要命令执行线程自己感知到这种超时警告；当第二阶段超时触发，则Java-debug-tool认为命令必须结束执行，会强行打断命令执行线程。超时机制的目的是为了不让命令执行太长时间，命令如果长时间没有收集到调试数据，则应该停止执行，并思考是否调试了一个错误的方法。当然，超时机制还可以定期清理那些因为未知原因断开连接的客户端持有的调试资源，比如字节码锁。</p>
<h4 id=获取方法执行视图>获取方法执行视图</h4>
<p>Java-debug-tool通过下面的信息来向调试者呈现出一次方法执行的视图：</p>
<ul>
<li>正在调试的方法信息。</li>
<li>方法调用堆栈。</li>
<li>调试耗时，包括对目标JVM造成的STW时间。</li>
<li>方法入参，包括入参的类型及参数值。</li>
<li>方法的执行路径。</li>
<li>代码执行耗时。</li>
<li>局部变量信息。</li>
<li>方法返回结果。</li>
<li>方法抛出的异常。</li>
<li>对象字段值快照。</li>
</ul>
<p>图4-3-2展示了Java-debug-tool获取到正在运行的方法的执行视图的信息。</p>
<div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210501212512.png style=display:block;width:50% alt=NAME align=center> </div>
<h3 id=java-debug-tool与同类产品对比分析>Java-debug-tool与同类产品对比分析</h3>
<p>Java-debug-tool的同类产品主要是greys，其他类似的工具大部分都是基于greys进行的二次开发，所以直接选择greys来和Java-debug-tool进行对比。</p>
<div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210501212535.png style=display:block;width:50% alt=NAME align=center> </div>
<h2 id=总结>总结</h2>
<p>本文详细剖析了Java动态调试关键技术的实现细节，并介绍了我们基于Java动态调试技术结合实际故障排查场景进行的一点探索实践；动态调试技术为研发人员进行线上问题排查提供了一种新的思路，我们基于动态调试技术解决了传统断点调试存在的问题，使得可以将断点调试这种技术应用在线上，以线下调试的思维来进行线上调试，提高问题排查效率。</p>
<h2 id=参考资料>参考资料</h2>
<ul>
<li><a href=https://tech.meituan.com/2019/11/07/java-dynamic-debugging-technology.html>Java 动态调试技术原理及实践</a></li>
</ul>
</div>
</main>
</div>
</div>
<footer class="bg-dark py-5 row d-print-none">
<div class="container-fluid mx-sm-5">
<div class=row>
<div class="col-6 col-sm-4 text-xs-center order-sm-2">
</div>
<div class="col-6 col-sm-4 text-right text-xs-center order-sm-3">
<ul class="list-inline mb-0">
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Weibo aria-label=Weibo>
<a class=text-white target=_blank rel="noopener noreferrer" href=https://weibo.com/u/3848950217>
<i class="fab fa-weibo"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Twitter aria-label=Twitter>
<a class=text-white target=_blank rel="noopener noreferrer" href=https://twitter.com/zhange_zzg>
<i class="fab fa-twitter"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="Stack Overflow" aria-label="Stack Overflow">
<a class=text-white target=_blank rel="noopener noreferrer" href=https://stackoverflow.com>
<i class="fab fa-stack-overflow"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=GitHub aria-label=GitHub>
<a class=text-white target=_blank rel="noopener noreferrer" href=https://github.com/infilos/infilos.com>
<i class="fab fa-github"></i>
</a>
</li>
</ul>
</div>
<div class="col-12 col-sm-4 text-center py-2 order-sm-2">
<small class=text-white>&copy; 2022 infilos.com All Rights Reserved</small>
</div>
</div>
</div>
</footer>
</div>
<script src=/js/popper.min.js integrity=sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49 crossorigin=anonymous></script>
<script src=/js/bootstrap.min.js integrity=sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy crossorigin=anonymous></script>
<script src=/js/main.min.5c74b870c6953931a705f390a49c7e4c0a842ec5c83b24354758dd674343ed0d.js integrity="sha256-XHS4cMaVOTGnBfOQpJx+TAqELsXIOyQ1R1jdZ0ND7Q0=" crossorigin=anonymous></script>
</body>
</html>