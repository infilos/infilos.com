<!doctype html><html lang=en class=no-js><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=generator content="Hugo 0.104.0"><meta name=ROBOTS content="INDEX, FOLLOW"><link rel=canonical type=text/html href=/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%80%A7%E8%83%BD%E4%B9%8B%E6%AE%87/><link rel="shortcut icon" href=/favicons/favicon.ico><link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180><link rel=icon type=image/png href=/favicons/favicon-16x16.png sizes=16x16><link rel=icon type=image/png href=/favicons/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/favicons/android-36x36.png sizes=36x36><link rel=icon type=image/png href=/favicons/android-48x48.png sizes=48x48><link rel=icon type=image/png href=/favicons/android-72x72.png sizes=72x72><link rel=icon type=image/png href=/favicons/android-96x96.png sizes=96x96><link rel=icon type=image/png href=/favicons/android-144x144.png sizes=144x144><link rel=icon type=image/png href=/favicons/android-192x192.png sizes=192x192><title>性能之殇 | infilos.com</title><meta property="og:title" content="性能之殇"><meta property="og:description" content="Infilos Wiki Website"><meta property="og:type" content="website"><meta property="og:url" content="/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%80%A7%E8%83%BD%E4%B9%8B%E6%AE%87/"><meta property="og:site_name" content="infilos.com"><meta itemprop=name content="性能之殇"><meta itemprop=description content="Infilos Wiki Website"><meta name=twitter:card content="summary"><meta name=twitter:title content="性能之殇"><meta name=twitter:description content="Infilos Wiki Website"><script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-123062585-1","auto"),ga("send","pageview"))</script><script async src=https://www.google-analytics.com/analytics.js></script>
<link rel=preload href=/scss/main.min.5f60a6da3ce936fccd1096f5a4541bd9d925f00a0dd08f1363f26c26bfbfda5b.css as=style><link href=/scss/main.min.5f60a6da3ce936fccd1096f5a4541bd9d925f00a0dd08f1363f26c26bfbfda5b.css rel=stylesheet integrity><script src=/js/jquery-3.5.1.min.js integrity="sha256-9/aliU8dGd2tb6OSsuzixeV4y/faTqgFtohetphbbj0=" crossorigin=anonymous></script></head><body class=td-section><header><nav class="js-navbar-scroll navbar navbar-expand-lg navbar-dark td-navbar"><a class=navbar-brand href=/><span class=navbar-logo><svg id="Capa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 512 512" style="enable-background:new 0 0 512 512"><path style="fill:#ffc107" d="M432.384 143.616c-4.165-4.164-10.917-4.164-15.083.0l-60.352 60.352c-4.164 4.165-4.164 10.917.0 15.083 21.187 20.463 54.951 19.876 75.413-1.311 19.962-20.668 19.962-53.435.0-74.102L432.384 143.616z"/><path style="fill:#607d8b" d="M42.667 277.334c-5.891.003-10.669-4.771-10.672-10.662-.002-4.338 2.623-8.245 6.64-9.882l234.667-96c5.455-2.233 11.687.38 13.92 5.835s-.38 11.687-5.835 13.92l-234.667 96C45.433 277.069 44.056 277.337 42.667 277.334z"/><path style="fill:#546e7a" d="M391.552 56.448l-32-32C343.938 8.745 322.689-.059 300.544.0h-3.755c-46.082.024-83.432 37.374-83.456 83.456v3.755c-.053 22.138 8.75 43.377 24.448 58.987l32 32c4.165 4.164 10.917 4.164 15.083.0L391.531 71.531C395.701 67.372 395.71 60.62 391.552 56.448z"/><path style="fill:#607d8b" d="M160 469.334c-3.279.006-6.379-1.497-8.405-4.075L34.261 315.926c-3.635-4.636-2.823-11.341 1.813-14.976s11.341-2.823 14.976 1.813l117.333 149.333c3.629 4.641 2.809 11.344-1.832 14.973C164.681 468.533 162.375 469.329 160 469.334z"/><path style="fill:#455a64" d="M487.467 86.848l-3.669-3.648c-37.687-36.557-97.71-36.197-134.955.811l-51.413 51.413c-36.996 37.25-37.357 97.263-.811 134.955l3.584 3.669c1.7 2.457 4.671 3.706 7.616 3.2 2.831.005 5.548-1.115 7.552-3.115l172.181-172.181c4.189-4.143 4.226-10.896.083-15.085-.028-.028-.055-.056-.083-.083L487.467 86.848z"/><g><path style="fill:#ffc107" d="M501.333 192H480c-5.891.0-10.667-4.776-10.667-10.667s4.776-10.667 10.667-10.667h21.333c5.891.0 10.667 4.776 10.667 10.667S507.225 192 501.333 192z"/><path style="fill:#ffc107" d="M394.667 298.667c-5.891.0-10.667-4.776-10.667-10.667v-21.333c0-5.891 4.776-10.667 10.667-10.667 5.891.0 10.667 4.776 10.667 10.667V288C405.333 293.891 400.558 298.667 394.667 298.667z"/><path style="fill:#ffc107" d="M480 277.334c-2.831.005-5.548-1.115-7.552-3.115l-21.333-21.333c-4.093-4.237-3.975-10.99.262-15.083 4.134-3.993 10.687-3.993 14.821.0l21.333 21.333c4.159 4.172 4.148 10.926-.024 15.085C485.514 276.209 482.815 277.327 480 277.334z"/></g><g><path style="fill:#455a64" d="M266.667 448H96c-29.455.0-53.333 23.878-53.333 53.333.0 5.891 4.776 10.667 10.667 10.667h256c5.891.0 10.667-4.776 10.667-10.667C320 471.878 296.122 448 266.667 448z"/><circle style="fill:#455a64" cx="32" cy="288" r="32"/></g><g/><g/><g/><g/><g/><g/><g/><g/><g/><g/><g/><g/><g/><g/><g/></svg></span><span class=font-weight-bold>infilos.com</span></a>
<button class=navbar-toggler type=button data-toggle=collapse data-target=#navbarSupportedContent aria-controls=navbarSupportedContent aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span></button><div class="collapse navbar-collapse" id=navbarSupportedContent><ul class="navbar-nav mr-auto"><li class=nav-item style=max-width:90px;min-width:10px><a class=nav-link href=/%e5%9f%ba%e7%a1%80%e7%9f%a5%e8%af%86><span>基础</span></a></li><li class=nav-item style=max-width:90px;min-width:10px><a class=nav-link href=/%e7%bc%96%e7%a8%8b%e8%af%ad%e8%a8%80><span>语言</span></a></li><li class=nav-item style=max-width:90px;min-width:10px><a class=nav-link href=/%e6%a1%86%e6%9e%b6%e4%b8%8e%e5%ba%93><span>框架库</span></a></li><li class="nav-item dropdown" style=max-width:90px;min-width:10px><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>分布式
<span>+</span></a><div class=dropdown-menu aria-labelledby=navbarDropdown><a class=dropdown-item href=/%e5%88%86%e5%b8%83%e5%bc%8f/base>基本构成</a></div></li><li class="nav-item dropdown" style=max-width:90px;min-width:10px><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>大数据
<span>+</span></a><div class=dropdown-menu aria-labelledby=navbarDropdown><a class=dropdown-item href=/%e5%ad%98%e5%82%a8%e7%b3%bb%e7%bb%9f>存储系统</a>
<a class=dropdown-item href=/%e6%9f%a5%e8%af%a2%e7%b3%bb%e7%bb%9f>查询系统</a>
<a class=dropdown-item href=/%e6%b6%88%e6%81%af%e7%b3%bb%e7%bb%9f>消息系统</a>
<a class=dropdown-item href=/%e5%a4%84%e7%90%86%e7%b3%bb%e7%bb%9f>处理系统</a>
<a class=dropdown-item href=/%e6%95%b0%e6%8d%ae%e6%b2%bb%e7%90%86>数据治理</a></div></li><li class="nav-item dropdown" style=max-width:90px;min-width:10px><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>中后台
<span>+</span></a><div class=dropdown-menu aria-labelledby=navbarDropdown><a class=dropdown-item href=/%e5%9f%ba%e7%a1%80%e8%ae%be%e6%96%bd>基础设施</a>
<a class=dropdown-item href=/%e7%94%a8%e6%88%b7%e7%b3%bb%e7%bb%9f>用户系统</a>
<a class=dropdown-item href=/%e4%ba%a4%e4%ba%92%e7%95%8c%e9%9d%a2>交互界面</a>
<a class=dropdown-item href=/%e4%b8%9a%e5%8a%a1%e7%b3%bb%e7%bb%9f>业务系统</a></div></li><li class=nav-item style=max-width:90px;min-width:10px><a class=nav-link href=/%e6%a8%a1%e5%bc%8f%e6%9e%b6%e6%9e%84><span>模式架构</span></a></li><li class=nav-item style=max-width:90px;min-width:10px><a class=nav-link href=/%e9%9d%a2%e8%af%95%e9%97%ae%e7%ad%94><span>面试</span></a></li><li class=nav-item style=max-width:90px;min-width:10px><a class=nav-link href=/%e7%ae%a1%e7%90%86%e8%b7%af%e5%be%84><span>管理</span></a></li><li class=nav-item style=max-width:90px;min-width:10px><a class=nav-link href=/%e5%bc%80%e6%ba%90%e9%a1%b9%e7%9b%ae><span>开源⭐</span></a></li></ul><div class="form-inline my-2 my-lg-0"><div class="nav-item nav-search-item my-2 my-md-0"><input type=search class="form-control td-search-input" placeholder="&#xf002; Search this site…" aria-label="Search this site…" autocomplete=off></div></div></div></nav></header><div class="container-fluid td-outer"><div class=td-main><div class="row flex-xl-nowrap"><div class="col-12 col-md-3 col-xl-2 td-sidebar d-print-none"></div><div class="d-none d-xl-block col-xl-2 td-toc d-print-none"></div><main class="col-12 col-md-9 col-xl-8 pl-md-5" role=main><div class=td-content><div class="pageinfo pageinfo-primary d-print-none"><p>This the multi-page printable view of this section.
<a href=# onclick="return print(),!1">Click here to print</a>.</p><p><a href=/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%80%A7%E8%83%BD%E4%B9%8B%E6%AE%87/>Return to the regular view of this page</a>.</p></div><h1 class=title>性能之殇</h1><ul><li>1: <a href=#pg-b49e980fa88d6369ca47e740dac83230>冯诺依曼瓶颈</a></li><li>2: <a href=#pg-aefe655ca29e5ca51256293a1cd4afe7>CPU实现</a></li><li>3: <a href=#pg-c110832f6dd0cb3d022a8ae5b42e5419>事件驱动</a></li><li>4: <a href=#pg-6b9f829b6c0311ea6d40749b6834a87f>Unix进程模型</a></li><li>5: <a href=#pg-203525012a04436533b5492427ca0bd8>DPDK-SDN-大页内存</a></li><li>6: <a href=#pg-bfaab3f47b8160c8fc71b55253bc915f>局部性与乐观</a></li><li>7: <a href=#pg-255f8164756bda67d84bcc9115fac66d>共同的瓶颈</a></li></ul><div class=content><blockquote><p>本文来自: <a href=https://lvwenhan.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/492.html>岁寒-性能之殇</a></p></blockquote><h2 id=reference>Reference</h2><p>电子计算机与信息技术是最近几十年人类科技发展最快的领域，无可争议地改变了每个人的生活：从生活方式到战争方式，从烹饪方式到国家治理方式，都被计算机和信息技术彻底地改变了。如果说核武器彻底改变了国与国之间相处的模式，那么计算机与信息技术则彻底改变了人类这个物种本身，人类的进化也进入了一个新的阶段。</p><blockquote><p>简单的说，生物进化之前还有化学进化。然而细胞一经诞生，中心法则的分子进化就趋于停滞了：38 亿年来，中心法则再没有新的变动，所有的蛋白质都由 20 种标准氨基酸连成，连碱基与氨基酸的对应关系也沿袭至今，所有现代生物都共用一套标准遗传密码。正如中心法则是化学进化的产物，却因为开创了生物进化而停止了化学进化，人类是生物进化的产物，也因为开创了文化进化和技术进化而停止了生物进化——进化已经走上了更高的难度。</p></blockquote><h2 id=abstract>Abstract</h2><p>本文的目标是在我有限的认知范围内，讨论一下人们为了提升性能而做出的各种努力，这其中包含硬件层面的 CPU、RAM、磁盘，操作系统层面的并发、并行、事件驱动，软件层面的多进程、多线程，网络层面的分布式，等等。事实上，上述名词并不局限于某一固定层面，计算机从 CPU 内的门电路到显示器中的某行字，是靠层层协作才得以实现的；计算机科学中的很多概念，都跨越了层次；事件驱动就是由 CPU 和操作系统协作完成测。</p></div></div><div class=td-content style=page-break-before:always><h1 id=pg-b49e980fa88d6369ca47e740dac83230>1 - 冯诺依曼瓶颈</h1><h2 id=天才冯诺依曼>天才冯·诺依曼</h2><p>冯·诺依曼于 1903年12月28日出生在奥匈帝国的布达佩斯，1957年2月8日卒于美国，终年 53 岁。在他短暂的一生中，他取得了绝大的成就，远不止于世人熟知的“冯·诺依曼架构”。</p><blockquote><p>约翰·冯·诺伊曼，出生于匈牙利的美国籍犹太人数学家家庭，现代电子计算机与博弈论的重要创始人，在泛函分析、遍历理论、几何学、拓扑学和数值分析等众多数学领域及计算机学、量子力学和经济学中都有重大贡献。</p></blockquote><p>出列对计算机科学的贡献，他还有一个称号不为大众所熟知：“博弈论之父”。博弈论被认为是 20 世纪经济学领域最伟大的成果之一。(说到博弈论，我相信很多人第一个想到的肯定跟我一些样，那么就是“纳什均衡”)。</p><h2 id=冯诺依曼架构>冯·诺依曼架构</h2><p>冯·诺依曼由于在曼哈顿工程中需要进行大量的运算，从而使用了当时最先进的两台计算机 Mark I 和 ENIAC，在使用 Mark I 和 ENIAC 的过程中，他意识到了存储程序的重要性，从而提出了存储程序逻辑架构。</p><p>“冯·诺依曼架构”定义如下：</p><ol><li>以运算单元为中心。</li><li>采用存储程序原理。</li><li>存储器是按地址访问、线性编址的空间。</li><li>控制流由指令流产生。</li><li>指令码由操作码和地址码组成。</li><li>数据以二进制编码。</li></ol><h3 id=优势>优势</h3><p>冯·诺依曼架构第一次将存储器和运算器分开，指令和数据均放置在存储器中，为计算机的通用性奠定了基础。虽然在规范中计算单元依然是核心，但冯·诺依曼架构事实上导致了以存储器为核心的现代计算机的诞生。</p><blockquote><p>注：请各位在心里明确一件事情，“存储器指的是内存，即 RAM。”而磁盘在理论上属于输入输出设备。</p></blockquote><p>该架构的另一项重要共现是使用二进制取代十进制，大幅降低了运算电路的复杂性。这为晶体管时代超大规模集成电路的诞生提供了最重要的基础，让我们实现了今天手腕上 Apple Watch 的运算性能能够远超早期大型计算机的壮举，这也是摩尔定律得以实现的基础。</p><h3 id=瓶颈>瓶颈</h3><p>冯·诺依曼架构为计算机大提速铺平了道路，却也埋下了一个隐患：在内存容量指数级增长以后，CPU 和内存之间的数据传输带宽称为了瓶颈。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20181125164709.png style=display:block;width:70% alt=NAME align=center></div><p>上图是 i9-7980XE 18 核 36 线程的民用最强 CPU，其配合超频过的 DDR4 3200MHz 内存，测试出的内存读取速度是 90GB/s。看起来是不是很快？看看图中的 L1 Cache，3.7TB/s。</p><p>我们再来算算时间。这颗 CPU 的最大睿频是 4.4GHz，就是说 CPU 执行一条指令需要的时间是 0.000000000227273 秒，即 0.22ns，而内存的延迟是 68.1ns。换句话说，只要去内存里读取一个字节，就需要 CPU 等待 300 个时钟周期，何其的浪费 CPU 时间啊。</p><p>CPU 的 L1/L2/L3 三级缓存是使用和 CPU 同样的 14 纳米工艺执照的硅半导体，每个 bit 都是用 6 个场效应管(即通俗讲的三极管)构成，成本高昂且非常占用 CPU 的核心面积，故不能做成很大的容量。</p><p>除此之外，三级缓存对计算机速度的提升来源于计算机内存的“局部性”，相关内容后续再展开讨论。</p><h2 id=接下来>接下来</h2><p>下一篇文章，我们将讨论分支预测、流水线与多个 CPU，看看那些上古大神为了提升性能都迸发出了什么奇思妙想，又都搞出了什么奇技淫巧。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-aefe655ca29e5ca51256293a1cd4afe7>2 - CPU实现</h1><p>CPU 硬件为了提高性能，逐步发展出了指令流水线(分支预测)和多核 CPU，本文我们将简单的探讨它们的原理和效果。</p><h2 id=指令流水线>指令流水线</h2><p>在一台纯粹的图灵机中，指令是一个接一个顺序执行的。而现实世界中的通用计算机所用的很多基础算法都是可以并行的，如加法器和乘法器，它们可以很容易的被切分成能够同时运行的多个指令，这样就可以大大提升性能。</p><blockquote><p>指令流水线，说白了是就是 CPU 电路层面的编发。</p><p>Intel Core i7 自 Sandy Bridge（2010）架构以来一直都是 14 级流水线设计。基于 Cedar Mill 架构的最后一代奔腾 4，在 2006 年就拥有 3.8GHz 的超高频率，却因为其长达 31 级的流水线而成了为样子货，被 AMD 1GHz 的芯片按在地上摩擦。</p></blockquote><p>流水线是现代 RISC(精简指令集) 核心的一个重要设计，它极大地提高了性能。</p><p>对于一条指令的执行过程，通常分为：取指令、指令译码、取操作数、运算、写结果。前面三步由控制器完成，后面两步由运算器完成。按照传统的做法，当控制器工作的时候运算器在休息，在运算器工作的时候控制器在休息。流水线的做法就是当控制器完成第一条指令的操作后，直接开始开始第二条指令的操作，同时运算器开始第一条指令的操作。这样就形成了流水线系统，这是一条2级流水线。</p><h3 id=risc-机器的五层流水线示意图>RISC 机器的五层流水线示意图</h3><p>下图形象的展示了流水线是如何提高性能的。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20181125165946.png style=display:block;width:70% alt=NAME align=center></div><h3 id=缺点>缺点</h3><p>指令流水线通过硬件层面的并发来提高性能，却也带来了一些无法避免的缺点。</p><ul><li>设计难度高，一步小心就成了高频低能的奔腾 4。</li><li>并发导致每条指令的执行时间变长。</li><li>优化难度大，有时候两行代码的顺序变动可能导致数倍的性能差异，这对编译器提出了更高的要求。</li><li>如果多次分支预测失败，将会导致严重的性能损失。</li></ul><h2 id=分支预测>分支预测</h2><p>指令形成流水线以后，就需要一种高效的调控来保证硬件层面的并发效果：最佳情况是每条流水线里的十几个指令都是正确的，这样完全不浪费时钟周期。而分支预测就是干这个的。</p><p>分支预测器猜测条件表达式两路分支中那一路最优可能发生，然后推测执行这一路的指令，来避免流水线停顿造成时间的浪费。但是，如果后来发现分支预测错误，那么流水线中推测执行的那些中间结果就要全部被放弃，重新获取正确的分支路线上的指令开始执行，这就带来了是一个时钟周期的延迟，这个时候，该 CPU 核心就是完全在浪费时间。</p><blockquote><p>幸运的是，当下主流的 CPU 在现代编译器的配合下，能够越来越高的完成这项工作。</p><p>还记得那个让 Intel CPU 性能跌 30% 的漏洞补丁吗，那个漏洞就是 CPU 设计的时候，分支预测设计的不完善导致的。</p></blockquote><h2 id=多核-cpu>多核 CPU</h2><p>多核 CPU 的每个核心拥有自己独立的运算单元、寄存器、一二级缓存，所有核心共用同一条内存总线，同一段内存。</p><p>多核 CPU 的出现，标志着人类的集成电路工艺遇到了一个严酷的瓶颈，无法再大规模提升单核性能，只能通过多核类聊以自慰。实际上，多核 CPU 性能的提升极其有限，还不如增加一点点单核频率所能提升的性能多。</p><h3 id=优势>优势</h3><p>多核 CPU 的优势很明显，就是可以并行地执行多个图灵机，可以显而易见地提升性能。只不过由于使用同一条内存总线，实际带来的效果有限，并且需要操作系统和编译器的密切配合才行。</p><blockquote><p>题外话： AMD64 技术可以运行 32 位的操作系统和应用程序，所用的方法是依旧使用 32 位宽的内存总线，每计算一次要取两次内存，性能提升也非常有限，不过好处就是可以使用大于 4GB 的内存了。大家应该都没忘记第一篇文章中提到的冯·诺依曼架构拥有 CPU 和内存通信带宽不足的弱点。（注：AMD64 技术是和 Intel 交叉授权的专利，i7 也是这么设计的）</p></blockquote><h3 id=劣势>劣势</h3><p>多核 CPU 劣势其实更加明显，但是人类也没有办法，谁不想用 20GHz 的 CPU 呢，谁想用这八核的 i7 呀。</p><ol><li>内存读写效率不变，甚至有降低的风险。</li><li>操作系统复杂度提升很多倍，计算资源的管理变得非常复杂。</li><li>依赖操作系统的进步：微软以肉眼可见的速度，在这十几年间大幅提升了 Windows 的多核效率和安全性：XP 只是能利用，7 可以自动调配一个进程在多个核心上游走，2008R2 解决了依赖 CPU0 调度导致司机的 BUG，8 可以利用多核心启动，10 优化了杀死进程依赖 CPU0 的问题。</li></ol><blockquote><p>超线程技术：Intel 的超线程技术是将 CPU 核心内部再分出两个逻辑核心，只增加了 5% 的裸面积，就带来了 15%~30% 的性能提升。</p></blockquote><h2 id=怀念过去>怀念过去</h2><p>Intel 肯定怀念摩尔定律提出时候的黄金年代，只依靠工艺的进步，就能一两年就性能翻番。AMD 肯定怀念 K8 的黄金一代，1G 战 4G，靠的就是把内存控制器从北桥芯片移到 CPU 内部，提升了 CPU 和内存的通信效率，自然性能倍增。而今天，人类的技术已经到达了一个瓶颈，只能通过不断的提升 CPU 和操作系统的复杂度来获得微弱的性能提升，呜呼哀哉。</p><p>不过我们也不能放弃希望，AMD RX VAGA64 显卡拥有 2048 位的显存位宽，理论极限还是很恐怖的，这可能就是未来内存的发展方向。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-c110832f6dd0cb3d022a8ae5b42e5419>3 - 事件驱动</h1><p>Event-Driven(事件驱动)这个词这几年随着 Node.js 的大热也成了一个热词，似乎已经成了“高性能”的代名词，殊不知事件驱动其实是通用计算机的胎记，是一种与生俱来的能力。本文我们就要一起了解一下事件驱动的价值和本质。</p><h2 id=通用计算机中的时间驱动>通用计算机中的时间驱动</h2><p>首先我们定义当下最火的 x86 PC 机为典型的通用电子计算机：可以写文章，可以打游戏，可以上网聊天，可以读U盘，可以打印，可以设计三维模型，可以编辑渲染视频，可以作路由器，还可以控制巨大的工业机器。那么，这种计算机的事件驱动能力就很容易理解了：</p><ol><li>假设 Chrome 正在播放 Youtube 视频，你按下了键盘上的空格键，视频暂停了。这个操作就是事件驱动：计算机获得了你单机空格的事件，于是把视频暂停了。</li><li>假设你正在跟人聊 QQ，别人发了一段文字给你，计算机获得了网络传输事件，于是将信息提取出来显示到了屏幕上，这也是事件驱动。</li></ol><h2 id=事件驱动的实现方式>事件驱动的实现方式</h2><p>事件驱动本质是由 CPU 提供的，因为 CPU 作为控制器+运算器，它需要随时响应意外事件，如上面例子中的键盘和网络。</p><p>CPU 对于意外事件的响应是依靠 Execption Control Flow(异常控制流)来实现的。</p><h2 id=强大的异常控制流>强大的异常控制流</h2><p>异常控制流是 CPU 的核心功能，它是以下听起来高大上的功能的基础。</p><h3 id=时间片>时间片</h3><p>CPU 时间片的分配也是利用异常控制流来实现的，它让多个进程在宏观上位于同一个 CPU 核心上同时运行，而我们知道在微观上任一个时刻，每个 CPU 核心都只能运行一条指令。</p><h3 id=虚拟内存>虚拟内存</h3><blockquote><p>这里的虚拟内存不是 Windows 的虚拟内存，是 Linux 虚拟内存，即逻辑内存。</p></blockquote><p>逻辑内存是用一段内存和一段磁盘上的存储空间放在一起组成的一个逻辑内存空间，对外依然表现为“线性数组内存空间”。逻辑内存引出了现代计算机的一个重要性能观念：</p><blockquote><p>内存局部性天然的让相邻指令需要读写的内存空间也相邻，于是可以把一个进程的内存放到磁盘上，再把一小部分的“热数据”放到内存中，让其作为磁盘的缓存，这样可以在降低很少性能的情况下，大幅提升计算机能够同时运行的进程数量，从而大幅提升性能。</p></blockquote><p>虚拟内存的本质其实是使用缓存+乐观的手段来提升计算机的性能。</p><h3 id=系统调用>系统调用</h3><p>系统调用是进程向操作系统索取资源的通道，这也是利用异常控制流来实现的。</p><h3 id=硬件中断>硬件中断</h3><p>键盘点击、鼠标移动、网络接收到数据、麦克风有声音输入、插入 U 盘这些操作全部需要 CPU 暂时停下手头的工作，来做出响应。</p><h3 id=进程线程>进程、线程</h3><p>进程的创建、管理和销毁全部都是基于异常控制流实现的，其生命周期的钩子函数也是操作系统依赖异常控制流实现的。在 Linux 上线程和进程没有功能上的区别。</p><h3 id=编程语言中的-try-catch>编程语言中的 try-catch</h3><p>C++ 编译成二进制程序，其异常控制语句是直接基于异常控制流实现的。Java 这种硬虚拟机语言，PHP 这种软虚拟机语言，其异常控制流的一部分也是基于最底层的异常控制流来实现的，另一部分可以用逻辑判断来实现。</p><h2 id=基于异常控制流的事件驱动>基于异常控制流的事件驱动</h2><p>其实现在人们讨论的事件驱动，是由 Linux 内核提供的 epoll，是 2002年10月18日伴随着 kernel 2.5.44 发布的，是 Linux 首次将操作系统中的 IO 事件和异常控制流暴露给了进程，实现了本文开头提的事件驱动。</p><h3 id=kqueue>Kqueue</h3><p>FreeBSD 4.1 版本于 2000 年发布，一起携带的 Kqueue 是 BSD 系统中事件驱动的 API 提供者。BSD 系统如今已遍地开花，从 macOS 到 iOS，从 watchOS 到 PS4 游戏机，都受到了 Kqueue 的蒙荫。</p><h3 id=epoll-是什么>epoll 是什么</h3><p>操作系统本身就是事件驱动的，所以 epoll 并不是什么新发明，而只是把本来不给用户空间的 API 暴露给了用户空间而已。</p><h3 id=epoll-做了什么>epoll 做了什么</h3><p>网络 IO 是一种纯异步的 IO 模型，所以 Nginx 和 Node.js 都基于 epoll 实现了完全的事件驱动，活得好了相比于 select/epoll 巨量的性能提升。而磁盘 IO 就没有这么幸运的，因此磁盘本身也是单体阻塞资源：即，有进程在写磁盘的时候，其他写入请求只能等待，就是天王老子来了也不行，磁盘做不到呀。所以磁盘 IO 是基于 epoll 实现的非阻塞 IO，但是其底层依旧是异步阻塞，即便这样，性能也已经爆棚了。Node 的磁盘 IO 性能远超其他解释型语言，过去几年在 web 后端霸占了一些对磁盘 IO 要求较高的领域。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-6b9f829b6c0311ea6d40749b6834a87f>4 - Unix进程模型</h1><p>Unix 系统 1969 年诞生于 AT&T 旗下的贝尔实验室。1971 年，Ken Thompson（Unix之父） 和 Dennis Ritchie（C语言之父）共同发明了 C 语言，并在 1973 年用 C 语言重写了 Unix。</p><p>Unix 自诞生起就是多用户、多任务的分时操作系统，其引入的“进程”概念是计算机科学中最成功的概念之一，几乎所有现代操作系统都是这一概念的受益者。但是进程也有局限，由于 AT&T 是做电话交换起家，所以 Unix 进程在设计之初就是延续的电话交换这个业务需求：保证电话交换的效率，就够了。</p><p>1984年，Richard Stallman 发起了 GNU 项目，目标是创建一个完全自由且向下兼容 Unix 的操作系统。之后 Linus Torvalds 与 1991 年发布了 Linux 内核，和 GNU 结合在了一起形成了 GNU/Linux 这个当下最成功的开源操作系统。所以 Redhat、CentOS、Ubuntu 这些如雷贯耳的 Linux 服务器操作系统，他们的内存模型也是高度类似 Unix 的。</p><h2 id=unix-进程模型>Unix 进程模型</h2><p>进程是操作系统提供的一种抽象，每个进程在自己看来都是一个独立的图灵机：独占 CPU 核心，一个一个地运行指令，读写内存。进程是计算机科学中最重要的概念之一，是进程使多用户、多任务成为了可能。</p><h3 id=上下文切换>上下文切换</h3><p>操作系统使用上下文切换让一个 CPU 核心上可以同时运行多个进程：在宏观时间尺度，例如 5 秒内，一台电脑的用户会认为他的桌面进程、音乐播放进程、鼠标响应进程、浏览器进程是在同时运行的。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20181125191627.png style=display:block;width:70% alt=NAME align=center></div><h3 id=上下文切换的过程>上下文切换的过程</h3><p>假设你正在运行网易云音乐进程，你突然想搜歌，假设焦点已经位于搜索框内：</p><ol><li>当前进程是网易云音乐，它正在播放音乐。</li><li>你突然打字，CPU 接到键盘发起的中断信号(异常控制流中的一个异常)，准备调起键盘处理进程。</li><li>将网易云音乐进程的寄存器、栈指针、程序计数器保存到内存中。</li><li>将键盘处理进程的寄存器、栈指针、程序计数器从内存中读出来，写入到 CPU 内部相应的模块中。</li><li>执行程序计数器的指令，键盘处理程序开始处理键盘输入。</li><li>完成了一次上下文切换。</li></ol><h3 id=名词解释>名词解释</h3><ul><li>寄存器：CPU 核心中用于暂时存储指令、地址和数据的电路，和内核频率一样，速度极快。</li><li>栈指针：该进程所拥有的栈的指针。</li><li>程序计数器：简称 PC，它存储着内核将要执行的下一个指令的内存地址。程序计数器是图灵机的核心组成部分。还记得冯·诺依曼架构吗，它的一大创造就是把指令和数据都存在内存里，让计算机获得了极大的自由度。</li></ul><h2 id=unix-进程模型的局限>Unix 进程模型的局限</h2><p>Unix 进程模型十分的清晰，上下文切换使用了一个非常简单的操作就实现了多个进程的宏观同时运行，是一个伟大的杰作。但是它却存在着一个潜在的缺陷，这个缺陷在 Unix 诞生数十年之后才渐渐浮出水面。</p><h3 id=致命的内存>致命的内存</h3><p>进程切换过程中需要分别写、读一些内存，该操作在 Unix 刚发明的时候没有发现有什么性能问题，但是 CPU 裹挟着摩尔定律一路狂奔，2000 年，ADM 领先 Intel 两天发布了第一款 1GHz 的微处理器 “AMD Athlon 1GHz”，此时一个指令的执行时间已经低于 1ns，而其内存延迟高达 60ns，这导致了一个之前不曾出现过的问题：</p><blockquote><p>上下文切换读写内存的时间成为了整个系统的性能瓶颈。</p></blockquote><h3 id=软件定义一切>软件定义一切</h3><p>我们将在下一篇文章中探讨 SDN(软件定义网络)，着这里我们先来看一下“软件定义一切”整个概念。</p><p>当下，不仅有软件定义网络，还有软件定义存储，甚至还出现了软件定义基础架构(这不就是云计算吗)。是什么导致了软件越来越强势，开始倾如过去只有专业的硬件设备才能提高的高性能高稳定性服务呢？我认为，就是通用计算机的发展导致的，确切的说，是 CPU 和网络的发展导致的。</p><p>当前的民用级 CPU 性能已经爆表，因为规模巨大，所以其价格也要显著低于同性能的专用处理器：40G 路由设备的价格大约是自建 40G 软路由价格的二十分之一。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-203525012a04436533b5492427ca0bd8>5 - DPDK-SDN-大页内存</h1><p>上文我们说到，当今的 x86 通用微处理器已经拥有了十分强大的性能，得益于其庞大的销量，其价格与专用 CPU 相比也有着巨大的优势，于是，软件定义一切诞生了！</p><h2 id=软路由>软路由</h2><p>说到软路由，很多人都露出了会心的微笑，因为其拥有低廉的价格、超多的功能、够用的性能和科学上网能力。现在网上能买到的软路由，其本质就是一个 x86 PC 加上多个网口，大多是基于 Linux 或 BSD 内核，使用 Intel 低端被动散热 CPU 打造出的千兆路由器，几百块就能实现千兆的性能，最重要的是拥有 QOS、多路拨号、负载均衡、防火墙、VPN 组网、科学上网等强大功能，传统路由器抛开科学上网不谈，其他功能也不是几百块就搞得定的。</p><h3 id=软路由的弱点>软路由的弱点</h3><p>软路由便宜，功能强大，但是也有弱点。它最大的弱点其实是性能：传统 *UNIX 网络栈的性能实在是不高。</p><p>软路由的 NAT 延迟比硬路由明显更大，而且几百块的软路由 NAT 性能也不够，跑到千兆都难，而几百块的硬路由跑到千兆很容易。那怎么办呢？改操作系统啊。</p><h2 id=sdn>SDN</h2><p>软件定义网络，其本质就是使用计算机科学中最常用的“虚拟机”构想，将传统由硬件实现的 交换、网关、路由、NAT 等网络流量控制流程交由软件来统一管理：可以实现硬件不动，网络结构瞬间变化，避免了传统的停机维护调试的烦恼，也为大规模公有云计算铺平了道路。</p><h3 id=虚拟机>虚拟机</h3><p>虚拟机的思想自底向上完整地贯穿了计算机的每一个部分，硬件层有三个场效应管虚拟出的 SRAM、多个内存芯片虚拟出的一个“线性数组内存”，软件层有 jvm 虚拟机，PHP 虚拟机（解释器）。自然而然的，当网络成为了更大规模计算的瓶颈的时候，人们就会想，为什么网络不能虚拟呢？</p><h3 id=openflow>OpenFlow</h3><p>最开始，SDN 还是基于硬件来实施的。Facebook 和 Google 使用的都是 OpenFlow 协议，作用在数据链路层（使用 MAC 地址通信的那一层，也就是普通交换机工作的那一层），它可以统一管理所有网关、交换等设备，让网络架构实时地做出改变，这对这种规模的公司所拥有的巨大的数据中心非常重要。</p><h2 id=dpdk>DPDK</h2><p>DPDK 是 SDN 更前沿的方向：使用 x86 通用 CPU 实现 10Gbps 甚至 40Gbps 的超高速网关（路由器）。</p><h3 id=dpdk-是什么>DPDK 是什么</h3><p>Intel DPDK 全称为 Intel Data Plane Development Kit，直译为“英特尔数据平面开发工具集”，它可以摆脱类 UNIX 网络数据包处理机制的局限，实现超高速的网络包处理。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20181125193348.png style=display:block;width:70% alt=NAME align=center></div><h3 id=dpdk-的价值>DPDK 的价值</h3><p>当下，一台 40G 核心网管路由器动辄数十万，而 40G 网卡也不会超过一万块，而一颗性能足够的 Intel CPU 也只需要几万块，软路由的性价比优势是巨大的。</p><p>实际上，阿里云和腾讯云也已经基于 DPDK 研发出了自用的 SDN，已经创造了很大的经济价值。</p><h2 id=怎么做到的>怎么做到的？</h2><p>DPDK 使用自研的数据链路层（MAC地址）和网络层（ip地址）处理功能（协议栈），抛弃操作系统（Linux，BSD 等）提供的网络处理功能（协议栈），直接接管物理网卡，在用户态处理数据包，并且配合大页内存和 NUMA 等技术，大幅提升了网络性能。有论文做过实测，10G 网卡使用 Linux 网络协议栈只能跑到 2G 多，而 DPDK 分分钟跑满。</p><h3 id=用户态网络栈>用户态网络栈</h3><p>上篇文章我们已经说到，Unix 进程在网络数据包过来的时候，要进行一次上下文切换，需要分别读写一次内存，当系统网络栈处理完数据把数据交给用户态的进程如 Nginx 去处理还会出现一次上下文切换，还要分别读写一次内存。夭寿啦，一共 1200 个 CPU 周期呀，太浪费了。</p><p>而用户态协议栈的意思就是把这块网卡完全交给一个位于用户态的进程去处理，CPU 看待这个网卡就像一个假肢一样，这个网卡数据包过来的时候也不会引发系统中断了，不会有上下文切换，一切都如丝般顺滑。当然，实现起来难度不小，因为 Linux 还是分时系统，一不小心就把 CPU 时间占完了，所以需要小心地处理阻塞和缓存问题。</p><h3 id=numa>NUMA</h3><p>NUMA 来源于 AMD Opteron 微架构，其特点是将 CPU 直接和某几根内存使用总线电路连接在一起，这样 CPU 在读取自己拥有的内存的时候就会很快，代价就是读取别 U 的内存的时候就会比较慢。这个技术伴随着服务器 CPU 核心数越来越多，内存总量越来越大的趋势下诞生的，因为传统的模型中不仅带宽不足，而且极易被抢占，效率下降的厉害。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20181125193711.png style=display:block;width:70% alt=NAME align=center></div><blockquote><p>NUMA 利用的就是电子计算机（图灵机 + 冯·诺依曼架构）天生就带的涡轮：局部性。</p></blockquote><h2 id=细说大页内存>细说大页内存</h2><h3 id=内存分页>内存分页</h3><p>为了实现虚拟内存管理机制，前人们发明了内存分页机制。这个技术诞生的时候，内存分页的默认大小是 4KB，而到了今天，绝大多数操作系统还是用的这个数字，但是内存的容量已经增长了不知道多少倍了。</p><h3 id=tlb-miss>TLB miss</h3><p>TLB（Translation Lookaside Buffers）转换检测缓冲区，是内存控制器中为增加虚拟地址到物理地址的翻译速度而设立的一组电子元件，最近十几年已经随着内存控制器被集成到了 CPU 内部，每颗 CPU 的 TLB 都有固定的长度。</p><p>如果缓存未命中（TLB miss），则要付出 20-30 个 CPU 周期的带价。假设应用程序需要 2MB 的内存，如果操作系统以 4KB 作为分页的单位，则需要 512 个页面，进而在 TLB 中需要 512 个表项，同时也需要 512 个页表项，操作系统需要经历至少 512 次 TLB Miss 和 512 次缺页中断才能将 2MB 应用程序空间全部映射到物理内存；然而，当操作系统采用 2MB 作为分页的基本单位时，只需要一次 TLB Miss 和一次缺页中断，就可以为 2MB 的应用程序空间建立虚实映射，并在运行过程中无需再经历 TLB Miss 和缺页中断。</p><h3 id=大页内存>大页内存</h3><p>大页内存 HugePage 是一种非常有效的减少 TLB miss 的方式，让我们来进行一个简单的计算。</p><p>2013 年发布的 Intel Haswell i7-4770 是当年的民用旗舰 CPU，其在使用 64 位 Windows 系统时，可以提供 1024 长度的 TLB，如果内存页的大小是 4KB，那么总缓存内存容量为 4MB，如果内存页的大小是 2MB，那么总缓存内存容量为 2GB。显然后者的 TLB miss 概率会低得多。</p><p>DPDK 支持 1G 的内存分页配置，这种模式下，一次性缓存的内存容量高达 1TB，绝对够用了。</p><p>不过大页内存的效果没有理论上那么惊人，DPDK 实测有 10%~15% 的性能提升，原因依旧是那个天生就带的涡轮：局部性。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-bfaab3f47b8160c8fc71b55253bc915f>6 - 局部性与乐观</h1><p>冯·诺依曼架构中，指令和数据均存储在内存中，彻底打开了计算机“通用”的大门。这个结构中，“线性数组”内存天生携带了一个涡轮：局部性。</p><h2 id=局部性分类>局部性分类</h2><h3 id=空间局部性>空间局部性</h3><p>空间局部性是最容易理解的局部性：如果一段内存被使用，那么之后，离他最近的内存也最容易被使用，无论是数据还是指令都是这样。举一个浅显易懂的例子：</p><p>循环处理一个 Array，当处理完了 <code>[2]</code> 之后，下一个访问的就是 <code>[3]</code>，他们在内存里是相邻的。</p><h3 id=时间局部性>时间局部性</h3><p>如果一个变量所在的内存被访问过，那么接下来这一段内存很可能被再次访问，例子也非常简单：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>$a = [];
</span></span><span style=display:flex><span>if ( !$b ) {
</span></span><span style=display:flex><span>	$a[] = $b;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>在一个 <code>function</code> 内，一个内存地址很可能被访问、修改多次。</p><h2 id=乐观>乐观</h2><p>“乐观”作为一种思考问题的方式广泛存在于计算机中，从硬件设计、内存管理、应用软件到数据库均广泛运用了这种思考方式，并给我们带来了十分可观的性能收益。</p><h3 id=乐观的-cpu>乐观的 CPU</h3><p>第一篇文章中的三级缓存和第二篇文章中的分支预测与流水线，均是乐观思想的代表。</p><h3 id=乐观的虚拟内存>乐观的虚拟内存</h3><p>虚拟内存依据计算机内存的局部性，将磁盘作为内存的本体，将内存作为磁盘的缓存，用很小的性能代价带来了数十倍并发进程数，是乐观思想的集大成者。</p><h3 id=乐观的缓存>乐观的缓存</h3><p>Java 经典面试题 LRU 缓存实现，也是乐观思想的一种表达。</p><p>同样，鸟哥的 <a href=http://www.laruence.com/2013/03/18/2846.html>yac</a> 也是这一思想的强烈体现。</p><p>设计 Yac 的经验假设：</p><ol><li>对于一个应用来说, 同名的 Cache 键, 对应的 Value 大小几乎相当。</li><li>不同的键名的个数是有限的。</li><li>Cache 的读次数, 远远大于写的次数。</li><li>Cache 不是数据库, 即使 Cache 失效也不会带来致命错误。</li></ol><p>Yac 的限制：</p><ol><li>key 的长度最大不能超过 48 个字符. (我想这个应该是能满足大家的需求的, 如果你非要用长 Key, 可以 MD5 以后再存)</li><li>Value 的最大长度不能超过 64M, 压缩后的长度不能超过 1M。</li><li>当内存不够的时候, Yac 会有比较明显的踢出率, 所以如果要使用 Yac, 那么尽量多给点内存吧。</li></ol><h3 id=乐观锁>乐观锁</h3><p>乐观锁在并发控制和数据库设计里都拥有重要地位，其本质就是在特定的需求下，假定不会冲突，冲突之后再浪费较长时间处理，比直接每次请求都浪费较短时间检测，总体的性能高。乐观锁在算法领域有着非常丰富而成熟的应用。</p><h3 id=乐观的分布式计算>乐观的分布式计算</h3><p>分布式计算的核心思想就是乐观，由 95% 可靠的 PC 机组成的分布式系统，起可靠性也不会达到 99.99%，但是绝大多数场景下，99% 的可靠性就够了，毕竟拿 PC 机做分布式比小型机便宜得多嘛。下一篇文章我会详细介绍分布式计算的性能之殇，此处不再赘述。</p><h3 id=乐观的代价>乐观的代价</h3><p>乐观给了我们很多的好处，总结起来就是一句话：以微小的性能损失换来大幅的性能提升。但是，人在河边走，哪有不湿鞋。每一个 2015 年 6 月入 A 股的散户，都觉得大盘还能再翻一番，岂不知一周之后，就是股灾了。</p><p>乐观的代价来自于“微小的性能损失”，就跟房贷市场中“微小的风险”一样，当大环境小幅波动的时候，他确实能承担压力，稳住系统，但是怕就怕突然雪崩：</p><ul><li>虚拟内存中的内存的局部性突然大幅失效，磁盘读写速度成了内存读写速度，系统卡死。</li><li>分布式数据库的六台机器中的 master 挂了，系统在一秒内选举出了新的 master，你以为系统会稳定运行？master 挂掉的原因就是压力过大，这样就会导致新的 master 瞬间又被打挂，然后一台一台地继续，服务彻底失效。</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-255f8164756bda67d84bcc9115fac66d>7 - 共同的瓶颈</h1><p>分布式计算是这些年的热门话题，各种大数据框架层出不穷，容器技术也奋起直追，各类数据库（Redis、ELasticsearch、MongoDB）也大搞分布式，可以说是好不热闹。分布式计算在大热的同时，也存在着两台机器也要硬上 Hadoop 的“面向简历编程”，接下来我就剖析一下分布式计算的本质，以及我的理解和体会。</p><h2 id=分布式计算的本质>分布式计算的本质</h2><p>分布式计算来源于人们日益增长的性能需求与落后的 x86 基础架构之间的矛盾。恰似设计模式是面向对象对现实问题的一种妥协。</p><h3 id=x86-服务器>x86 服务器</h3><p>x86 服务器，俗称 PC 服务器、微机服务器，近二十年以迅雷不及掩耳盗铃之势全面抢占了绝大部分的服务器市场，它和小型机比只有一个优势，其他的全是缺点，性能、可靠性、可扩展性、占地面积都不如小型机，但是一个优势就决定了每年 2000 多亿美元的 IDC 市场被 x86 服务器占领了 90%，这个优势就是价格。毕竟有钱能使磨推鬼嘛。</p><p>现有的分布式计算，无论是 Hadoop 之类的大数据平台，还是 HBase 这样的分布式数据库，无论是 Docker 这种容器排布，还是 Redis 这种朴素分布式数据库，其本质都是因为 x86 的扩展性不够好，导致大家只能自己想办法利用网络来自己构建一个宏观上更强性能更高负载能力的计算机。</p><h3 id=分布式计算是一种新的计算机结构>分布式计算，是一种新的计算机结构</h3><p>基于网络的 x86 服务器分布式计算，其本质是把网络当做总线，设计了一套新的计算机体系结构：</p><ul><li>每台机器就等于一个运算器加一个存储器。</li><li>master 节点就是控制器和输入设备、输出设备。</li></ul><h3 id=x86-分布式计算的弱点>x86 分布式计算的弱点</h3><p>上古时代，小型机的扩展能力是非常变态的，到今天，基于小型机的 Oracle 数据库系统依旧能做到惊人的性能和可靠性。实际上单颗 x86 CPU 的性能已经远超 IBM 小型机用的 PowerPC，但是当数量来到几百颗，x86 服务器集群就败下阵来，原因也非常简单：</p><ol><li>小型机是专门设计的硬件和专门设计的软件，只面向这种规模（例如几百颗 CPU）的计算。</li><li>小型机是完全闭源的，不需要考虑扩展性，特定的几种硬件在稳定性上前进了一大步。</li><li>x86 的 IO 性能被架构锁死了，各种总线、PCI、PCIe、USB、SATA、以太网，为了个人计算机的便利性，牺牲了很多的性能和可靠性。</li><li>小型机使用总线通信，可以实现极高的信息传递效率，极其有效的监控以及极高的故障隔离速度。</li><li>x86 服务器基于网络的分布式具有天然的缺陷：</li><li>操作系统决定了网络性能不足。</li><li>网络需要使用事件驱动处理，比总线电路的延迟高几个数量级。</li><li>PC 机的硬件不够可靠，故障率高。</li><li>很难有效监控，隔离故障速度慢。</li></ol><h2 id=x86-分布式计算的基本套路>x86 分布式计算的基本套路</h2><h3 id=google-系大数据处理框架>Google 系大数据处理框架</h3><p>2003 年到 2004 年间，Google 发表了 MapReduce、GFS（Google File System）和 BigTable 三篇技术论文，提出了一套全新的分布式计算理论。MapReduce 是分布式计算框架，GFS（Google File System）是分布式文件系统，BigTable 是基于 GFS 的数据存储系统，这三大组件组成了 Google 的分布式计算模型。</p><p>Hadoop、Spark、Storm 是目前最重要的三大分布式计算系统，他们都是承袭 Google 的思路实现并且一步一步发展到今天的。</p><p>MapReduce 的基本原理也十分简单：将可以并行执行的任务切分开来，分配到不同的机器上去处理，最终再汇总结果。而 GFS 是基于 Master-Slave 架构的分布式文件系统，其 master 只扮演控制者的角色，操控着所有的 slave 干活。</p><h3 id=redismongodb-的分布式>Redis/MongoDB 的分布式</h3><p>Redis 有两个不同的分布式方案。Redis Cluster 是官方提供的工具，它通过特殊的协议，实现了每台机器都拥有数据存储和分布式调节功能，性能没有损失。缺点就是缺乏统一管理，运维不友好。Codis 是一个非常火的 Redis 集群搭建方案，其基本原理可以简单地描述如下：通过一个 proxy 层，完全隔离掉了分布式调节功能，底层的多台机器可以任意水平扩展，运维十分友好。</p><p>MongoDB 官方提供了一套完整的分布式部署的方案，提供了 mongos 控制中心，config server 配置存储，以及众多的 shard（其底层一般依然有两台互为主从强数据一致性的 mongod）。这三个组件可以任意部署在任意的机器上，MongoDB 提供了 master 选举功能，在检测到 master 异常后会自动选举出新的 master 节点。</p><h2 id=问题和瓶颈>问题和瓶颈</h2><p>人们费这么大的劲研究基于网络的 x86 服务器分布式计算，目的是什么？还不是为了省钱，想用一大票便宜的 PC 机替换掉昂贵的小型机、大型机。虽然人们已经想尽了办法，但还是有一些顽固问题无法彻底解决。</p><h3 id=master-失效问题>master 失效问题</h3><p>无论怎样设计，master 失效必然会导致服务异常，因为网络本身不够可靠，所以监控系统的容错要做的比较高，所以基于网络的分布式系统的故障恢复时间一般在秒级。而小型机的单 CPU 故障对外是完全无感的。</p><p>现行的选举机制主要以节点上的数据以及节点数据之间的关系为依据，通过一顿猛如虎的数学操作，选举出一个新的 master。逻辑上，选举没有任何问题，如果 master 因为硬件故障而失效，新的 master 会自动顶替上，并在短时间内恢复工作。</p><p>而自然界总是狠狠地打人类的脸：</p><ol><li>硬件故障概率极低，大部分 master 失效都不是因为硬件故障。</li><li>如果是流量过大导致的 master 失效，那么选举出新的 master 也无济于事：提升集群规模才是解决之道。</li><li>即使能够及时地在一分钟之内顶替上 master 的工作，那这一分钟的异常也可能导致雪崩式的 cache miss，从磁盘缓存到虚拟内存，从 TLB 到三级缓存，再到二级缓存和一级缓存，全部失效。如果每一层的失效会让系统响应时间增加五倍的话，那最终的总响应时长将是惊人的。</li></ol><h3 id=系统规模问题>系统规模问题</h3><p>无论是 Master-Slave 模式还是 Proxy 模式，整个系统的流量最终还是要落到一个特定的资源上。当然这个资源可能是多台机器，但是依旧无法解决一个严重的问题：系统规模越大，其本底性能损失就越大。</p><p>这其实是我们所在的这个宇宙空间的一个基本规律。我一直认为，这个宇宙里只有一个自然规律：熵增。既然我们这个宇宙是一个熵增宇宙，那么这个问题就无法解决。</p><h2 id=超级计算机>超级计算机</h2><p>超级计算机可以看成一个规模特别巨大的分布式计算系统，他的性能瓶颈从目前的眼光来看，是超多计算核心（数百万）的调节效率问题。其本质是通信速率不够快，信息传递的太慢，让数百万核心一起工作，传递命令和数据的工作占据了绝大多数的运行时间。</p><h2 id=神经网络>神经网络</h2><p>深度学习这几年大火，其原因就是卷积神经网络（CNN）造就的 AlphaGo 打败了人类，计算机在这个无法穷举的游戏里彻底赢了。伴随着 Google 帝国的强大推力，深度学习，机器学习，乃至人工智能，这几个词在过去的两年大火，特别是在中美两国。现在拿手机拍张照背后都有机器学习你敢信？</p><p>机器学习的瓶颈，本质也是数据交换：机器学习需要极多的计算，而计算速度的瓶颈现在就在运算器和存储器的通信上，这也是显卡搞深度学习比 CPU 快数十倍的原因：显存和 GPU 信息交换的速度极快。</p><h2 id=九九归一>九九归一</h2><p>分布式系统的性能问题，表现为多个方面，但是归根到底，其原因只是一个非常单纯的矛盾：人们日益增长的性能需求和数据一致性之间的矛盾。一旦需要强数据一致性，那就必然存在一个限制速度的瓶颈，这个瓶颈就是信息传递的速度决定的。</p><p>同样，超级计算机和神经网络的瓶颈也都是信息传递的速度。</p><h3 id=那么信息传递速度的瓶颈在哪里呢>那么，信息传递速度的瓶颈在哪里呢？</h3><p>我个人认为，信息传递的瓶颈最表层是人类的硬件制造水平决定的，再往底层去是冯·诺依曼架构决定的，再往底层去是图灵机的逻辑模型决定的。可是图灵机是计算机可行的理论基础呀，所以，还是怪这个熵增宇宙吧，为什么规模越大维护成本越高呢，你也是个成熟的宇宙了，该学会自己把自己变成熵减宇宙了。</p></div></main></div></div><footer class="bg-dark py-5 row d-print-none"><div class="container-fluid mx-sm-5"><div class=row><div class="col-6 col-sm-4 text-xs-center order-sm-2"></div><div class="col-6 col-sm-4 text-right text-xs-center order-sm-3"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=GitHub aria-label=GitHub><a class=text-white target=_blank rel="noopener noreferrer" href=https://github.com/infilos><i class="fab fa-github"></i></a></li></ul></div><div class="col-12 col-sm-4 text-center py-2 order-sm-2"><small class=text-white>&copy; 2022 infilos.com All Rights Reserved</small></div></div></div></footer></div><script src=/js/popper.min.js integrity=sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49 crossorigin=anonymous></script>
<script src=/js/bootstrap.min.js integrity=sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy crossorigin=anonymous></script>
<script src=/js/main.min.7d5b92c4889cf0554b0ea5e2309b0b81b196aa7c9a235632938a25d9fc4d8a7c.js integrity="sha256-fVuSxIic8FVLDqXiMJsLgbGWqnyaI1Yyk4ol2fxNinw=" crossorigin=anonymous></script></body></html>