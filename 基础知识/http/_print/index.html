<!doctype html><html lang=zh class=no-js>
<head>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=generator content="Hugo 0.88.1">
<meta name=ROBOTS content="INDEX, FOLLOW">
<link rel=canonical type=text/html href=/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/http/>
<link rel="shortcut icon" href=/favicons/favicon.ico>
<link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180>
<link rel=icon type=image/png href=/favicons/favicon-16x16.png sizes=16x16>
<link rel=icon type=image/png href=/favicons/favicon-32x32.png sizes=32x32>
<link rel=icon type=image/png href=/favicons/android-36x36.png sizes=36x36>
<link rel=icon type=image/png href=/favicons/android-48x48.png sizes=48x48>
<link rel=icon type=image/png href=/favicons/android-72x72.png sizes=72x72>
<link rel=icon type=image/png href=/favicons/android-96x96.png sizes=96x96>
<link rel=icon type=image/png href=/favicons/android-144x144.png sizes=144x144>
<link rel=icon type=image/png href=/favicons/android-192x192.png sizes=192x192>
<title>HTTP | infilos.com</title><meta property="og:title" content="HTTP">
<meta property="og:description" content="Infilos Wiki Website">
<meta property="og:type" content="website">
<meta property="og:url" content="/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/http/"><meta property="og:site_name" content="infilos.com">
<meta itemprop=name content="HTTP">
<meta itemprop=description content="Infilos Wiki Website"><meta name=twitter:card content="summary">
<meta name=twitter:title content="HTTP">
<meta name=twitter:description content="Infilos Wiki Website">
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga('create','UA-123062585-1','auto'),ga('send','pageview'))</script>
<script async src=https://www.google-analytics.com/analytics.js></script>
<link rel=preload href=/scss/main.min.847464b684a6e89d7276700a5c500c17ab494dd1755b2654a7b27d8b59e3347e.css as=style>
<link href=/scss/main.min.847464b684a6e89d7276700a5c500c17ab494dd1755b2654a7b27d8b59e3347e.css rel=stylesheet integrity>
<script src=/js/jquery-3.5.1.min.js integrity="sha256-9/aliU8dGd2tb6OSsuzixeV4y/faTqgFtohetphbbj0=" crossorigin=anonymous></script>
<link rel=stylesheet href=https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.css>
</head>
<body class=td-section>
<header>
<nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-column flex-md-row td-navbar">
<a class=navbar-brand href=/>
<span class=navbar-logo><svg id="Capa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 512 512" style="enable-background:new 0 0 512 512"><path style="fill:#ffc107" d="M432.384 143.616c-4.165-4.164-10.917-4.164-15.083.0l-60.352 60.352c-4.164 4.165-4.164 10.917.0 15.083 21.187 20.463 54.951 19.876 75.413-1.311 19.962-20.668 19.962-53.435.0-74.102L432.384 143.616z"/><path style="fill:#607d8b" d="M42.667 277.334c-5.891.003-10.669-4.771-10.672-10.662-.002-4.338 2.623-8.245 6.64-9.882l234.667-96c5.455-2.233 11.687.38 13.92 5.835s-.38 11.687-5.835 13.92l-234.667 96C45.433 277.069 44.056 277.337 42.667 277.334z"/><path style="fill:#546e7a" d="M391.552 56.448l-32-32C343.938 8.745 322.689-.059 300.544.0h-3.755c-46.082.024-83.432 37.374-83.456 83.456v3.755c-.053 22.138 8.75 43.377 24.448 58.987l32 32c4.165 4.164 10.917 4.164 15.083.0L391.531 71.531C395.701 67.372 395.71 60.62 391.552 56.448z"/><path style="fill:#607d8b" d="M160 469.334c-3.279.006-6.379-1.497-8.405-4.075L34.261 315.926c-3.635-4.636-2.823-11.341 1.813-14.976s11.341-2.823 14.976 1.813l117.333 149.333c3.629 4.641 2.809 11.344-1.832 14.973C164.681 468.533 162.375 469.329 160 469.334z"/><path style="fill:#455a64" d="M487.467 86.848l-3.669-3.648c-37.687-36.557-97.71-36.197-134.955.811l-51.413 51.413c-36.996 37.25-37.357 97.263-.811 134.955l3.584 3.669c1.7 2.457 4.671 3.706 7.616 3.2 2.831.005 5.548-1.115 7.552-3.115l172.181-172.181c4.189-4.143 4.226-10.896.083-15.085-.028-.028-.055-.056-.083-.083L487.467 86.848z"/><g><path style="fill:#ffc107" d="M501.333 192H480c-5.891.0-10.667-4.776-10.667-10.667s4.776-10.667 10.667-10.667h21.333c5.891.0 10.667 4.776 10.667 10.667S507.225 192 501.333 192z"/><path style="fill:#ffc107" d="M394.667 298.667c-5.891.0-10.667-4.776-10.667-10.667v-21.333c0-5.891 4.776-10.667 10.667-10.667 5.891.0 10.667 4.776 10.667 10.667V288C405.333 293.891 400.558 298.667 394.667 298.667z"/><path style="fill:#ffc107" d="M480 277.334c-2.831.005-5.548-1.115-7.552-3.115l-21.333-21.333c-4.093-4.237-3.975-10.99.262-15.083 4.134-3.993 10.687-3.993 14.821.0l21.333 21.333c4.159 4.172 4.148 10.926-.024 15.085C485.514 276.209 482.815 277.327 480 277.334z"/></g><g><path style="fill:#455a64" d="M266.667 448H96c-29.455.0-53.333 23.878-53.333 53.333.0 5.891 4.776 10.667 10.667 10.667h256c5.891.0 10.667-4.776 10.667-10.667C320 471.878 296.122 448 266.667 448z"/><circle style="fill:#455a64" cx="32" cy="288" r="32"/></g><g/><g/><g/><g/><g/><g/><g/><g/><g/><g/><g/><g/><g/><g/><g/></svg></span><span class=font-weight-bold>infilos.com</span>
</a>
<div class="collapse navbar-collapse" id=navbarSupportedContent>
<ul class="navbar-nav mr-auto">
<li class="nav-item dropdown" style=max-width:90px;min-width:10px>
<a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>
基础
<span>+</span>
</a>
<div class=dropdown-menu aria-labelledby=navbarDropdown>
<a class=dropdown-item href=/%e5%9f%ba%e7%a1%80%e7%9f%a5%e8%af%86/%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f>操作系统</a>
<a class=dropdown-item href=/%e5%9f%ba%e7%a1%80%e7%9f%a5%e8%af%86/%e6%80%a7%e8%83%bd%e4%b9%8b%e6%ae%87>性能之殇</a>
<a class=dropdown-item href=/%e5%9f%ba%e7%a1%80%e7%9f%a5%e8%af%86/io%e6%a8%a1%e5%9e%8b>IO 模型</a>
<a class=dropdown-item href=/%e5%9f%ba%e7%a1%80%e7%9f%a5%e8%af%86/%e7%bd%91%e7%bb%9c%e5%9f%ba%e7%a1%80>网络基础</a>
<a class=dropdown-item href=/%e5%9f%ba%e7%a1%80%e7%9f%a5%e8%af%86/tcp-ip>TCP-IP</a>
<a class=dropdown-item href=/%e5%9f%ba%e7%a1%80%e7%9f%a5%e8%af%86/http>HTTP</a>
</div>
</li>
<li class="nav-item dropdown" style=max-width:90px;min-width:10px>
<a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>
语言
<span>+</span>
</a>
<div class=dropdown-menu aria-labelledby=navbarDropdown>
<a class=dropdown-item href=/%e7%bc%96%e7%a8%8b%e8%af%ad%e8%a8%80/java>Java 编程</a>
<a class=dropdown-item href=/%e7%bc%96%e7%a8%8b%e8%af%ad%e8%a8%80/jvm-core>JVM 核心</a>
<a class=dropdown-item href=/%e7%bc%96%e7%a8%8b%e8%af%ad%e8%a8%80/jvm-concurrent>JVM 并发</a>
<a class=dropdown-item href=/%e7%bc%96%e7%a8%8b%e8%af%ad%e8%a8%80/scala>Scala 编程</a>
</div>
</li>
<li class="nav-item dropdown" style=max-width:90px;min-width:10px>
<a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>
框架库
<span>+</span>
</a>
<div class=dropdown-menu aria-labelledby=navbarDropdown>
<a class=dropdown-item href=/%e6%a1%86%e6%9e%b6%e4%b8%8e%e5%ba%93/spring>Spring</a>
<a class=dropdown-item href=/%e6%a1%86%e6%9e%b6%e4%b8%8e%e5%ba%93/hikari>Hikari</a>
<a class=dropdown-item href=/%e6%a1%86%e6%9e%b6%e4%b8%8e%e5%ba%93/parboiled>Parboiled</a>
</div>
</li>
<li class="nav-item dropdown" style=max-width:90px;min-width:10px>
<a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>
分布式
<span>+</span>
</a>
<div class=dropdown-menu aria-labelledby=navbarDropdown>
<a class=dropdown-item href=/%e5%88%86%e5%b8%83%e5%bc%8f/base>基本构成</a>
</div>
</li>
<li class="nav-item dropdown" style=max-width:90px;min-width:10px>
<a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>
大数据
<span>+</span>
</a>
<div class=dropdown-menu aria-labelledby=navbarDropdown>
<a class=dropdown-item href=/%e5%ad%98%e5%82%a8%e7%b3%bb%e7%bb%9f>存储系统</a>
<a class=dropdown-item href=/%e6%9f%a5%e8%af%a2%e7%b3%bb%e7%bb%9f>查询系统</a>
<a class=dropdown-item href=/%e6%b6%88%e6%81%af%e7%b3%bb%e7%bb%9f>消息系统</a>
<a class=dropdown-item href=/%e5%a4%84%e7%90%86%e7%b3%bb%e7%bb%9f>处理系统</a>
<a class=dropdown-item href=/%e7%ae%a1%e7%90%86%e7%b3%bb%e7%bb%9f>管理系统</a>
</div>
</li>
<li class="nav-item dropdown" style=max-width:90px;min-width:10px>
<a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>
中后台
<span>+</span>
</a>
<div class=dropdown-menu aria-labelledby=navbarDropdown>
<a class=dropdown-item href=/%e5%9f%ba%e7%a1%80%e8%ae%be%e6%96%bd>基础设施</a>
<a class=dropdown-item href=/%e4%ba%a4%e4%ba%92%e7%95%8c%e9%9d%a2>交互界面</a>
<a class=dropdown-item href=/%e4%b8%9a%e5%8a%a1%e7%b3%bb%e7%bb%9f>业务系统</a>
</div>
</li>
<li class="nav-item dropdown" style=max-width:90px;min-width:10px>
<a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>
模式架构
<span>+</span>
</a>
<div class=dropdown-menu aria-labelledby=navbarDropdown>
<a class=dropdown-item href=/%e6%a8%a1%e5%bc%8f%e6%9e%b6%e6%9e%84/design-pattern>设计模式</a>
<a class=dropdown-item href=/%e6%a8%a1%e5%bc%8f%e6%9e%b6%e6%9e%84/micro-service>微服务架构</a>
</div>
</li>
<li class=nav-item style=max-width:90px;min-width:10px>
<a class=nav-link href=/%e9%9d%a2%e8%af%95%e9%97%ae%e7%ad%94>
<span>面试</span>
</a>
</li>
<li class=nav-item style=max-width:90px;min-width:10px>
<a class=nav-link href=/%e7%ae%a1%e7%90%86%e8%b7%af%e5%be%84>
<span>管理</span>
</a>
</li>
<li class=nav-item style=max-width:90px;min-width:10px>
<a class=nav-link href=/%e5%bc%80%e6%ba%90%e9%a1%b9%e7%9b%ae>
<span>开源</span>
</a>
</li>
</ul>
<div class="form-inline my-2 my-lg-0">
<div class="nav-item nav-search-item my-2 my-md-0">
<input type=search class="form-control td-search-input" placeholder="&#xf002; 站内搜索…" aria-label=站内搜索… autocomplete=off>
</div>
</div>
</div>
</nav>
</header>
<div class="container-fluid td-outer">
<div class=td-main>
<div class="row flex-xl-nowrap">
<div class="col-12 col-md-3 col-xl-2 td-sidebar d-print-none">
</div>
<div class="d-none d-xl-block col-xl-2 td-toc d-print-none">
</div>
<main class="col-12 col-md-9 col-xl-8 pl-md-5" role=main>
<div class=td-content>
<div class="pageinfo pageinfo-primary d-print-none">
<p>
这是本节的多页打印视图。
<a href=# onclick="return print(),!1">点击此处打印</a>.
</p><p>
<a href=/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/http/>返回本页常规视图</a>.
</p>
</div>
<h1 class=title>HTTP</h1>
<ul>
<li>1: <a href=#pg-ba3a2142a28aeb9c71dcbf441b6c5d61>HTTP 概述</a></li>
<li>2: <a href=#pg-f5c77c7841949e1aa4080a8500b54dc8>URL 与资源</a></li>
<li>3: <a href=#pg-3f9e6e84aa6b28fde606994de099bc1b>HTTP 报文</a></li>
<li>4: <a href=#pg-99925a267a45bd0c179d4c1f7c667768>连接管理</a></li>
<li>5: <a href=#pg-7a1e106ccc9be0b15fab7e1aaaadb524>性能探索</a></li>
</ul>
<div class=content>
</div>
</div>
<div class=td-content>
<h1 id=pg-ba3a2142a28aeb9c71dcbf441b6c5d61>1 - HTTP 概述</h1>
<h2 id=http---因特网的多媒体信使>HTTP - 因特网的多媒体信使</h2>
<p>HTTP 使用的是可靠的数据传输协议，能够保证数据在传输过程中不会被损坏或产生混乱。</p>
<h2 id=web客户端和服务器>Web客户端和服务器</h2>
<p>Web 内容都是存在 Web 服务器上，Web 服务器使用的是 HTTP 协议，因此也称为 HTTP 服务器。</p>
<p>HTTP 客户端，例如浏览器向 HTTP 服务器发送请求，服务器在 HTTP 响应中会送所请求的数据。</p>
<h2 id=资源>资源</h2>
<p>Web 服务器是 Web 资源的宿主。Web 资源是 Web 内容的源头。</p>
<p>资源可以是静态文件，如：文本文件、HTML文件、word文件、JPEG文件、AVI文件等等。也可以是根据需要生成内容的软件程序。</p>
<h3 id=媒体类型>媒体类型</h3>
<p>HTTP 为因特网上数千种不同的数据类型都打上了名为 MIME 类型（MIME type）的数据格式标签。</p>
<p>Web 服务器会为所有 HTTP 对象数据附加一个 MIME 类型。Web 客户端从服务器取回一个对象时会查看相关的 MIME 类型以决定如何处理这个对象。</p>
<p>MIME 类型是一种文本标记，表示一种主要的对象类型和一个特定的子类型，中间由一个斜杠分割。</p>
<ul>
<li><code>text/html</code>：HTML 格式的文本文档</li>
<li><code>text/plain</code>：普通的 ASCII 文本文档</li>
<li><code>image/jpeg</code>：JPEG 格式的图片</li>
<li><code>image/gif</code>：GIF 格式的图片</li>
<li><code>video/quicktime</code>：Apple 的 QuickTime 电影</li>
<li><code>application/vnd.ms-powerpoint</code>：微软的 PowerPoint 演示文件</li>
<li>&mldr;.</li>
</ul>
<h3 id=uri>URI</h3>
<p>每个 Web 服务器资源都有一个名字，称为 <strong>统一资源标识符</strong>。
URI 有两种形式：URL 和 URN。</p>
<h3 id=url>URL</h3>
<p><strong>统一资源定位符</strong>，即 URL，是资源标识符最常见的形式，描述了一台特定服务器上某资源的特定位置。</p>
<p>URL 基本都遵循一种标准格式，即由三部分组成：</p>
<ul>
<li>第一部分：<strong>方案</strong>，说明了资源使用的协议类型，通常是 HTTP 协议(http://)。</li>
<li>第二部分：服务器的因特网地址，比如：www.joes.com 。</li>
<li>第三部分：其余部分指定了 Web 服务器上的某个资源，比如：/pictures/image.gif 。</li>
</ul>
<p>现在几乎所有的 URI 都是 URL。</p>
<h3 id=urn>URN</h3>
<p>URI 的第二种形式是<strong>统一资源名</strong>，即 URN。作为特定内容的唯一名称使用，与目前的资源所在地无关。无论这个资源位于何处，都可以使用多种协议，仅通过名字就能访问该资源。</p>
<h2 id=事务>事务</h2>
<p>一个 HTTP 事务由一条请求命令和一个响应结果组成。这种通信是通过名为 HTTP 报文的格式化数据块进行的。</p>
<h3 id=方法>方法</h3>
<p>HTTP 支持集中不同的请求命令，这些命令被称为 HTTP 方法，该方法告诉服务器要执行什么动作。</p>
<table>
<thead>
<tr>
<th style=text-align:left>HTTP方法</th>
<th style=text-align:left>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style=text-align:left>GET</td>
<td style=text-align:left>从服务器向客户端发送命名资源</td>
</tr>
<tr>
<td style=text-align:left>PUT</td>
<td style=text-align:left>将来自客户端的数据存储到一个命名的服务器资源中去</td>
</tr>
<tr>
<td style=text-align:left>DELETE</td>
<td style=text-align:left>从服务器中删除命名资源</td>
</tr>
<tr>
<td style=text-align:left>POST</td>
<td style=text-align:left>将客户端数据发送到一个服务器网关应用程序</td>
</tr>
<tr>
<td style=text-align:left>HEAD</td>
<td style=text-align:left>仅发送命名资源响应中的HTTP首部</td>
</tr>
</tbody>
</table>
<h3 id=状态码>状态码</h3>
<p>每条 HTTP 响应报文都会携带一个状态码。是一个三位数字，以告诉客户端请求是否成功，或者是否要采取其他动作。</p>
<p>伴随每个状态码，还会有一条<strong>原因短语</strong>，对状态码进行描述。</p>
<h2 id=报文>报文</h2>
<p>HTTP 报文有多行简单的字符串组成。都是纯文本。对应请求和响应分为<strong>请求报文</strong>和<strong>响应报文</strong>。</p>
<p>HTTP 报文的三个部分：</p>
<ul>
<li>起始行：即报文第一行，在请求报文中说明要做什么，在响应报文中说明出现了什么情况；</li>
<li>首部字段：起始行后面有零个或多个首部字段。每个首部字段包含一个名字和一个值，使用冒号分割。以一个空行结束；</li>
<li>主体：空行之后就是可选的报文主体，包含了所有类型的数据。起始行与首部字段都是结构化的文本，而主体中可以包含任意的二进制数据，或者文本。</li>
</ul>
<h2 id=连接>连接</h2>
<h3 id=tcpip>TCP/IP</h3>
<p>HTTP 是一个应用层协议，无需操心网络通信的具体细节，它把联网的细节都交给了因特网传输协议 TCP/IP。</p>
<p>TCP提供了：</p>
<ol>
<li>无差错的数据传输；</li>
<li>按序传输，数据总是按照顺序到达；</li>
<li>为分段的数据流，可以在任意时刻以任意尺寸将数据发送出去。</li>
</ol>
<h3 id=连接ip地址及端口号>连接、IP地址及端口号</h3>
<p>HTTP 客户端需要使用**网际协议(Internet Protocol, IP)**地址和端口号在客户端和服务器之间建立一条TCP连接。</p>
<h2 id=web的结构组件>Web的结构组件</h2>
<ul>
<li>代理：位于客户端和服务器之间的 HTTP 中间实体；</li>
<li>缓存：HTTP 的仓库，使常用页面的副本能够保存在离客户端更近的地方；</li>
<li>网关：连接其他应用程序的特殊 Web 服务器；</li>
<li>隧道：对 HTTP 通信报文进行盲转发的特殊代理；</li>
<li>Agent 代理：发起自动 HTTP 请求的半智能 Web 客户端。</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-f5c77c7841949e1aa4080a8500b54dc8>2 - URL 与资源</h1>
<p>URL 就是因特网资源的标准化名称。URL 指向一条电子信息片段，告诉你它们位于何处，以及如何与之交互。</p>
<h2 id=浏览因特网资源>浏览因特网资源</h2>
<p>URI 是一个更通用的概念，由两个主要的子集 URL 和 URN 构成，URL 是通过描述资源的位置来标识资源，URN 是通过名字来标识资源，与资源的位置无关。</p>
<p>HTTP 规范将更通用的概念 URI作为其资源标示符，但实际上，HTTP 应用程序处理的只是 URI 的子集 URL。</p>
<p>URL 由三部分构成：方案(协议)、服务器位置、资源路径。</p>
<p>URL 为应用程序提供了一种访问资源的手段。定义了用户所需的资源以及如何获取它。</p>
<h2 id=url的语法>URL的语法</h2>
<p>根据方案的不同，URL 语法会随之变化，但大部分都建立在由 9 部分构成的同样格式上：</p>
<pre><code>&lt;scheme&gt;://&lt;user&gt;:&lt;password&gt;@&lt;host&gt;:&lt;port&gt;/&lt;path&gt;;&lt;params&gt;?&lt;query&gt;#&lt;frag&gt;
</code></pre>
<p>几乎没有哪个 URL 完整包含了这 9 部分，其中最主要的就是<strong>方案、主机、路径。</strong></p>
<p>通用 URL 组件总结：</p>
<table>
<thead>
<tr>
<th style=text-align:left>组件</th>
<th style=text-align:left>描述</th>
<th style=text-align:left>默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td style=text-align:left>方案</td>
<td style=text-align:left>访问服务器以获取资源时要使用哪种协议</td>
<td style=text-align:left>无</td>
</tr>
<tr>
<td style=text-align:left>用户</td>
<td style=text-align:left>某些方案访问资源时需要的用户名</td>
<td style=text-align:left>匿名</td>
</tr>
<tr>
<td style=text-align:left>密码</td>
<td style=text-align:left>用户名后面可能要包含的密码，中间由冒号(:)分割</td>
<td style=text-align:left>&lt;E-mail 地址></td>
</tr>
<tr>
<td style=text-align:left>主机</td>
<td style=text-align:left>资源宿主服务器的主机名或点分IP地址</td>
<td style=text-align:left>无</td>
</tr>
<tr>
<td style=text-align:left>端口</td>
<td style=text-align:left>资源宿主服务器正在监听的端口号。很多方案有默认的端口号，比如HTTP为80</td>
<td style=text-align:left>每个方案特有</td>
</tr>
<tr>
<td style=text-align:left>路径</td>
<td style=text-align:left>服务器上资源的本地名，由一个斜杠(/)将其与前面的URL组件分割</td>
<td style=text-align:left>无</td>
</tr>
<tr>
<td style=text-align:left>参数</td>
<td style=text-align:left>某些方案会使用这个组件来指定输入参数，参数为名/值对，URL 中可以包含多个参数字段,它们相互之间以及与路径 的其余部分之间用分号(;)分隔</td>
<td style=text-align:left>无</td>
</tr>
<tr>
<td style=text-align:left>查询</td>
<td style=text-align:left>某些方案会用这个组件传递参数以激活应用程序，查询组 件的内容没有通用格式。 用字符“?”将其与 URL 的其余 部分分隔开来</td>
<td style=text-align:left>无</td>
</tr>
<tr>
<td style=text-align:left>片段</td>
<td style=text-align:left>一小片或一部分资源的名字，引用对象时, 不会将 frag 字 段传送给服务器;这个字段是在客户端内部使用的。 通过 字符“#”将其与 URL 的其余部分分隔开来</td>
<td style=text-align:left>无</td>
</tr>
</tbody>
</table>
<h3 id=方案---使用什么协议>方案 - 使用什么协议</h3>
<p><strong>方案</strong>是规定如何访问指定资源的主要标识符，告诉负责解析 URL 的应用程序使用什么协议。</p>
<p>方案组件必须以一个字母符号开始，由第一个冒号（:）与 URL 的其他部分分割。大小写无关。</p>
<h3 id=主机与端口>主机与端口</h3>
<p>主机组件标识了因特网上能够访问资源的宿主机器。
端口组件标识了服务器正在监听的网络端口。</p>
<h3 id=用户名和密码>用户名和密码</h3>
<p>有些服务器需要输入用户名和密码才能访问资源，比如 FTP。</p>
<pre><code>ftp://ftp.prep.ai.mit.edu/pub/gnu 
ftp://anonymous@ftp.prep.ai.mit.edu/pub/gnu 
ftp://anonymous:my_passwd@ftp.prep.ai.mit.edu/pub/gnu 
http://joe:joespasswd@www.joes-hardware.com/sales_info.txt
</code></pre>
<ol>
<li>第一个例子并没有用户和密码组件，只有方案、主机、路径。</li>
<li>第二个例子指定了<code>anonymous</code>为用户名。</li>
<li>第三个例子指定了<code>anonymous</code>为用户，<code>my_passwd</code>为密码，中间用冒号(:)分割。</li>
</ol>
<h3 id=路径>路径</h3>
<p>说明了资源位于服务器的什么地方，通常像一个分级的文件系统路径，是服务器定位资源时所需的信息。</p>
<h3 id=参数>参数</h3>
<p><strong>参数</strong>组件，向应用程序提供它们所需的输入参数，以便正确的与服务器进行交互。为应用程序提供了访问资源所需的所有附加信息。</p>
<pre><code>ftp://prep.ai.mit.edu/pub/gnu;type=d
</code></pre>
<p>这个例子中，有一个参数<code>type=d</code>，参数名为<code>type</code>，值为<code>d</code>。</p>
<p>HTTP URL 的路径可以分成若干路径段，每段都可以有自己的参数：</p>
<pre><code>http://www.joes-hardware.com/hammers;sale=false/index.html;graphics=true
</code></pre>
<p>这个例子有两个路径段，<code>hammers</code>和<code>index.html</code>，<code>hammers</code>路径段有参数<code>sale</code>，值为<code>false</code>，<code>index.html</code>路径段有参数<code>graphics</code>，值为<code>true</code>。</p>
<h3 id=查询字符串>查询字符串</h3>
<p>URL 的查询组件和标识网关资源的 URL 路径组件一起被发送给网关资源。由问号(?)与其他组件分割，由一系列“名/值”对构成，个“名/值”对使用<code>&</code>分割。</p>
<pre><code>http://www.joes-hardware.com/inventory-check.cgi?item=12731&amp;color=blue
</code></pre>
<h3 id=片段>片段</h3>
<p>有些资源，比如 HTML，除了资源级别的划分，还可以更进一步的进行划分。为了引用部分资源或资源的一个片段，URL 支持使用<strong>片段</strong>组件来表示一个资源内部的片段。</p>
<p>片段挂在 URL 的最右边，使用<code>#</code>与其他组件分割：</p>
<pre><code>http://www.joes-hardware.com/tools.html#drills
</code></pre>
<p>即引用资源<code>tools.html</code>的一部分，这部分的名字为<code>drills</code>。</p>
<p>HTTP 服务器只处理整个对象，而不是对象的片段，客户端不能将片段传送给服务器。浏览器从服务器获得了整个片段之后，会根据片段来显示你感兴趣的那部分资源。</p>
<h2 id=url快捷方式>URL快捷方式</h2>
<h3 id=相对url>相对URL</h3>
<p>URL 有两种方式：<strong>绝对、相对。</strong></p>
<p>绝对 URL 中包含有访问资源所需的全部信息。相对 URL 必须根据<strong>基础</strong> URL 进行解析，以获取访问资源所需的全部信息。</p>
<p>为保持一组资源的可移植性提供了便捷。</p>
<ol>
<li>基础URL
<ol>
<li>在资源中显式提供</li>
<li>封装资源的基础URL</li>
<li>没有基础URL</li>
</ol>
</li>
<li>解析相对引用</li>
</ol>
<h3 id=自动扩展url>自动扩展URL</h3>
<p>有些浏览器会在用户提交 URL 之后，或者在用户输入的时候尝试自动扩展 URL，以为用户提供便利。</p>
<ul>
<li>主机名扩展</li>
<li>历史扩展</li>
</ul>
<h2 id=各种令人头疼的字符>各种令人头疼的字符</h2>
<h3 id=url字符集>URL字符集</h3>
<p>URL 的设计者将<strong>转义序列</strong>集成到 US-ASCII 字符集，以实现可移植性和完整性。</p>
<h3 id=编码机制>编码机制</h3>
<p>为了避开安全字符集表示法带来的限制，通过一种“转义”表示法来表示不安全的字符，这种转义表示法包含一个百分号(<strong>%</strong>)，后跟<strong>两个</strong>表示字符 ASCII 码的十六进制数，以此来表示不安全的字符。</p>
<p>比如：</p>
<table>
<thead>
<tr>
<th style=text-align:left>字符</th>
<th style=text-align:left>ASCII码</th>
<th style=text-align:left>示例URL</th>
</tr>
</thead>
<tbody>
<tr>
<td style=text-align:left><code>~</code></td>
<td style=text-align:left>126(0x<font color=#ff0000>7E</font>)</td>
<td style=text-align:left><a href=http://www.joes-hardware.com/>http://www.joes-hardware.com/</a><font color=#ff0000>%7E</font>joe</td>
</tr>
<tr>
<td style=text-align:left><code>空格</code></td>
<td style=text-align:left>32(0x<font color=#ff0000>20</font>)</td>
<td style=text-align:left><a href=http://www.joes-hardware.com/more>http://www.joes-hardware.com/more</a><font color=#ff0000>%20</font>tools.html</td>
</tr>
<tr>
<td style=text-align:left><code>%</code></td>
<td style=text-align:left>37(0x<font color=#ff0000>25</font>)</td>
<td style=text-align:left><a href=http://www.joes-hardware.com/100>http://www.joes-hardware.com/100</a><font color=#ff0000>%25</font>satisfaction.html</td>
</tr>
</tbody>
</table>
<h3 id=字符限制>字符限制</h3>
<p>在 URL 中存在一些保留字符具有特殊含义。</p>
<p>这些字符有：<code>%</code>、<code>/</code>、<code>.</code>、<code>..</code>、<code>#</code>、<code>?</code>、<code>;</code>、<code>:</code>、<code>$,+</code>、<code>@ & =</code>、<code>{}|\^~[]</code>、<code>&lt;>"</code>、<code>0x00-0x1F, 0x7F</code>、<code>>0x7F</code>。</p>
<h2 id=方案>方案</h2>
<table>
<thead>
<tr>
<th style=text-align:left>方案</th>
<th style=text-align:left>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style=text-align:left>http</td>
<td style=text-align:left>超文本传输协议方案，除了没有用户名和密码之外, 与通用的URL格式相符。端口默认为 80。</td>
</tr>
<tr>
<td style=text-align:left>https</td>
<td style=text-align:left>方案 https 与方案 http 是一对。 唯一的区别在于方案 https 使用了网景的 SSL,SSL 为 HTTP 连接提供了端到端的加密机制。其语法与 HTTP 的语法相同,默认端口为 443。</td>
</tr>
<tr>
<td style=text-align:left>mailto</td>
<td style=text-align:left>Mailto URL 指向的是 E-mail 地址。</td>
</tr>
<tr>
<td style=text-align:left>ftp</td>
<td style=text-align:left>文件传输协议 URL 可以用来从 FTP 服务器上下载或向其上载文件, 并获取 FTP 服务器 上的目录结构内容的列表。</td>
</tr>
<tr>
<td style=text-align:left>rtsp,rtspu</td>
<td style=text-align:left>RTSP URL 是可以通过实时流传输协议(Real Time Streaming Protocol)解析的音 / 视频 媒体资源的标识符。方案 rtspu 中的 u 表示它是使用 UDP 协议来获取资源的。</td>
</tr>
<tr>
<td style=text-align:left>file</td>
<td style=text-align:left>方案 file 表示一台指定主机上可直接访问的文件。</td>
</tr>
<tr>
<td style=text-align:left>news</td>
<td style=text-align:left>根据 RFC 1036 的定义, 方案 news 用来访问一些特定的文章或新闻组。</td>
</tr>
<tr>
<td style=text-align:left>telnet</td>
<td style=text-align:left>用于访问交互式业务。它表示的并不是对象自身，而是可通过 telnet 协议访问的交互式应用程序(资源)。</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-3f9e6e84aa6b28fde606994de099bc1b>3 - HTTP 报文</h1>
<h2 id=报文流>报文流</h2>
<p>HTTP 报文即 HTTP 应用程序之间发送的数据块。以一些文本形式的<strong>元信息</strong>开头以描述报文的内容及含义，后跟可选的数据部分。</p>
<h3 id=报文流入源端服务器>报文流入源端服务器</h3>
<p>**流入(inbound)<strong>和</strong>流出(outbound)<strong>用于描述</strong>事物处理(transaction)**的方向。</p>
<p>首先报文流入源端服务器，工作完成后，会流回用户的 Agent 代理(如浏览器)。</p>
<h3 id=报文向下游流动>报文向下游流动</h3>
<p>所有报文(请求、响应)发送者都在接收者的<strong>上游</strong>，所有报文都会向<strong>下游</strong>流动。</p>
<h2 id=报文的组成部分>报文的组成部分</h2>
<p>HTTP 报文为简单的格式化数据块，包含：起始行、首部、主体。</p>
<p>起始行和首部是由行分割 ASCII 文本。每行都以一个由两个字符组成的终止符作为结束：回车符(ASCII 13)和换行符(ASCII 10)。这个终止序列称为 <strong>CRLF</strong>。</p>
<p>主体是一个可选的数据块，可是是文本或二进制数据，或为空。首部中会给出主体的信息，比如类型或长度。</p>
<h3 id=报文的语法>报文的语法</h3>
<p>所有报文分为两类：请求报文、响应报文。</p>
<p>请求报文格式：</p>
<pre><code>&lt;method&gt; &lt;request-URL&gt; &lt;version&gt; 
&lt;headers&gt;

&lt;entity-body&gt;
</code></pre>
<p>响应报文格式：</p>
<pre><code>&lt;version&gt; &lt;status&gt; &lt;reason-phrase&gt; 
&lt;headers&gt;

&lt;entity-body&gt;
</code></pre>
<ul>
<li>方法：客户端希望服务器对资源执行的操作。</li>
<li>请求 URL：命名了所请求的资源或 URL 路径组件的完整 URL。</li>
<li>版本：报文所使用的 HTTP 版本：<code>HTTP/&lt;major>.&lt;minor></code>。</li>
<li>状态码：这个三位数字描述了请求过程中发生的情况。</li>
<li>原因短语：数字状态码的可读版本，包含行终止序列之前的所有文本。</li>
<li>首部：可以有零个或多个首部。每个首部都包含一个名字, 后面跟着一个冒号(:), 然后是一个可选的空格, 接着是一个值, 最后是一个 CRLF。最后由一个空行 CRLF 结束，表示首部结束，后面是主体。</li>
<li>实体的主体部分：包含一个由任意数据组成的数据块。</li>
</ul>
<h3 id=起始行>起始行</h3>
<p>所有 HTTP 报文都以起始行开始，请求报文中说明<strong>要做什么</strong>，响应报文中说明<strong>发生了什么</strong>。</p>
<ol>
<li>
<p>请求行：请求服务器对资源进行一些操作</p>
</li>
<li>
<p>响应行：承载了状态信息和操作产生的所有结果数据</p>
</li>
<li>
<p>方法：</p>
<table>
<thead>
<tr>
<th style=text-align:left>方法</th>
<th style=text-align:left>描述</th>
<th style=text-align:left>是否包含主体</th>
</tr>
</thead>
<tbody>
<tr>
<td style=text-align:left>GET</td>
<td style=text-align:left>从服务器获取一份文档</td>
<td style=text-align:left>否</td>
</tr>
<tr>
<td style=text-align:left>HEAD</td>
<td style=text-align:left>只从服务器获取文档的首部</td>
<td style=text-align:left>否</td>
</tr>
<tr>
<td style=text-align:left>POST</td>
<td style=text-align:left>向服务器发送需要处理的数据</td>
<td style=text-align:left>是</td>
</tr>
<tr>
<td style=text-align:left>PUT</td>
<td style=text-align:left>将请求的主体部分存储在服务器上</td>
<td style=text-align:left>是</td>
</tr>
<tr>
<td style=text-align:left>TRACE</td>
<td style=text-align:left>对可能经过代理服务器传送到服务器上去的报文进行追踪</td>
<td style=text-align:left>否</td>
</tr>
<tr>
<td style=text-align:left>OPTIONS</td>
<td style=text-align:left>决定可以在服务器上执行哪些方法</td>
<td style=text-align:left>否</td>
</tr>
<tr>
<td style=text-align:left>DELETE</td>
<td style=text-align:left>从服务器上删除一份文档</td>
<td style=text-align:left>否</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>状态码：</p>
<table>
<thead>
<tr>
<th style=text-align:left>整体范围</th>
<th style=text-align:left>已定义范围</th>
<th style=text-align:left>分类</th>
</tr>
</thead>
<tbody>
<tr>
<td style=text-align:left>100 ~ 199</td>
<td style=text-align:left>100 ~ 101</td>
<td style=text-align:left>信息提示</td>
</tr>
<tr>
<td style=text-align:left>200 ~ 299</td>
<td style=text-align:left>200 ~ 206</td>
<td style=text-align:left>成功</td>
</tr>
<tr>
<td style=text-align:left>300 ~ 399</td>
<td style=text-align:left>300 ~ 305</td>
<td style=text-align:left>重定向</td>
</tr>
<tr>
<td style=text-align:left>400 ~ 499</td>
<td style=text-align:left>400 ~ 415</td>
<td style=text-align:left>客户端错误</td>
</tr>
<tr>
<td style=text-align:left>500 ~ 599</td>
<td style=text-align:left>500 ~ 505</td>
<td style=text-align:left>服务端错误</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>原因短语</p>
</li>
<li>
<p>版本号</p>
</li>
</ol>
<h3 id=首部>首部</h3>
<ol>
<li>首部分类
<ol>
<li>通用首部：出现在请求报文、响应报文</li>
<li>请求首部：请求信息</li>
<li>响应首部：响应信息</li>
<li>实体首部：实体信息</li>
<li>扩展首部：尚未定义的新首部</li>
</ol>
</li>
<li>首部延续行：将较长的首部分为多行，多出来的行前使用空格或制表符(Tab)</li>
</ol>
<h3 id=实体的主体部分>实体的主体部分</h3>
<h2 id=方法>方法</h2>
<h3 id=head>HEAD</h3>
<p>与 GET 方法类似，但在响应中只返回首部，不返回主体部分。这允许客户端在未获取实际资源的情况下检查资源：</p>
<ul>
<li>在不获取资源的情况下了解资源</li>
<li>通过查看响应中的状态码判断资源是否存在</li>
<li>通过查看首部，判断资源是否被修改</li>
</ul>
<h3 id=options>OPTIONS</h3>
<p>询问服务器通常支持 哪些方法,或者对某些特殊资源支持哪些方法。</p>
<h2 id=状态码>状态码</h2>
<h3 id=信息状态码>信息状态码</h3>
<table>
<thead>
<tr>
<th style=text-align:left>状态码</th>
<th style=text-align:left>原因短语</th>
<th style=text-align:left>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style=text-align:left>100</td>
<td style=text-align:left>Continue</td>
<td style=text-align:left>说明收到了请求的初始部分,请客户端继续.</td>
</tr>
<tr>
<td style=text-align:left>101</td>
<td style=text-align:left>Switching Protocols</td>
<td style=text-align:left>说明服务器正在根据客户端的指定,将协议切换成Update首部所列的协议</td>
</tr>
</tbody>
</table>
<h3 id=成功状态码>成功状态码</h3>
<table>
<thead>
<tr>
<th style=text-align:left>状态码</th>
<th style=text-align:left>原因短语</th>
<th style=text-align:left>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style=text-align:left>200</td>
<td style=text-align:left>OK</td>
<td style=text-align:left>请求没有问题,实体的主体部分包含了所请求的资源.</td>
</tr>
<tr>
<td style=text-align:left>201</td>
<td style=text-align:left>Created</td>
<td style=text-align:left>用于创建服务器对象的请求(比如PUT),响应体的实体主体部分中应该包含各种引用了已创建资源的URL,Location首部包含的则是最具体的引用.</td>
</tr>
<tr>
<td style=text-align:left>202</td>
<td style=text-align:left>Accepted</td>
<td style=text-align:left>请求已被接受,但服务器还未对其执行任何动作.不能保证服务器会完成这个请求;只表示接受请求时,它看起来是有效的.</td>
</tr>
<tr>
<td style=text-align:left>203</td>
<td style=text-align:left>Non-Authoritative Information</td>
<td style=text-align:left>实体首部包含的信息不是来自于源端服务器,而是来自资源的一个副本.</td>
</tr>
<tr>
<td style=text-align:left>204</td>
<td style=text-align:left>No Content</td>
<td style=text-align:left>响应报文中用于若干首部和一个状态行,但没有实体的主题部分.主要用于在浏览器不转为显示新文档的情况下,对其进行更行.</td>
</tr>
<tr>
<td style=text-align:left>205</td>
<td style=text-align:left>Reset Content</td>
<td style=text-align:left>另一个主要用于浏览器的代码,负责告诉浏览器清除当前页中的所有HTML表单元素.</td>
</tr>
<tr>
<td style=text-align:left>206</td>
<td style=text-align:left>Partial Content</td>
<td style=text-align:left>成功执行了一个部分或Range(范围)请求.</td>
</tr>
</tbody>
</table>
<h3 id=重定向状态码>重定向状态码</h3>
<table>
<thead>
<tr>
<th style=text-align:left>状态码</th>
<th style=text-align:left>原因短语</th>
<th style=text-align:left>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style=text-align:left>300</td>
<td style=text-align:left>Multiple Choices</td>
<td style=text-align:left>客户点请求一个实际指向多个资源的URL时会返回这个状态码,比如服务器上有某个HTML的英语和法语版本.返回这个状态码时会有一个选项列表,这样用户就可以选择他希望使用的那一项了.</td>
</tr>
<tr>
<td style=text-align:left>301</td>
<td style=text-align:left>Moved Permanently</td>
<td style=text-align:left>在请求的URL已被移除时使用.响应的Location首部中应该包含资源现在所处的URL.</td>
</tr>
<tr>
<td style=text-align:left>302</td>
<td style=text-align:left>Found</td>
<td style=text-align:left>与301状态码类似,但是客户端应该使用Location首部给出的URL来临时定位资源.</td>
</tr>
<tr>
<td style=text-align:left>303</td>
<td style=text-align:left>See Other</td>
<td style=text-align:left>告诉客户端应该使用另一个URL来获取资源,新的URL位于响应报文的Location首部.</td>
</tr>
<tr>
<td style=text-align:left>304</td>
<td style=text-align:left>Not Modified</td>
<td style=text-align:left>客户端可以通过所包含的请求首部,使其请求变成有条件的.</td>
</tr>
<tr>
<td style=text-align:left>305</td>
<td style=text-align:left>Use Proxy</td>
<td style=text-align:left>用来说明必须通过一个代理访问资源,代理的位置有Location首部给出.</td>
</tr>
<tr>
<td style=text-align:left>306</td>
<td style=text-align:left>(未使用)</td>
<td style=text-align:left>当前未使用.</td>
</tr>
<tr>
<td style=text-align:left>307</td>
<td style=text-align:left>Temporary Redirect</td>
<td style=text-align:left>与301状态码类似,但是客户端应该使用Location首部给出的URL来临时定位资源.</td>
</tr>
</tbody>
</table>
<h3 id=客户端错误状态码>客户端错误状态码</h3>
<table>
<thead>
<tr>
<th style=text-align:left>状态码</th>
<th style=text-align:left>原因短语</th>
<th style=text-align:left>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style=text-align:left>400</td>
<td style=text-align:left>Bad Request</td>
<td style=text-align:left>用于告诉客户端它发错了一个错误请求.</td>
</tr>
<tr>
<td style=text-align:left>401</td>
<td style=text-align:left>Unauthorized</td>
<td style=text-align:left>与适当的首部一起返回,在这些首部中请求客户端在获取对资源的访问权之前,对自己进行认证.</td>
</tr>
<tr>
<td style=text-align:left>402</td>
<td style=text-align:left>Payment Required</td>
<td style=text-align:left>还未使用,但已保留.</td>
</tr>
<tr>
<td style=text-align:left>403</td>
<td style=text-align:left>Forbidden</td>
<td style=text-align:left>用于说明请求被服务器拒绝了.</td>
</tr>
<tr>
<td style=text-align:left>404</td>
<td style=text-align:left>Not Found</td>
<td style=text-align:left>用于说明服务器无法找到所请求的URL.</td>
</tr>
<tr>
<td style=text-align:left>405</td>
<td style=text-align:left>Method Not Allowed</td>
<td style=text-align:left>发起的请求中带有所请求的URL不支持的方法时,使用此状态码.应该在响应中包含Allow首部,以告诉客户端所请求的资源有哪些可以使用的方法.</td>
</tr>
<tr>
<td style=text-align:left>406</td>
<td style=text-align:left>Not Acceptable</td>
<td style=text-align:left>客户端可以指定参数来说明他们愿意接受什么类型的实体.</td>
</tr>
<tr>
<td style=text-align:left>407</td>
<td style=text-align:left>Proxy Authentication Required</td>
<td style=text-align:left>与401状态码类似,但用于要求对资源进行认证的代理服务器.</td>
</tr>
<tr>
<td style=text-align:left>408</td>
<td style=text-align:left>Request Timeout</td>
<td style=text-align:left>如果客户端完成请求所花的时间太长,服务器可以返回此状态码,并关闭连接.</td>
</tr>
<tr>
<td style=text-align:left>409</td>
<td style=text-align:left>Conflict</td>
<td style=text-align:left>用于说明请求可能在资源上引发一些冲突.</td>
</tr>
<tr>
<td style=text-align:left>410</td>
<td style=text-align:left>Gone</td>
<td style=text-align:left>与401类似,只是服务器曾经拥有该资源.</td>
</tr>
<tr>
<td style=text-align:left>411</td>
<td style=text-align:left>Length Required</td>
<td style=text-align:left>服务器要求在请求报文中包含Content-Length首部.</td>
</tr>
<tr>
<td style=text-align:left>412</td>
<td style=text-align:left>Precondition Failed</td>
<td style=text-align:left>客户端发起了条件请求,且其中一个条件失败了的时候使用.</td>
</tr>
<tr>
<td style=text-align:left>413</td>
<td style=text-align:left>Request Entity Too Large</td>
<td style=text-align:left>客户端发送的实体主体部分比服务器能够或者希望处理的要大时,使用此状态码.</td>
</tr>
<tr>
<td style=text-align:left>414</td>
<td style=text-align:left>Request URI Too Long</td>
<td style=text-align:left>客户端所发请求中的请求URL比服务器能够或希望处理的要大时,使用此状态码.</td>
</tr>
<tr>
<td style=text-align:left>415</td>
<td style=text-align:left>Unsupported Media Type</td>
<td style=text-align:left>服务器无法理解或支持客户端所发实体的内容类型.</td>
</tr>
<tr>
<td style=text-align:left>416</td>
<td style=text-align:left>Requested Range Not Satistiable</td>
<td style=text-align:left>请求报文所请求的是指定资源的某个范围,而此范围无效或无法满足时,使用此状态码.</td>
</tr>
<tr>
<td style=text-align:left>417</td>
<td style=text-align:left>Expectation Failed</td>
<td style=text-align:left>请求的Expect请求首部包含了一起期望,但服务器无法满足此期望.</td>
</tr>
</tbody>
</table>
<h3 id=服务器错误状态码>服务器错误状态码</h3>
<table>
<thead>
<tr>
<th style=text-align:left>状态码</th>
<th style=text-align:left>原因短语</th>
<th style=text-align:left>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style=text-align:left>500</td>
<td style=text-align:left>Internal Server Error</td>
<td style=text-align:left>服务器遇到一个妨碍它为请求提供服务的错误时,使用此代码.</td>
</tr>
<tr>
<td style=text-align:left>501</td>
<td style=text-align:left>Not Implement</td>
<td style=text-align:left>客户端发起的请求超出服务器的能力范围.</td>
</tr>
<tr>
<td style=text-align:left>502</td>
<td style=text-align:left>Bad Gateway</td>
<td style=text-align:left>作为代理或网关使用的服务器从请求响应链的下一条链路上收到了一条伪响应.</td>
</tr>
<tr>
<td style=text-align:left>503</td>
<td style=text-align:left>Service Unavailable</td>
<td style=text-align:left>服务器现在无法为请求提供服务.</td>
</tr>
<tr>
<td style=text-align:left>504</td>
<td style=text-align:left>Gateway Timeout</td>
<td style=text-align:left>与状态码408类似,只是这里的响应来自一个网关或代理,他们在等待另一服务器对其请求进行响应时超时了.</td>
</tr>
<tr>
<td style=text-align:left>505</td>
<td style=text-align:left>HTTP Version Not Supperted</td>
<td style=text-align:left>服务器收到的请求使用了它无法或不愿意支持的协议版本时.</td>
</tr>
</tbody>
</table>
<h2 id=首部-1>首部</h2>
<p>首部和方法配合工作,共同决定了客户端和服务器能做什么事情.</p>
<ul>
<li>通用首部: 客户端和服务器都可以使用的通用首部.可以在客户端或服务器和其他应用程序之间提供一些非常有用的通用功能,提供了报文相关的最基本信息.比如Date首部.</li>
<li>请求首部: 是请求报文特有的.为服务器提供了一些额外信息,比如客户端希望接收什么类型的数据.</li>
<li>响应首部: 响应报文有自己的首部集,以便为客户端提供信息.</li>
<li>实体首部: 指的是用于应对实体主体部分的首部.比如,可以用实体首部来说明实体主体部分的数据类型.</li>
<li>扩展首部: 是非标准的首部,有应用程序开发正创建,但还未添加到已批准的HTTP规范中.</li>
</ul>
<h3 id=通用首部>通用首部</h3>
<table>
<thead>
<tr>
<th style=text-align:left>首部</th>
<th style=text-align:left>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style=text-align:left>Connection</td>
<td style=text-align:left>允许客户端和服务器指定与请求/响应连接有关的选项</td>
</tr>
<tr>
<td style=text-align:left>Date</td>
<td style=text-align:left>提供日期和时间标志,说明报文是什么时间创建的</td>
</tr>
<tr>
<td style=text-align:left>MIME-Version</td>
<td style=text-align:left>给出了发送端使用的 MIME 版本</td>
</tr>
<tr>
<td style=text-align:left>Trailer</td>
<td style=text-align:left>如果报文采用了分块传输编码方式,就可以用这个首部列出位于报文拖挂(trailer)部分的首部集合</td>
</tr>
<tr>
<td style=text-align:left>Transfer-Encoding</td>
<td style=text-align:left>告知接收端为了保证报文的可靠传输,对报文采用了什么编码方式</td>
</tr>
<tr>
<td style=text-align:left>Update</td>
<td style=text-align:left>给出了发送端可能想要“升级”使用的新版本或协议</td>
</tr>
<tr>
<td style=text-align:left>Via</td>
<td style=text-align:left>显示了报文经过的中间节点(代理、网关)</td>
</tr>
</tbody>
</table>
<h4 id=通用缓存首部>通用缓存首部</h4>
<table>
<thead>
<tr>
<th style=text-align:left>首部</th>
<th style=text-align:left>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style=text-align:left>Cache-Control</td>
<td style=text-align:left>用于随报文传送缓存指示</td>
</tr>
<tr>
<td style=text-align:left>Pragma</td>
<td style=text-align:left>另一种随报文传送指示的方式,但并不专用于缓存</td>
</tr>
<tr>
<td style=text-align:left>Connection</td>
<td style=text-align:left>AAAA</td>
</tr>
</tbody>
</table>
<h3 id=请求首部>请求首部</h3>
<p>只在请求报文才有意义的首部.用于说明谁或什么在发送请求,请求源自何处,或者客户端的喜好和能力.服务器可以根据请求首部给出的客户端信息,试着为客户端提供更好的响应.</p>
<table>
<thead>
<tr>
<th style=text-align:left>首部</th>
<th style=text-align:left>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style=text-align:left>Client-IP</td>
<td style=text-align:left>提供了运行客户端的机器的 IP 地址</td>
</tr>
<tr>
<td style=text-align:left>From</td>
<td style=text-align:left>提供了客户端用户的 E-mail 地址</td>
</tr>
<tr>
<td style=text-align:left>Host</td>
<td style=text-align:left>给出了接收请求的服务器的主机名和端口号</td>
</tr>
<tr>
<td style=text-align:left>Referer</td>
<td style=text-align:left>提供了包含当前请求 URI 的文档的 URL</td>
</tr>
<tr>
<td style=text-align:left>UA-Color</td>
<td style=text-align:left>提供了与客户端显示器的显示颜色有关的信息</td>
</tr>
<tr>
<td style=text-align:left>UA-CPU</td>
<td style=text-align:left>给出了客户端 CPU 的类型或制造商</td>
</tr>
<tr>
<td style=text-align:left>UA-Disp</td>
<td style=text-align:left>提供了与客户端显示器(屏幕)能力有关的信息</td>
</tr>
<tr>
<td style=text-align:left>UA-OS</td>
<td style=text-align:left>给出了运行在客户端机器上的操作系统名称及版本</td>
</tr>
<tr>
<td style=text-align:left>UA-Pixels</td>
<td style=text-align:left>提供了客户端显示器的像素信息</td>
</tr>
<tr>
<td style=text-align:left>User-Agent</td>
<td style=text-align:left>将发起请求的应用程序名称告知服务器</td>
</tr>
</tbody>
</table>
<h4 id=accept首部>Accept首部</h4>
<p>Accept首部为客户端提供了一种将喜好和能力告诉服务器的方式.</p>
<table>
<thead>
<tr>
<th style=text-align:left>首部</th>
<th style=text-align:left>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style=text-align:left>Accept</td>
<td style=text-align:left>告诉服务器能够发送那些媒体类型</td>
</tr>
<tr>
<td style=text-align:left>Accept-Charset</td>
<td style=text-align:left>能够发送那些字符集</td>
</tr>
<tr>
<td style=text-align:left>Accept-Encoding</td>
<td style=text-align:left>能够发送哪些编码方式</td>
</tr>
<tr>
<td style=text-align:left>Accept-Language</td>
<td style=text-align:left>能够发送那些语言</td>
</tr>
<tr>
<td style=text-align:left>TE</td>
<td style=text-align:left>能够使用哪些扩展传输编码</td>
</tr>
</tbody>
</table>
<h4 id=条件请求首部>条件请求首部</h4>
<p>有时客户端希望为请求加上某些限制.</p>
<table>
<thead>
<tr>
<th style=text-align:left>首部</th>
<th style=text-align:left>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style=text-align:left>Expect</td>
<td style=text-align:left>允许客户端列出某请求所要求的服务器行为</td>
</tr>
<tr>
<td style=text-align:left>If-Match</td>
<td style=text-align:left>如果实体标记与文档当前的实体标记匹配,就获取这份文档</td>
</tr>
<tr>
<td style=text-align:left>If-Modified-Since</td>
<td style=text-align:left>除非在某个指定的日期之后资源被修改过,否则就限制这个请求</td>
</tr>
<tr>
<td style=text-align:left>If-None-Match</td>
<td style=text-align:left>如果提供的实体标记与当前文档的实体标记不相符,就获取文档</td>
</tr>
<tr>
<td style=text-align:left>If-Range</td>
<td style=text-align:left>允许对文档的某个范围进行条件请求</td>
</tr>
<tr>
<td style=text-align:left>If-Unmodified-Since</td>
<td style=text-align:left>除非在某个指定日期之后资源没有被修改过,否则就限制这个请求</td>
</tr>
<tr>
<td style=text-align:left>Range</td>
<td style=text-align:left>如果服务器支持范围请求,就请求资源的指定范围</td>
</tr>
</tbody>
</table>
<h4 id=安全请求首部>安全请求首部</h4>
<p>HTTP本身就支持一种简单的机制,可以对请求进行质询/响应认证.这种机制要求客户端在获取特定资源之前,相对自身进行认证,这样就可以使事务稍微安全一些.</p>
<table>
<thead>
<tr>
<th style=text-align:left>首部</th>
<th style=text-align:left>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style=text-align:left>Authorization</td>
<td style=text-align:left>包含了客户端提供给服务器,以便对其自身进行认证的数据</td>
</tr>
<tr>
<td style=text-align:left>Cookie</td>
<td style=text-align:left>客户端用它向服务器传送一个令牌——它并不是真正的安全首部,但确实隐含了安全功能</td>
</tr>
<tr>
<td style=text-align:left>Cookie2</td>
<td style=text-align:left>用来说明请求端支持的 cookie 版本</td>
</tr>
</tbody>
</table>
<h4 id=代理请求首部>代理请求首部</h4>
<table>
<thead>
<tr>
<th style=text-align:left>首部</th>
<th style=text-align:left>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style=text-align:left>Max-Forward</td>
<td style=text-align:left>在通往源端服务器的路径上, 将请求转发给其他代理或网关的最大次数——与Trace方法一同使用</td>
</tr>
<tr>
<td style=text-align:left>Proxy-Authorization</td>
<td style=text-align:left>与Authorization首部相同,但这个首部是在与代理进行认证时使用</td>
</tr>
<tr>
<td style=text-align:left>Proxy-Connection</td>
<td style=text-align:left>与 Connection 首部相同,但这个首部是在与代理建立连接时使用的</td>
</tr>
</tbody>
</table>
<h3 id=响应首部>响应首部</h3>
<p>响应报文有自己的响应首部集.为客户端提供了一些额外信息,比如谁在发送响应,响应者的功能,甚至于响应相关的一些特殊指令.这些首部有助于客户端处理响应,并在将来发起更好的请求.</p>
<table>
<thead>
<tr>
<th style=text-align:left>首部</th>
<th style=text-align:left>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style=text-align:left>Age</td>
<td style=text-align:left>(从最初创建开始)响应持续时间</td>
</tr>
<tr>
<td style=text-align:left>Public</td>
<td style=text-align:left>服务器为其资源支持的请求方法列表</td>
</tr>
<tr>
<td style=text-align:left>Retry-After</td>
<td style=text-align:left>如果资源不可用的话,在此日期或时间重试</td>
</tr>
<tr>
<td style=text-align:left>Server</td>
<td style=text-align:left>服务器应用程序软件的名称和版本</td>
</tr>
<tr>
<td style=text-align:left>Title</td>
<td style=text-align:left>对 HTML 文档来说,就是 HTML 文档的源端给出的标题</td>
</tr>
<tr>
<td style=text-align:left>Warning</td>
<td style=text-align:left>比原因短语中更详细一些的警告报文</td>
</tr>
</tbody>
</table>
<h4 id=协商首部>协商首部</h4>
<p>服务器可以用他们来传递与可协商资源有关的信息.</p>
<table>
<thead>
<tr>
<th style=text-align:left>首部</th>
<th style=text-align:left>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style=text-align:left>Accept-Ranges</td>
<td style=text-align:left>对此资源来说,服务器可接受的范围类型</td>
</tr>
<tr>
<td style=text-align:left>Vary</td>
<td style=text-align:left>服务器查看的其他首部的列表,可能会使响应发生变化;也就是说,这是一个首部列表,服务器会根据这些首部的内容挑选出最适合的资源版本发送给客户端</td>
</tr>
</tbody>
</table>
<h4 id=安全响应首部>安全响应首部</h4>
<p>上面已经提到请求端的安全首部,本质上这里说的就是 HTTP 的质询 / 响应认证机制的响应侧.</p>
<table>
<thead>
<tr>
<th style=text-align:left>首部</th>
<th style=text-align:left>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style=text-align:left>Proxy-Authenticate</td>
<td style=text-align:left>来自代理的对客户端的质询列表</td>
</tr>
<tr>
<td style=text-align:left>Set-Cookie</td>
<td style=text-align:left>不是真正的安全首部,但隐含有安全功能;可以在客户端设置一个令牌,以便服务器对客户端进行标识</td>
</tr>
<tr>
<td style=text-align:left>Set-Cookie2</td>
<td style=text-align:left>与 Set-Cookie 类似, RFC 2965 Cookie 定义</td>
</tr>
<tr>
<td style=text-align:left>WWW-Authenticate</td>
<td style=text-align:left>来自服务器的对客户端的质询列表</td>
</tr>
</tbody>
</table>
<h3 id=实体首部>实体首部</h3>
<p>有很多首部可以用来描述HTTP报文的负荷.由于请求和响应报文中都可能包含实体部分,所以在这两种类型的报文中都可能出现这些首部.</p>
<p>实体首部提供了有关实体及其内容的大量信息,从有关对象类型的信息,到能够对资源使用的各种有效的请求方法.总之,实体首部可以告知报文的接收者它在对什么进行处理.</p>
<table>
<thead>
<tr>
<th style=text-align:left>首部</th>
<th style=text-align:left>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style=text-align:left>Allow</td>
<td style=text-align:left>列出了可以对此实体执行的请求方法</td>
</tr>
<tr>
<td style=text-align:left>Location</td>
<td style=text-align:left>告知客户端实体实际上位于何处;用于将接收端定向到资源的(可能是新的)位置(URL)上去</td>
</tr>
</tbody>
</table>
<h4 id=内容首部>内容首部</h4>
<p>提供了与实体内容有关的特定信息,说明了其类型,尺寸以及处理它需要的其他有用信息.</p>
<table>
<thead>
<tr>
<th style=text-align:left>首部</th>
<th style=text-align:left>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style=text-align:left>Content-Base</td>
<td style=text-align:left>解析主体中的相对 URL 时使用的基础URL</td>
</tr>
<tr>
<td style=text-align:left>Content-Encoding</td>
<td style=text-align:left>对主体执行的任意编码方式</td>
</tr>
<tr>
<td style=text-align:left>Content-Language</td>
<td style=text-align:left>理解主体时最适宜使用的自然语言</td>
</tr>
<tr>
<td style=text-align:left>Content-Length</td>
<td style=text-align:left>主体的长度或尺寸</td>
</tr>
<tr>
<td style=text-align:left>Content-Location</td>
<td style=text-align:left>资源实际所处的位置</td>
</tr>
<tr>
<td style=text-align:left>Content-MD5</td>
<td style=text-align:left>主体的 MD5 校验和</td>
</tr>
<tr>
<td style=text-align:left>Content-Range</td>
<td style=text-align:left>在整个资源中此实体表示的字节范围</td>
</tr>
<tr>
<td style=text-align:left>Content-Type</td>
<td style=text-align:left>这个主体的对象类型</td>
</tr>
</tbody>
</table>
<h4 id=实体缓存首部>实体缓存首部</h4>
<p>通过缓存首部说明了如何或什么时候进行缓存.</p>
<table>
<thead>
<tr>
<th style=text-align:left>首部</th>
<th style=text-align:left>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style=text-align:left>ETag</td>
<td style=text-align:left>与此实体相关的实体标记</td>
</tr>
<tr>
<td style=text-align:left>Expires</td>
<td style=text-align:left>实体不再有效,要从原始的源端再次获取此实体的日期和时间</td>
</tr>
<tr>
<td style=text-align:left>Last-Modified</td>
<td style=text-align:left>这个实体最后一次被修改的日期和时间</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-99925a267a45bd0c179d4c1f7c667768>4 - 连接管理</h1>
<h2 id=tcp连接>TCP连接</h2>
<p>HTTP 通信由 TCP/IP 承载。</p>
<h3 id=tcp的可靠数据管道>TCP的可靠数据管道</h3>
<p>TCP 为 HTTP 提供了一条<strong>可靠的比特传输管道</strong>。TCP 会<strong>按序、无差错</strong>的承载 HTTP 数据。</p>
<p>一次 HTTP 请求过程：</p>
<div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/TCPwithWEB.jpg style=display:block;width:50% alt=NAME align=center> </div>
<h3 id=tcp流是分段的由ip分组传送>TCP流是分段的、由IP分组传送</h3>
<p>HTTP 发送一条报文时，会以流的形式将报文数据的内容通过一条打开的 TCP 连接按序传输。TCP 收到数据流以后，将数据流分成段，并将段封装在 IP分组(IP数据报) 中，通过因特网传输。</p>
<p>每个 TCP 段都由 IP 分组承载，从一个 IP地址发往另一个 IP地址。每个 IP分组中包括：</p>
<ul>
<li>一个 IP 分组首部(通常20字节)</li>
<li>一个 TCP 段首部(通常20字节)</li>
<li>一个 TCP 数据块(0 或多个字节)</li>
</ul>
<div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/HTTP&HTTPS.jpg style=display:block;width:50% alt=NAME align=center> </div>
<h3 id=保持tcp连接持续不断的运行>保持TCP连接持续不断的运行</h3>
<p>TCP 通过<strong>端口号</strong>来保持连接持续不断的运行。</p>
<p>TCP连接是通过 4 个值来识别的：<code>&lt; 源 IP 地址、源端口号、目的 IP 地址、目的端口号 ></code></p>
<p><strong>这 4 个值共同定义了一条连接。</strong></p>
<p>一个 IP 分组：</p>
<div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/IP-Block.jpg style=display:block;width:50% alt=NAME align=center> </div>
<h3 id=用tcp套接字编程>用TCP套接字编程</h3>
<p>OS 提供了操作 TCP 连接的 API。该 API 向 HTTP 隐藏了所有 TCP 和 IP 的细节。</p>
<p>TCP 套接字通信过程：</p>
<div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/TCP-Server.jpg style=display:block;width:50% alt=NAME align=center> </div>
<h2 id=tcp性能>TCP性能</h2>
<h3 id=http事务的时延>HTTP事务的时延</h3>
<p>主要原因：</p>
<ol>
<li>客户端根据 URL 确定服务器的 IP 和端口号，即DNS解析时间。</li>
<li>客户端向服务器发送一条 TCP 连接请求，并等待服务器返回一个接收应答。即建立 TCP连接的时间。</li>
<li>客户端通过已建立的 TCP 管道发送 HTTP 请求，即 HTTP 报文的传输和处理时间。</li>
<li>服务器返回 HTTP 响应，即 HTTP 报文传输时间。</li>
</ol>
<h3 id=性能聚焦区域>性能聚焦区域</h3>
<ol>
<li>TCP 连接建立握手</li>
<li>TCP 慢启动拥塞控制</li>
<li>数据聚集的 Ngale 算法</li>
<li>用于捎带 ACK 的 TCP 延迟确认算法</li>
<li>TIME_WAIT 时延和端口耗尽</li>
</ol>
<h2 id=http连接的处理>HTTP连接的处理</h2>
<h3 id=常被误解的connection首部>常被误解的Connection首部</h3>
<p>Connection 首部承载 3 种不同类型的标签：</p>
<ol>
<li>HTTP 首部字段名，列出只与此连接有关的首部；</li>
<li>任意标签值，用于描述此连接的非标准选项；</li>
<li>值 close，说明操作完成之后需关闭这条持久连接。</li>
</ol>
<h3 id=串行事务处理时延>串行事务处理时延</h3>
<p>一个页面包含多个元素需要加载时，如果每个事务都要(串行的建立)一条新的连接，那么连接时延和慢启动时延就会叠加起来。</p>
<p>一些提供 HTTP 连接性能的方法：</p>
<ol>
<li>并行连接：通过多条 TCP 连接发起并发的 HTTP 请求。
<ol>
<li>每个事物打开/关闭新的连接，耗费时间和带宽</li>
<li>TCP 慢启动的特性导致每条新连接的性能下降</li>
<li>受内存与带宽限制，可打开的并行连接数有限</li>
</ol>
</li>
<li>持久连接：重用 TCP 连接，以消除连接及关闭延时。
<ol>
<li>管理多个持久连接的操作复杂度</li>
<li>HTTP/1.0+ Keep-Alive</li>
<li>HTTP/1.1 默认开启持久连接</li>
</ol>
</li>
<li>管道化连接：通过共享的 TCP 连接发起并发的 HTTP 请求。将多条请求放入队列，当第一条请求发出后，队列中的请求就可以发送了。</li>
<li>复用的连接：交替传送请求和响应报文。</li>
</ol>
<h2 id=关闭连接>关闭连接</h2>
<ol>
<li>完全关闭与半关闭：套接字调用<code>close()</code>会将 TCP 连接的输入输出信道都关闭，称为完全关闭。调用<code>shutdown()</code>单独关闭输入或输出信道，称为半关闭。</li>
<li>TCP 关闭及重置错误</li>
<li>正常关闭：首先关闭输出信道，然后等待另一端关闭输出信道，当两端都确认不再发送任何数据之后，连接被完全关闭。</li>
</ol>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-7a1e106ccc9be0b15fab7e1aaaadb524>5 - 性能探索</h1>
<p><a href=https://www.mnot.net/blog/2016/04/22/ideal-http>Ideal HTTP Performance</a>一文的翻译，点击查看原文。</p>
<p>Web性能的隐性规则是减少终端用户能够感知到的延迟；在用户之前获得页面并使交互变得尽可能的快。</p>
<p>至于HTTP而言，这意味着一个理想的协议交互看起来像这样：</p>
<div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/WEB%E6%80%A7%E8%83%BD%E7%90%86%E6%83%B3%E7%9A%84%E5%8D%8F%E8%AE%AE%E4%BA%A4%E4%BA%92.jpg style=display:block;width:50% alt=NAME align=center> </div>
<p>意思就是一个页面的加载过程中，需要<strong>在最少的往返次数中，发送尽可能少的数据到服务端，然后下载尽可能少的必须的数据</strong>。</p>
<p>额外数数据同时意味着更多的转换时间和更多的出错机会，比如拥堵或者丢包，这将严重的影响性能。</p>
<p>由于协议“隔阂(chattiness)”的更多往返次数会带来更多的延迟，尤其是移动网络(一个往返100ms可以作为你最好的预期)。</p>
<p>如果这是最理想的情况，那HTTP是如何度量的？我们又如何来提升呢？</p>
<h2 id=http11>HTTP/1.1</h2>
<p>多种原因说明HTTP/1.1是一个很好的协议，但遗憾的是现代的Web工作方式意味着性能并不是其中之一。一个典型的页面加载方式看起来会是这样：</p>
<div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/HTTP1.1.jpg style=display:block;width:50% alt=NAME align=center> </div>
<p>这并不是特别的理想。</p>
<p>Web使用的HTTP/1是非常“饶舌”的，因为客户端需要多次去请求服务端以寻求它需要的更多东西；首先是HTML，然后是CSS和Javascript。每次这样的交互都会增加新的一个或多个往返从而增加了页面加载的延迟，这与理想中的“最少的往返次数”相悖。</p>
<p>此外，仅对页面的请求就增加了大量的数据，这与理想中的“发送尽可能少的数据到服务端”相悖。这是因为比如<code>Referer、User-Agent、Cookie</code>这样的冗长Header信息会在每次请求中重复，并且又被大量的Web页面所需要的资源加倍增长。</p>
<p>最终，由于HTTP/1的<code>head-of-line blocking</code>问题(线头阻塞:队列首个packet由于他的目的端口正忙而被延迟转发)，将多个资源组装到一个大的CSS代码、内嵌或连接，成为了一个普遍的最佳实践。这些都是HTTP/1中漂亮的性能hack，但是他们同样有一个损失：他们下载了远多于客户端需求的数据来显示一个页面，这与我们的理想相悖，并不能做到尽可能快的展示页面。</p>
<p>总的来说，HTTP/1并是不是一无是处，性能上的智能。举例来说，它拥有缓存，允许你在一个新的拷贝时完全不需要网络。还有受限制的请求，当有一个老的拷贝时避免你去转换大的东西。</p>
<h2 id=http2>HTTP/2</h2>
<p>HTTP/2试图通过几种方式去解决HTTP/1.1中的问题：</p>
<ol>
<li>完全的<strong>复用</strong>意味着线头阻塞不再是问题。可以通过单个HTTP连接加载整个Web页面，而不用担心创建了多少个请求。数据浪费的优化技巧可以被丢下了。</li>
<li>Header压缩移除了由于冗长头部信息引起的单个消息的消耗。现在可以将数十个甚至数百个请求合并到仅仅一些IP包中。这更接近于理想中的两种“更少的数据”。</li>
<li>HTTP/2的<strong>服务端PUSH</strong>主动提供客户端的需要，避免更多的往复次数带来的消耗。</li>
</ol>
<p>因此，HTTP/2的运作看起来会像这样：</p>
<div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/HTTP2.jpg style=display:block;width:50% alt=NAME align=center> </div>
<p>图中可以看到服务端在没有请求的情况下向客户端发送CSS、Javascript和图片。它知道客户端可能将会请求这些，因此它使用<strong>Server Push</strong>发送合成的请求/响应对到客户端，以节省一个往复次数。它不再是一个“饶舌”的协议，结果是他能更充分的使用网络。</p>
<p>需要注意的是，并不是说这些会更简单。HTTP/2仍然有很多存在的问题，特别是关于推送的时机。</p>
<h2 id=http2--缓存摘要>HTTP/2 + 缓存摘要</h2>
<p>服务端PUSH一个通常的问题是“客户端的缓存中是否已经有一个拷贝？”，因为推送天生是投机性的，总会出现你推送的东西并不是客户端需要的。</p>
<p>HTTP/2允许客户端在这种情况下通过<code>RESET_STREAM</code>取消推送。然而尽管这样，仍然会有一次往复的交互被浪费了，或许他们可以用来处理更值得的事情。记住，理想的是仅发送客户端用于显示页面仅需要的数据。</p>
<p>一个提议的方案是客户端使用一个紧凑的<code>Cache Digest</code>来告诉服务端它已经拥有的cache，从而使得服务端知道哪些是需要的。</p>
<div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/HTTP2_cache.jpg style=display:block;width:50% alt=NAME align=center> </div>
<p>因为缓存摘要使用<code>Golumb Compressed Sets</code>，它实时计算并使用少一1000个字节将浏览器缓存告诉服务端，通过连接在前几个包发送给服务端。</p>
<p>现在，我们避免了额外的往复次数，相关的数据浪费，直接嵌入和一些相似的hack，和非必须请求的数据浪费。这使我们里理想更进一步！</p>
<p>缓存摘要只是一个提议，但在HTTP社区中已经表现出很明显的兴趣。</p>
<h2 id=tcp>TCP</h2>
<p>目前为止，并没有谈到浏览器加载Web页面所使用的其他协议对性能的影响。</p>
<p>然而，真正的问题要比下面图片暗示的要多，TCP在HTTP开始前需要三次握手，来协定一个新连接的参数。</p>
<div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/TCP.jpg style=display:block;width:50% alt=NAME align=center> </div>
<p>这意味着一个连接的创建所需要的最少往返次数，这使每个新连接的创建增加了额外的。</p>
<p><code>TCP Fast Open</code>技术(在TCP3次握手的同时也进行数据交换)允许应用在<code>SYN</code>和<code>SYN+ACK</code>包中发送数据以避免这样的消耗。遗憾的是，仅被Linux和OSX支持。并且，社区的开发刚刚起步，在HTTP中使用TFO仍然有很多棘手的问题。</p>
<p>换句话说，TFO并不能保证随着SYN包发出的数据只会出现一次，很容易重复甚至引起恶意的回复攻击。因此，在一个TFO连接上的第一次请求就使用HTTP POST并不是一个明智的选择。更有问题的是，需要GET同样是有副作用的，但是浏览器并没有很好的方式来区分这些URL。</p>
<h2 id=tls>TLS</h2>
<p>TLS提供了另一种在TCP握手完成之后启动连接的方式。它看起来会是这样：</p>
<div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/TLS.jpg style=display:block;width:50% alt=NAME align=center> </div>
<p>在HTTP能够发送数据前需要两次完整的往复交互。在客户端达到服务端之前，<code>session tickets</code>允许你可以避免一次往复次数：</p>
<div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/TLS-session-tickets.jpg style=display:block;width:50% alt=NAME align=center> </div>
<p>很快，TLS将支持在客户端到达服务端之前提供“0往复次数”(zero round trip)的握手,换言之，HTTP可以在第一次往复中发送数据，避免额外的消耗。然而，和TFO一样，你需要能够确保第一次往复中发送的数据不会造成任何不好的影响。</p>
<h2 id=httpnext>HTTP/next</h2>
<p>TFO和TLS 1.3都是用来减少开启服务端连接的消耗。另一种方式尽量重用已开启的连接。</p>
<p>最后，这个讨论是如何使用HTTP/2的连接来使合并更加激烈(aggressively)，不仅仅是它是否能够帮助减少开启新连接的消耗，并且是能够使已存在的连接更加高效，就像TCP一样长寿命并且繁忙。</p>
<p>这些事情包括向客户端推送证书，以证明该连接能够跟他初始协定的一样被更多的源使用。</p>
<p>另外一个更彻底的改变正在被讨论：使用UDP替换TCP，比如QUIC(Goole定制的一种基于UDP的低延迟互联网传输协议)。</p>
</div>
</main>
</div>
</div>
<footer class="bg-dark py-5 row d-print-none">
<div class="container-fluid mx-sm-5">
<div class=row>
<div class="col-6 col-sm-4 text-xs-center order-sm-2">
</div>
<div class="col-6 col-sm-4 text-right text-xs-center order-sm-3">
<ul class="list-inline mb-0">
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Weibo aria-label=Weibo>
<a class=text-white target=_blank rel="noopener noreferrer" href=https://weibo.com/u/3848950217>
<i class="fab fa-weibo"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Twitter aria-label=Twitter>
<a class=text-white target=_blank rel="noopener noreferrer" href=https://twitter.com/zhange_zzg>
<i class="fab fa-twitter"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="Stack Overflow" aria-label="Stack Overflow">
<a class=text-white target=_blank rel="noopener noreferrer" href=https://stackoverflow.com>
<i class="fab fa-stack-overflow"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=GitHub aria-label=GitHub>
<a class=text-white target=_blank rel="noopener noreferrer" href=https://github.com/infilos/infilos.com>
<i class="fab fa-github"></i>
</a>
</li>
</ul>
</div>
<div class="col-12 col-sm-4 text-center py-2 order-sm-2">
<small class=text-white>&copy; 2021 infilos.com All Rights Reserved</small>
</div>
</div>
</div>
</footer>
</div>
<script src=/js/popper.min.js integrity=sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49 crossorigin=anonymous></script>
<script src=/js/bootstrap.min.js integrity=sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy crossorigin=anonymous></script>
<script src=/js/main.min.5c74b870c6953931a705f390a49c7e4c0a842ec5c83b24354758dd674343ed0d.js integrity="sha256-XHS4cMaVOTGnBfOQpJx+TAqELsXIOyQ1R1jdZ0ND7Q0=" crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/docsearch.js@2.6.3/dist/cdn/docsearch.min.js></script>
<script>docsearch({apiKey:'123',indexName:'infilos_com',inputSelector:'.td-search-input',debug:!1})</script>
</body>
</html>