<!doctype html><html lang=zh class=no-js><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=generator content="Hugo 0.100.2"><meta name=ROBOTS content="INDEX, FOLLOW"><link rel=canonical type=text/html href=/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/><link rel="shortcut icon" href=/favicons/favicon.ico><link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180><link rel=icon type=image/png href=/favicons/favicon-16x16.png sizes=16x16><link rel=icon type=image/png href=/favicons/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/favicons/android-36x36.png sizes=36x36><link rel=icon type=image/png href=/favicons/android-48x48.png sizes=48x48><link rel=icon type=image/png href=/favicons/android-72x72.png sizes=72x72><link rel=icon type=image/png href=/favicons/android-96x96.png sizes=96x96><link rel=icon type=image/png href=/favicons/android-144x144.png sizes=144x144><link rel=icon type=image/png href=/favicons/android-192x192.png sizes=192x192><title>存储系统 | infilos.com</title><meta property="og:title" content="存储系统"><meta property="og:description" content="Infilos Wiki Website"><meta property="og:type" content="website"><meta property="og:url" content="/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/"><meta property="og:site_name" content="infilos.com"><meta itemprop=name content="存储系统"><meta itemprop=description content="Infilos Wiki Website"><meta name=twitter:card content="summary"><meta name=twitter:title content="存储系统"><meta name=twitter:description content="Infilos Wiki Website"><script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga('create','UA-123062585-1','auto'),ga('send','pageview'))</script><script async src=https://www.google-analytics.com/analytics.js></script>
<link rel=preload href=/scss/main.min.847464b684a6e89d7276700a5c500c17ab494dd1755b2654a7b27d8b59e3347e.css as=style><link href=/scss/main.min.847464b684a6e89d7276700a5c500c17ab494dd1755b2654a7b27d8b59e3347e.css rel=stylesheet integrity><script src=/js/jquery-3.5.1.min.js integrity="sha256-9/aliU8dGd2tb6OSsuzixeV4y/faTqgFtohetphbbj0=" crossorigin=anonymous></script></head><body class=td-section><header><nav class="js-navbar-scroll navbar navbar-expand-lg navbar-dark td-navbar"><a class=navbar-brand href=/><span class=navbar-logo><svg id="Capa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 512 512" style="enable-background:new 0 0 512 512"><path style="fill:#ffc107" d="M432.384 143.616c-4.165-4.164-10.917-4.164-15.083.0l-60.352 60.352c-4.164 4.165-4.164 10.917.0 15.083 21.187 20.463 54.951 19.876 75.413-1.311 19.962-20.668 19.962-53.435.0-74.102L432.384 143.616z"/><path style="fill:#607d8b" d="M42.667 277.334c-5.891.003-10.669-4.771-10.672-10.662-.002-4.338 2.623-8.245 6.64-9.882l234.667-96c5.455-2.233 11.687.38 13.92 5.835s-.38 11.687-5.835 13.92l-234.667 96C45.433 277.069 44.056 277.337 42.667 277.334z"/><path style="fill:#546e7a" d="M391.552 56.448l-32-32C343.938 8.745 322.689-.059 300.544.0h-3.755c-46.082.024-83.432 37.374-83.456 83.456v3.755c-.053 22.138 8.75 43.377 24.448 58.987l32 32c4.165 4.164 10.917 4.164 15.083.0L391.531 71.531C395.701 67.372 395.71 60.62 391.552 56.448z"/><path style="fill:#607d8b" d="M160 469.334c-3.279.006-6.379-1.497-8.405-4.075L34.261 315.926c-3.635-4.636-2.823-11.341 1.813-14.976s11.341-2.823 14.976 1.813l117.333 149.333c3.629 4.641 2.809 11.344-1.832 14.973C164.681 468.533 162.375 469.329 160 469.334z"/><path style="fill:#455a64" d="M487.467 86.848l-3.669-3.648c-37.687-36.557-97.71-36.197-134.955.811l-51.413 51.413c-36.996 37.25-37.357 97.263-.811 134.955l3.584 3.669c1.7 2.457 4.671 3.706 7.616 3.2 2.831.005 5.548-1.115 7.552-3.115l172.181-172.181c4.189-4.143 4.226-10.896.083-15.085-.028-.028-.055-.056-.083-.083L487.467 86.848z"/><g><path style="fill:#ffc107" d="M501.333 192H480c-5.891.0-10.667-4.776-10.667-10.667s4.776-10.667 10.667-10.667h21.333c5.891.0 10.667 4.776 10.667 10.667S507.225 192 501.333 192z"/><path style="fill:#ffc107" d="M394.667 298.667c-5.891.0-10.667-4.776-10.667-10.667v-21.333c0-5.891 4.776-10.667 10.667-10.667 5.891.0 10.667 4.776 10.667 10.667V288C405.333 293.891 400.558 298.667 394.667 298.667z"/><path style="fill:#ffc107" d="M480 277.334c-2.831.005-5.548-1.115-7.552-3.115l-21.333-21.333c-4.093-4.237-3.975-10.99.262-15.083 4.134-3.993 10.687-3.993 14.821.0l21.333 21.333c4.159 4.172 4.148 10.926-.024 15.085C485.514 276.209 482.815 277.327 480 277.334z"/></g><g><path style="fill:#455a64" d="M266.667 448H96c-29.455.0-53.333 23.878-53.333 53.333.0 5.891 4.776 10.667 10.667 10.667h256c5.891.0 10.667-4.776 10.667-10.667C320 471.878 296.122 448 266.667 448z"/><circle style="fill:#455a64" cx="32" cy="288" r="32"/></g><g/><g/><g/><g/><g/><g/><g/><g/><g/><g/><g/><g/><g/><g/><g/></svg></span><span class=font-weight-bold>infilos.com</span></a>
<button class=navbar-toggler type=button data-toggle=collapse data-target=#navbarSupportedContent aria-controls=navbarSupportedContent aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span></button><div class="collapse navbar-collapse" id=navbarSupportedContent><ul class="navbar-nav mr-auto"><li class=nav-item style=max-width:90px;min-width:10px><a class=nav-link href=/%e5%9f%ba%e7%a1%80%e7%9f%a5%e8%af%86><span>基础</span></a></li><li class=nav-item style=max-width:90px;min-width:10px><a class=nav-link href=/%e7%bc%96%e7%a8%8b%e8%af%ad%e8%a8%80><span>语言</span></a></li><li class=nav-item style=max-width:90px;min-width:10px><a class=nav-link href=/%e6%a1%86%e6%9e%b6%e4%b8%8e%e5%ba%93><span>框架库</span></a></li><li class="nav-item dropdown" style=max-width:90px;min-width:10px><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>分布式
<span>+</span></a><div class=dropdown-menu aria-labelledby=navbarDropdown><a class=dropdown-item href=/%e5%88%86%e5%b8%83%e5%bc%8f/base>基本构成</a></div></li><li class="nav-item dropdown" style=max-width:90px;min-width:10px><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>大数据
<span>+</span></a><div class=dropdown-menu aria-labelledby=navbarDropdown><a class=dropdown-item href=/%e5%ad%98%e5%82%a8%e7%b3%bb%e7%bb%9f>存储系统</a>
<a class=dropdown-item href=/%e6%9f%a5%e8%af%a2%e7%b3%bb%e7%bb%9f>查询系统</a>
<a class=dropdown-item href=/%e6%b6%88%e6%81%af%e7%b3%bb%e7%bb%9f>消息系统</a>
<a class=dropdown-item href=/%e5%a4%84%e7%90%86%e7%b3%bb%e7%bb%9f>处理系统</a>
<a class=dropdown-item href=/%e6%95%b0%e6%8d%ae%e6%b2%bb%e7%90%86>数据治理</a></div></li><li class="nav-item dropdown" style=max-width:90px;min-width:10px><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>中后台
<span>+</span></a><div class=dropdown-menu aria-labelledby=navbarDropdown><a class=dropdown-item href=/%e5%9f%ba%e7%a1%80%e8%ae%be%e6%96%bd>基础设施</a>
<a class=dropdown-item href=/%e7%94%a8%e6%88%b7%e7%b3%bb%e7%bb%9f>用户系统</a>
<a class=dropdown-item href=/%e4%ba%a4%e4%ba%92%e7%95%8c%e9%9d%a2>交互界面</a>
<a class=dropdown-item href=/%e4%b8%9a%e5%8a%a1%e7%b3%bb%e7%bb%9f>业务系统</a></div></li><li class=nav-item style=max-width:90px;min-width:10px><a class=nav-link href=/%e6%a8%a1%e5%bc%8f%e6%9e%b6%e6%9e%84><span>模式架构</span></a></li><li class=nav-item style=max-width:90px;min-width:10px><a class=nav-link href=/%e9%9d%a2%e8%af%95%e9%97%ae%e7%ad%94><span>面试</span></a></li><li class=nav-item style=max-width:90px;min-width:10px><a class=nav-link href=/%e7%ae%a1%e7%90%86%e8%b7%af%e5%be%84><span>管理</span></a></li><li class=nav-item style=max-width:90px;min-width:10px><a class=nav-link href=/%e5%bc%80%e6%ba%90%e9%a1%b9%e7%9b%ae><span>开源</span></a></li></ul><div class="form-inline my-2 my-lg-0"><div class="nav-item nav-search-item my-2 my-md-0"><input type=search class="form-control td-search-input" placeholder="&#xf002; 站内搜索…" aria-label=站内搜索… autocomplete=off></div></div></div></nav></header><div class="container-fluid td-outer"><div class=td-main><div class="row flex-xl-nowrap"><div class="col-12 col-md-3 col-xl-2 td-sidebar d-print-none"></div><div class="d-none d-xl-block col-xl-2 td-toc d-print-none"></div><main class="col-12 col-md-9 col-xl-8 pl-md-5" role=main><div class=td-content><div class="pageinfo pageinfo-primary d-print-none"><p>这是本节的多页打印视图。
<a href=# onclick="return print(),!1">点击此处打印</a>.</p><p><a href=/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/>返回本页常规视图</a>.</p></div><h1 class=title>存储系统</h1><ul><li>1: <a href=#pg-7710d6805fed4e0175c70d82d7258c0e>RDBMS</a></li><ul><li>1.1: <a href=#pg-c5780ac44a15b29613233ec776da4b55>CH01-工作方式</a></li><li>1.2: <a href=#pg-5f440bea0444e267ba103fefcd6501d8>CH02-设计理论</a></li><li>1.3: <a href=#pg-a9b9d58ba7418e7426e97d813794b4a4>CH03-设计流程</a></li><li>1.4: <a href=#pg-17a8347e6e10342607180b4d34ede039>CH04-核心知识</a></li></ul><li>2: <a href=#pg-4885df7df9d3b6d8eeec5ee8188100ae>JDBC</a></li><ul></ul><li>3: <a href=#pg-52b3784f2c0fc27209a7dfce796a520a>SQL</a></li><ul><li>3.1: <a href=#pg-6b3f5552bcb7e8d7e392d0c4f28a8929>CH01-语法基础</a></li><li>3.2: <a href=#pg-3a7e7b2f0ca69ac47bbbc3c0d6b38685>CH02-查询练习</a></li><li>3.3: <a href=#pg-737e18886ba6621c88d9e916998f72b7>CH03-查询进阶</a></li><li>3.4: <a href=#pg-141228844e3202b20692d12c3ddf6e9d>CH04-查询优化</a></li><li>3.5: <a href=#pg-a0a7894d7606a3f738000a19c4f86fef>CH05-连接查询</a></li><li>3.6: <a href=#pg-e8a3ce34a9aeb6190bbdae2666689618>CH06-子查询</a></li><li>3.7: <a href=#pg-53bea1355742a9e6bdb4f8c8158e6d2d>CH07-运维语句</a></li></ul><li>4: <a href=#pg-90906b5d575a42bc40411c9bf01bcfb6>MySQL</a></li><ul><li>4.1: <a href=#pg-90adba63667076abecda8b645b08e594>CH01-数据类型</a></li><li>4.2: <a href=#pg-87823f5c8c995312533c60e735d79427>CH02-存储引擎</a></li><li>4.3: <a href=#pg-e59a8b6bc16ee47aa4e9119f76c58aa2>CH03-索引B+树</a></li><li>4.4: <a href=#pg-e153ee081a2e00565371b72f637f2039>CH04-性能优化</a></li><li>4.5: <a href=#pg-29d040819faa80f395ba725e176690a3>CH05-分库分表</a></li><li>4.6: <a href=#pg-18dd619a88421627df2c9f215cacaecc>CH06-复制分离</a></li><li>4.7: <a href=#pg-280203572e4e446020b171753e2c2a12>CH07-执行过程</a></li><li>4.8: <a href=#pg-2f770b4ebcff7b1cb1f0b0c93c9c266f>CH08-参考规约</a></li></ul><li>5: <a href=#pg-c98eb4e5d30b0012286d2018ebc8246d>MySQL 实战</a></li><ul><li>5.1: <a href=#pg-763a4cb19f42bf3fcb7e0895e1f01027>CH01-基础架构</a></li><li>5.2: <a href=#pg-d94c10e940f788e4706645fab4ee4d18>CH02-日志系统</a></li><li>5.3: <a href=#pg-1fed0fae3032d08ee3c0cb9fd99595b3>CH03-事务隔离</a></li><li>5.4: <a href=#pg-1b4b5a489c633646179898f8f72f66d8>CH04-索引-上</a></li><li>5.5: <a href=#pg-557271842e3f9b6b61f8f0a1bbe2a7ca>CH05-索引-下</a></li><li>5.6: <a href=#pg-b26ced95223bb69a1c58b680a8a4194b>CH06-全局锁与表锁</a></li><li>5.7: <a href=#pg-8e6aafa223e735459e0969042de4d54f>CH07-行级锁</a></li><li>5.8: <a href=#pg-5a6f17ddd74c080d6a6db2bc41956240>CH08-MVCC</a></li><li>5.9: <a href=#pg-b3a9aaf767396fa16fcdb3ef3e2418e2>CH09-索引选择</a></li><li>5.10: <a href=#pg-f15574a70dd70677547f9af779af61e7>CH10-优化器</a></li><li>5.11: <a href=#pg-b5f4fe77f26d63013e450536e7f82498>CH11-字符串索引</a></li><li>5.12: <a href=#pg-dde8ff71211369b0042c90065fcda5a8>CH12-刷脏页</a></li><li>5.13: <a href=#pg-7d71d54ed4346590dcce5e8857f0ecab>CH13-空间回收</a></li><li>5.14: <a href=#pg-1110a052c9014ea2f2ce98636dc8222e>CH14-Count 实现</a></li><li>5.15: <a href=#pg-a9a6c55b68fda9e4efeb68fc40c903fb>CH15-日志与索引</a></li><li>5.16: <a href=#pg-b807b194725472ab54d11fa9ec4d9df1>CH16-Orderby 实现</a></li><li>5.17: <a href=#pg-02e6b423705190731118b8e6ba37b6be>CH17-随机查询</a></li><li>5.18: <a href=#pg-c97a922d5ae648249382bedaf569f0b9>CH18-性能案例</a></li><li>5.19: <a href=#pg-119f403b73cc8648488456e693930f29>CH19-单行优化</a></li><li>5.20: <a href=#pg-7e8bb06b45a4ba47027135fe453d090e>CH20-幻读</a></li><li>5.21: <a href=#pg-2ee15cd6d8af391cfa48aa5881a3b0ae>CH21-加锁规则</a></li><li>5.22: <a href=#pg-dc8b53c2b34d4163603667083641eb15>CH22-优化场景</a></li><li>5.23: <a href=#pg-966a8aee076105d80306d2602993e6ba>CH23-可靠保证</a></li><li>5.24: <a href=#pg-269a373cc5da095b05f71f1689fd1e2e>CH24-主备一致</a></li><li>5.25: <a href=#pg-0675bad201397104cfbb2f53d0046fe9>CH25-高可用</a></li><li>5.26: <a href=#pg-5dfea19463cdc24ffa1cb4b681fba9a8>CH26-备库延迟</a></li><li>5.27: <a href=#pg-53b4ceed281c41c2c9e040d31ccadf5e>CH27-主库故障</a></li><li>5.28: <a href=#pg-7371b53aa14505a693659fe7b806bde8>CH28-读写分离</a></li><li>5.29: <a href=#pg-ef5b50851aefc62365f4120a4c995d4f>CH29-故障判断</a></li><li>5.30: <a href=#pg-3cf5d6f4b487f2512a1f937d50db6efb>CH30-动态观察锁</a></li><li>5.31: <a href=#pg-105696c87ee0cea84747208605caecd0>CH31-误删恢复</a></li><li>5.32: <a href=#pg-96bf2c9b77e9408d0238c4a9ae5d4cda>CH32-KILL 语句</a></li><li>5.33: <a href=#pg-029fcd79263b8e63f77ed4e182b0a61e>CH33-内存占用</a></li><li>5.34: <a href=#pg-ae53ce85470f1a5d487b0943e0f46675>CH34-JOIN 应用</a></li><li>5.35: <a href=#pg-3259143b4213c83ebd11172671a116d6>CH35-JOIN 优化</a></li><li>5.36: <a href=#pg-70bbd7d7aa199195163b3e70c1cbb13c>CH36-临时表重名</a></li><li>5.37: <a href=#pg-a61074124cee621204f12f3145ff7887>CH37-内部临时表</a></li><li>5.38: <a href=#pg-9bdb84907c295c993aefeec8cdf5f549>CH38-Memory 引擎</a></li><li>5.39: <a href=#pg-cf1ea9bcb1f19bd706aa66a3e390e045>CH39-自增主键连续性</a></li><li>5.40: <a href=#pg-b63334801747ae29bc0a483233fbcc37>INSERT 相关锁</a></li><li>5.41: <a href=#pg-0f37df922c2c496cc572639d8e1133cf>CH41-表快速复制</a></li><li>5.42: <a href=#pg-ed8d3e3e94c1b3f3e80059ed212b894f>CH42-GRANT 授权</a></li><li>5.43: <a href=#pg-fd30e526e9e2682ba8fa3c42b6302654>CH43-分区表</a></li><li>5.44: <a href=#pg-ebc9290eef1e6eb88a30545292b21094>CH44-问题答疑</a></li></ul><li>6: <a href=#pg-4b14a7394e1dbce5cdcb3d0f4ba659af>MySQL 内幕</a></li><ul></ul><li>7: <a href=#pg-9653d45f3d65839c479cbf585b3db5c7>Redis</a></li><ul><li>7.1: <a href=#pg-15dc494595c2bd4672f094c19c69802f>CH01-基本类型</a></li><li>7.2: <a href=#pg-74fbd382412792c903e2f596fdcce9b7>CH02-高级类型</a></li><li>7.3: <a href=#pg-fa602568c373b012706150061f875875>CH03-Stream</a></li><li>7.4: <a href=#pg-f39b5b7bdbb59acf255fb62ce2763d03>CH04-对象机制</a></li><li>7.5: <a href=#pg-d6ad1d4083c795b0ad006b6fb71ea3c7>CH05-底层结构</a></li><li>7.6: <a href=#pg-e23ea9a97b8e45f6fe4f13ffc2073690>CH06-缓存机制</a></li><li>7.7: <a href=#pg-76cf898359b51ee9f123cd859135b47d>CH07-高可用性</a></li><li>7.8: <a href=#pg-609363fe593c01d2ba6ab13171671b34>CH08-百亿量级</a></li><li>7.9: <a href=#pg-52ebc52fef800cc7b90e32b1026ac24d>CH09-实现搜索</a></li><li>7.10: <a href=#pg-0651586b1071ed29fcfe45d22825ffb0>CH10-常见问题</a></li></ul></ul><div class=content></div></div><div class=td-content><h1 id=pg-7710d6805fed4e0175c70d82d7258c0e>1 - RDBMS</h1></div><div class=td-content><h1 id=pg-c5780ac44a15b29613233ec776da4b55>1.1 - CH01-工作方式</h1><h2 id=相关算法>相关算法</h2><h3 id=时间复杂度>时间复杂度</h3><blockquote><p>对于数据库而言，重要的不是数据量，而是解决数据量增加时引起的运算量问题。</p></blockquote><p>时间复杂度用来检验某个算法处理一定量的数据要花多长时间，时间复杂度不会给出确切的运算次数，但是给出的是一种理念。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210503150549.png style=display:block;width:50% alt=NAME align=center></div><ul><li><p>绿：O(1)或者叫常数阶复杂度，保持为常数（要不人家就不会叫常数阶复杂度了）。</p></li><li><p>红：O(log(n))对数阶复杂度，即使在十亿级数据量时也很低。</p></li><li><p>粉：最糟糕的复杂度是 O(n^2)，平方阶复杂度，运算数快速膨胀。</p></li><li><p>黑和蓝：另外两种复杂度（的运算数也是）快速增长。</p></li></ul><p>假设要处理2000条元素：</p><ul><li>O(1) 算法会消耗 1 次运算</li><li>O(log(n)) 算法会消耗 7 次运算</li><li>O(n) 算法会消耗 2000 次运算</li><li>O(n*log(n)) 算法会消耗 14,000 次运算</li><li>O(n^2) 算法会消耗 4,000,000 次运算</li></ul><h3 id=归并排序>归并排序</h3><p>归并排序是把问题拆分为小问题，通过解决小问题来解决最初的问题，即分治法。</p><p>什么是归并排序：</p><ul><li>你可以更改算法，以便于节省内存空间，方法是不创建新的序列而是直接修改输入序列。注：这种算法叫『<strong>原地算法</strong>』(in-place algorithm)</li><li>你可以更改算法，以便于同时使用磁盘空间和少量内存而避免巨量磁盘 I/O。方法是只向内存中加载当前处理的部分。在仅仅100MB的内存缓冲区内排序一个几个GB的表时，这是个很重要的技巧。注：这种算法叫『<strong>外部排序</strong>』(external sorting)。</li><li>你可以更改算法，以便于在 多处理器/多线程/多服务器 上运行。比如，分布式合并排序是 <strong>Hadoop</strong> 的关键组件之一。</li></ul><h3 id=二叉树搜索>二叉树搜索</h3><blockquote><p>数据库中查询的时间复杂度，使我们无法使用矩阵，转而使用二叉搜索树(BST)。</p></blockquote><ul><li>二叉搜索树只需 log(N) 次运算，而如果直接使用阵列则需要 N 次运算。</li></ul><h3 id=b树索引>B+树索引</h3><blockquote><ul><li><p>为什么引入 B+ 树？</p><p>查找一个特定值这个树挺好用，但是当你需要<strong>查找两个值之间的多个元素</strong>时，就会有大麻烦了。你的成本将是 O(N)，因为你必须查找树的每一个节点，以判断它是否处于那 2 个值之间（例如，对树使用中序遍历）。而且这个操作不是磁盘I/O有利的，因为你必须读取整个树。我们需要找到高效的范围查询方法。</p></li></ul></blockquote><p>如果在数据库中增加或删除一行，对 B+ 树来说：</p><ul><li>你必须在B+树中的节点之间保持顺序，否则节点会变得一团糟，你无法从中找到想要的节点。</li><li>你必须尽可能降低B+树的层数，否则 O(log(N)) 复杂度会变成 O(N)。</li></ul><p>B+树需要自我整理和自我平衡。但是这样也带来了成本：在B+树中，插入和删除操作是 O(log(N)) 复杂度。所以有些人听到过使用太多索引不是个好主意这类说法。没错，你减慢了快速插入/更新/删除表中的一个行的操作，因为数据库需要以代价高昂的每索引 O(log(N)) 运算来更新表的索引。再者，增加索引意味着给事务管理器带来更多的工作负荷（在本文结尾我们会探讨这个管理器）。</p><h3 id=哈希表>哈希表</h3><blockquote><p>当你想快速查找值时，哈希表是非常有用的。而且，理解哈希表会帮助我们接下来理解一个数据库常见的联接操作，叫做『哈希联接』。这个<strong>数据结构也被数据库用来保存一些内部的东西</strong>（比如<strong>锁表</strong>或者<strong>缓冲池</strong>，我们在下文会研究这两个概念）</p></blockquote><p>为什么不用阵列？</p><ul><li>如果有了好的哈希函数，在哈希表里搜索的时间复杂度是 O(1)。</li><li><strong>一个哈希表可以只装载一半到内存，剩下的哈希桶可以留在硬盘上</strong>。</li><li>用阵列的话，你需要一个连续内存空间。如果你加载一个大表，很难分配足够的连续内存空间。</li></ul><h2 id=全局概览>全局概览</h2><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210503151253.png style=display:block;width:50% alt=NAME align=center></div><h3 id=核心组件>核心组件</h3><ul><li><p><strong>进程管理器（process manager）</strong>：很多数据库具备一个需要妥善管理的进程/线程池。再者，为了实现纳秒级操作，一些现代数据库使用自己的线程而不是操作系统线程。</p></li><li><p><strong>网络管理器（network manager）</strong>：网路I/O是个大问题，尤其是对于分布式数据库。所以一些数据库具备自己的网络管理器。</p></li><li><p><strong>文件系统管理器（File system manager）</strong>：磁盘I/O是数据库的首要瓶颈。具备一个文件系统管理器来完美地处理OS文件系统甚至取代OS文件系统，是非常重要的。</p></li><li><p><strong>内存管理器（memory manager）</strong>：为了避免磁盘I/O带来的性能损失，需要大量的内存。但是如果你要处理大容量内存你需要高效的内存管理器，尤其是你有很多查询同时使用内存的时候。</p></li><li><p><strong>安全管理器（Security Manager）</strong>：用于对用户的验证和授权。</p></li><li><p><strong>客户端管理器（Client manager）</strong>：用于管理客户端连接。</p></li></ul><h3 id=工具>工具</h3><ul><li><strong>备份管理器（Backup manager）</strong>：用于保存和恢复数据。</li><li><strong>恢复管理器（Recovery manager</strong>）：用于崩溃后重启数据库到一个一致状态。</li><li><strong>监控管理器（Monitor manager）</strong>：用于记录数据库活动信息和提供监控数据库的工具。</li><li><strong>管理员管理器（Administration manager）</strong>：用于保存元数据（比如表的名称和结构），提供管理数据库、模式、表空间的工具。</li></ul><h3 id=查询管理器>查询管理器</h3><ul><li><strong>查询解析器（Query parser）</strong>：用于检查查询是否合法</li><li><strong>查询重写器（Query rewriter）</strong>：用于预优化查询</li><li><strong>查询优化器（Query optimizer）</strong>：用于优化查询</li><li><strong>查询执行器（Query executor）</strong>：用于编译和执行查询</li></ul><h3 id=数据管理器>数据管理器：</h3><ul><li><strong>事务管理器（Transaction manager）</strong>：用于处理事务</li><li><strong>缓存管理器（Cache manager）</strong>：数据被使用之前置于内存，或者数据写入磁盘之前置于内存</li><li><strong>数据访问管理器（Data access manager）</strong>：访问磁盘中的数据</li></ul><h2 id=查询流程>查询流程</h2><p>主要介绍数据库如何通过如下进程来管理 SQL 查询：</p><ul><li>客户端管理器</li><li>查询管理器</li><li>数据管理器（含恢复管理器）</li><li>客户端管理器</li></ul><h2 id=客户端管理器>客户端管理器</h2><blockquote><p>客户端管理器是处理客户端通信的。客户端可以是一个（网站）服务器或者一个最终用户或最终应用。客户端管理器通过一系列知名的API（JDBC, ODBC, OLE-DB …）提供不同的方式来访问数据库。客户端管理器也提供专有的数据库访问API。</p></blockquote><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210503151620.png style=display:block;width:50% alt=NAME align=center></div><p><strong>当你连接到数据库时</strong>：</p><ul><li>管理器首先检查你的验证信息（用户名和密码），然后检查你是否有访问数据库的授权。这些权限由DBA分配。</li><li>然后，管理器检查是否有空闲进程（或线程）来处理你对查询。</li><li>管理器还会检查数据库是否负载很重。</li><li>管理器可能会等待一会儿来获取需要的资源。如果等待时间达到超时时间，它会关闭连接并给出一个可读的错误信息。</li><li>然后管理器会把你的查询送给查询管理器来处理。</li><li>因为查询处理进程不是『不全则无』的，一旦它从查询管理器得到数据，它会把部分结果保存到一个缓冲区并且开始给你发送。</li><li>如果遇到问题，管理器关闭连接，向你发送可读的解释信息，然后释放资源。</li></ul><h2 id=查询管理器-1>查询管理器</h2><blockquote><p>数据库的关键，在这部分里，一个写得糟糕的查询可以转换成一个快速执行的代码，代码执行的结果被送到客户端管理器。</p></blockquote><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210503151752.png style=display:block;width:50% alt=NAME align=center></div><p>这个多步骤操作过程如下：</p><ul><li>查询首先被<strong>解析</strong>并判断是否合法</li><li>然后被<strong>重写</strong>，去除了无用的操作并且加入<strong>预优化</strong>部分</li><li>接着被<strong>优化</strong>以便提升性能，并被<strong>转换为可执行代码</strong>和<strong>数据访问计划</strong>。</li><li>然后计划被<strong>编译</strong></li><li>最后，被<strong>执行</strong></li></ul><h3 id=查询解析器>查询解析器</h3><blockquote><p>每一条SQL语句都要送到解析器来检查语法，如果你的查询有错，解析器将拒绝该查询。比如，如果你写成”SLECT …” 而不是 “SELECT …”，那就没有下文了。</p></blockquote><ul><li><p>解析器还会检查关键字是否使用正确的顺序，比如 WHERE 写在 SELECT 之前会被拒绝。</p></li><li><p>然后，解析器要分析查询中的表和字段，使用数据库元数据来检查：</p><ul><li>表是否存在</li><li>表的字段是否存在</li><li>对某类型字段的 运算 是否 可能（比如，你不能将整数和字符串进行比较，你不能对一个整数使用 substring() 函数）</li></ul></li><li><p>接着，解析器检查在查询中你是否有权限来读取（或写入）表。再强调一次：这些权限由DBA分配。</p></li><li><p>在解析过程中，SQL 查询被转换为内部表示（通常是一个树）。</p></li><li><p>如果一切正常，内部表示被送到查询重写器。</p></li></ul><h3 id=查询重写器>查询重写器</h3><p>在这一步，我们已经有了查询的内部表示，重写器的目标是：</p><ul><li>预优化查询</li><li>避免不必要的运算</li><li>帮助优化器找到合理的最佳解决方案</li></ul><p>重写器按照一系列已知的规则对查询执行检测。如果查询匹配一种模式的规则，查询就会按照这条规则来重写。下面是（可选）规则的非详尽的列表：</p><ul><li><strong>视图合并</strong>：如果你在查询中使用视图，视图就会转换为它的 SQL 代码。</li><li><strong>子查询扁平化</strong>：子查询是很难优化的，因此重写器会尝试移除子查询</li><li><strong>去除不必要的运算符</strong>：比如，如果你用了 DISTINCT，而其实你有 UNIQUE 约束（这本身就防止了数据出现重复），那么 DISTINCT 关键字就被去掉了。</li><li><strong>排除冗余的联接</strong>：如果相同的 JOIN 条件出现两次，比如隐藏在视图中的 JOIN 条件，或者由于传递性产生的无用 JOIN，都会被消除。</li><li><strong>常数计算赋值</strong>：如果你的查询需要计算，那么在重写过程中计算会执行一次。比如 WHERE AGE > 10+2 会转换为 WHERE AGE > 12 ， TODATE(“日期字符串”) 会转换为 datetime 格式的日期值。</li><li><strong>（高级）分区裁剪（Partition Pruning）</strong>：如果你用了分区表，重写器能够找到需要使用的分区。</li><li><strong>（高级）物化视图重写（Materialized view rewrite）</strong>：如果你有个物化视图匹配查询谓词的一个子集，重写器将检查视图是否最新并修改查询，令查询使用物化视图而不是原始表。</li><li><strong>（高级）自定义规则</strong>：如果你有自定义规则来修改查询（就像 Oracle policy），重写器就会执行这些规则。</li><li><strong>（高级）OLAP转换</strong>：分析/加窗 函数，星形联接，ROLLUP 函数……都会发生转换（但我不确定这是由重写器还是优化器来完成，因为两个进程联系很紧，必须看是什么数据库）。</li></ul><h3 id=统计信息>统计信息</h3><p>数据库和操作系统是如何保存数据的？两者使用的最小单位叫做页或块（默认 4 或 8 KB）。这就是说如果你仅需要 1KB，也会占用一个页。要是页的大小为 8KB，你就浪费了 7KB。</p><p>当你要求数据库收集统计信息，数据库会计算下列值：</p><ul><li>表中行和页的数量</li><li>表中每个列中的：<ul><li>唯一值</li><li>数据长度（最小，最大，平均）</li><li>数据范围（最小，最大，平均）</li></ul></li><li>表的索引信息</li></ul><p><strong>这些统计信息会帮助优化器估计查询所需的磁盘 I/O、CPU、和内存使用</strong>。</p><p>对每个列的统计非常重要。比如，如果一个表 PERSON 需要联接 2 个列： LAST_NAME, FIRST_NAME。根据统计信息，数据库知道FIRST_NAME只有 1,000 个不同的值，LAST_NAME 有 1,000,000 个不同的值。因此，数据库就会按照 LAST_NAME, FIRST_NAME 联接。因为 LAST_NAME 不大可能重复，多数情况下比较 LAST_NAME 的头 2 、 3 个字符就够了，这将大大减少比较的次数。</p><p>不过，这些只是基本的统计。你可以让数据库做一种高级统计，叫直方图。直方图是列值分布情况的统计信息。例如：</p><ul><li>出现最频繁的值</li><li>分位数(quantiles)</li><li>…</li></ul><p>这些额外的统计会帮助数据库找到更佳的查询计划，尤其是对于等式谓词（例如： WHERE AGE = 18 ）或范围谓词（例如： WHERE AGE > 10 and AGE &lt; 40），因为数据库可以更好的了解这些谓词相关的数字类型数据行（注：这个概念的技术名称叫选择率）。</p><p>统计信息保存在数据库元数据内，例如（非分区）表的统计信息位置：</p><ul><li>Oracle： USER / ALL / DBA_TABLES 和 USER / ALL / DBA_TAB_COLUMNS</li><li>DB2： SYSCAT.TABLES 和 SYSCAT.COLUMNS</li></ul><p><strong>统计信息必须及时更新</strong>。如果一个表有 1,000,000 行而数据库认为它只有 500 行，没有比这更糟糕的了。统计唯一的不利之处是需要时间来计算，这就是为什么数据库大多默认情况下不会自动计算统计信息。数据达到百万级时统计会变得困难，这时候，你可以选择仅做基本统计或者在一个数据库样本上执行统计。</p><p>举个例子，我参与的一个项目需要处理每表上亿条数据的库，我选择只统计10%，结果造成了巨大的时间消耗。本例证明这是个糟糕的决定，因为有时候 Oracle 10G 从特定表的特定列中选出的 10% 跟全部 100% 有很大不同（对于拥有一亿行数据的表，这种情况极少发生）。这次错误的统计导致了一个本应 30 秒完成的查询最后执行了 8 个小时，查找这个现象根源的过程简直是个噩梦。这个例子显示了统计的重要性。</p><h3 id=查询优化器>查询优化器</h3><blockquote><p>所有的现代数据库都在用<strong>基于成本的优化</strong>（即CBO）来优化查询。道理是针对每个运算设置一个成本，通过应用成本最低廉的一系列运算，来找到最佳的降低查询成本的方法。</p></blockquote><p>为了理解成本优化器的原理，我觉得最好用个例子来『感受』一下这个任务背后的复杂性。这里我将给出联接 2 个表的 3 个方法，我们很快就能看到即便一个简单的联接查询对于优化器来说都是个噩梦。之后，我们会了解真正的优化器是怎么做的。</p><p><strong>对于这些联接操作，我会专注于它们的时间复杂度，但是，数据库优化器计算的是它们的 CPU 成本、磁盘 I/O 成本、和内存需求</strong>。时间复杂度和 CPU 成本的区别是，时间成本是个近似值（给我这样的懒家伙准备的）。而 CPU 成本，我这里包括了所有的运算，比如：加法、条件判断、乘法、迭代……还有呢：</p><ul><li><p>每一个高级代码运算都要特定数量的低级 CPU 运算。</p></li><li><p>对于 Intel Core i7、Intel Pentium 4、AMD Opteron…等，（就 CPU 周期而言）CPU 的运算成本是不同的，也就是说它取决于 CPU 的架构。</p></li></ul><p>使用时间复杂度就容易多了（至少对我来说），用它我也能了解到 CBO 的概念。由于磁盘 I/O 是个重要的概念，我偶尔也会提到它。请牢记，<strong>大多数时候瓶颈在于磁盘 I/O 而不是 CPU 使用</strong>。</p><h4 id=索引>索引</h4><blockquote><p>在研究 B+树的时候我们谈到了索引，要记住一点，索引都是已经排了序的。</p></blockquote><p>仅供参考：还有其他类型的索引，比如位图索引，在 CPU、磁盘I/O、和内存方面与B+树索引的成本并不相同。</p><p>另外，很多现代数据库为了改善执行计划的成本，可以仅为当前查询动态地生成临时索引。</p><h4 id=存取路径>存取路径</h4><p>在应用联接运算符（join operators）之前，你首先需要获得数据。以下就是获得数据的方法。</p><p>注：由于所有存取路径的真正问题是磁盘 I/O，我不会过多探讨时间复杂度。</p><ul><li><p>全扫描</p><p>如果你读过执行计划，一定看到过『全扫描』（或只是『扫描』）一词。简单的说全扫描就是数据库完整的读一个表或索引。就磁盘 I/O 而言，很明显全表扫描的成本比索引全扫描要高昂。</p></li><li><p>范围扫描</p><p>其他类型的扫描有索引范围扫描，比如当你使用谓词 ” WHERE AGE > 20 AND AGE &lt; 40 ” 的时候它就会发生。</p><p>当然，你需要在 AGE 字段上有索引才能用到索引范围扫描。</p><p>在第一部分我们已经知道，范围查询的时间成本大约是 log(N)+M，这里 N 是索引的数据量，M 是范围内估测的行数。多亏有了统计我们才能知道 N 和 M 的值（注： M 是谓词 “ AGE > 20 AND AGE &lt; 40 ” 的选择率）。另外范围扫描时，你不需要读取整个索引，因此在磁盘 I/O 方面没有全扫描那么昂贵。</p></li><li><p>唯一扫描</p><p>如果你只需要从索引中取一个值你可以用唯一扫描。</p></li><li><p>根据 ROW ID 存取</p><p>多数情况下，如果数据库使用索引，它就必须查找与索引相关的行，这样就会用到根据 ROW ID 存取的方式。</p></li><li><p>其它路径</p><p>我没有列举所有的存取路径，如果你感兴趣可以读一读 Oracle文档。其它数据库里也许叫法不同但背后的概念是一样的。</p></li></ul><h4 id=联结运算符>联结运算符</h4><p>我要展现的是3个个常用联接运算符：合并联接（Merge join），哈希联接（Hash Join）和嵌套循环联接（Nested Loop Join）。但是在此之前，我需要引入新词汇了：内关系和外关系（ inner relation and outer relation）这里的关系可以是：</p><ul><li>一个表</li><li>一个索引</li><li>上一个运算的中间结果（比如上一个联接运算的结果）</li></ul><p>当你联接两个关系时，联接算法对两个关系的处理是不同的。在本文剩余部分，我将假定：</p><ul><li>外关系是左侧数据集</li><li>内关系是右侧数据集</li></ul><p>比如， A JOIN B 是 A 和 B 的联接，这里 A 是外关系，B 是内关系。</p><p>多数情况下， <strong>A JOIN B 的成本跟 B JOIN A 的成本是不同的</strong>。</p><p>在这一部分，我还将假定外关系有 N 个元素，内关系有 M 个元素。要记住，真实的优化器通过统计知道 N 和 M 的值。</p><p>注：N 和 M 是关系的基数。</p><h5 id=嵌套循环查询>嵌套循环查询</h5><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210503152955.png style=display:block;width:50% alt=NAME align=center></div><ul><li>针对外关系的每一行，查看内关系里的所有行来寻找匹配的行。</li></ul><p>伪代码的形式：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#000>nested_loop_join</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>array</span> <span style=color:#000>outer</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>array</span> <span style=color:#000>inner</span><span style=color:#ce5c00;font-weight:700>)</span>
</span></span><span style=display:flex><span>  <span style=color:#204a87;font-weight:700>for</span> <span style=color:#000>each</span> <span style=color:#000>row</span> <span style=color:#000>a</span> <span style=color:#000>in</span> <span style=color:#000>outer</span>
</span></span><span style=display:flex><span>    <span style=color:#204a87;font-weight:700>for</span> <span style=color:#000>each</span> <span style=color:#000>row</span> <span style=color:#000>b</span> <span style=color:#000>in</span> <span style=color:#000>inner</span>
</span></span><span style=display:flex><span>      <span style=color:#000>if</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>match_join_condition</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>a</span><span style=color:#ce5c00;font-weight:700>,</span><span style=color:#000>b</span><span style=color:#ce5c00;font-weight:700>))</span>
</span></span><span style=display:flex><span>        <span style=color:#000>write_result_in_output</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>a</span><span style=color:#ce5c00;font-weight:700>,</span><span style=color:#000>b</span><span style=color:#ce5c00;font-weight:700>)</span>
</span></span><span style=display:flex><span>      <span style=color:#000>end</span> <span style=color:#204a87;font-weight:700>if</span>
</span></span><span style=display:flex><span>    <span style=color:#000>end</span> <span style=color:#204a87;font-weight:700>for</span>
</span></span><span style=display:flex><span>   <span style=color:#000>end</span> <span style=color:#204a87;font-weight:700>for</span>
</span></span></code></pre></div><p>由于这是个双迭代，<strong>时间复杂度是 O(N*M)</strong>。</p><p>在磁盘 I/O 方面， 针对 N 行外关系的每一行，内部循环需要从内关系读取 M 行。这个算法需要从磁盘读取 N+ N*M 行。但是，如果内关系足够小，你可以把它读入内存，那么就只剩下 M + N 次读取。这样修改之后，内关系必须是最小的，因为它有更大机会装入内存。</p><p>在CPU成本方面没有什么区别，但是在磁盘 I/O 方面，最好最好的，是每个关系只读取一次。</p><p>当然，内关系可以由索引代替，对磁盘 I/O 更有利。</p><p>由于这个算法非常简单，下面这个版本在内关系太大无法装入内存时，对磁盘 I/O 更加有利。原因如下：</p><ul><li>为了避免逐行读取两个关系，</li><li>你可以成簇读取，把（两个关系里读到的）两簇数据行保存在内存里，</li><li>比较两簇数据，保留匹配的，</li><li>然后从磁盘加载新的数据簇来继续比较</li><li>直到加载了所有数据。</li></ul><p>可能的算法如下：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8f5902;font-style:italic>// improved version to reduce the disk I/O.
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span><span style=color:#000>nested_loop_join_v2</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>file</span> <span style=color:#000>outer</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>file</span> <span style=color:#000>inner</span><span style=color:#ce5c00;font-weight:700>)</span>
</span></span><span style=display:flex><span>  <span style=color:#204a87;font-weight:700>for</span> <span style=color:#000>each</span> <span style=color:#000>bunch</span> <span style=color:#000>ba</span> <span style=color:#000>in</span> <span style=color:#000>outer</span>
</span></span><span style=display:flex><span>  <span style=color:#8f5902;font-style:italic>// ba is now in memory
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span>    <span style=color:#204a87;font-weight:700>for</span> <span style=color:#000>each</span> <span style=color:#000>bunch</span> <span style=color:#000>bb</span> <span style=color:#000>in</span> <span style=color:#000>inner</span>
</span></span><span style=display:flex><span>        <span style=color:#8f5902;font-style:italic>// bb is now in memory
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span>        <span style=color:#204a87;font-weight:700>for</span> <span style=color:#000>each</span> <span style=color:#000>row</span> <span style=color:#000>a</span> <span style=color:#000>in</span> <span style=color:#000>ba</span>
</span></span><span style=display:flex><span>          <span style=color:#204a87;font-weight:700>for</span> <span style=color:#000>each</span> <span style=color:#000>row</span> <span style=color:#000>b</span> <span style=color:#000>in</span> <span style=color:#000>bb</span>
</span></span><span style=display:flex><span>            <span style=color:#000>if</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>match_join_condition</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>a</span><span style=color:#ce5c00;font-weight:700>,</span><span style=color:#000>b</span><span style=color:#ce5c00;font-weight:700>))</span>
</span></span><span style=display:flex><span>              <span style=color:#000>write_result_in_output</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>a</span><span style=color:#ce5c00;font-weight:700>,</span><span style=color:#000>b</span><span style=color:#ce5c00;font-weight:700>)</span>
</span></span><span style=display:flex><span>            <span style=color:#000>end</span> <span style=color:#204a87;font-weight:700>if</span>
</span></span><span style=display:flex><span>          <span style=color:#000>end</span> <span style=color:#204a87;font-weight:700>for</span>
</span></span><span style=display:flex><span>       <span style=color:#000>end</span> <span style=color:#204a87;font-weight:700>for</span>
</span></span><span style=display:flex><span>    <span style=color:#000>end</span> <span style=color:#204a87;font-weight:700>for</span>
</span></span><span style=display:flex><span>   <span style=color:#000>end</span> <span style=color:#204a87;font-weight:700>for</span>
</span></span></code></pre></div><p><strong>使用这个版本，时间复杂度没有变化，但是磁盘访问降低了</strong>：</p><ul><li>用前一个版本，算法需要 N + N*M 次访问（每次访问读取一行）。</li><li>用新版本，磁盘访问变为 外关系的数据簇数量 + 外关系的数据簇数量 * 内关系的数据簇数量。</li><li>增加数据簇的尺寸，可以降低磁盘访问。</li></ul><h5 id=哈希连接>哈希连接</h5><p>哈希联接更复杂，不过在很多场合比嵌套循环联接成本低。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210503153546.png style=display:block;width:50% alt=NAME align=center></div><p>哈希联接的原理是：</p><ul><li>读取内关系的所有元素</li><li>在内存里建一个哈希表</li><li>逐条读取外关系的所有元素 +（用哈希表的哈希函数）计算每个元素的哈希值，来查找内关系里相关的哈希桶内</li><li>是否与外关系的元素匹配。</li></ul><p>在时间复杂度方面我需要做些假设来简化问题：</p><ul><li>内关系被划分成 X 个哈希桶</li><li>哈希函数几乎均匀地分布每个关系内数据的哈希值，就是说哈希桶大小一致。</li><li>外关系的元素与哈希桶内的所有元素的匹配，成本是哈希桶内元素的数量。</li></ul><p>时间复杂度是 (M/X) * N + 创建哈希表的成本(M) + 哈希函数的成本 * N 。如果哈希函数创建了足够小规模的哈希桶，那么复杂度就是 O(M+N)。</p><p>还有个哈希联接的版本，对内存有利但是对磁盘 I/O 不够有利。 这回是这样的：</p><ul><li>计算内关系和外关系双方的哈希表</li><li>保存哈希表到磁盘</li><li>然后逐个哈希桶比较（其中一个读入内存，另一个逐行读取）。</li></ul><h5 id=合并连接>合并连接</h5><blockquote><p>合并联接是唯一产生排序的联接算法。</p></blockquote><p>注：这个简化的合并联接不区分内表或外表；两个表扮演同样的角色。但是真实的实现方式是不同的，比如当处理重复值时。</p><ul><li>1.（可选）排序联接运算：两个输入源都按照联接关键字排序。</li><li>2.合并联接运算：排序后的输入源合并到一起。</li><li><strong>排序</strong></li></ul><p>我们已经谈到过合并排序，在这里合并排序是个很好的算法（但是并非最好的，如果内存足够用的话，还是哈希联接更好）。</p><p>然而有时数据集已经排序了，比如：</p><ul><li>如果表内部就是有序的，比如联接条件里一个索引组织表(index-organized table)</li><li>如果关系是联接条件里的一个索引</li><li>如果联接应用在一个查询中已经排序的中间结果</li><li><strong>合并联接</strong></li></ul><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210503153852.png style=display:block;width:50% alt=NAME align=center></div><p>这部分与我们研究过的合并排序中的合并运算非常相似。不过这一次呢，我们不是从两个关系里挑选所有元素，而是只挑选相同的元素。道理如下：</p><ul><li>在两个关系中，比较当前元素（当前=头一次出现的第一个）</li><li>如果相同，就把两个元素都放入结果，再比较两个关系里的下一个元素</li><li>如果不同，就去带有最小元素的关系里找下一个元素（因为下一个元素可能会匹配）</li><li>重复 1、2、3步骤直到其中一个关系的最后一个元素。</li></ul><p>因为两个关系都是已排序的，你不需要『回头去找』，所以这个方法是有效的。</p><p>该算法是个简化版，因为它没有处理两个序列中相同数据出现多次的情况（即多重匹配）。真实版本『仅仅』针对本例就更加复杂，所以我才选择简化版。</p><ul><li><p>如果两个关系都已经排序，时间复杂度是 O(N+M)</p></li><li><p>如果两个关系需要排序，时间复杂度是对两个关系排序的成本：O(N<em>Log(N) + M</em>Log(M))</p></li></ul><h5 id=最优算法>最优算法</h5><p>如果有最好的，就没必要弄那么多种类型了。这个问题很难，因为很多因素都要考虑，比如：</p><ul><li><strong>空闲内存</strong>：没有足够的内存的话就跟强大的哈希联接拜拜吧（至少是完全内存中哈希联接）。</li><li><strong>两个数据集的大小</strong>。比如，如果一个大表联接一个很小的表，那么嵌套循环联接就比哈希联接快，因为后者有创建哈希的高昂成本；如果两个表都非常大，那么嵌套循环联接CPU成本就很高昂。</li><li><strong>是否有索引</strong>：有两个 B+树索引的话，聪明的选择似乎是合并联接。</li><li><strong>结果是否需要排序</strong>：即使你用到的是未排序的数据集，你也可能想用成本较高的合并联接（带排序的），因为最终得到排序的结果后，你可以把它和另一个合并联接串起来（或者也许因为查询用 ORDER BY/GROUP BY/DISTINCT 等操作符隐式或显式地要求一个排序结果）。</li><li><strong>关系是否已经排序</strong>：这时候合并联接是最好的候选项。</li><li><strong>联接的类型</strong>：是等值联接（比如 tableA.col1 = tableB.col2 ）？ 还是内联接？外联接？笛卡尔乘积？或者自联接？有些联接在特定环境下是无法工作的。</li><li><strong>数据的分布</strong>：如果联接条件的数据是倾斜的（比如根据姓氏来联接人，但是很多人同姓），用哈希联接将是个灾难，原因是哈希函数将产生分布极不均匀的哈希桶。</li><li>如果你希望联接操作使用<strong>多线程或多进程</strong>。</li></ul><p>想要更详细的信息，可以阅读DB2, ORACLE 或 SQL Server)的文档。</p><h5 id=应用实例>应用实例</h5><p>我们已经研究了 3 种类型的联接操作。现在，比如说我们要联接 5 个表，来获得一个人的全部信息。一个人可以有：</p><ul><li>多个手机号（MOBILES）</li><li>多个邮箱（MAILS）</li><li>多个地址（ADRESSES）</li><li>多个银行账号（BANK_ACCOUNTS）</li></ul><p>换句话说，我们需要用下面的查询快速得到答案：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>SELECT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>*</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>from</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>PERSON</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>MOBILES</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>MAILS</span><span style=color:#000;font-weight:700>,</span><span style=color:#000>ADRESSES</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>BANK_ACCOUNTS</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>WHERE</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#000>PERSON</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>PERSON_ID</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>MOBILES</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>PERSON_ID</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>AND</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>PERSON</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>PERSON_ID</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>MAILS</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>PERSON_ID</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>AND</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>PERSON</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>PERSON_ID</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>ADRESSES</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>PERSON_ID</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>AND</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>PERSON</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>PERSON_ID</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>BANK_ACCOUNTS</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>PERSON_ID</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><p>作为一个查询优化器，我必须找到处理数据最好的方法。但有 2 个问题：</p><ul><li>每个联接使用那种类型？<ul><li>我有 3 种可选（哈希、合并、嵌套），同时可能用到 0, 1 或 2 个索引（不必说还有多种类型的索引）。</li></ul></li><li>按什么顺序执行联接？</li></ul><p>比如，下图显示了针对 4 个表仅仅 3 次联接，可能采用的执行计划：</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210503154121.png style=display:block;width:50% alt=NAME align=center></div><p>现实世界的查询还会有其他关系运算符，像 OUTER JOIN, CROSS JOIN, GROUP BY, ORDER BY, PROJECTION, UNION, INTERSECT, DISTINCT … 这意味着更多的可能性。</p><p><strong>那么，数据库是如何处理的呢</strong>？</p><ul><li>动态规划</li><li>贪心算法</li><li>启发算法</li></ul><p>关系型数据库会尝试我刚刚提到的多种方法，<strong>优化器真正的工作是在有限时间里找到一个好的解决方案</strong>。但多数时候，优化器找到的不是最佳的方案，而是一个『不错』的。</p><h5 id=动态规划>动态规划</h5><blockquote><p>对于小规模的查询，采取粗暴的方式是有可能的。但是为了让中等规模的查询也能采取粗暴的方式，我们有办法避免不必要的计算，这就是动态规划。</p></blockquote><p>这几个字背后的理念是，很多执行计划是非常相似的。看看下图这几种计划：</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210503154314.png style=display:block;width:50% alt=NAME align=center></div><p>它们都有相同的子树（A JOIN B），所以，不必在每个计划中计算这个子树的成本，计算一次，保存结果，当再遇到这个子树时重用。用更正规的说法，我们面对的是个重叠问题。为了避免对部分结果的重复计算，我们使用记忆法。</p><p>应用这一技术，我们不再有 (2*N)!/(N+1)! 的复杂度，而是“只有” 3^N。在之前 4 个JOIN 的例子里，这意味着将 336 次排序降为 81 次。如果是大一些的查询，比如 8 个 JOIN （其实也不是很大啦），就是将 57,657,600 次降为 6551 次。</p><p>针对大规模查询，你也可以用动态规划方法，但是要附加额外的规则（或者称为启发式算法）来减少可能性。</p><ul><li><p>如果我们仅分析一个特定类型的计划（例如左深树 left-deep tree，参考)，我们得到 n*2^n 而不是 3^n。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210503154348.png style=display:block;width:50% alt=NAME align=center></div></li><li><p>如果我们加上逻辑规则来避免一些模式的计划（像『如果一个表有针对指定谓词的索引，就不要对表尝试合并联接，要对索引』），就会在不给最佳方案造成过多伤害的前提下，减少可能性的数量。【译者注：原文应该是有两处笔误： as=has, to=too】</p></li><li><p>如果我们在流程里增加规则（像『联接运算先于其他所有的关系运算』），也能减少大量的可能性。</p></li></ul><h5 id=贪心算法>贪心算法</h5><blockquote><p>但是，优化器面对一个非常大的查询，或者为了尽快找到答案（然而查询速度就快不起来了），会应用另一种算法，叫贪婪算法。</p></blockquote><p>原理是按照一个规则（或启发）以渐进的方式制定查询计划。在这个规则下，贪婪算法逐步寻找最佳算法，先处理一条JOIN，接着每一步按照同样规则加一条新的JOIN。</p><p>我们来看个简单的例子。比如一个针对5张表（A,B,C,D,E）4次JOIN 的查询，为了简化我们把嵌套JOIN作为可能的联接方式，按照『使用最低成本的联接』规则。</p><ul><li>直接从 5 个表里选一个开始（比如 A）</li><li>计算每一个与 A 的联接（A 作为内关系或外关系）</li><li>发现 “A JOIN B” 成本最低</li><li>计算每一个与 “A JOIN B” 的结果联接的成本（“A JOIN B” 作为内关系或外关系）</li><li>发现 “(A JOIN B) JOIN C” 成本最低</li><li>计算每一个与 “(A JOIN B) JOIN C” 的结果联接的成本</li><li>……</li><li>最后确定执行计划 “( ( (A JOIN B) JOIN C) JOIN D ) JOIN E )”</li></ul><p>因为我们是武断地从表 A 开始，我们可以把同样的算法用在 B，然后 C，然后 D, 然后 E。最后保留成本最低的执行计划。</p><p>顺便说一句，这个算法有个名字，叫『最近邻居算法』。</p><p>抛开细节不谈，只需一个良好的模型和一个 N<em>log(N) 复杂度的排序，问题就轻松解决了。这个算法的复杂度是 O(N</em>log(N)) ，对比一下完全动态规划的 O(3^N)。如果你有个20个联接的大型查询，这意味着 26 vs 3,486,784,401 ，天壤之别！</p><p>这个算法的问题是，我们做的假设是：找到 2 个表的最佳联接方法，保留这个联接结果，再联接下一个表，就能得到最低的成本。但是：</p><ul><li>即使在 A, B, C 之间，A JOIN B 可得最低成本</li><li>(A JOIN C) JOIN B 也许比 (A JOIN B) JOIN C 更好。</li></ul><p>为了改善这一状况，你可以多次使用基于不同规则的贪心算法，并保留最佳的执行计划。</p><h5 id=查询计划缓存>查询计划缓存</h5><p>由于创建查询计划是耗时的，大多数据库把计划保存在查询计划缓存，来避免重复计算。这个话题比较大，因为数据库需要知道什么时候更新过时的计划。办法是设置一个上限，如果一个表的统计变化超过了上限，关于该表的查询计划就从缓存中清除。</p><h3 id=查询执行器>查询执行器</h3><p>在这个阶段，我们有了一个优化的执行计划，再编译为可执行代码。然后，如果有足够资源（内存，CPU），查询执行器就会执行它。计划中的操作符 (JOIN, SORT BY …) 可以顺序或并行执行，这取决于执行器。为了获得和写入数据，查询执行器与数据管理器交互，本文下一部分来讨论数据管理器。</p><h2 id=数据管理器-1>数据管理器</h2><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210503154627.png style=display:block;width:50% alt=NAME align=center></div><p>在这一步，查询管理器执行了查询，需要从表和索引获取数据，于是向数据管理器提出请求。但是有 2 个问题：</p><ul><li>关系型数据库使用事务模型，所以，当其他人在同一时刻使用或修改数据时，你无法得到这部分数据。</li><li>数据提取是数据库中速度最慢的操作，所以数据管理器需要足够聪明地获得数据并保存在内存缓冲区内。</li></ul><p>在这一部分，我们看看关系型数据库是如何处理这两个问题的。</p><h3 id=缓存管理器>缓存管理器</h3><p>前文已经说过，数据库的主要瓶颈是磁盘 I/O。为了提高性能，现代数据库使用缓存管理器。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210503154658.png style=display:block;width:50% alt=NAME align=center></div><p>查询执行器不会直接从文件系统拿数据，而是向缓存管理器要。缓存管理器有一个内存缓存区，叫做缓冲池，从内存读取数据显著地提升数据库性能。对此很难给出一个数量级，因为这取决于你需要的是哪种操作：</p><ul><li>顺序访问（比如：全扫描） vs 随机访问（比如：按照row id访问）</li><li>读还是写</li></ul><p>以及数据库使用的磁盘类型：</p><ul><li>7.2k/10k/15k rpm的硬盘</li><li>SSD</li><li>RAID 1/5/…</li></ul><p>要我说，内存比磁盘要快100到10万倍。然而，这导致了另一个问题（数据库总是这样…)，缓存管理器需要在查询执行器使用数据之前得到数据，否则查询管理器不得不等待数据从缓慢的磁盘中读出来。</p><h4 id=预读>预读</h4><p>这个问题叫预读。查询执行器知道它将需要什么数据，因为它了解整个查询流，而且通过统计也了解磁盘上的数据。过程是这样的：</p><ul><li>当查询执行器处理它的第一批数据时，会告诉缓存管理器预先装载第二批数据</li><li>当开始处理第二批数据时，告诉缓存管理器预先装载第三批数据，并且告诉缓存管理器第一批可以从缓存里清掉了。</li><li>……</li></ul><p>缓存管理器在缓冲池里保存所有的这些数据。为了确定一条数据是否有用，缓存管理器给缓存的数据添加了额外的信息（叫闩锁）。</p><p>有时查询执行器不知道它需要什么数据，有的数据库也不提供这个功能。相反，它们使用一种推测预读法（比如：如果查询执行器想要数据1、3、5，它不久后很可能会要 7、9、11），或者顺序预读法（这时候缓存管理器只是读取一批数据后简单地从磁盘加载下一批连续数据）。</p><p>为了监控预读的工作状况，现代数据库引入了一个度量叫缓冲/缓存命中率，用来显示请求的数据在缓存中找到而不是从磁盘读取的频率。</p><p>注：糟糕的缓存命中率不总是意味着缓存工作状态不佳。</p><p>缓冲只是容量有限的内存空间，因此，为了加载新的数据，它需要移除一些数据。加载和清除缓存需要一些磁盘和网络I/O的成本。如果你有个经常执行的查询，那么每次都把查询结果加载然后清除，效率就太低了。现代数据库用缓冲区置换策略来解决这个问题。</p><h4 id=缓冲区置换>缓冲区置换</h4><blockquote><p>多数现代数据库(至少 SQL Server, MySQL, Oracle 和 DB2)使用 LRU 算法。</p></blockquote><p>LRU代表最近最少使用（Least Recently Used）算法，背后的原理是：在缓存里保留的数据是最近使用的，所以更有可能再次使用。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210503154947.png style=display:block;width:50% alt=NAME align=center></div><p>为了更好的理解，我假设缓冲区里的数据没有被闩锁锁住（就是说是可以被移除的）。在这个简单的例子里，缓冲区可以保存 3 个元素：</p><ul><li>1：缓存管理器（简称CM）使用数据1，把它放入空的缓冲区</li><li>2：CM使用数据4，把它放入半载的缓冲区</li><li>3：CM使用数据3，把它放入半载的缓冲区</li><li>4：CM使用数据9，缓冲区满了，所以数据1被清除，因为它是最后一个最近使用的，数据9加入到缓冲区</li><li>5：CM使用数据4，数据4已经在缓冲区了，所以它再次成为第一个最近使用的。</li><li>6：CM使用数据1，缓冲区满了，所以数据9被清除，因为它是最后一个最近使用的，数据1加入到缓冲区</li><li>……</li></ul><p>这个算法效果很好，但是有些限制。<strong>如果对一个大表执行全表扫描怎么办</strong>？换句话说，当表/索引的大小超出缓冲区会发生什么？使用这个算法会清除之前缓存内所有的数据，而且全扫描的数据很可能只使用一次。</p><h4 id=缓冲区置换改进>缓冲区置换：改进</h4><p>为了防止这个现象，有些数据库增加了特殊的规则，比如Oracle文档中的描述：</p><blockquote><p>『对非常大的表来说，数据库通常使用直接路径来读取，即直接加载区块，来避免填满缓冲区。对于中等大小的表，数据库可以使用直接读取或缓存读取。如果选择缓存读取，数据库把区块置于LRU的尾部，防止清空当前缓冲区。』</p></blockquote><p>还有一些可能，比如使用高级版本的LRU，叫做 LRU-K。例如，SQL Server 使用 LRU-2。</p><p>这个算法的原理是把更多的历史记录考虑进来。简单LRU（也就是 LRU-1），只考虑最后一次使用的数据。LRU-K呢：</p><ul><li>考虑数据最后第K次使用的情况</li><li>数据使用的次数加进了权重</li><li>一批新数据加载进入缓存，旧的但是经常使用的数据不会被清除（因为权重更高）</li><li>但是这个算法不会保留缓存中不再使用的数据</li><li>所以数据如果不再使用，权重值随着时间推移而降低</li></ul><p>计算权重是需要成本的，所以SQL Server只是使用 K=2，这个值性能不错而且额外开销可以接受。</p><h4 id=其他算法>其他算法</h4><p>当然还有其他管理缓存的算法，比如：</p><ul><li>2Q（类LRU-K算法）</li><li>CLOCK（类LRU-K算法）</li><li>MRU（最新使用的算法，用LRU同样的逻辑但不同的规则）</li><li>LRFU（Least Recently and Frequently Used，最近最少使用最近最不常用）</li><li>……</li></ul><h4 id=写缓冲区>写缓冲区</h4><p>我只探讨了读缓存 —— 在使用之前预先加载数据。用来保存数据、成批刷入磁盘，而不是逐条写入数据从而造成很多单次磁盘访问。</p><p>要记住，<strong>缓冲区保存的是页（最小的数据单位）而不是行（逻辑上/人类习惯的观察数据的方式）</strong>。缓冲池内的页如果被修改了但还没有写入磁盘，就是脏页。有很多算法来决定写入脏页的最佳时机，但这个问题与事务的概念高度关联，下面我们就谈谈事务。</p><h3 id=事务管理器>事务管理器</h3><p>最后但同样重要的，是事务管理器，我们将看到这个进程是如何保证每个查询在自己的事务内执行的。但开始之前，我们需要理解ACID事务的概念。</p><p>一个ACID事务是一个工作单元，它要保证4个属性：</p><ul><li>原子性（Atomicity）: 事务『要么全部完成，要么全部取消』，即使它持续运行10个小时。如果事务崩溃，状态回到事务之前（事务回滚）。</li><li>一致性（Consistency）: 只有合法的数据（依照关系约束和函数约束）能写入数据库，一致性与原子性和隔离性有关。</li><li>隔离性（Isolation）: 如果2个事务 A 和 B 同时运行，事务 A 和 B 最终的结果是相同的，不管 A 是结束于 B 之前/之后/运行期间。</li><li>持久性（Durability）: 一旦事务提交（也就是成功执行）,不管发生什么（崩溃或者出错），数据要保存在数据库中。</li></ul><p>在同一个事务内，你可以运行多个SQL查询来读取、创建、更新和删除数据。当两个事务使用相同的数据，麻烦就来了。经典的例子是从账户A到账户B的汇款。假设有2个事务：</p><ul><li>事务1（T1）从账户A取出100美元给账户B</li><li>事务2（T2）从账户A取出50美元给账户B</li></ul><p>我们回来看看ACID属性：</p><ul><li>原子性确保不管 T1 期间发生什么（服务器崩溃、网络中断…），你不能出现账户A 取走了100美元但没有给账户B 的现象（这就是数据不一致状态）。</li><li>隔离性确保如果 T1 和 T2 同时发生，最终A将减少150美元，B将得到150美元，而不是其他结果，比如因为 T2 部分抹除了 T1 的行为，A减少150美元而B只得到50美元（这也是不一致状态）。</li><li>持久性确保如果 T1 刚刚提交，数据库就发生崩溃，T1 不会消失得无影无踪。</li><li>一致性确保钱不会在系统内生成或灭失。</li></ul><h3 id=并发控制>并发控制</h3><p>确保隔离性、一致性和原子性的真正问题是<strong>对相同数据的写操作（增、更、删）</strong>：</p><ul><li>如果所有事务只是读取数据，它们可以同时工作，不会更改另一个事务的行为。</li><li>如果（至少）有一个事务在修改其他事务读取的数据，数据库需要找个办法对其它事务隐藏这种修改。而且，它还需要确保这个修改操作不会被另一个看不到这些数据修改的事务擦除。</li></ul><p>这个问题叫<strong>并发控制</strong>。</p><p>最简单的解决办法是依次执行每个事务（即顺序执行），但这样就完全没有伸缩性了，在一个多处理器/多核服务器上只有一个核心在工作，效率很低。</p><ul><li>理想的办法是，每次一个事务创建或取消时：</li><li>监控所有事务的所有操作</li><li>检查是否2个（或更多）事务的部分操作因为读取/修改相同的数据而存在冲突</li><li>重新编排冲突事务中的操作来减少冲突的部分</li><li>按照一定的顺序执行冲突的部分（同时非冲突事务仍然在并发运行）</li><li>考虑事务有可能被取消</li></ul><p>用更正规的说法，这是对冲突的调度问题。更具体点儿说，这是个非常困难而且CPU开销很大的优化问题。企业级数据库无法承担等待几个小时，来寻找每个新事务活动最好的调度，因此就使用不那么理想的方式以避免更多的时间浪费在解决冲突上。</p><h3 id=锁管理器>锁管理器</h3><blockquote><p>为了解决这个问题，多数数据库使用<strong>锁</strong>和/或<strong>数据版本控制</strong>。这是个很大的话题，我会集中探讨锁，和一点点数据版本控制。</p></blockquote><h4 id=悲观锁>悲观锁</h4><h4 id=悲观锁-1>悲观锁</h4><p>原理是：</p><ul><li>如果一个事务需要一条数据,它就把数据锁住</li><li>如果另一个事务也需要这条数据, 它就必须要等第一个事务释放这条数据</li></ul><p>这个锁叫<strong>排他锁</strong>。</p><p>但是对一个仅仅读取数据的事务使用排他锁非常昂贵，因为这会迫使其它只需要读取相同数据的事务等待。因此就有了另一种锁，<strong>共享锁</strong>。</p><p><strong>共享锁是这样的</strong>：</p><ul><li>如果一个事务只需要读取数据A, 它会给数据A加上『共享锁』并读取</li><li>如果第二个事务也需要仅仅读取数据A, 它会给数据A加上『共享锁』并读取</li><li>如果第三个事务需要修改数据A, 它会给数据A加上『排他锁』，但是必须等待另外两个事务释放它们的共享锁。</li></ul><p>同样的，如果一块数据被加上排他锁，一个只需要读取该数据的事务必须等待排他锁释放才能给该数据加上共享锁。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210503155723.png style=display:block;width:50% alt=NAME align=center></div><p>锁管理器是添加和释放锁的进程，在内部用一个哈希表保存锁信息（关键字是被锁的数据），并且了解每一块数据是：</p><ul><li>被哪个事务加的锁</li><li>哪个事务在等待数据解锁</li></ul><h4 id=死锁>死锁</h4><p>但是使用锁会导致一种情况，2个事务永远在等待一块数据：</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210503155747.png style=display:block;width:50% alt=NAME align=center></div><p>在本图中：</p><ul><li>事务A 给 数据1 加上排他锁并且等待获取数据2</li><li>事务B 给 数据2 加上排他锁并且等待获取数据1</li></ul><p>这叫<strong>死锁</strong>。</p><p>在死锁发生时，锁管理器要选择取消（回滚）一个事务，以便消除死锁。这可是个艰难的决定：</p><ul><li>杀死数据修改量最少的事务（这样能减少回滚的成本）？</li><li>杀死持续时间最短的事务，因为其它事务的用户等的时间更长？</li><li>杀死能用更少时间结束的事务（避免可能的资源饥荒）？</li><li>一旦发生回滚，有多少事务会受到回滚的影响？</li></ul><p>在作出选择之前，锁管理器需要检查是否有死锁存在。</p><p>哈希表可以看作是个图表（见上文图），图中出现循环就说明有死锁。由于检查循环是昂贵的（所有锁组成的图表是很庞大的），经常会通过简单的途径解决：<strong>使用超时设定</strong>。如果一个锁在超时时间内没有加上，那事务就进入死锁状态。</p><p>锁管理器也可以在加锁之前检查该锁会不会变成死锁，但是想要完美的做到这一点还是很昂贵的。因此这些预检经常设置一些基本规则。</p><h4 id=两段锁>两段锁</h4><blockquote><p>实现纯粹的隔离最简单的方法是：事务开始时获取锁，结束时释放锁。就是说，事务开始前必须等待确保自己能加上所有的锁，当事务结束时释放自己持有的锁。这是行得通的，但是为了等待所有的锁，大量的时间被浪费了。</p></blockquote><p>更快的方法是<strong>两段锁协议</strong>（Two-Phase Locking Protocol，2PC，由 DB2 和 SQL Server使用），在这里，事务分为两个阶段：</p><ul><li><strong>成长阶段</strong>：事务可以获得锁，但不能释放锁。</li><li><strong>收缩阶段</strong>：事务可以释放锁（对于已经处理完而且不会再次处理的数据），但不能获得新锁。</li></ul><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210503155901.png style=display:block;width:50% alt=NAME align=center></div><p>这两条简单规则背后的过程是：</p><ul><li>释放不再使用的锁，来降低其它事务的等待时间</li><li>防止发生这类情况：事务最初获得的数据，在事务开始后被修改，当事务重新读取该数据时发生不一致。</li></ul><p>这个规则可以很好地工作，但有个例外：如果修改了一条数据、释放了关联的锁后，事务被取消（回滚），而另一个事务读到了修改后的值，但最后这个值却被回滚。为了避免这个问题，<strong>所有独占锁必须在事务结束时释放</strong>。</p><h4 id=版本控制>版本控制</h4><blockquote><p>当然了，真实的数据库使用更复杂的系统，涉及到更多类型的锁（比如意向锁，intention locks）和更多的粒度（行级锁、页级锁、分区锁、表锁、表空间锁），但是思路是相同的。</p></blockquote><p>我只探讨纯粹基于锁的方法，<strong>数据版本控制是解决这个问题的另一个方法</strong>。</p><p>版本控制是这样的：</p><ul><li>每个事务可以在相同时刻修改相同的数据</li><li>每个事务有自己的数据拷贝（或者叫版本）</li><li>如果2个事务修改相同的数据，只接受一个修改，另一个将被拒绝，相关的事务回滚（或重新运行）</li></ul><p>这将提高性能，因为：</p><ul><li>读事务不会阻塞写事务</li><li>写事务不会阻塞读</li><li>没有『臃肿缓慢』的锁管理器带来的额外开销</li></ul><p>除了两个事务写相同数据的时候，数据版本控制各个方面都比锁表现得更好。只不过，你很快就会发现磁盘空间消耗巨大。</p><p><strong>数据版本控制和锁机制是两种不同的见解</strong>：乐观锁和悲观锁。两者各有利弊，完全取决于使用场景（读多还是写多）。</p><blockquote><p>一些数据库，比如DB2（直到版本 9.7）和 SQL Server（不含快照隔离）仅使用锁机制。其他的像PostgreSQL, MySQL 和 Oracle 使用锁和鼠标版本控制混合机制。</p></blockquote><h3 id=日志管理器>日志管理器</h3><p>我们已经知道，为了提升性能，数据库把数据保存在内存缓冲区内。但如果当事务提交时服务器崩溃，崩溃时还在内存里的数据会丢失，这破坏了事务的持久性。你可以把所有数据都写在磁盘上，但是如果服务器崩溃，最终数据可能只有部分写入磁盘，这破坏了事务的原子性。</p><p><strong>事务作出的任何修改必须是或者撤销，或者完成</strong>。</p><p>有 2 个办法解决这个问题：</p><ul><li><strong>影子副本/页（Shadow copies/pages）</strong>：每个事务创建自己的数据库副本（或部分数据库的副本），并基于这个副本来工作。一旦出错，这个副本就被移除；一旦成功，数据库立即使用文件系统的一个把戏，把副本替换到数据中，然后删掉『旧』数据。</li><li><strong>事务日志（Transaction log）</strong>：事务日志是一个存储空间，在每次写盘之前，数据库在事务日志中写入一些信息，这样当事务崩溃或回滚，数据库知道如何移除或完成尚未完成的事务。</li></ul><h4 id=wal预写式日志>WAL（预写式日志）</h4><blockquote><p>影子副本/页在运行较多事务的大型数据库时制造了大量磁盘开销，所以现代数据库使用<strong>事务日志</strong>。事务日志必须保存在<strong>稳定的存储</strong>上，我不会深挖存储技术，但至少RAID磁盘是必须的，以防磁盘故障。</p></blockquote><p>多数数据库（至少是Oracle,SQL Server,DB2,PostgreSQL, MySQL 和SQLite) 使用预写日志协议（Write-Ahead Logging protocol ，WAL）来处理事务日志。WAL协议有 3 个规则：</p><ul><li>每个对数据库的修改都产生一条日志记录，在数据写入磁盘之前日志记录必须写入事务日志。</li><li>日志记录必须按顺序写入；记录 A 发生在记录 B 之前，则 A 必须写在 B 之前。</li><li>当一个事务提交时，在事务成功之前，提交顺序必须写入到事务日志。</li></ul><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210503160352.png style=display:block;width:50% alt=NAME align=center></div><p>这个工作由日志管理器完成。简单的理解就是，日志管理器处于缓存管理器（cache manager）和数据访问管理器（data access manager，负责把数据写入磁盘）之间，每个 update / delete / create / commit / rollback 操作在写入磁盘之前先写入事务日志。这个过程并不简单，原因在于<strong>如何找到写日志的同时保持良好的性能的方法</strong>，如果事务日志写得太慢，整体都会慢下来。</p><h4 id=aries>ARIES</h4><blockquote><p>1992年，IBM 研究人员『发明』了WAL的增强版，叫 ARIES。ARIES 或多或少地在现代数据库中使用，逻辑未必相同，但AIRES背后的概念无处不在。ARIES 代表『数据库恢复原型算法』（Algorithms forRecovery andIsolationExploitingSemantics）。</p></blockquote><p>这个技术要达到一个双重目标：</p><ul><li>写日志的同时保持良好性能</li><li>快速和可靠的数据恢复</li></ul><p>有多个原因让数据库不得不回滚事务：</p><ul><li>因为用户取消</li><li>因为服务器或网络故障</li><li>因为事务破坏了数据库完整性（比如一个列有唯一性约束而事务添加了重复值）</li><li>因为死锁</li></ul><h4 id=日志内容>日志内容</h4><blockquote><p>有时候（比如网络出现故障），数据库可以恢复事务。这怎么可能呢？为了回答这个问题，我们需要了解日志里保存的信息。</p></blockquote><p>事务的<strong>每一个操作（增/删/改）产生一条日志</strong>，由如下内容组成：</p><ul><li>LSN：一个唯一的日志序列号（Log Sequence Number）。LSN是按时间顺序分配的，这意味着如果操作 A 先于操作 B，log A 的 LSN 要比 log B 的 LSN 小。</li><li>TransID：产生操作的事务ID。</li><li>PageID：被修改的数据在磁盘上的位置。磁盘数据的最小单位是页，所以数据的位置就是它所处页的位置。</li><li>PrevLSN：同一个事务产生的上一条日志记录的链接。</li><li>UNDO：取消本次操作的方法。比如，如果操作是一次更新，UNDO将或者保存元素更新前的值/状态（物理UNDO），或者回到原来状态的反向操作（<strong>逻辑UNDO</strong>, 只使用逻辑UNDO，因为处理物理UNDO太过混乱了)。</li><li>REDO：重复本次操作的方法。 同样的，有 2 种方法：或者保存操作后的元素值/状态，或者保存操作本身以便重复。</li><li>…：（供您参考，一个 ARIES 日志还有 2 个字段：UndoNxtLSN 和 Type）。</li></ul><p>磁盘上每个页（保存数据的，不是保存日志的）都记录着最后一个修改该数据操作的LSN。</p><blockquote><p>注：据我所知，只有 PostgreSQL 没有使用UNDO，而是用一个垃圾回收服务来删除旧版本的数据。这个跟 PostgreSQL 对数据版本控制的实现有关。</p></blockquote><p>为了更好的说明这一点，这有一个简单的日志记录演示图，是由查询 “<code>UPDATE FROM PERSON SET AGE = 18;</code>” 产生的:</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210503160551.png style=display:block;width:50% alt=NAME align=center></div><p>每条日志都有一个唯一的LSN，链接在一起的日志属于同一个事务。日志按照时间顺序链接（链接列表的最后一条日志是最后一个操作产生的）。</p><h4 id=日志缓冲区>日志缓冲区</h4><blockquote><p>为了防止写日志成为主要的瓶颈，数据库使用了日志缓冲区。</p></blockquote><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210503160636.png style=display:block;width:50% alt=NAME align=center></div><p>当查询执行器要求做一次修改：</p><ol><li><p>缓存管理器将修改存入自己的缓冲区；</p></li><li><p>日志管理器将相关的日志存入自己的缓冲区；</p></li><li><p>到了这一步，查询执行器认为操作完成了（因此可以请求做另一次修改）；</p></li><li><p>接着（不久以后）日志管理器把日志写入事务日志，什么时候写日志由某算法来决定。</p></li><li><p>接着（不久以后）缓存管理器把修改写入磁盘，什么时候写盘由某算法来决定。</p></li></ol><p><strong>当事务提交，意味着事务每一个操作的5个步骤都完成了</strong>。写事务日志是很快的，因为它只是『在事务日志某处增加一条日志』；而数据写盘就更复杂了，因为要用『能够快速读取的方式写入数据』。</p><h4 id=steal-和-force-策略>STEAL 和 FORCE 策略</h4><blockquote><p>出于性能方面的原因，<strong>第 5 步有可能在提交之后完成</strong>，因为一旦发生崩溃，还有可能用REDO日志恢复事务。这叫做 <strong>NO-FORCE策略</strong>。</p></blockquote><p>数据库可以选择FORCE策略（比如第 5 步在提交之前必须完成）来降低恢复时的负载。</p><p>另一个问题是，<strong>要选择数据是一步步的写入（STEAL策略），还是缓冲管理器需要等待提交命令来一次性全部写入（NO-STEAL策略）</strong>。选择STEAL还是NO-STEAL取决于你想要什么：快速写入但是从 UNDO 日志恢复缓慢，还是快速恢复。</p><p>下面是这些策略对恢复的影响：</p><ul><li><strong>STEAL/NO-FORCE 需要 UNDO 和 REDO: 性能高</strong>，但是日志和恢复过程更复杂 (比如 ARIES)。多数数据库选择这个策略。 注：这是我从多个学术论文和教程里看到的，但并没有看到官方文档里显式说明这一点。</li><li>STEAL/ FORCE 只需要 UNDO.</li><li>NO-STEAL/NO-FORCE 只需要 REDO.</li><li>NO-STEAL/FORCE 什么也不需要: 性能最差，而且需要巨大的内存。</li></ul><h4 id=关于恢复>关于恢复</h4><blockquote><p>Ok，有了不错的日志，我们来用用它们！</p></blockquote><p>假设新来的实习生让数据库崩溃了，你重启了数据库，恢复过程开始了。</p><p>ARIES从崩溃中恢复有三个阶段：</p><ul><li><ol><li><strong>分析阶段</strong>：恢复进程读取全部事务日志，来重建崩溃过程中所发生事情的时间线，决定哪个事务要回滚（所有未提交的事务都要回滚）、崩溃时哪些数据需要写盘。</li></ol></li><li><ol start=2><li><strong>Redo阶段</strong>：这一关从分析中选中的一条日志记录开始，使用 REDO 来将数据库恢复到崩溃之前的状态。</li></ol><ul><li>在REDO阶段，REDO日志按照时间顺序处理（使用LSN）。</li><li>对每一条日志，恢复进程需要读取包含数据的磁盘页LSN。</li><li>如果LSN（磁盘页）>= LSN（日志记录），说明数据已经在崩溃前写到磁盘（但是值已经被日志之后、崩溃之前的某个操作覆盖），所以不需要做什么。</li><li>如果LSN（磁盘页）&lt; LSN（日志记录），那么磁盘上的页将被更新。</li><li>即使将被回滚的事务，REDO也是要做的，因为这样简化了恢复过程（但是我相信现代数据库不会这么做的）。</li></ul></li><li><ol start=3><li><strong>Undo阶段</strong>：这一阶段回滚所有崩溃时未完成的事务。回滚从每个事务的最后一条日志开始，并且按照时间倒序处理UNDO日志（使用日志记录的PrevLSN）。</li></ol></li></ul><p>恢复过程中，事务日志必须留意恢复过程的操作，以便写入磁盘的数据与事务日志相一致。一个解决办法是移除被取消的事务产生的日志记录，但是这个太困难了。相反，ARIES在事务日志中记录补偿日志，来逻辑上删除被取消的事务的日志记录。</p><p>当事务被『手工』取消，或者被锁管理器取消（为了消除死锁），或仅仅因为网络故障而取消，那么分析阶段就不需要了。对于哪些需要 REDO 哪些需要 UNDO 的信息在 2 个内存表中：</p><ul><li>事务表（保存当前所有事务的状态）</li><li>脏页表（保存哪些数据需要写入磁盘）</li></ul><p>当新的事务产生时，这两个表由缓存管理器和事务管理器更新。因为是在内存中，当数据库崩溃时它们也被破坏掉了。</p><p>分析阶段的任务就是在崩溃之后，用事务日志中的信息重建上述的两个表。为了加快分析阶段，ARIES提出了一个概念：<strong>检查点（check point）</strong>，就是不时地把事务表和脏页表的内容，还有此时最后一条LSN写入磁盘。那么在分析阶段当中，只需要分析这个LSN之后的日志即可。</p><h2 id=最后>最后</h2><p>如果你想很好地了解数据库，我推荐这篇研究论文：<a href=https://dsf.berkeley.edu/papers/fntdb07-architecture.pdf>Architecture of a Database System</a>，对数据库有很好的介绍（共110页），而且非计算机专业人士也能读懂。</p><p>所以，当你不得不在问题多多的 NoSQL数据库和坚如磐石的关系型数据库之间抉择的时候，要三思而行。不要误会，某些 NoSQL数据库是很棒的，但是它们毕竟还年轻，只是解决了少量应用关注的一些特定问题。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-5f440bea0444e267ba103fefcd6501d8>1.2 - CH02-设计理论</h1><blockquote><p>本节介绍如何将一个<strong>关系模型</strong>（基于表的数据模型）合理的转化为<strong>数据表</strong>和<strong>关系表</strong>，以及确定<strong>主外健</strong>的。这便是数据库设计理论基础，包括术语，函数依赖，范式等理论基础。</p></blockquote><h2 id=术语>术语</h2><p>关系模型是一种基于表的数据模型，以下为关系学生信息，该表有很多不足之处，本文研究内容就是如何改进它。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210503161015.png style=display:block;width:50% alt=NAME align=center></div><p>下面是一些重要术语：</p><ul><li><strong>属性（attribute）</strong>：列的名字，上图有学号、姓名、班级、兴趣爱好、班主任、课程、授课主任、分数。</li><li><strong>依赖（relation）</strong>：列属性间存在的某种联系。</li><li><strong>元组（tuple）</strong>：每一个行，如第二行 （1301，小明，13班，篮球，王老师，英语，赵英，70） 就是一个元组</li><li><strong>表（table）</strong>：由多个属性，以及众多元组所表示的各个实例组成。</li><li><strong>模式（schema）</strong>：这里我们指逻辑结构，如 学生信息（学号，姓名，班级，兴趣爱好，班主任，课程，授课主任，分数） 的笼统表述。</li><li><strong>域（domain）</strong>：数据类型，如string、integer等，上图中每一个属性都有它的数据类型（即域）。</li><li><strong>键（key）</strong>：由关系的一个或多个属性组成，任意两个键相同的元组，所有属性都相同。需要保证表示键的属性最少。一个关系可以存在好几种键，工程中一般从这些候选键中选出一个作为<strong>主键（primary key）</strong>。</li><li><strong>候选键（prime attribute）</strong>：由关系的一个或多个属性组成，候选键都具备键的特征，都有资格成为主键。</li><li><strong>超键（super key）</strong>：包含键的属性集合，无需保证属性集的最小化。每个键也是超键。可以认为是<strong>键的超集</strong>。</li><li><strong>外键（foreign key）</strong>：如果某一个关系A中的一个（组）属性是另一个关系B的键，则该（组）属性在A中称为外键。</li><li><strong>主属性（prime attribute）</strong>：所有候选键所包含的属性都是主属性。</li><li><strong>投影（projection）</strong>：选取特定的列，如将关系学生信息投影为学号、姓名即得到上表中仅包含学号、姓名的列</li><li><strong>选择（selection）</strong>：按照一定条件选取特定元组，如选择上表中分数>80的元组。</li><li><strong>笛卡儿积（交叉连接Cross join）</strong>：第一个关系每一行分别与第二个关系的每一行组合。</li><li><strong>自然连接（natural join）</strong>：第一个关系中每一行与第二个关系的每一行进行匹配，如果得到有交叉部分则合并，若无交叉部分则舍弃。</li><li><strong>连接（theta join）</strong>：即加上约束条件的笛卡儿积，先得到笛卡儿积，然后根据约束条件删除不满足的元组。</li><li><strong>外连接（outer join）</strong>：执行自然连接后，将舍弃的部分也加入，并且匹配失败处的属性用NULL代替。</li><li><strong>除法运算（division）</strong>：关系R除以关系S的结果为T，则T包含所有在R但不在S中的属性，且T的元组与S的元组的所有组合在R中。</li></ul><h2 id=函数依赖>函数依赖</h2><blockquote><p>通过函数依赖关系，来帮助你确定表中的合理主外健等；这里只是简介，有这么个概念就可以了，因为大多数情况你不用那些所谓的推倒关系，你也是可以凭借<strong>直觉</strong>设计出来的。</p></blockquote><p>记 A->B 表示 A 函数决定 B，也可以说 B 函数依赖于 A。</p><p>如果 {A1，A2，&mldr; ，An} 是关系的一个或多个属性的集合，该集合函数决定了关系的其它所有属性并且是最小的，那么该集合就称为键码。</p><p>对于 A->B，如果能找到 A 的真子集 A&rsquo;，使得 A&rsquo;-> B，那么 A->B 就是部分函数依赖，否则就是完全函数依赖。</p><p>对于 A->B，B->C，则 A->C 是一个传递函数依赖。</p><h2 id=异常>异常</h2><blockquote><p>不符合范式的关系，会产生很多异常，为了引出<strong>范式</strong>的内容。</p></blockquote><p>以下的学生课程关系的函数依赖为 Sno, Cname -> Sname, Sdept, Mname, Grade，键码为 {Sno, Cname}。也就是说，确定学生和课程之后，就能确定其它信息。</p><table><thead><tr><th style=text-align:center>Sno</th><th style=text-align:center>Sname</th><th style=text-align:center>Sdept</th><th style=text-align:center>Mname</th><th style=text-align:center>Cname</th><th style=text-align:center>Grade</th></tr></thead><tbody><tr><td style=text-align:center>1</td><td style=text-align:center>学生-1</td><td style=text-align:center>学院-1</td><td style=text-align:center>院长-1</td><td style=text-align:center>课程-1</td><td style=text-align:center>90</td></tr><tr><td style=text-align:center>2</td><td style=text-align:center>学生-2</td><td style=text-align:center>学院-2</td><td style=text-align:center>院长-2</td><td style=text-align:center>课程-2</td><td style=text-align:center>80</td></tr><tr><td style=text-align:center>2</td><td style=text-align:center>学生-2</td><td style=text-align:center>学院-2</td><td style=text-align:center>院长-2</td><td style=text-align:center>课程-1</td><td style=text-align:center>100</td></tr><tr><td style=text-align:center>3</td><td style=text-align:center>学生-3</td><td style=text-align:center>学院-2</td><td style=text-align:center>院长-2</td><td style=text-align:center>课程-2</td><td style=text-align:center>95</td></tr></tbody></table><p>不符合范式的关系，会产生很多异常，主要有以下四种异常:</p><ul><li>冗余数据: 例如 <code>学生-2</code> 出现了两次。</li><li>修改异常: 修改了一个记录中的信息，但是另一个记录中相同的信息却没有被修改。</li><li>删除异常: 删除一个信息，那么也会丢失其它信息。例如删除了 <code>课程-1</code> 需要删除第一行和第三行，那么 <code>学生-1</code> 的信息就会丢失。</li><li>插入异常: 例如想要插入一个学生的信息，如果这个学生还没选课，那么就无法插入。</li></ul><h2 id=范式>范式</h2><blockquote><p>范式理论是为了解决以上提到四种异常。</p></blockquote><p>高级别范式的依赖于低级别的范式，1NF 是最低级别的范式。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210503161210.png style=display:block;width:50% alt=NAME align=center></div><h3 id=1-第一范式-1nf>1. 第一范式 (1NF)</h3><p>属性不可分。</p><h3 id=2-第二范式-2nf>2. 第二范式 (2NF)</h3><p>每个非主属性完全函数依赖于键码。</p><p>可以通过分解来满足。</p><p><strong>分解前</strong></p><table><thead><tr><th style=text-align:center>Sno</th><th style=text-align:center>Sname</th><th style=text-align:center>Sdept</th><th style=text-align:center>Mname</th><th style=text-align:center>Cname</th><th style=text-align:center>Grade</th></tr></thead><tbody><tr><td style=text-align:center>1</td><td style=text-align:center>学生-1</td><td style=text-align:center>学院-1</td><td style=text-align:center>院长-1</td><td style=text-align:center>课程-1</td><td style=text-align:center>90</td></tr><tr><td style=text-align:center>2</td><td style=text-align:center>学生-2</td><td style=text-align:center>学院-2</td><td style=text-align:center>院长-2</td><td style=text-align:center>课程-2</td><td style=text-align:center>80</td></tr><tr><td style=text-align:center>2</td><td style=text-align:center>学生-2</td><td style=text-align:center>学院-2</td><td style=text-align:center>院长-2</td><td style=text-align:center>课程-1</td><td style=text-align:center>100</td></tr><tr><td style=text-align:center>3</td><td style=text-align:center>学生-3</td><td style=text-align:center>学院-2</td><td style=text-align:center>院长-2</td><td style=text-align:center>课程-2</td><td style=text-align:center>95</td></tr></tbody></table><p>以上学生课程关系中，{Sno, Cname} 为键码，有如下函数依赖:</p><ul><li>Sno -> Sname, Sdept</li><li>Sdept -> Mname</li><li>Sno, Cname-> Grade</li></ul><p>Grade 完全函数依赖于键码，它没有任何冗余数据，每个学生的每门课都有特定的成绩。</p><p>Sname, Sdept 和 Mname 都部分依赖于键码，当一个学生选修了多门课时，这些数据就会出现多次，造成大量冗余数据。</p><p><strong>分解后</strong></p><p>关系-1</p><table><thead><tr><th style=text-align:center>Sno</th><th style=text-align:center>Sname</th><th style=text-align:center>Sdept</th><th style=text-align:center>Mname</th></tr></thead><tbody><tr><td style=text-align:center>1</td><td style=text-align:center>学生-1</td><td style=text-align:center>学院-1</td><td style=text-align:center>院长-1</td></tr><tr><td style=text-align:center>2</td><td style=text-align:center>学生-2</td><td style=text-align:center>学院-2</td><td style=text-align:center>院长-2</td></tr><tr><td style=text-align:center>3</td><td style=text-align:center>学生-3</td><td style=text-align:center>学院-2</td><td style=text-align:center>院长-2</td></tr></tbody></table><p>有以下函数依赖:</p><ul><li>Sno -> Sname, Sdept</li><li>Sdept -> Mname</li></ul><p>关系-2</p><table><thead><tr><th style=text-align:center>Sno</th><th style=text-align:center>Cname</th><th style=text-align:center>Grade</th></tr></thead><tbody><tr><td style=text-align:center>1</td><td style=text-align:center>课程-1</td><td style=text-align:center>90</td></tr><tr><td style=text-align:center>2</td><td style=text-align:center>课程-2</td><td style=text-align:center>80</td></tr><tr><td style=text-align:center>2</td><td style=text-align:center>课程-1</td><td style=text-align:center>100</td></tr><tr><td style=text-align:center>3</td><td style=text-align:center>课程-2</td><td style=text-align:center>95</td></tr></tbody></table><p>有以下函数依赖:</p><ul><li>Sno, Cname -> Grade</li></ul><h3 id=3-第三范式-3nf>3. 第三范式 (3NF)</h3><p>非主属性不传递函数依赖于键码。</p><p>上面的 关系-1 中存在以下传递函数依赖:</p><ul><li>Sno -> Sdept -> Mname</li></ul><p>可以进行以下分解:</p><p>关系-11</p><table><thead><tr><th style=text-align:center>Sno</th><th style=text-align:center>Sname</th><th style=text-align:center>Sdept</th></tr></thead><tbody><tr><td style=text-align:center>1</td><td style=text-align:center>学生-1</td><td style=text-align:center>学院-1</td></tr><tr><td style=text-align:center>2</td><td style=text-align:center>学生-2</td><td style=text-align:center>学院-2</td></tr><tr><td style=text-align:center>3</td><td style=text-align:center>学生-3</td><td style=text-align:center>学院-2</td></tr></tbody></table><p>关系-12</p><table><thead><tr><th style=text-align:center>Sdept</th><th style=text-align:center>Mname</th></tr></thead><tbody><tr><td style=text-align:center>学院-1</td><td style=text-align:center>院长-1</td></tr><tr><td style=text-align:center>学院-2</td><td style=text-align:center>院长-2</td></tr></tbody></table><blockquote><p>更多细节：<a href=https://blog.csdn.net/calcular/article/details/79332453>关系数据库设计理论</a></p></blockquote></div><div class=td-content style=page-break-before:always><h1 id=pg-a9b9d58ba7418e7426e97d813794b4a4>1.3 - CH03-设计流程</h1><blockquote><p><a href=https://www.pdai.tech/md/db/sql/sql-db-theory-design.html>https://www.pdai.tech/md/db/sql/sql-db-theory-design.html</a></p></blockquote></div><div class=td-content style=page-break-before:always><h1 id=pg-17a8347e6e10342607180b4d34ede039>1.4 - CH04-核心知识</h1><h2 id=事务>事务</h2><h3 id=概念>概念</h3><p>事务指的是满足 ACID 特性的一组操作，可以通过 Commit 提交一个事务，也可以使用 Rollback 进行回滚。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210503161528.png style=display:block;width:50% alt=NAME align=center></div><h3 id=acid>ACID</h3><ul><li>原子性：Atomicity<ul><li>事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚。</li><li>回滚可以用日志来实现，日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。</li></ul></li><li>一致性：Consistency<ul><li>数据库在事务执行前后都保持一致性状态。在一致性状态下，所有事务对一个数据的读取结果都是相同的。</li></ul></li><li>隔离性：Isolation<ul><li>一个事务所做的修改在最终提交以前，对其它事务是不可见的。</li></ul></li><li>持久性：Durability<ul><li>一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。</li><li>可以通过数据库备份和恢复来实现，在系统发生崩溃时，使用备份的数据库进行数据恢复。</li></ul></li></ul><p>事务的 ACID 特性概念简单，但不是很好理解，主要是因为这几个特性不是一种平级关系:</p><ul><li>只有满足一致性，事务的执行结果才是正确的。</li><li>在无并发的情况下，事务串行执行，隔离性一定能够满足。此时只要能满足原子性，就一定能满足一致性。</li><li>在并发的情况下，多个事务并行执行，事务不仅要满足原子性，还需要满足隔离性，才能满足一致性。</li><li>事务满足持久化是为了能应对数据库崩溃的情况。</li></ul><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210503161752.png style=display:block;width:50% alt=NAME align=center></div><h3 id=autocommit>AUTOCOMMIT</h3><p>MySQL 默认采用自动提交模式。也就是说，如果不显式使用<code>START TRANSACTION</code>语句来开始一个事务，那么每个查询都会被当做一个事务自动提交。</p><h2 id=并发一致性>并发一致性</h2><p>在并发环境下，事务的隔离性很难保证，因此会出现很多并发一致性问题。</p><ul><li><p>产生并发不一致性问题主要原因是破坏了事务的隔离性，解决方法是通过并发控制来保证隔离性。</p></li><li><p>并发控制可以通过封锁来实现，但是封锁操作需要用户自己控制，相当复杂。</p></li><li><p>数据库管理系统提供了事务的隔离级别，让用户以一种更轻松的方式处理并发一致性问题。</p></li></ul><h3 id=丢失修改>丢失修改</h3><p>T1 和 T2 两个事务都对一个数据进行修改，T1 先修改，T2 随后修改，T2 的修改覆盖了 T1 的修改。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210503161851.png style=display:block;width:50% alt=NAME align=center></div><h3 id=脏读>脏读</h3><p>T1 修改一个数据，T2 随后读取这个数据。如果 T1 撤销了这次修改，那么 T2 读取的数据是脏数据。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210503161930.png style=display:block;width:50% alt=NAME align=center></div><h3 id=不可重复读>不可重复读</h3><p>T2 读取一个数据，T1 对该数据做了修改。如果 T2 再次读取这个数据，此时读取的结果和第一次读取的结果不同。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210503161952.png style=display:block;width:50% alt=NAME align=center></div><h3 id=幻读>幻读</h3><p>T1 读取某个范围的数据，T2 在这个范围内插入新的数据，T1 再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210503162018.png style=display:block;width:50% alt=NAME align=center></div><h2 id=封锁>封锁</h2><h3 id=封锁粒度>封锁粒度</h3><p>MySQL 中提供了两种封锁粒度: <strong>行级锁以及表级锁</strong>。</p><ul><li><p>应该尽量只锁定需要修改的那部分数据，而不是所有的资源。</p><ul><li>锁定的数据量越少，发生锁争用的可能就越小，系统的并发程度就越高。</li></ul></li><li><p>但是加锁需要消耗资源，锁的各种操作(包括获取锁、释放锁、以及检查锁状态)都会增加系统开销。</p><ul><li>因此封锁粒度越小，系统开销就越大。</li></ul></li></ul><p>在选择封锁粒度时，需要在锁开销和并发程度之间做一个权衡。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210503162201.png style=display:block;width:50% alt=NAME align=center></div><h3 id=封锁类型>封锁类型</h3><h4 id=读写锁>读写锁</h4><ul><li>排它锁(Exclusive)，简写为 X 锁，又称写锁。</li><li>共享锁(Shared)，简写为 S 锁，又称读锁。</li></ul><p>有以下两个规定:</p><ul><li>一个事务对数据对象 A 加了 X 锁，就可以对 A 进行读取和更新。加锁期间其它事务不能对 A 加任何锁。</li><li>一个事务对数据对象 A 加了 S 锁，可以对 A 进行读取操作，但是不能进行更新操作。加锁期间其它事务能对 A 加 S 锁，但是不能加 X 锁。</li></ul><p>锁的兼容关系如下:</p><table><thead><tr><th style=text-align:center>-</th><th style=text-align:center>X</th><th style=text-align:center>S</th></tr></thead><tbody><tr><td style=text-align:center>X</td><td style=text-align:center>×</td><td style=text-align:center>×</td></tr><tr><td style=text-align:center>S</td><td style=text-align:center>×</td><td style=text-align:center>√</td></tr></tbody></table><h4 id=意向锁>意向锁</h4><p>使用意向锁(Intention Locks)可以更容易地支持多粒度封锁。</p><p>在存在行级锁和表级锁的情况下，事务 T 想要对表 A 加 X 锁，就需要先检测是否有其它事务对表 A 或者表 A 中的任意一行加了锁，那么就需要对表 A 的每一行都检测一次，这是非常耗时的。</p><p>意向锁在原来的 X/S 锁之上引入了 IX/IS，IX/IS 都是表锁，用来表示一个事务想要在表中的某个数据行上加 X 锁或 S 锁。有以下两个规定:</p><ul><li>一个事务在获得某个数据行对象的 S 锁之前，必须先获得表的 IS 锁或者更强的锁；</li><li>一个事务在获得某个数据行对象的 X 锁之前，必须先获得表的 IX 锁。</li></ul><p>通过引入意向锁，事务 T 想要对表 A 加 X 锁，只需要先检测是否有其它事务对表 A 加了 X/IX/S/IS 锁，如果加了就表示有其它事务正在使用这个表或者表中某一行的锁，因此事务 T 加 X 锁失败。</p><p>各种锁的兼容关系如下:</p><table><thead><tr><th style=text-align:center>-</th><th style=text-align:center>X</th><th style=text-align:center>IX</th><th style=text-align:center>S</th><th style=text-align:center>IS</th></tr></thead><tbody><tr><td style=text-align:center>X</td><td style=text-align:center>×</td><td style=text-align:center>×</td><td style=text-align:center>×</td><td style=text-align:center>×</td></tr><tr><td style=text-align:center>IX</td><td style=text-align:center>×</td><td style=text-align:center>√</td><td style=text-align:center>×</td><td style=text-align:center>√</td></tr><tr><td style=text-align:center>S</td><td style=text-align:center>×</td><td style=text-align:center>×</td><td style=text-align:center>√</td><td style=text-align:center>√</td></tr><tr><td style=text-align:center>IS</td><td style=text-align:center>×</td><td style=text-align:center>√</td><td style=text-align:center>√</td><td style=text-align:center>√</td></tr></tbody></table><p>解释如下:</p><ul><li>任意 IS/IX 锁之间都是兼容的，因为它们只是表示想要对表加锁，而不是真正加锁；</li><li>S 锁只与 S 锁和 IS 锁兼容，也就是说事务 T 想要对数据行加 S 锁，其它事务可以已经获得对表或者表中的行的 S 锁。</li></ul><h3 id=封锁协议>封锁协议</h3><h4 id=三级封锁协议>三级封锁协议</h4><p><strong>一级封锁协议</strong></p><p>事务 T 要修改数据 A 时必须加 X 锁，直到 T 结束才释放锁。</p><p>可以解决丢失修改问题，因为不能同时有两个事务对同一个数据进行修改，那么事务的修改就不会被覆盖。</p><table><thead><tr><th style=text-align:center>T1</th><th style=text-align:center>T2</th></tr></thead><tbody><tr><td style=text-align:center>lock-x(A)</td><td style=text-align:center></td></tr><tr><td style=text-align:center>read A=20</td><td style=text-align:center></td></tr><tr><td style=text-align:center></td><td style=text-align:center>lock-x(A)</td></tr><tr><td style=text-align:center></td><td style=text-align:center>wait</td></tr><tr><td style=text-align:center>write A=19</td><td style=text-align:center>.</td></tr><tr><td style=text-align:center>commit</td><td style=text-align:center>.</td></tr><tr><td style=text-align:center>unlock-x(A)</td><td style=text-align:center>.</td></tr><tr><td style=text-align:center></td><td style=text-align:center>obtain</td></tr><tr><td style=text-align:center></td><td style=text-align:center>read A=19</td></tr><tr><td style=text-align:center></td><td style=text-align:center>write A=21</td></tr><tr><td style=text-align:center></td><td style=text-align:center>commit</td></tr><tr><td style=text-align:center></td><td style=text-align:center>unlock-x(A)</td></tr></tbody></table><p><strong>二级封锁协议</strong></p><p>在一级的基础上，要求读取数据 A 时必须加 S 锁，读取完马上释放 S 锁。</p><p>可以解决读脏数据问题，因为如果一个事务在对数据 A 进行修改，根据 1 级封锁协议，会加 X 锁，那么就不能再加 S 锁了，也就是不会读入数据。</p><table><thead><tr><th style=text-align:center>T1</th><th style=text-align:center>T2</th></tr></thead><tbody><tr><td style=text-align:center>lock-x(A)</td><td style=text-align:center></td></tr><tr><td style=text-align:center>read A=20</td><td style=text-align:center></td></tr><tr><td style=text-align:center>write A=19</td><td style=text-align:center></td></tr><tr><td style=text-align:center></td><td style=text-align:center>lock-s(A)</td></tr><tr><td style=text-align:center></td><td style=text-align:center>wait</td></tr><tr><td style=text-align:center>rollback</td><td style=text-align:center>.</td></tr><tr><td style=text-align:center>A=20</td><td style=text-align:center>.</td></tr><tr><td style=text-align:center>unlock-x(A)</td><td style=text-align:center>.</td></tr><tr><td style=text-align:center></td><td style=text-align:center>obtain</td></tr><tr><td style=text-align:center></td><td style=text-align:center>read A=20</td></tr><tr><td style=text-align:center></td><td style=text-align:center>commit</td></tr><tr><td style=text-align:center></td><td style=text-align:center>unlock-s(A)</td></tr></tbody></table><p><strong>三级封锁协议</strong></p><p>在二级的基础上，要求读取数据 A 时必须加 S 锁，直到事务结束了才能释放 S 锁。</p><p>可以解决不可重复读的问题，因为读 A 时，其它事务不能对 A 加 X 锁，从而避免了在读的期间数据发生改变。</p><table><thead><tr><th style=text-align:center>T1</th><th style=text-align:center>T2</th></tr></thead><tbody><tr><td style=text-align:center>lock-s(A)</td><td style=text-align:center></td></tr><tr><td style=text-align:center>read A=20</td><td style=text-align:center></td></tr><tr><td style=text-align:center></td><td style=text-align:center>lock-x(A)</td></tr><tr><td style=text-align:center></td><td style=text-align:center>wait</td></tr><tr><td style=text-align:center>read A=20</td><td style=text-align:center>.</td></tr><tr><td style=text-align:center>commit</td><td style=text-align:center>.</td></tr><tr><td style=text-align:center>unlock-s(A)</td><td style=text-align:center>.</td></tr><tr><td style=text-align:center></td><td style=text-align:center>obtain</td></tr><tr><td style=text-align:center></td><td style=text-align:center>read A=20</td></tr><tr><td style=text-align:center></td><td style=text-align:center>write A=19</td></tr><tr><td style=text-align:center></td><td style=text-align:center>commit</td></tr><tr><td style=text-align:center></td><td style=text-align:center>unlock-X(A)</td></tr></tbody></table><h4 id=两段锁协议>两段锁协议</h4><p>加锁和解锁分为两个阶段进行。</p><p>可串行化调度是指，通过并发控制，使得并发执行的事务结果与某个串行执行的事务结果相同。</p><p>事务遵循两段锁协议是保证可串行化调度的充分条件。例如以下操作满足两段锁协议，它是可串行化调度。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-html data-lang=html><span style=display:flex><span>lock-x(A)...lock-s(B)...lock-s(C)...unlock(A)...unlock(C)...unlock(B)
</span></span></code></pre></div><p>但不是必要条件，例如以下操作不满足两段锁协议，但是它还是可串行化调度。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-html data-lang=html><span style=display:flex><span>lock-x(A)...unlock(A)...lock-s(B)...unlock(B)...lock-s(C)...unlock(C)
</span></span></code></pre></div><h3 id=mysql隐式显式锁定>MySQL：隐式/显式锁定</h3><p>MySQL 的 InnoDB 存储引擎采用两段锁协议，会根据隔离级别在需要的时候自动加锁，并且所有的锁都是在同一时刻被释放，这被称为隐式锁定。</p><p>InnoDB 也可以使用特定的语句进行显示锁定:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>SELECT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>...</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>LOCK</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>In</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>SHARE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>MODE</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>SELECT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>...</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>FOR</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>UPDATE</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><h2 id=隔离级别>隔离级别</h2><ul><li>未提交读：Read Uncommitted<ul><li>事务中的修改，即使没有提交，对其它事务也是可见的。</li></ul></li><li>提交读：Read Committed<ul><li>一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。</li></ul></li><li>可重复读：Repeatable Read<ul><li>保证在同一个事务中多次读取同样数据的结果是一样的。</li></ul></li><li>可串行化：Serializable<ul><li>强制事务串行执行。</li></ul></li></ul><hr><table><thead><tr><th style=text-align:center>隔离级别</th><th style=text-align:center>脏读</th><th style=text-align:center>不可重复读</th><th style=text-align:center>幻影读</th></tr></thead><tbody><tr><td style=text-align:center>未提交读</td><td style=text-align:center>√</td><td style=text-align:center>√</td><td style=text-align:center>√</td></tr><tr><td style=text-align:center>提交读</td><td style=text-align:center>×</td><td style=text-align:center>√</td><td style=text-align:center>√</td></tr><tr><td style=text-align:center>可重复读</td><td style=text-align:center>×</td><td style=text-align:center>×</td><td style=text-align:center>√</td></tr><tr><td style=text-align:center>可串行化</td><td style=text-align:center>×</td><td style=text-align:center>×</td><td style=text-align:center>×</td></tr></tbody></table><h2 id=多版本并发控制>多版本并发控制</h2><p>多版本并发控制(Multi-Version Concurrency Control, MVCC)是 MySQL 的 InnoDB 存储引擎实现隔离级别的一种具体方式，用于实现提交读和可重复读这两种隔离级别。而未提交读隔离级别总是读取最新的数据行，无需使用 MVCC。可串行化隔离级别需要对所有读取的行都加锁，单纯使用 MVCC 无法实现。</p><h3 id=版本号>版本号</h3><ul><li>系统版本号: 是一个递增的数字，每开始一个新的事务，系统版本号就会自动递增。</li><li>事务版本号: 事务开始时的系统版本号。</li></ul><h3 id=隐藏的列>隐藏的列</h3><p>MVCC 在每行记录后面都保存着两个隐藏的列，用来存储两个版本号:</p><ul><li>创建版本号: 指示创建一个数据行的快照时的系统版本号；</li><li>删除版本号: 如果该快照的删除版本号大于当前事务版本号表示该快照有效，否则表示该快照已经被删除了。</li></ul><h3 id=undo-日志>Undo 日志</h3><p>MVCC 使用到的快照存储在 Undo 日志中，该日志通过回滚指针把一个数据行(Record)的所有快照连接起来。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210503162944.png style=display:block;width:50% alt=NAME align=center></div><h3 id=实现过程>实现过程</h3><p>以下实现过程针对可重复读隔离级别。</p><p>当开始新一个事务时，该事务的版本号肯定会大于当前所有数据行快照的创建版本号，理解这一点很关键。</p><h4 id=1-select>1. SELECT</h4><p>多个事务必须读取到同一个数据行的快照，并且这个快照是距离现在最近的一个有效快照。但是也有例外，如果有一个事务正在修改该数据行，那么它可以读取事务本身所做的修改，而不用和其它事务的读取结果一致。</p><p>把没有对一个数据行做修改的事务称为 T，T 所要读取的数据行快照的创建版本号必须小于 T 的版本号，因为如果大于或者等于 T 的版本号，那么表示该数据行快照是其它事务的最新修改，因此不能去读取它。除此之外，T 所要读取的数据行快照的删除版本号必须大于 T 的版本号，因为如果小于等于 T 的版本号，那么表示该数据行快照是已经被删除的，不应该去读取它。</p><h4 id=2-insert>2. INSERT</h4><p>将当前系统版本号作为数据行快照的创建版本号。</p><h4 id=3-delete>3. DELETE</h4><p>将当前系统版本号作为数据行快照的删除版本号。</p><h4 id=4-update>4. UPDATE</h4><p>将当前系统版本号作为更新前的数据行快照的删除版本号，并将当前系统版本号作为更新后的数据行快照的创建版本号。可以理解为先执行 DELETE 后执行 INSERT。</p><h3 id=快照读与当前读>快照读与当前读</h3><h4 id=1-快照读>1. 快照读</h4><p>使用 MVCC 读取的是快照中的数据，这样可以减少加锁所带来的开销。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>select</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>*</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>from</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>table</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>...;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><h4 id=2-当前读>2. 当前读</h4><p>读取的是最新的数据，需要加锁。以下第一个语句需要加 S 锁，其它都需要加 X 锁。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>select</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>*</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>from</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>table</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>where</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>?</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>lock</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>in</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>share</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>mode</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>select</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>*</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>from</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>table</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>where</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>?</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>for</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>update</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>insert</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>update</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>delete</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><h2 id=next-key-locks>Next-Key Locks</h2><p>Next-Key Locks 是 MySQL 的 InnoDB 存储引擎的一种锁实现。</p><p>MVCC 不能解决幻读的问题，Next-Key Locks 就是为了解决这个问题而存在的。在可重复读(REPEATABLE READ)隔离级别下，使用 MVCC + Next-Key Locks 可以解决幻读问题。</p><h3 id=record-locks>Record Locks</h3><p>锁定一个记录上的索引，而不是记录本身。</p><p>如果表没有设置索引，InnoDB 会自动在主键上创建隐藏的聚簇索引，因此 Record Locks 依然可以使用。</p><h3 id=gap-locks>Gap Locks</h3><p>锁定索引之间的间隙，但是不包含索引本身。例如当一个事务执行以下语句，其它事务就不能在 t.c 中插入 15。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>SELECT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>c</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>FROM</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>t</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>WHERE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>c</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>BETWEEN</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#0000cf;font-weight:700>10</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>and</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#0000cf;font-weight:700>20</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>FOR</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>UPDATE</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><h3 id=next-key-locks-1>Next-Key Locks</h3><p>它是 Record Locks 和 Gap Locks 的结合，不仅锁定一个记录上的索引，也锁定索引之间的间隙。例如一个索引包含以下值: 10, 11, 13, and 20，那么就需要锁定以下区间:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#000;font-weight:700>(</span><span style=color:#000>negative</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>infinity</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#0000cf;font-weight:700>10</span><span style=color:#000;font-weight:700>]</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>10</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#0000cf;font-weight:700>11</span><span style=color:#000;font-weight:700>]</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>11</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#0000cf;font-weight:700>13</span><span style=color:#000;font-weight:700>]</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>13</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#0000cf;font-weight:700>20</span><span style=color:#000;font-weight:700>]</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>20</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>positive</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>infinity</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div></div><div class=td-content style=page-break-before:always><h1 id=pg-4885df7df9d3b6d8eeec5ee8188100ae>2 - JDBC</h1><div class="pageinfo pageinfo-primary"><p>JDBC 4.2 Specification</p></div></div><div class=td-content style=page-break-before:always><h1 id=pg-52b3784f2c0fc27209a7dfce796a520a>3 - SQL</h1></div><div class=td-content><h1 id=pg-6b3f5552bcb7e8d7e392d0c4f28a8929>3.1 - CH01-语法基础</h1><h2 id=开始>开始</h2><p>Schema 定义了数据如何存储、存储什么样的数据以及数据如何分解等信息，数据库和表都有模式。</p><p>主键的值不允许修改，也不允许复用(不能使用已经删除的主键值赋给新数据行的主键)。</p><p>SQL(Structured Query Language)，标准 SQL 由 ANSI 标准委员会管理，从而称为 ANSI SQL。各个 DBMS 都有自己的实现，如 PL/SQL、Transact-SQL 等。</p><p>SQL 语句不区分大小写，但是数据库表名、列名和值是否区分依赖于具体的 DBMS 以及配置。</p><p>SQL 支持以下三种注释:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#ce5c00;font-weight:700>#</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#a40000>注释</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>SELECT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>*</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>FROM</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>mytable</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#8f5902;font-style:italic>-- 注释
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span><span style=color:#8f5902;font-style:italic>/* 注释1
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>   注释2 */</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><p>数据库创建与使用:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>CREATE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>DATABASE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>test</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#000>USE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>test</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><h2 id=创建表>创建表</h2><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>CREATE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>TABLE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>mytable</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>(</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#000>id</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87>INT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>NOT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>NULL</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>AUTO_INCREMENT</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#000>col1</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87>INT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>NOT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>NULL</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>DEFAULT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#000>col2</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87>VARCHAR</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>45</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>NULL</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#000>col3</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87>DATE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>NULL</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>PRIMARY</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>KEY</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>(</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>id</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000;font-weight:700>));</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><h2 id=修改表>修改表</h2><p>添加列</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>ALTER</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>TABLE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>mytable</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>ADD</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>col</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87>CHAR</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>20</span><span style=color:#000;font-weight:700>);</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><p>删除列</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>ALTER</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>TABLE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>mytable</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>DROP</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>COLUMN</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>col</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><p>删除表</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>DROP</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>TABLE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>mytable</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><h2 id=插入>插入</h2><p>普通插入</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>INSERT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>INTO</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>mytable</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>col1</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>col2</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>VALUES</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>val1</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>val2</span><span style=color:#000;font-weight:700>);</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><p>插入检索出来的数据</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>INSERT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>INTO</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>mytable1</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>col1</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>col2</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>SELECT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>col1</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>col2</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>FROM</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>mytable2</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><p>将一个表的内容插入到一个新表</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>CREATE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>TABLE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>newtable</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>AS</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>SELECT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>*</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>FROM</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>mytable</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><h2 id=更新>更新</h2><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>UPDATE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>mytable</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>SET</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>col</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>val</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>WHERE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>id</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><h2 id=删除>删除</h2><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>DELETE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>FROM</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>mytable</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>WHERE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>id</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><p><strong>TRUNCATE TABLE</strong> 可以清空表，也就是删除所有行。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>TRUNCATE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>TABLE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>mytable</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><p>使用更新和删除操作时一定要用 WHERE 子句，不然会把整张表的数据都破坏。可以先用 SELECT 语句进行测试，防止错误删除。</p><h2 id=查询>查询</h2><h3 id=distinct>DISTINCT</h3><p>相同值只会出现一次。它作用于所有列，也就是说所有列的值都相同才算相同。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>SELECT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>DISTINCT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>col1</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>col2</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>FROM</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>mytable</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><h3 id=limit>LIMIT</h3><p>限制返回的行数。可以有两个参数，第一个参数为起始行，从 0 开始；第二个参数为返回的总行数。</p><p>返回前 5 行:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>SELECT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>*</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>FROM</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>mytable</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>LIMIT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#0000cf;font-weight:700>5</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>SELECT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>*</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>FROM</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>mytable</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>LIMIT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#0000cf;font-weight:700>0</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#0000cf;font-weight:700>5</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><p>返回第 3 ~ 5 行:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>SELECT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>*</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>FROM</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>mytable</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>LIMIT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#0000cf;font-weight:700>2</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#0000cf;font-weight:700>3</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><h2 id=排序>排序</h2><ul><li><strong>ASC</strong> : 升序(默认)</li><li><strong>DESC</strong> : 降序</li></ul><p>可以按多个列进行排序，并且为每个列指定不同的排序方式:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>SELECT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>*</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>FROM</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>mytable</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>ORDER</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>BY</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>col1</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>DESC</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>col2</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>ASC</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><h2 id=过滤>过滤</h2><p>不进行过滤的数据非常大，导致通过网络传输了多余的数据，从而浪费了网络带宽。因此尽量使用 SQL 语句来过滤不必要的数据，而不是传输所有的数据到客户端中然后由客户端进行过滤。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>SELECT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>*</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>FROM</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>mytable</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>WHERE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>col</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>IS</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>NULL</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><p>下表显示了 WHERE 子句可用的操作符</p><table><thead><tr><th style=text-align:center>操作符</th><th style=text-align:center>说明</th></tr></thead><tbody><tr><td style=text-align:center>=</td><td style=text-align:center>等于</td></tr><tr><td style=text-align:center>&lt;</td><td style=text-align:center>小于</td></tr><tr><td style=text-align:center>></td><td style=text-align:center>大于</td></tr><tr><td style=text-align:center>&lt;> !=</td><td style=text-align:center>不等于</td></tr><tr><td style=text-align:center>&lt;= !></td><td style=text-align:center>小于等于</td></tr><tr><td style=text-align:center>>= !&lt;</td><td style=text-align:center>大于等于</td></tr><tr><td style=text-align:center>BETWEEN</td><td style=text-align:center>在两个值之间</td></tr><tr><td style=text-align:center>IS NULL</td><td style=text-align:center>为 NULL 值</td></tr></tbody></table><p>应该注意到，NULL 与 0、空字符串都不同。</p><p><strong>AND 和 OR</strong> 用于连接多个过滤条件。优先处理 AND，当一个过滤表达式涉及到多个 AND 和 OR 时，可以使用 () 来决定优先级，使得优先级关系更清晰。</p><p><strong>IN</strong> 操作符用于匹配一组值，其后也可以接一个 SELECT 子句，从而匹配子查询得到的一组值。</p><p><strong>NOT</strong> 操作符用于否定一个条件。</p><h2 id=通配符>通配符</h2><p>通配符也是用在过滤语句中，但它只能用于文本字段。</p><ul><li><strong>%</strong> 匹配 >=0 个任意字符；</li><li><strong>_</strong> 匹配 ==1 个任意字符；</li><li><strong><input disabled type=checkbox></strong> 可以匹配集合内的字符，例如 <code>[ab]</code> 将匹配字符 a 或者 b。用脱字符 ^ 可以对其进行否定，也就是不匹配集合内的字符。</li></ul><p>使用 Like 来进行通配符匹配。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>SELECT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>*</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>FROM</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>mytable</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>WHERE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>col</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>LIKE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#4e9a06>&#39;[^AB]%&#39;</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#8f5902;font-style:italic>-- 不以 A 和 B 开头的任意文本
</span></span></span></code></pre></div><p>不要滥用通配符，通配符位于开头处匹配会非常慢。</p><h2 id=计算字段>计算字段</h2><p>在数据库服务器上完成数据的转换和格式化的工作往往比客户端上快得多，并且转换和格式化后的数据量更少的话可以减少网络通信量。</p><p>计算字段通常需要使用 <strong>AS</strong> 来取别名，否则输出的时候字段名为计算表达式。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>SELECT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>col1</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>*</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>col2</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>AS</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>alias</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>FROM</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>mytable</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><p><strong>CONCAT()</strong> 用于连接两个字段。许多数据库会使用空格把一个值填充为列宽，因此连接的结果会出现一些不必要的空格，使用 <strong>TRIM()</strong> 可以去除首尾空格。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>SELECT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>CONCAT</span><span style=color:#000;font-weight:700>(</span><span style=color:#204a87;font-weight:700>TRIM</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>col1</span><span style=color:#000;font-weight:700>),</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#4e9a06>&#39;(&#39;</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>TRIM</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>col2</span><span style=color:#000;font-weight:700>),</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#4e9a06>&#39;)&#39;</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>AS</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>concat_col</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>FROM</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>mytable</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><h2 id=函数>函数</h2><p>各个 DBMS 的函数都是不相同的，因此不可移植，以下主要是 MySQL 的函数。</p><h3 id=汇总>汇总</h3><table><thead><tr><th style=text-align:center>函 数</th><th style=text-align:center>说 明</th></tr></thead><tbody><tr><td style=text-align:center>AVG()</td><td style=text-align:center>返回某列的平均值</td></tr><tr><td style=text-align:center>COUNT()</td><td style=text-align:center>返回某列的行数</td></tr><tr><td style=text-align:center>MAX()</td><td style=text-align:center>返回某列的最大值</td></tr><tr><td style=text-align:center>MIN()</td><td style=text-align:center>返回某列的最小值</td></tr><tr><td style=text-align:center>SUM()</td><td style=text-align:center>返回某列值之和</td></tr></tbody></table><p>AVG() 会忽略 NULL 行。</p><p>使用 DISTINCT 可以让汇总函数值汇总不同的值。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>SELECT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>AVG</span><span style=color:#000;font-weight:700>(</span><span style=color:#204a87;font-weight:700>DISTINCT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>col1</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>AS</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>avg_col</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>FROM</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>mytable</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><h3 id=文本处理>文本处理</h3><table><thead><tr><th style=text-align:center>函数</th><th style=text-align:center>说明</th></tr></thead><tbody><tr><td style=text-align:center>LEFT()</td><td style=text-align:center>左边的字符</td></tr><tr><td style=text-align:center>RIGHT()</td><td style=text-align:center>右边的字符</td></tr><tr><td style=text-align:center>LOWER()</td><td style=text-align:center>转换为小写字符</td></tr><tr><td style=text-align:center>UPPER()</td><td style=text-align:center>转换为大写字符</td></tr><tr><td style=text-align:center>LTRIM()</td><td style=text-align:center>去除左边的空格</td></tr><tr><td style=text-align:center>RTRIM()</td><td style=text-align:center>去除右边的空格</td></tr><tr><td style=text-align:center>LENGTH()</td><td style=text-align:center>长度</td></tr><tr><td style=text-align:center>SOUNDEX()</td><td style=text-align:center>转换为语音值</td></tr></tbody></table><p>其中， <strong>SOUNDEX()</strong> 可以将一个字符串转换为描述其语音表示的字母数字模式。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>SELECT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>*</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>FROM</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>mytable</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>WHERE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>SOUNDEX</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>col1</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>SOUNDEX</span><span style=color:#000;font-weight:700>(</span><span style=color:#4e9a06>&#39;apple&#39;</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><h3 id=日期和时间处理>日期和时间处理</h3><ul><li>日期格式: <code>YYYY-MM-DD</code></li><li>时间格式: <code>HH:MM:SS</code></li></ul><table><thead><tr><th style=text-align:center>函 数</th><th style=text-align:center>说 明</th></tr></thead><tbody><tr><td style=text-align:center>AddDate()</td><td style=text-align:center>增加一个日期(天、周等)</td></tr><tr><td style=text-align:center>AddTime()</td><td style=text-align:center>增加一个时间(时、分等)</td></tr><tr><td style=text-align:center>CurDate()</td><td style=text-align:center>返回当前日期</td></tr><tr><td style=text-align:center>CurTime()</td><td style=text-align:center>返回当前时间</td></tr><tr><td style=text-align:center>Date()</td><td style=text-align:center>返回日期时间的日期部分</td></tr><tr><td style=text-align:center>DateDiff()</td><td style=text-align:center>计算两个日期之差</td></tr><tr><td style=text-align:center>Date_Add()</td><td style=text-align:center>高度灵活的日期运算函数</td></tr><tr><td style=text-align:center>Date_Format()</td><td style=text-align:center>返回一个格式化的日期或时间串</td></tr><tr><td style=text-align:center>Day()</td><td style=text-align:center>返回一个日期的天数部分</td></tr><tr><td style=text-align:center>DayOfWeek()</td><td style=text-align:center>对于一个日期，返回对应的星期几</td></tr><tr><td style=text-align:center>Hour()</td><td style=text-align:center>返回一个时间的小时部分</td></tr><tr><td style=text-align:center>Minute()</td><td style=text-align:center>返回一个时间的分钟部分</td></tr><tr><td style=text-align:center>Month()</td><td style=text-align:center>返回一个日期的月份部分</td></tr><tr><td style=text-align:center>Now()</td><td style=text-align:center>返回当前日期和时间</td></tr><tr><td style=text-align:center>Second()</td><td style=text-align:center>返回一个时间的秒部分</td></tr><tr><td style=text-align:center>Time()</td><td style=text-align:center>返回一个日期时间的时间部分</td></tr><tr><td style=text-align:center>Year()</td><td style=text-align:center>返回一个日期的年份部分</td></tr></tbody></table><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#000>mysql</span><span style=color:#ce5c00;font-weight:700>&gt;</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>SELECT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>NOW</span><span style=color:#000;font-weight:700>();</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>2018-4-14 20:25:11
</span></span></code></pre></div><h3 id=数值处理>数值处理</h3><table><thead><tr><th style=text-align:center>函数</th><th style=text-align:center>说明</th></tr></thead><tbody><tr><td style=text-align:center>SIN()</td><td style=text-align:center>正弦</td></tr><tr><td style=text-align:center>COS()</td><td style=text-align:center>余弦</td></tr><tr><td style=text-align:center>TAN()</td><td style=text-align:center>正切</td></tr><tr><td style=text-align:center>ABS()</td><td style=text-align:center>绝对值</td></tr><tr><td style=text-align:center>SQRT()</td><td style=text-align:center>平方根</td></tr><tr><td style=text-align:center>MOD()</td><td style=text-align:center>余数</td></tr><tr><td style=text-align:center>EXP()</td><td style=text-align:center>指数</td></tr><tr><td style=text-align:center>PI()</td><td style=text-align:center>圆周率</td></tr><tr><td style=text-align:center>RAND()</td><td style=text-align:center>随机数</td></tr></tbody></table><h2 id=分组>分组</h2><p>分组就是把具有相同的数据值的行放在同一组中。</p><p>可以对同一分组数据使用汇总函数进行处理，例如求分组数据的平均值等。</p><p>指定的分组字段除了能按该字段进行分组，也会自动按该字段进行排序。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>SELECT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>col</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>COUNT</span><span style=color:#000;font-weight:700>(</span><span style=color:#ce5c00;font-weight:700>*</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>AS</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>num</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>FROM</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>mytable</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>GROUP</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>BY</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>col</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><p>GROUP BY 自动按分组字段进行排序，ORDER BY 也可以按汇总字段来进行排序。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>SELECT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>col</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>COUNT</span><span style=color:#000;font-weight:700>(</span><span style=color:#ce5c00;font-weight:700>*</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>AS</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>num</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>FROM</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>mytable</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>GROUP</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>BY</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>col</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>ORDER</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>BY</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>num</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><p><strong>WHERE 过滤行，HAVING 过滤分组，行过滤应当先于分组过滤。</strong></p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>SELECT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>col</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>COUNT</span><span style=color:#000;font-weight:700>(</span><span style=color:#ce5c00;font-weight:700>*</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>AS</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>num</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>FROM</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>mytable</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>WHERE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>col</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>&gt;</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#0000cf;font-weight:700>2</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>GROUP</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>BY</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>col</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>HAVING</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>num</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>&gt;=</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#0000cf;font-weight:700>2</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><p>分组规定:</p><ul><li>GROUP BY 子句出现在 WHERE 子句之后，ORDER BY 子句之前；</li><li>除了汇总字段外，SELECT 语句中的每一字段都必须在 GROUP BY 子句中给出；</li><li>NULL 的行会单独分为一组；</li><li>大多数 SQL 实现不支持 GROUP BY 列具有可变长度的数据类型。</li></ul><h2 id=子查询>子查询</h2><p>子查询中只能返回一个字段的数据。</p><p>可以将子查询的结果作为 WHRER 语句的过滤条件:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>SELECT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>*</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>FROM</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>mytable1</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>WHERE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>col1</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>IN</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>(</span><span style=color:#204a87;font-weight:700>SELECT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>col2</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>               </span><span style=color:#204a87;font-weight:700>FROM</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>mytable2</span><span style=color:#000;font-weight:700>);</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><p>下面的语句可以检索出客户的订单数量，子查询语句会对第一个查询检索出的每个客户执行一次:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>SELECT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>cust_name</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>(</span><span style=color:#204a87;font-weight:700>SELECT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>COUNT</span><span style=color:#000;font-weight:700>(</span><span style=color:#ce5c00;font-weight:700>*</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>                   </span><span style=color:#204a87;font-weight:700>FROM</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>Orders</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>                   </span><span style=color:#204a87;font-weight:700>WHERE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>Orders</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>cust_id</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>Customers</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>cust_id</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>                   </span><span style=color:#204a87;font-weight:700>AS</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>orders_num</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>FROM</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>Customers</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>ORDER</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>BY</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>cust_name</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><h2 id=连接>连接</h2><p>连接用于连接多个表，使用 JOIN 关键字，并且条件语句使用 ON 而不是 WHERE。</p><p>连接可以替换子查询，并且比子查询的效率一般会更快。</p><p>可以用 AS 给列名、计算字段和表名取别名，给表名取别名是为了简化 SQL 语句以及连接相同表。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210503212822.png style=display:block;width:80% alt=NAME align=center></div><h3 id=内连接>内连接</h3><p>内连接又称等值连接，使用 INNER JOIN 关键字。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>SELECT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>A</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>value</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>B</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>value</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>FROM</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>tablea</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>AS</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>A</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>INNER</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>JOIN</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>tableb</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>AS</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>B</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>ON</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>A</span><span style=color:#000;font-weight:700>.</span><span style=color:#204a87;font-weight:700>key</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>B</span><span style=color:#000;font-weight:700>.</span><span style=color:#204a87;font-weight:700>key</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><p>可以不明确使用 INNER JOIN，而使用普通查询并在 WHERE 中将两个表中要连接的列用等值方法连接起来。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>SELECT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>A</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>value</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>B</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>value</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>FROM</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>tablea</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>AS</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>A</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>tableb</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>AS</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>B</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>WHERE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>A</span><span style=color:#000;font-weight:700>.</span><span style=color:#204a87;font-weight:700>key</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>B</span><span style=color:#000;font-weight:700>.</span><span style=color:#204a87;font-weight:700>key</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><p>在没有条件语句的情况下返回笛卡尔积。</p><h3 id=自连接>自连接</h3><p>自连接可以看成内连接的一种，只是连接的表是自身而已。</p><p>一张员工表，包含员工姓名和员工所属部门，要找出与 Jim 处在同一部门的所有员工姓名。</p><p>子查询版本</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>SELECT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>name</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>FROM</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>employee</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>WHERE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>department</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>(</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>      </span><span style=color:#204a87;font-weight:700>SELECT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>department</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>      </span><span style=color:#204a87;font-weight:700>FROM</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>employee</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>      </span><span style=color:#204a87;font-weight:700>WHERE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>name</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#4e9a06>&#34;Jim&#34;</span><span style=color:#000;font-weight:700>);</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><p>自连接版本</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>SELECT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>e1</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>name</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>FROM</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>employee</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>AS</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>e1</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>INNER</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>JOIN</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>employee</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>AS</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>e2</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>ON</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>e1</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>department</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>e2</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>department</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>      </span><span style=color:#204a87;font-weight:700>AND</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>e2</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>name</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#4e9a06>&#34;Jim&#34;</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><h3 id=自然连接>自然连接</h3><p>自然连接是把同名列通过等值测试连接起来的，同名列可以有多个。</p><p>内连接和自然连接的区别: 内连接提供连接的列，而自然连接自动连接所有同名列。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>SELECT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>A</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>value</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>B</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>value</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>FROM</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>tablea</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>AS</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>A</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>NATURAL</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>JOIN</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>tableb</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>AS</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>B</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><h3 id=外连接>外连接</h3><p>外连接保留了没有关联的那些行。分为左外连接，右外连接以及全外连接，左外连接就是保留左表没有关联的行。</p><p>检索所有顾客的订单信息，包括还没有订单信息的顾客。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>SELECT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>Customers</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>cust_id</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>Orders</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>order_num</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>FROM</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>Customers</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>LEFT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>OUTER</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>JOIN</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>Orders</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>ON</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>Customers</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>cust_id</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>Orders</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>cust_id</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><p>customers 表:</p><table><thead><tr><th style=text-align:center>cust_id</th><th style=text-align:center>cust_name</th></tr></thead><tbody><tr><td style=text-align:center>1</td><td style=text-align:center>a</td></tr><tr><td style=text-align:center>2</td><td style=text-align:center>b</td></tr><tr><td style=text-align:center>3</td><td style=text-align:center>c</td></tr></tbody></table><p>orders 表:</p><table><thead><tr><th style=text-align:center>order_id</th><th style=text-align:center>cust_id</th></tr></thead><tbody><tr><td style=text-align:center>1</td><td style=text-align:center>1</td></tr><tr><td style=text-align:center>2</td><td style=text-align:center>1</td></tr><tr><td style=text-align:center>3</td><td style=text-align:center>3</td></tr><tr><td style=text-align:center>4</td><td style=text-align:center>3</td></tr></tbody></table><p>结果:</p><table><thead><tr><th style=text-align:center>cust_id</th><th style=text-align:center>cust_name</th><th style=text-align:center>order_id</th></tr></thead><tbody><tr><td style=text-align:center>1</td><td style=text-align:center>a</td><td style=text-align:center>1</td></tr><tr><td style=text-align:center>1</td><td style=text-align:center>a</td><td style=text-align:center>2</td></tr><tr><td style=text-align:center>3</td><td style=text-align:center>c</td><td style=text-align:center>3</td></tr><tr><td style=text-align:center>3</td><td style=text-align:center>c</td><td style=text-align:center>4</td></tr><tr><td style=text-align:center>2</td><td style=text-align:center>b</td><td style=text-align:center>Null</td></tr></tbody></table><h2 id=组合查询>组合查询</h2><p>使用 <strong>UNION</strong> 来组合两个查询，如果第一个查询返回 M 行，第二个查询返回 N 行，那么组合查询的结果一般为 M+N 行。</p><p>每个查询必须包含相同的列、表达式和聚集函数。</p><p>默认会去除相同行，如果需要保留相同行，使用 UNION ALL。</p><p>只能包含一个 ORDER BY 子句，并且必须位于语句的最后。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>SELECT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>col</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>FROM</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>mytable</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>WHERE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>col</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#0000cf;font-weight:700>1</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>UNION</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>SELECT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>col</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>FROM</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>mytable</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>WHERE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>col</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#0000cf;font-weight:700>2</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><h2 id=视图>视图</h2><p>视图是虚拟的表，本身不包含数据，也就不能对其进行索引操作。</p><p>对视图的操作和对普通表的操作一样。</p><p>视图具有如下好处:</p><ul><li>简化复杂的 SQL 操作，比如复杂的连接；</li><li>只使用实际表的一部分数据；</li><li>通过只给用户访问视图的权限，保证数据的安全性；</li><li>更改数据格式和表示。</li></ul><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>CREATE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>VIEW</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>myview</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>AS</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>SELECT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>Concat</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>col1</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>col2</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>AS</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>concat_col</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>col3</span><span style=color:#ce5c00;font-weight:700>*</span><span style=color:#000>col4</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>AS</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>compute_col</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>FROM</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>mytable</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>WHERE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>col5</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>val</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><h2 id=存储过程>存储过程</h2><p>存储过程可以看成是对一系列 SQL 操作的批处理。</p><p>使用存储过程的好处:</p><ul><li>代码封装，保证了一定的安全性；</li><li>代码复用；</li><li>由于是预先编译，因此具有很高的性能。</li></ul><p>命令行中创建存储过程需要自定义分隔符，因为命令行是以 ; 为结束符，而存储过程中也包含了分号，因此会错误把这部分分号当成是结束符，造成语法错误。</p><p>包含 in、out 和 inout 三种参数。</p><p>给变量赋值都需要用 select into 语句。</p><p>每次只能给一个变量赋值，不支持集合的操作。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>delimiter</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>//</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>create</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>procedure</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>myprocedure</span><span style=color:#000;font-weight:700>(</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>out</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>ret</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87>int</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>    </span><span style=color:#204a87;font-weight:700>begin</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>        </span><span style=color:#204a87;font-weight:700>declare</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>y</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87>int</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>        </span><span style=color:#204a87;font-weight:700>select</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>sum</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>col1</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>        </span><span style=color:#204a87;font-weight:700>from</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>mytable</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>        </span><span style=color:#204a87;font-weight:700>into</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>y</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>        </span><span style=color:#204a87;font-weight:700>select</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>y</span><span style=color:#ce5c00;font-weight:700>*</span><span style=color:#000>y</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>into</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>ret</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>    </span><span style=color:#204a87;font-weight:700>end</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>//</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>delimiter</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>call</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>myprocedure</span><span style=color:#000;font-weight:700>(</span><span style=color:#ce5c00;font-weight:700>@</span><span style=color:#000>ret</span><span style=color:#000;font-weight:700>);</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>select</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>@</span><span style=color:#000>ret</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><h2 id=游标>游标</h2><p>在存储过程中使用游标可以对一个结果集进行移动遍历。</p><p>游标主要用于交互式应用，其中用户需要对数据集中的任意行进行浏览和修改。</p><p>使用游标的四个步骤:</p><ol><li>声明游标，这个过程没有实际检索出数据；</li><li>打开游标；</li><li>取出数据；</li><li>关闭游标；</li></ol><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>delimiter</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>//</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>create</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>procedure</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>myprocedure</span><span style=color:#000;font-weight:700>(</span><span style=color:#204a87;font-weight:700>out</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>ret</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87>int</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>    </span><span style=color:#204a87;font-weight:700>begin</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>        </span><span style=color:#204a87;font-weight:700>declare</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>done</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87>boolean</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>default</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#0000cf;font-weight:700>0</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>        </span><span style=color:#204a87;font-weight:700>declare</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>mycursor</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>cursor</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>for</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>        </span><span style=color:#204a87;font-weight:700>select</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>col1</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>from</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>mytable</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>        </span><span style=color:#ce5c00;font-weight:700>#</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#a40000>定义了一个</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>continue</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>handler</span><span style=color:#a40000>，当</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>sqlstate</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#4e9a06>&#39;02000&#39;</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#a40000>这个条件出现时，会执行</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>set</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>done</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#0000cf;font-weight:700>1</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>        </span><span style=color:#204a87;font-weight:700>declare</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>continue</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>handler</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>for</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>sqlstate</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#4e9a06>&#39;02000&#39;</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>set</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>done</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>        </span><span style=color:#204a87;font-weight:700>open</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>mycursor</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>        </span><span style=color:#000>repeat</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>            </span><span style=color:#204a87;font-weight:700>fetch</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>mycursor</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>into</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>ret</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>            </span><span style=color:#204a87;font-weight:700>select</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>ret</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>        </span><span style=color:#204a87;font-weight:700>until</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>done</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>end</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>repeat</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>        </span><span style=color:#204a87;font-weight:700>close</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>mycursor</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>    </span><span style=color:#204a87;font-weight:700>end</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>//</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>delimiter</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><h2 id=触发器>触发器</h2><p>触发器会在某个表执行以下语句时而自动执行: DELETE、INSERT、UPDATE。</p><p>触发器必须指定在语句执行之前还是之后自动执行，之前执行使用 BEFORE 关键字，之后执行使用 AFTER 关键字。BEFORE 用于数据验证和净化，AFTER 用于审计跟踪，将修改记录到另外一张表中。</p><p>INSERT 触发器包含一个名为 NEW 的虚拟表。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>CREATE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>TRIGGER</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>mytrigger</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>AFTER</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>INSERT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>ON</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>mytable</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>FOR</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>EACH</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>ROW</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>SELECT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>NEW</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>col</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>into</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>@</span><span style=color:#204a87;font-weight:700>result</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>SELECT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>@</span><span style=color:#204a87;font-weight:700>result</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#8f5902;font-style:italic>-- 获取结果
</span></span></span></code></pre></div><p>DELETE 触发器包含一个名为 OLD 的虚拟表，并且是只读的。</p><p>UPDATE 触发器包含一个名为 NEW 和一个名为 OLD 的虚拟表，其中 NEW 是可以被修改的，而 OLD 是只读的。</p><p>MySQL 不允许在触发器中使用 CALL 语句，也就是不能调用存储过程。</p><h2 id=事务管理>事务管理</h2><p>基本术语:</p><ul><li>事务(transaction)指一组 SQL 语句；</li><li>回退(rollback)指撤销指定 SQL 语句的过程；</li><li>提交(commit)指将未存储的 SQL 语句结果写入数据库表；</li><li>保留点(savepoint)指事务处理中设置的临时占位符(placeholder)，你可以对它发布回退(与回退整个事务处理不同)。</li></ul><p>不能回退 SELECT 语句，回退 SELECT 语句也没意义；也不能回退 CREATE 和 DROP 语句。</p><p>MySQL 的事务提交默认是隐式提交，每执行一条语句就把这条语句当成一个事务然后进行提交。当出现 START TRANSACTION 语句时，会关闭隐式提交；当 COMMIT 或 ROLLBACK 语句执行后，事务会自动关闭，重新恢复隐式提交。</p><p>通过设置 autocommit 为 0 可以取消自动提交；autocommit 标记是针对每个连接而不是针对服务器的。</p><p>如果没有设置保留点，ROLLBACK 会回退到 START TRANSACTION 语句处；如果设置了保留点，并且在 ROLLBACK 中指定该保留点，则会回退到该保留点。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>START</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>TRANSACTION</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#ce5c00;font-weight:700>//</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>...</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#000>SAVEPOINT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>delete1</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#ce5c00;font-weight:700>//</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>...</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>ROLLBACK</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>TO</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>delete1</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#ce5c00;font-weight:700>//</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>...</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>COMMIT</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><h2 id=字符集>字符集</h2><p>基本术语:</p><ul><li>字符集为字母和符号的集合；</li><li>编码为某个字符集成员的内部表示；</li><li>校对字符指定如何比较，主要用于排序和分组。</li></ul><p>除了给表指定字符集和校对外，也可以给列指定:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>CREATE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>TABLE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>mytable</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#000;font-weight:700>(</span><span style=color:#000>col</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87>VARCHAR</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>10</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87>CHARACTER</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>SET</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>latin</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>COLLATE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>latin1_general_ci</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>DEFAULT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87>CHARACTER</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>SET</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>hebrew</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>COLLATE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>hebrew_general_ci</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><p>可以在排序、分组时指定校对:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>SELECT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>*</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>FROM</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>mytable</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>ORDER</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>BY</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>col</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>COLLATE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>latin1_general_ci</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><h2 id=权限管理>权限管理</h2><p>MySQL 的账户信息保存在 mysql 这个数据库中。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#000>USE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>mysql</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>SELECT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>user</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>FROM</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>user</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><p><strong>创建账户</strong></p><p>新创建的账户没有任何权限。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>CREATE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>USER</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>myuser</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>IDENTIFIED</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>BY</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#4e9a06>&#39;mypassword&#39;</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><p><strong>修改账户名</strong></p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>RENAME</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>myuser</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>TO</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>newuser</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><p><strong>删除账户</strong></p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>DROP</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>USER</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>myuser</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><p><strong>查看权限</strong></p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>SHOW</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>GRANTS</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>FOR</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>myuser</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><p><strong>授予权限</strong></p><p>账户用 username@host 的形式定义，username@% 使用的是默认主机名。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>GRANT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>SELECT</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>INSERT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>ON</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>mydatabase</span><span style=color:#000;font-weight:700>.</span><span style=color:#ce5c00;font-weight:700>*</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>TO</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>myuser</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><p><strong>删除权限</strong></p><p>GRANT 和 REVOKE 可在几个层次上控制访问权限:</p><ul><li>整个服务器，使用 GRANT ALL 和 REVOKE ALL；</li><li>整个数据库，使用 ON database.*；</li><li>特定的表，使用 ON database.table；</li><li>特定的列；</li><li>特定的存储过程。</li></ul><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>REVOKE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>SELECT</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>INSERT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>ON</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>mydatabase</span><span style=color:#000;font-weight:700>.</span><span style=color:#ce5c00;font-weight:700>*</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>FROM</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>myuser</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><p><strong>更改密码</strong></p><p>必须使用 Password() 函数</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>SET</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>PASSWROD</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>FOR</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>myuser</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>Password</span><span style=color:#000;font-weight:700>(</span><span style=color:#4e9a06>&#39;new_password&#39;</span><span style=color:#000;font-weight:700>);</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div></div><div class=td-content style=page-break-before:always><h1 id=pg-3a7e7b2f0ca69ac47bbbc3c0d6b38685>3.2 - CH02-查询练习</h1><h2 id=建表>建表</h2><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210503213629.png style=display:block;width:50% alt=NAME align=center></div><h2 id=插入数据>插入数据</h2><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#8f5902;font-style:italic>-- MySQL dump 10.13  Distrib 5.7.17, for macos10.12 (x86_64)
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>--
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>-- Host: localhost    Database: learn_sql_pdai_tech
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>-- ------------------------------------------------------
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>-- Server version	5.7.28
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#8f5902;font-style:italic>/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#8f5902;font-style:italic>/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#8f5902;font-style:italic>/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#8f5902;font-style:italic>/*!40101 SET NAMES utf8 */</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#8f5902;font-style:italic>/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#8f5902;font-style:italic>/*!40103 SET TIME_ZONE=&#39;+00:00&#39; */</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#8f5902;font-style:italic>/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#8f5902;font-style:italic>/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#8f5902;font-style:italic>/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE=&#39;NO_AUTO_VALUE_ON_ZERO&#39; */</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#8f5902;font-style:italic>/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#8f5902;font-style:italic>--
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>-- Table structure for table `COURSE`
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>--
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>DROP</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>TABLE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>IF</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>EXISTS</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>COURSE</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#8f5902;font-style:italic>/*!40101 SET @saved_cs_client     = @@character_set_client */</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#8f5902;font-style:italic>/*!40101 SET character_set_client = utf8 */</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>CREATE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>TABLE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>COURSE</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>(</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>CNO</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87>varchar</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>5</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>NOT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>NULL</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>CNAME</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87>varchar</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>10</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>NOT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>NULL</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>TNO</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87>varchar</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>10</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>NOT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>NULL</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>ENGINE</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#000>InnoDB</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>DEFAULT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>CHARSET</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#000>utf8</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#8f5902;font-style:italic>/*!40101 SET character_set_client = @saved_cs_client */</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#8f5902;font-style:italic>--
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>-- Dumping data for table `COURSE`
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>--
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>LOCK</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>TABLES</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>COURSE</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>WRITE</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#8f5902;font-style:italic>/*!40000 ALTER TABLE `COURSE` DISABLE KEYS */</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>INSERT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>INTO</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>COURSE</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>VALUES</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>(</span><span style=color:#4e9a06>&#39;3-105&#39;</span><span style=color:#000;font-weight:700>,</span><span style=color:#4e9a06>&#39;计算机导论&#39;</span><span style=color:#000;font-weight:700>,</span><span style=color:#4e9a06>&#39;825&#39;</span><span style=color:#000;font-weight:700>),(</span><span style=color:#4e9a06>&#39;3-245&#39;</span><span style=color:#000;font-weight:700>,</span><span style=color:#4e9a06>&#39;操作系统&#39;</span><span style=color:#000;font-weight:700>,</span><span style=color:#4e9a06>&#39;804&#39;</span><span style=color:#000;font-weight:700>),(</span><span style=color:#4e9a06>&#39;6-166&#39;</span><span style=color:#000;font-weight:700>,</span><span style=color:#4e9a06>&#39;数据电路&#39;</span><span style=color:#000;font-weight:700>,</span><span style=color:#4e9a06>&#39;856&#39;</span><span style=color:#000;font-weight:700>),(</span><span style=color:#4e9a06>&#39;9-888&#39;</span><span style=color:#000;font-weight:700>,</span><span style=color:#4e9a06>&#39;高等数学&#39;</span><span style=color:#000;font-weight:700>,</span><span style=color:#4e9a06>&#39;100&#39;</span><span style=color:#000;font-weight:700>);</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#8f5902;font-style:italic>/*!40000 ALTER TABLE `COURSE` ENABLE KEYS */</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#000>UNLOCK</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>TABLES</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#8f5902;font-style:italic>--
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>-- Table structure for table `SCORE`
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>--
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>DROP</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>TABLE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>IF</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>EXISTS</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>SCORE</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#8f5902;font-style:italic>/*!40101 SET @saved_cs_client     = @@character_set_client */</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#8f5902;font-style:italic>/*!40101 SET character_set_client = utf8 */</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>CREATE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>TABLE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>SCORE</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>(</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>SNO</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87>varchar</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>3</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>NOT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>NULL</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>CNO</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87>varchar</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>5</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>NOT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>NULL</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>DEGREE</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87>decimal</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>10</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>NOT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>NULL</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>ENGINE</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#000>InnoDB</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>DEFAULT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>CHARSET</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#000>utf8</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#8f5902;font-style:italic>/*!40101 SET character_set_client = @saved_cs_client */</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#8f5902;font-style:italic>--
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>-- Dumping data for table `SCORE`
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>--
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>LOCK</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>TABLES</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>SCORE</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>WRITE</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#8f5902;font-style:italic>/*!40000 ALTER TABLE `SCORE` DISABLE KEYS */</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>INSERT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>INTO</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>SCORE</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>VALUES</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>(</span><span style=color:#4e9a06>&#39;103&#39;</span><span style=color:#000;font-weight:700>,</span><span style=color:#4e9a06>&#39;3-245&#39;</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>86</span><span style=color:#000;font-weight:700>.</span><span style=color:#0000cf;font-weight:700>0</span><span style=color:#000;font-weight:700>),(</span><span style=color:#4e9a06>&#39;105&#39;</span><span style=color:#000;font-weight:700>,</span><span style=color:#4e9a06>&#39;3-245&#39;</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>75</span><span style=color:#000;font-weight:700>.</span><span style=color:#0000cf;font-weight:700>0</span><span style=color:#000;font-weight:700>),(</span><span style=color:#4e9a06>&#39;109&#39;</span><span style=color:#000;font-weight:700>,</span><span style=color:#4e9a06>&#39;3-245&#39;</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>68</span><span style=color:#000;font-weight:700>.</span><span style=color:#0000cf;font-weight:700>0</span><span style=color:#000;font-weight:700>),(</span><span style=color:#4e9a06>&#39;103&#39;</span><span style=color:#000;font-weight:700>,</span><span style=color:#4e9a06>&#39;3-105&#39;</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>92</span><span style=color:#000;font-weight:700>.</span><span style=color:#0000cf;font-weight:700>0</span><span style=color:#000;font-weight:700>),(</span><span style=color:#4e9a06>&#39;105&#39;</span><span style=color:#000;font-weight:700>,</span><span style=color:#4e9a06>&#39;3-105&#39;</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>88</span><span style=color:#000;font-weight:700>.</span><span style=color:#0000cf;font-weight:700>0</span><span style=color:#000;font-weight:700>),(</span><span style=color:#4e9a06>&#39;109&#39;</span><span style=color:#000;font-weight:700>,</span><span style=color:#4e9a06>&#39;3-105&#39;</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>76</span><span style=color:#000;font-weight:700>.</span><span style=color:#0000cf;font-weight:700>0</span><span style=color:#000;font-weight:700>),(</span><span style=color:#4e9a06>&#39;101&#39;</span><span style=color:#000;font-weight:700>,</span><span style=color:#4e9a06>&#39;3-105&#39;</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>64</span><span style=color:#000;font-weight:700>.</span><span style=color:#0000cf;font-weight:700>0</span><span style=color:#000;font-weight:700>),(</span><span style=color:#4e9a06>&#39;107&#39;</span><span style=color:#000;font-weight:700>,</span><span style=color:#4e9a06>&#39;3-105&#39;</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>91</span><span style=color:#000;font-weight:700>.</span><span style=color:#0000cf;font-weight:700>0</span><span style=color:#000;font-weight:700>),(</span><span style=color:#4e9a06>&#39;101&#39;</span><span style=color:#000;font-weight:700>,</span><span style=color:#4e9a06>&#39;6-166&#39;</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>85</span><span style=color:#000;font-weight:700>.</span><span style=color:#0000cf;font-weight:700>0</span><span style=color:#000;font-weight:700>),(</span><span style=color:#4e9a06>&#39;107&#39;</span><span style=color:#000;font-weight:700>,</span><span style=color:#4e9a06>&#39;6-106&#39;</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>79</span><span style=color:#000;font-weight:700>.</span><span style=color:#0000cf;font-weight:700>0</span><span style=color:#000;font-weight:700>),(</span><span style=color:#4e9a06>&#39;108&#39;</span><span style=color:#000;font-weight:700>,</span><span style=color:#4e9a06>&#39;3-105&#39;</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>78</span><span style=color:#000;font-weight:700>.</span><span style=color:#0000cf;font-weight:700>0</span><span style=color:#000;font-weight:700>),(</span><span style=color:#4e9a06>&#39;108&#39;</span><span style=color:#000;font-weight:700>,</span><span style=color:#4e9a06>&#39;6-166&#39;</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>81</span><span style=color:#000;font-weight:700>.</span><span style=color:#0000cf;font-weight:700>0</span><span style=color:#000;font-weight:700>);</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#8f5902;font-style:italic>/*!40000 ALTER TABLE `SCORE` ENABLE KEYS */</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#000>UNLOCK</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>TABLES</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#8f5902;font-style:italic>--
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>-- Table structure for table `STUDENT`
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>--
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>DROP</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>TABLE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>IF</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>EXISTS</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>STUDENT</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#8f5902;font-style:italic>/*!40101 SET @saved_cs_client     = @@character_set_client */</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#8f5902;font-style:italic>/*!40101 SET character_set_client = utf8 */</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>CREATE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>TABLE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>STUDENT</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>(</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>SNO</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87>varchar</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>3</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>NOT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>NULL</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>SNAME</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87>varchar</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>4</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>NOT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>NULL</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>SSEX</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87>varchar</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>2</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>NOT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>NULL</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>SBIRTHDAY</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>datetime</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>DEFAULT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>NULL</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#204a87;font-weight:700>CLASS</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87>varchar</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>5</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>DEFAULT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>NULL</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>ENGINE</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#000>InnoDB</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>DEFAULT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>CHARSET</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#000>utf8</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#8f5902;font-style:italic>/*!40101 SET character_set_client = @saved_cs_client */</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#8f5902;font-style:italic>--
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>-- Dumping data for table `STUDENT`
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>--
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>LOCK</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>TABLES</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>STUDENT</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>WRITE</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#8f5902;font-style:italic>/*!40000 ALTER TABLE `STUDENT` DISABLE KEYS */</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>INSERT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>INTO</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>STUDENT</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>VALUES</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>(</span><span style=color:#4e9a06>&#39;108&#39;</span><span style=color:#000;font-weight:700>,</span><span style=color:#4e9a06>&#39;曾华&#39;</span><span style=color:#000;font-weight:700>,</span><span style=color:#4e9a06>&#39;男&#39;</span><span style=color:#000;font-weight:700>,</span><span style=color:#4e9a06>&#39;1977-09-01 00:00:00&#39;</span><span style=color:#000;font-weight:700>,</span><span style=color:#4e9a06>&#39;95033&#39;</span><span style=color:#000;font-weight:700>),(</span><span style=color:#4e9a06>&#39;105&#39;</span><span style=color:#000;font-weight:700>,</span><span style=color:#4e9a06>&#39;匡明&#39;</span><span style=color:#000;font-weight:700>,</span><span style=color:#4e9a06>&#39;男&#39;</span><span style=color:#000;font-weight:700>,</span><span style=color:#4e9a06>&#39;1975-10-02 00:00:00&#39;</span><span style=color:#000;font-weight:700>,</span><span style=color:#4e9a06>&#39;95031&#39;</span><span style=color:#000;font-weight:700>),(</span><span style=color:#4e9a06>&#39;107&#39;</span><span style=color:#000;font-weight:700>,</span><span style=color:#4e9a06>&#39;王丽&#39;</span><span style=color:#000;font-weight:700>,</span><span style=color:#4e9a06>&#39;女&#39;</span><span style=color:#000;font-weight:700>,</span><span style=color:#4e9a06>&#39;1976-01-23 00:00:00&#39;</span><span style=color:#000;font-weight:700>,</span><span style=color:#4e9a06>&#39;95033&#39;</span><span style=color:#000;font-weight:700>),(</span><span style=color:#4e9a06>&#39;101&#39;</span><span style=color:#000;font-weight:700>,</span><span style=color:#4e9a06>&#39;李军&#39;</span><span style=color:#000;font-weight:700>,</span><span style=color:#4e9a06>&#39;男&#39;</span><span style=color:#000;font-weight:700>,</span><span style=color:#4e9a06>&#39;1976-02-20 00:00:00&#39;</span><span style=color:#000;font-weight:700>,</span><span style=color:#4e9a06>&#39;95033&#39;</span><span style=color:#000;font-weight:700>),(</span><span style=color:#4e9a06>&#39;109&#39;</span><span style=color:#000;font-weight:700>,</span><span style=color:#4e9a06>&#39;王芳&#39;</span><span style=color:#000;font-weight:700>,</span><span style=color:#4e9a06>&#39;女&#39;</span><span style=color:#000;font-weight:700>,</span><span style=color:#4e9a06>&#39;1975-02-10 00:00:00&#39;</span><span style=color:#000;font-weight:700>,</span><span style=color:#4e9a06>&#39;95031&#39;</span><span style=color:#000;font-weight:700>),(</span><span style=color:#4e9a06>&#39;103&#39;</span><span style=color:#000;font-weight:700>,</span><span style=color:#4e9a06>&#39;陆君&#39;</span><span style=color:#000;font-weight:700>,</span><span style=color:#4e9a06>&#39;男&#39;</span><span style=color:#000;font-weight:700>,</span><span style=color:#4e9a06>&#39;1974-06-03 00:00:00&#39;</span><span style=color:#000;font-weight:700>,</span><span style=color:#4e9a06>&#39;95031&#39;</span><span style=color:#000;font-weight:700>);</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#8f5902;font-style:italic>/*!40000 ALTER TABLE `STUDENT` ENABLE KEYS */</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#000>UNLOCK</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>TABLES</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#8f5902;font-style:italic>--
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>-- Table structure for table `TEACHER`
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>--
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>DROP</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>TABLE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>IF</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>EXISTS</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>TEACHER</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#8f5902;font-style:italic>/*!40101 SET @saved_cs_client     = @@character_set_client */</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#8f5902;font-style:italic>/*!40101 SET character_set_client = utf8 */</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>CREATE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>TABLE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>TEACHER</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>(</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>TNO</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87>varchar</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>3</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>NOT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>NULL</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>TNAME</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87>varchar</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>4</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>NOT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>NULL</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>TSEX</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87>varchar</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>2</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>NOT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>NULL</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>TBIRTHDAY</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>datetime</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>NOT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>NULL</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>PROF</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87>varchar</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>6</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>DEFAULT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>NULL</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>DEPART</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87>varchar</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>10</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>NOT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>NULL</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>ENGINE</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#000>InnoDB</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>DEFAULT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>CHARSET</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#000>utf8</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#8f5902;font-style:italic>/*!40101 SET character_set_client = @saved_cs_client */</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#8f5902;font-style:italic>--
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>-- Dumping data for table `TEACHER`
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>--
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>LOCK</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>TABLES</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>TEACHER</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>WRITE</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#8f5902;font-style:italic>/*!40000 ALTER TABLE `TEACHER` DISABLE KEYS */</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>INSERT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>INTO</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>TEACHER</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>VALUES</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>(</span><span style=color:#4e9a06>&#39;804&#39;</span><span style=color:#000;font-weight:700>,</span><span style=color:#4e9a06>&#39;李诚&#39;</span><span style=color:#000;font-weight:700>,</span><span style=color:#4e9a06>&#39;男&#39;</span><span style=color:#000;font-weight:700>,</span><span style=color:#4e9a06>&#39;1958-12-02 00:00:00&#39;</span><span style=color:#000;font-weight:700>,</span><span style=color:#4e9a06>&#39;副教授&#39;</span><span style=color:#000;font-weight:700>,</span><span style=color:#4e9a06>&#39;计算机系&#39;</span><span style=color:#000;font-weight:700>),(</span><span style=color:#4e9a06>&#39;856&#39;</span><span style=color:#000;font-weight:700>,</span><span style=color:#4e9a06>&#39;张旭&#39;</span><span style=color:#000;font-weight:700>,</span><span style=color:#4e9a06>&#39;男&#39;</span><span style=color:#000;font-weight:700>,</span><span style=color:#4e9a06>&#39;1969-03-12 00:00:00&#39;</span><span style=color:#000;font-weight:700>,</span><span style=color:#4e9a06>&#39;讲师&#39;</span><span style=color:#000;font-weight:700>,</span><span style=color:#4e9a06>&#39;电子工程系&#39;</span><span style=color:#000;font-weight:700>),(</span><span style=color:#4e9a06>&#39;825&#39;</span><span style=color:#000;font-weight:700>,</span><span style=color:#4e9a06>&#39;王萍&#39;</span><span style=color:#000;font-weight:700>,</span><span style=color:#4e9a06>&#39;女&#39;</span><span style=color:#000;font-weight:700>,</span><span style=color:#4e9a06>&#39;1972-05-05 00:00:00&#39;</span><span style=color:#000;font-weight:700>,</span><span style=color:#4e9a06>&#39;助教&#39;</span><span style=color:#000;font-weight:700>,</span><span style=color:#4e9a06>&#39;计算机系&#39;</span><span style=color:#000;font-weight:700>),(</span><span style=color:#4e9a06>&#39;831&#39;</span><span style=color:#000;font-weight:700>,</span><span style=color:#4e9a06>&#39;刘冰&#39;</span><span style=color:#000;font-weight:700>,</span><span style=color:#4e9a06>&#39;女&#39;</span><span style=color:#000;font-weight:700>,</span><span style=color:#4e9a06>&#39;1977-08-14 00:00:00&#39;</span><span style=color:#000;font-weight:700>,</span><span style=color:#4e9a06>&#39;助教&#39;</span><span style=color:#000;font-weight:700>,</span><span style=color:#4e9a06>&#39;电子工程系&#39;</span><span style=color:#000;font-weight:700>);</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#8f5902;font-style:italic>/*!40000 ALTER TABLE `TEACHER` ENABLE KEYS */</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#000>UNLOCK</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>TABLES</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#8f5902;font-style:italic>/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#8f5902;font-style:italic>/*!40101 SET SQL_MODE=@OLD_SQL_MODE */</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#8f5902;font-style:italic>/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#8f5902;font-style:italic>/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#8f5902;font-style:italic>/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#8f5902;font-style:italic>/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#8f5902;font-style:italic>/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#8f5902;font-style:italic>/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#8f5902;font-style:italic>-- Dump completed on 2020-02-06 18:18:25
</span></span></span></code></pre></div><h2 id=相关练习>相关练习</h2><ol><li><p>查询 Student 中所有记录的 Sname、Ssex、Class 列：</p><p><code>SELECT SNAME,SSEX,CLASS FROM STUDENT;</code></p></li><li><p>查询教师所有的单位即不重复的Depart列：</p><p><code>SELECT DISTINCT DEPART FORM TEACHER;</code></p></li><li><p>查询Student表的所有记录：</p><p><code>SELECT * FROM STUDENT;</code></p></li><li><p>查询Score表中成绩在60到80之间的所有记录：</p><p><code>SELECT * FROM SCORE WHERE DEGREE > 60 AND DEGREE &lt; 80;</code></p></li><li><p>查询Score表中成绩为85，86或88的记录：</p><p><code>SELECT * FROM SCORE WHERE DEGREE=85 OR DEGREE=86 OR DEGREE=88;</code></p></li><li><p>查询Student表中“95031”班或性别为“女”的同学记录：</p><p><code>SELECT * FROM STUDENT WHERE CLASS='95031' OR SSEX='女';</code></p></li><li><p>以Class降序查询Student表的所有记录：</p><p><code>SELECT * FROM STUDENT ORDER BY CLASS DESC;</code></p></li><li><p>以Cno升序、Degree降序查询Score表的所有记录：</p><p><code>SELECT * FROM SCORE ORDER BY CNO ASC, DEGREE DESC;</code></p></li><li><p>查询“95031”班的学生人数：</p><p><code>SELECT COUNT(*) FROM STUDENT WHERE CLASS='95031';</code></p></li><li><p>查询Score表中的最高分的学生学号和课程号：</p><p><code>SELECT SNO,CNO FROM SCORE WHERE DEGREE=(SELECT MAX(DEGREE) FROM SCORE);</code></p></li><li><p>查询‘3-105’号课程的平均分：</p><p><code>SELECT AVG(DEGREE) FROM SCROE WHERE CNO='3-105';</code></p></li><li><p>查询Score表中至少有5名学生选修的并以3开头的课程的平均分数：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-SQL data-lang=SQL><span style=display:flex><span><span style=color:#204a87;font-weight:700>SELECT</span><span style=color:#f8f8f8;text-decoration:underline> 
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>	</span><span style=color:#204a87;font-weight:700>AVG</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>DEGREE</span><span style=color:#000;font-weight:700>),</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>CNO</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>FROM</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>SCORE</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>WHERE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>CNO</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>LIKE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#4e9a06>&#39;3%&#39;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>GROUP</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>BY</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>CNO</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>HAVING</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>COUNT</span><span style=color:#000;font-weight:700>(</span><span style=color:#ce5c00;font-weight:700>*</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>&gt;</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#0000cf;font-weight:700>5</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div></li><li><p>查询最低分大于70，最高分小于90的Sno列：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>SELECT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>SNO</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>FROM</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>SCORE</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>GROUP</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>BY</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>SNO</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>HAVING</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>MIN</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>DEGREE</span><span style=color:#000;font-weight:700>)</span><span style=color:#ce5c00;font-weight:700>&gt;</span><span style=color:#0000cf;font-weight:700>70</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>AND</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>MAX</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>DEGREE</span><span style=color:#000;font-weight:700>)</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>90</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div></li><li><p>查询所有学生的Sname、Cno和Degree列：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>SELECT</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>	</span><span style=color:#000>SNAME</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>CNO</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>DEGREE</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>FROM</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>STUDENT</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>SCORE</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>WHERE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>STUDENT</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>SNO</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#000>SCORE</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>SNO</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div></li><li><p>查询所有学生的Sno、Cname和Degree列：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>SELECT</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>	</span><span style=color:#000>SCORE</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>SNO</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>	</span><span style=color:#000>CNO</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>	</span><span style=color:#000>DEGREE</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>FROM</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>STUDENT</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>SCORE</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>WHERE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>STUDENT</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>SNO</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#000>SCORE</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>SNO</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div></li><li><p>查询所有学生的Sname、Cname和Degree列：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>SELECT</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>	</span><span style=color:#000>A</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>SNAME</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>	</span><span style=color:#000>B</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>CNAME</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>	</span><span style=color:#204a87;font-weight:700>C</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>DEGREE</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>FROM</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>STUDENT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>A</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>JOIN</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>(</span><span style=color:#000>COURSE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>B</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>SCORE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>C</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>ON</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>A</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>SNO</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>C</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>SNO</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>AND</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>B</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>CNO</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>C</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>CNO</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div></li><li><p>查询“95033”班所选课程的平均分：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>SELECT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>AVG</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>DEGREE</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>FROM</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>SCORE</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>WHERE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>SNO</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>IN</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>(</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>SELECT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>SNO</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>FROM</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>STUDENT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>WHERE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>CLASS</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#4e9a06>&#39;95033&#39;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#000;font-weight:700>);</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div></li><li><p>假设使用如下命令建立了一个grade表：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>CREATE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>TABLE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>grade</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>(</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>	</span><span style=color:#000>low</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87>numeric</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>3</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#0000cf;font-weight:700>0</span><span style=color:#000;font-weight:700>),</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#000>upp</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87>numeric</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>3</span><span style=color:#000;font-weight:700>),</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#000>rank</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87>char</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#000;font-weight:700>);</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>insert</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>into</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>grade</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>values</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>90</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#0000cf;font-weight:700>100</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#4e9a06>&#39;A&#39;</span><span style=color:#000;font-weight:700>);</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>insert</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>into</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>grade</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>values</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>80</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#0000cf;font-weight:700>89</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#4e9a06>&#39;B&#39;</span><span style=color:#000;font-weight:700>);</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>insert</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>into</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>grade</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>values</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>70</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#0000cf;font-weight:700>79</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#4e9a06>&#39;C&#39;</span><span style=color:#000;font-weight:700>);</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>insert</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>into</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>grade</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>values</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>60</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#0000cf;font-weight:700>69</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#4e9a06>&#39;D&#39;</span><span style=color:#000;font-weight:700>);</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>insert</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>into</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>grade</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>values</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>0</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#0000cf;font-weight:700>59</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#4e9a06>&#39;E&#39;</span><span style=color:#000;font-weight:700>);</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div></li><li><p>现查询所有同学的Sno、Cno和rank列：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>SELECT</span><span style=color:#f8f8f8;text-decoration:underline> 
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>	</span><span style=color:#000>A</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>SNO</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>	</span><span style=color:#000>A</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>CNO</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>	</span><span style=color:#000>B</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>RANK</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>FROM</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>SCORE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>A</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>GRADE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>B</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>WHERE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>A</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>DEGREE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>BETWEEN</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>B</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>LOW</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>AND</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>B</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>UPP</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>ORDER</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>BY</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>RANK</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div></li><li><p>查询选修“3-105”课程的成绩高于“109”号同学成绩的所有同学的记录：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>select</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>*</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>from</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>SCORE</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>where</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>CNO</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#4e9a06>&#39;3-105&#39;</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>and</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>DEGREE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>&gt;</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>ALL</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>(</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>select</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>DEGREE</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>from</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>SCORE</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>where</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>SNO</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#4e9a06>&#39;109&#39;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#000;font-weight:700>);</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div></li><li><p>查询score中选学一门以上课程的同学中分数为非最高分成绩的学生记录：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>select</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>*</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>from</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>SCORE</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>where</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>CNO</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#4e9a06>&#39;3-105&#39;</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>and</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>DEGREE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>&gt;</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>ALL</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>(</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>select</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>DEGREE</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>from</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>SCORE</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>where</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>SNO</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#4e9a06>&#39;109&#39;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#000;font-weight:700>);</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div></li><li><p>查询和学号为108的同学同年出生的所有学生的Sno、Sname和Sbirthday列：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>select</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#000>SNO</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#000>SNAME</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#000>SBIRTHDAY</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>from</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>STUDENT</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>where</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>year</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>SBIRTHDAY</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>(</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>select</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>year</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>SBIRTHDAY</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>from</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>STUDENT</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>where</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>SNO</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#4e9a06>&#39;108&#39;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#000;font-weight:700>);</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div></li><li><p>查询“张旭“教师任课的学生成绩：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>select</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>*</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>from</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>SCORE</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>where</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>cno</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>(</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>select</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>CNO</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>from</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>COURSE</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>    </span><span style=color:#204a87;font-weight:700>inner</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>join</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>TEACHER</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>on</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>COURSE</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>TNO</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>TEACHER</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>TNO</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>and</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>TNAME</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#4e9a06>&#39;张旭&#39;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#000;font-weight:700>);</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div></li><li><p>查询选修某课程的同学人数多于5人的教师姓名：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>select</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>TNAME</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>from</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>TEACHER</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>where</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>TNO</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>(</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>select</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>TNO</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>from</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>COURSE</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>where</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>CNO</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>(</span><span style=color:#204a87;font-weight:700>select</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>CNO</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>               </span><span style=color:#204a87;font-weight:700>from</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>SCORE</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>               </span><span style=color:#204a87;font-weight:700>group</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>by</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>CNO</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>               </span><span style=color:#204a87;font-weight:700>having</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>count</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>SNO</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>&gt;</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#0000cf;font-weight:700>5</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#000;font-weight:700>);</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div></li><li><p>查询95033班和95031班全体学生的记录：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>select</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>*</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>from</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>STUDENT</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>where</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>CLASS</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>in</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>(</span><span style=color:#4e9a06>&#39;95033&#39;</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#4e9a06>&#39;95031&#39;</span><span style=color:#000;font-weight:700>);</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div></li><li><p>查询存在有85分以上成绩的课程Cno：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>select</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>cno</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>from</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>SCORE</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>group</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>by</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>CNO</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>having</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>MAX</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>DEGREE</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>&gt;</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#0000cf;font-weight:700>85</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div></li><li><p>查询出“计算机系“教师所教课程的成绩表：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>select</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>*</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>from</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>SCORE</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>where</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>CNO</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>in</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>(</span><span style=color:#204a87;font-weight:700>select</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>CNO</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>              </span><span style=color:#204a87;font-weight:700>from</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>TEACHER</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>COURSE</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>              </span><span style=color:#204a87;font-weight:700>where</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>DEPART</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#4e9a06>&#39;计算机系&#39;</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>and</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>COURSE</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>TNO</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>TEACHER</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>TNO</span><span style=color:#000;font-weight:700>);</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div></li><li><p>查询“计算机系”与“电子工程系“不同职称的教师的Tname和Prof：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>select</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#000>tname</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#000>prof</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>from</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>TEACHER</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>where</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>depart</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#4e9a06>&#39;计算机系&#39;</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>and</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>prof</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>not</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>in</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>(</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>select</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>prof</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>from</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>TEACHER</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>where</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>depart</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#4e9a06>&#39;电子工程系&#39;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#000;font-weight:700>);</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div></li><li><p>查询选修编号为“3-105“课程且成绩至少高于选修编号为“3-245”的同学的Cno、Sno和Degree,并按Degree从高到低次序排序：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>select</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#000>CNO</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#000>SNO</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#000>DEGREE</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>from</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>SCORE</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>where</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>CNO</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#4e9a06>&#39;3-105&#39;</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>and</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>DEGREE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>&gt;</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>any</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>(</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>select</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>DEGREE</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>from</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>SCORE</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>where</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>CNO</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#4e9a06>&#39;3-245&#39;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>order</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>by</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>DEGREE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>desc</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div></li><li><p>查询选修编号为“3-105”且成绩高于选修编号为“3-245”课程的同学的Cno、Sno和Degree：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>SELECT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>*</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>FROM</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>SCORE</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>WHERE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>DEGREE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>&gt;</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>ALL</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>(</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>SELECT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>DEGREE</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>FROM</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>SCORE</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>WHERE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>CNO</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#4e9a06>&#39;3-245&#39;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>ORDER</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>by</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>DEGREE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>desc</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div></li><li><p>查询所有教师和同学的name、sex和birthday：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>select</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#000>TNAME</span><span style=color:#f8f8f8;text-decoration:underline>     </span><span style=color:#000>name</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#000>TSEX</span><span style=color:#f8f8f8;text-decoration:underline>      </span><span style=color:#000>sex</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#000>TBIRTHDAY</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>birthday</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>from</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>TEACHER</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>union</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>select</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#000>sname</span><span style=color:#f8f8f8;text-decoration:underline>     </span><span style=color:#000>name</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#000>SSEX</span><span style=color:#f8f8f8;text-decoration:underline>      </span><span style=color:#000>sex</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#000>SBIRTHDAY</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>birthday</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>from</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>STUDENT</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div></li><li><p>查询所有“女”教师和“女”同学的name、sex和birthday：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>select</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#000>TNAME</span><span style=color:#f8f8f8;text-decoration:underline>     </span><span style=color:#000>name</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#000>TSEX</span><span style=color:#f8f8f8;text-decoration:underline>      </span><span style=color:#000>sex</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#000>TBIRTHDAY</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>birthday</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>from</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>TEACHER</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>where</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>TSEX</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#4e9a06>&#39;女&#39;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>union</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>select</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#000>sname</span><span style=color:#f8f8f8;text-decoration:underline>     </span><span style=color:#000>name</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#000>SSEX</span><span style=color:#f8f8f8;text-decoration:underline>      </span><span style=color:#000>sex</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#000>SBIRTHDAY</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>birthday</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>from</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>STUDENT</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>where</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>SSEX</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#4e9a06>&#39;女&#39;</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div></li><li><p>查询成绩比该课程平均成绩低的同学的成绩表：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>SELECT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>A</span><span style=color:#000;font-weight:700>.</span><span style=color:#ce5c00;font-weight:700>*</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>FROM</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>SCORE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>A</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>WHERE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>DEGREE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>(</span><span style=color:#204a87;font-weight:700>SELECT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>AVG</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>DEGREE</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>                </span><span style=color:#204a87;font-weight:700>FROM</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>SCORE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>B</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>                </span><span style=color:#204a87;font-weight:700>WHERE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>A</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>CNO</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>B</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>CNO</span><span style=color:#000;font-weight:700>);</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div></li><li><p>查询所有任课教师的Tname和Depart：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>select</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#000>TNAME</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#000>DEPART</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>from</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>TEACHER</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>a</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>where</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>exists</span><span style=color:#000;font-weight:700>(</span><span style=color:#204a87;font-weight:700>select</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>*</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>             </span><span style=color:#204a87;font-weight:700>from</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>COURSE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>b</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>             </span><span style=color:#204a87;font-weight:700>where</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>a</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>TNO</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>b</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>TNO</span><span style=color:#000;font-weight:700>);</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div></li><li><p>查询所有未讲课的教师的Tname和Depart：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>select</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#000>TNAME</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#000>DEPART</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>from</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>TEACHER</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>a</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>where</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>tno</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>not</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>in</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>(</span><span style=color:#204a87;font-weight:700>select</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>tno</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>                  </span><span style=color:#204a87;font-weight:700>from</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>COURSE</span><span style=color:#000;font-weight:700>);</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div></li><li><p>查询至少有2名男生的班号：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>select</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>CLASS</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>from</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>STUDENT</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>where</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>SSEX</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#4e9a06>&#39;男&#39;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>group</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>by</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>CLASS</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>having</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>count</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>SSEX</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>&gt;</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div></li><li><p>查询Student表中不姓“王”的同学记录：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>select</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>*</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>from</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>STUDENT</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>where</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>SNAME</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>not</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>like</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#4e9a06>&#34;王%&#34;</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div></li><li><p>查询Student表中每个学生的姓名和年龄：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>select</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#000>SNAME</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>year</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>now</span><span style=color:#000;font-weight:700>())</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>-</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>year</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>SBIRTHDAY</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>from</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>STUDENT</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div></li><li><p>查询Student表中最大和最小的Sbirthday日期值：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>select</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>min</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>SBIRTHDAY</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>birthday</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>from</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>STUDENT</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>union</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>select</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>max</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>SBIRTHDAY</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>birthday</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>from</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>STUDENT</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div></li><li><p>以班号和年龄从大到小的顺序查询Student表中的全部记录：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>select</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>*</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>from</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>STUDENT</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>order</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>by</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>CLASS</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>desc</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>year</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>now</span><span style=color:#000;font-weight:700>())</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>-</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>year</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>SBIRTHDAY</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>desc</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div></li><li><p>查询“男”教师及其所上的课程：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>select</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>*</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>from</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>TEACHER</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>COURSE</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>where</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>TSEX</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#4e9a06>&#39;男&#39;</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>and</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>COURSE</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>TNO</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>TEACHER</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>TNO</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div></li><li><p>查询最高分同学的Sno、Cno和Degree列：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>select</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#000>sno</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#000>CNO</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#000>DEGREE</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>from</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>SCORE</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>where</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>DEGREE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>(</span><span style=color:#204a87;font-weight:700>select</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>max</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>DEGREE</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>                </span><span style=color:#204a87;font-weight:700>from</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>SCORE</span><span style=color:#000;font-weight:700>);</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div></li><li><p>查询和“李军”同性别的所有同学的Sname：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>select</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>sname</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>from</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>STUDENT</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>where</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>SSEX</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>(</span><span style=color:#204a87;font-weight:700>select</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>SSEX</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>              </span><span style=color:#204a87;font-weight:700>from</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>STUDENT</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>              </span><span style=color:#204a87;font-weight:700>where</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>SNAME</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#4e9a06>&#39;李军&#39;</span><span style=color:#000;font-weight:700>);</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div></li><li><p>查询和“李军”同性别并同班的同学Sname：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>select</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>sname</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>from</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>STUDENT</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>where</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>(</span><span style=color:#000>SSEX</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>CLASS</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>(</span><span style=color:#204a87;font-weight:700>select</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>                         </span><span style=color:#000>SSEX</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>                         </span><span style=color:#204a87;font-weight:700>CLASS</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>                       </span><span style=color:#204a87;font-weight:700>from</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>STUDENT</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>                       </span><span style=color:#204a87;font-weight:700>where</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>SNAME</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#4e9a06>&#39;李军&#39;</span><span style=color:#000;font-weight:700>);</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div></li><li><p>查询所有选修“计算机导论”课程的“男”同学的成绩表：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>select</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>*</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>from</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>SCORE</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>STUDENT</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>where</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>SCORE</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>SNO</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>STUDENT</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>SNO</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>and</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>SSEX</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#4e9a06>&#39;男&#39;</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>and</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>CNO</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>(</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>select</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>CNO</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>from</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>COURSE</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>where</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>CNAME</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#4e9a06>&#39;计算机导论&#39;</span><span style=color:#000;font-weight:700>);</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div></li><li><p>使用游标方式来同时查询每位同学的名字，他所选课程及成绩：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>declare</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>cursor</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>student_cursor</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>is</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>select</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>S</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>SNO</span><span style=color:#000;font-weight:700>,</span><span style=color:#000>S</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>SNAME</span><span style=color:#000;font-weight:700>,</span><span style=color:#204a87;font-weight:700>C</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>CNAME</span><span style=color:#000;font-weight:700>,</span><span style=color:#000>SC</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>DEGREE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>as</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>DEGREE</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>from</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>STUDENT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>S</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>COURSE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>C</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>SCORE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>SC</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>where</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>S</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>SNO</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#000>SC</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>SNO</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>and</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>SC</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>CNO</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#204a87;font-weight:700>C</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>CNO</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#000>student_row</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>student_cursor</span><span style=color:#ce5c00;font-weight:700>%</span><span style=color:#000>ROWTYPE</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>begin</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>open</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>student_cursor</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>   </span><span style=color:#000>loop</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>    </span><span style=color:#204a87;font-weight:700>fetch</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>student_cursor</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>INTO</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>student_row</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>    </span><span style=color:#000>exit</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>when</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>student_cursor</span><span style=color:#ce5c00;font-weight:700>%</span><span style=color:#000>NOTFOUND</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>     </span><span style=color:#000>dbms_output</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>put_line</span><span style=color:#000;font-weight:700>(</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>student_row</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>SNO</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>||</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#4e9a06>&#39;&#39;</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>||</span><span style=color:#f8f8f8;text-decoration:underline> 
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#000>student_row</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>SNAME</span><span style=color:#ce5c00;font-weight:700>||</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#4e9a06>&#39;&#39;</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>||</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>student_row</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>CNAME</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>||</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#4e9a06>&#39;&#39;</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>||</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#000>student_row</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>DEGREE</span><span style=color:#000;font-weight:700>);</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>   </span><span style=color:#204a87;font-weight:700>end</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>loop</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>close</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>student_cursor</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>END</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#ce5c00;font-weight:700>/</span><span style=color:#f8f8f8;text-decoration:underline> 
</span></span></span></code></pre></div></li><li><p>声明触发器指令，每当有同学转换班级时执行触发器显示当前和之前所在班级：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>CREATE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>OR</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>REPLACE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>TRIGGER</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>display_class_changes</span><span style=color:#f8f8f8;text-decoration:underline> 
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>AFTER</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>DELETE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>OR</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>INSERT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>OR</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>UPDATE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>ON</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>student</span><span style=color:#f8f8f8;text-decoration:underline> 
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>FOR</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>EACH</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>ROW</span><span style=color:#f8f8f8;text-decoration:underline> 
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>WHEN</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>(</span><span style=color:#204a87;font-weight:700>NEW</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>sno</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>&gt;</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#0000cf;font-weight:700>0</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> 
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>BEGIN</span><span style=color:#f8f8f8;text-decoration:underline> 
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>   </span><span style=color:#000>dbms_output</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>put_line</span><span style=color:#000;font-weight:700>(</span><span style=color:#4e9a06>&#39;Old class: &#39;</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>||</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>:</span><span style=color:#204a87;font-weight:700>OLD</span><span style=color:#000;font-weight:700>.</span><span style=color:#204a87;font-weight:700>class</span><span style=color:#000;font-weight:700>);</span><span style=color:#f8f8f8;text-decoration:underline> 
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>   </span><span style=color:#000>dbms_output</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>put_line</span><span style=color:#000;font-weight:700>(</span><span style=color:#4e9a06>&#39;New class: &#39;</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>||</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>:</span><span style=color:#204a87;font-weight:700>NEW</span><span style=color:#000;font-weight:700>.</span><span style=color:#204a87;font-weight:700>class</span><span style=color:#000;font-weight:700>);</span><span style=color:#f8f8f8;text-decoration:underline> 
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>END</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline> 
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#ce5c00;font-weight:700>/</span><span style=color:#f8f8f8;text-decoration:underline> 
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>Update</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>student</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>set</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>class</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#0000cf;font-weight:700>95031</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>where</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>sno</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#0000cf;font-weight:700>109</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div></li><li><p>删除已设置的触发器指令：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>DROP</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>TRIGGER</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>display_class_changes</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div></li></ol></div><div class=td-content style=page-break-before:always><h1 id=pg-737e18886ba6621c88d9e916998f72b7>3.3 - CH03-查询进阶</h1><blockquote><p><a href=https://www.pdai.tech/md/db/sql-lan/sql-lan-leetcode.html>https://www.pdai.tech/md/db/sql-lan/sql-lan-leetcode.html</a></p></blockquote></div><div class=td-content style=page-break-before:always><h1 id=pg-141228844e3202b20692d12c3ddf6e9d>3.4 - CH04-查询优化</h1><h2 id=负向查询不能使用索引>负向查询不能使用索引</h2><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>select</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>name</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>from</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>user</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>where</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>id</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>not</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>in</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>3</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>4</span><span style=color:#000;font-weight:700>);</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><p>应该修改为:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>select name from user where id in (2,5,6);
</span></span></code></pre></div><h2 id=前导模糊查询不能使用索引>前导模糊查询不能使用索引</h2><p>如:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>select</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>name</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>from</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>user</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>where</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>name</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>like</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#4e9a06>&#39;%zhangsan&#39;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><p>非前导则可以:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>select</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>name</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>from</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>user</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>where</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>name</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>like</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#4e9a06>&#39;zhangsan%&#39;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><p>建议可以考虑使用 <code>Lucene</code> 等全文索引工具来代替频繁的模糊查询。</p><h2 id=数据区分不明显的不建议创建索引>数据区分不明显的不建议创建索引</h2><p>如 user 表中的性别字段，可以明显区分的才建议创建索引，如身份证等字段。</p><h2 id=字段的默认值不要为-null>字段的默认值不要为 null</h2><p>这样会带来和预期不一致的查询结果。</p><h2 id=在字段上进行计算不能命中索引>在字段上进行计算不能命中索引</h2><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>select</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>name</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>from</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>user</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>where</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>FROM_UNIXTIME</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>create_time</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>CURDATE</span><span style=color:#000;font-weight:700>();</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><p>应该修改为:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>select</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>name</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>from</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>user</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>where</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>create_time</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>FROM_UNIXTIME</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>CURDATE</span><span style=color:#000;font-weight:700>());</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><h2 id=最左前缀问题>最左前缀问题</h2><p>如果给 user 表中的 username pwd 字段创建了复合索引那么使用以下SQL 都是可以命中索引:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>select</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>username</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>from</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>user</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>where</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>username</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#4e9a06>&#39;zhangsan&#39;</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>and</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>pwd</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#4e9a06>&#39;axsedf1sd&#39;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>select</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>username</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>from</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>user</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>where</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>pwd</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#4e9a06>&#39;axsedf1sd&#39;</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>and</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>username</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#4e9a06>&#39;zhangsan&#39;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>select</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>username</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>from</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>user</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>where</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>username</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#4e9a06>&#39;zhangsan&#39;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><p>但是使用</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>select</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>username</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>from</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>user</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>where</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>pwd</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#4e9a06>&#39;axsedf1sd&#39;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><p>是不能命中索引的。</p><h2 id=如果明确知道只有一条记录返回>如果明确知道只有一条记录返回</h2><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>select</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>name</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>from</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>user</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>where</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>username</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#4e9a06>&#39;zhangsan&#39;</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>limit</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#0000cf;font-weight:700>1</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><p>可以提高效率，可以让数据库停止游标移动。</p><h2 id=不要让数据库帮我们做强制类型转换>不要让数据库帮我们做强制类型转换</h2><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>select</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>name</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>from</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>user</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>where</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>telno</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#0000cf;font-weight:700>18722222222</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><p>这样虽然可以查出数据，但是会导致全表扫描。</p><p>需要修改为</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>select name from user where telno=&#39;18722222222&#39;
</span></span></code></pre></div><h2 id=如果需要进行-join-的字段两表的字段类型要相同>如果需要进行 join 的字段两表的字段类型要相同</h2><p>不然也不会命中索引。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-a0a7894d7606a3f738000a19c4f86fef>3.5 - CH05-连接查询</h1><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211118215743.png style=display:block;width:100% alt=NAME align=center></div><div><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20220508221018.png style=display:block;margin-left:auto;margin-right:auto;width:100% alt=20220508221018></div><div><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20220508221055.png style=display:block;margin-left:auto;margin-right:auto;width:100% alt=20220508221055></div><div><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20220508221115.png style=display:block;margin-left:auto;margin-right:auto;width:60% alt=20220508221115></div></div><div class=td-content style=page-break-before:always><h1 id=pg-e8a3ce34a9aeb6190bbdae2666689618>3.6 - CH06-子查询</h1><p>子查询是嵌套在较大查询中的 SQL 查询。子查询也称为内部查询或内部选择，而包含子查询的语句也称为外部查询或外部选择。</p><ul><li>子查询可以嵌套在 SELECT，INSERT，UPDATE 或 DELETE 语句内或另一个子查询中。</li><li>子查询通常会在另一个 SELECT 语句的 WHERE 子句中添加。</li><li>您可以使用比较运算符，如 >，&lt;，或 =。比较运算符也可以是多行运算符，如 IN，ANY 或 ALL。</li><li>子查询必须被圆括号 () 括起来。</li><li>内部查询首先在其父查询之前执行，以便可以将内部查询的结果传递给外部查询。执行过程可以参考下图：</li></ul><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211215005015.png style=display:block;width:100% alt=NAME align=center></div><p>子查询的子查询</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>SELECT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>cust_name</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>cust_contact</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>FROM</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>customers</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>WHERE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>cust_id</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>IN</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>(</span><span style=color:#204a87;font-weight:700>SELECT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>cust_id</span><span style=color:#f8f8f8;text-decoration:underline>                 
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>                  </span><span style=color:#204a87;font-weight:700>FROM</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>orders</span><span style=color:#f8f8f8;text-decoration:underline>                  
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>                  </span><span style=color:#204a87;font-weight:700>WHERE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>order_num</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>IN</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>(</span><span style=color:#204a87;font-weight:700>SELECT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>order_num</span><span style=color:#f8f8f8;text-decoration:underline>     
</span></span></span></code></pre></div></div><div class=td-content style=page-break-before:always><h1 id=pg-53bea1355742a9e6bdb4f8c8158e6d2d>3.7 - CH07-运维语句</h1><ul><li>DDL（Data Definition Languages）语句<ul><li>数据定义语言，这些语句定义了不同的数据段、数据库、表、列、索引等数据库对象的定义。常用的语句关键字主要包括 create、drop、alter等。</li></ul></li><li>DML（Data Manipulation Language）语句<ul><li>数据操纵语句，用于添加、删除、更新和查询数据库记录，并检查数据完整性，常用的语句关键字主要包括 insert、delete、udpate 和select 等。(增添改查）</li></ul></li><li>DCL（Data Control Language）语句<ul><li>数据控制语句，用于控制不同数据段直接的许可和访问级别的语句。这些语句定义了数据库、表、字段、用户的访问权限和安全级别。主要的语句关键字包括 grant、revoke 等。</li></ul></li></ul><h2 id=ddl>DDL</h2><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span># mysql -uroot -p
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>CREATE USER           #创建用户
</span></span><span style=display:flex><span>CREATE DATABASE       #创建数据库
</span></span><span style=display:flex><span>CREATE TABLE          #创建表
</span></span><span style=display:flex><span>CREATE VIEW           #创建视图
</span></span><span style=display:flex><span>CREATE INDEX          #创建索引
</span></span><span style=display:flex><span>CREATE TRIGGER        #创建触发器
</span></span><span style=display:flex><span>CREATE EVENT          #创建事件
</span></span><span style=display:flex><span>CREATE PROCEDURE      #创建存储过程
</span></span><span style=display:flex><span>CREATE FUNCTION       #创建自定义函数
</span></span></code></pre></div><h3 id=创建用户>创建用户</h3><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>CREATE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>USER</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#4e9a06>&#39;bingwang&#39;</span><span style=color:#ce5c00;font-weight:700>@</span><span style=color:#4e9a06>&#39;192.168.0.10&#39;</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><h3 id=创建数据库>创建数据库</h3><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>CREATE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>DATABASE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>db_name</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>CREATE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>DATABASE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>test_db</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>DEFAULT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>CHARSET</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>utf8mb4</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>DROP</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>DATABASE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>IF</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>EXISTS</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>test_db</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><h3 id=创建表>创建表</h3><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>SHOW</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>CREATE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>TABLE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>tbname</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>CREATE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>TABLE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>t_test</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>(</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>     </span><span style=color:#000>id</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87>INT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>NOT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>NULL</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>AUTO_INCREMENT</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>     </span><span style=color:#000>name</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87>VARCHAR</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>50</span><span style=color:#000;font-weight:700>),</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>     </span><span style=color:#204a87;font-weight:700>PRIMARY</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>KEY</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>id</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>ENGINE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>InnoDB</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>DEFAUL</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>CHARSET</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>utf8mb4</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>DROP</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>TABLE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>IF</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>EXISTS</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>t_test</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><h3 id=复制表>复制表</h3><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#ce5c00;font-weight:700>#</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#a40000>仅结构</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>CREATE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>TABLE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>newbook2</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>LIKE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>newbook</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>CREATE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>TABLE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>newbook3</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>SELECT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>*</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>FROM</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>newbook</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>WHERE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#0000cf;font-weight:700>1</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#0000cf;font-weight:700>2</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#ce5c00;font-weight:700>#</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#a40000>结构</span><span style=color:#ce5c00;font-weight:700>+</span><span style=color:#a40000>数据</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>CREATE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>TABLE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>newbook4</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>SELECT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>*</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>FROM</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>newbook</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#ce5c00;font-weight:700>#</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#a40000>部分数据</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>CREATE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>TABLE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>newbook5</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>SELECT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>id</span><span style=color:#000;font-weight:700>,</span><span style=color:#000>girl_name</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>FROM</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>newbook</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>where</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>id</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#ce5c00;font-weight:700>#</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#a40000>仅部分字段不含数据</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>CREATE</span><span style=color:#f8f8f8;text-decoration:underline>	</span><span style=color:#204a87;font-weight:700>TABLE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>newbook6</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>SELECT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>id</span><span style=color:#000;font-weight:700>,</span><span style=color:#000>girl_name</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>from</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>newbook</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>where</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#0000cf;font-weight:700>1</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#0000cf;font-weight:700>2</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><h3 id=修改表名>修改表名</h3><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>ALTER</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>TABLE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>book</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>RENAME</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>TO</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>newbook</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><h3 id=修改列名>修改列名</h3><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>ALTER</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>TABLE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>book</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>CHANGE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>COLUMN</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>girl_anme</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>girl_name</span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87>varchar</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>10</span><span style=color:#000;font-weight:700>);</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><h3 id=修改列类型>修改列类型</h3><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>ALTER</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>TABLE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>book</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>MODIFY</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>COLUMN</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>authorId</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87>bigint</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>20</span><span style=color:#000;font-weight:700>);</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><h3 id=添加新列>添加新列</h3><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>ALTER</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>table</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>book</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>ADD</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>COLUMN</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>gender</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>tinyint</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>4</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>AFTER</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>name</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><h3 id=删除列>删除列</h3><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>ALTER</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>TABLE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>book</span><span style=color:#f8f8f8;text-decoration:underline>	</span><span style=color:#204a87;font-weight:700>DROP</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>COLUMN</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>gender</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><h3 id=创建视图>创建视图</h3><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>SHOW</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>CREATE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>VIEW</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>test_view</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>CREATE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>VIEW</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>test_view</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>AS</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>SELECT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>*</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>FROM</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>t_test</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>WHERE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>id</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>IN</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>2</span><span style=color:#000;font-weight:700>);</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><h3 id=创建索引>创建索引</h3><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>CREATE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>UNIQUE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>INDEX</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>name_ind</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>ON</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>t_test</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>name</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>USING</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>BTREE</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>CREATE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>INDEX</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>name_index</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>ON</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>t_test</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>name</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>5</span><span style=color:#000;font-weight:700>));</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><h3 id=创建触发器>创建触发器</h3><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>CREATE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>TRIGGER</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>trigger_name</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>trigger_time</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>trigger_event</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>FOR</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>EACH</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>ROW</span><span style=color:#f8f8f8;text-decoration:underline> 
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>BEGIN</span><span style=color:#f8f8f8;text-decoration:underline> 
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#000>trigger_stmt</span><span style=color:#f8f8f8;text-decoration:underline> 
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>END</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><h3 id=创建存储过程>创建存储过程</h3><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>CREATE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>PROCEDURE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>procedure_name</span><span style=color:#000;font-weight:700>([</span><span style=color:#000>proc_parameter</span><span style=color:#000;font-weight:700>[,...]])</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>BEGIN</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#000;font-weight:700>...</span><span style=color:#a40000>存储过程体</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>END</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><h3 id=创建自定义函数>创建自定义函数</h3><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>CREATE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>FUNCTION</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>function_name</span><span style=color:#000;font-weight:700>([</span><span style=color:#000>func_parameter</span><span style=color:#000;font-weight:700>[,...]])</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>RETURNS</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>type</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>BEGIN</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#000;font-weight:700>...</span><span style=color:#a40000>函数体</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>END</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div></div><div class=td-content style=page-break-before:always><h1 id=pg-90906b5d575a42bc40411c9bf01bcfb6>4 - MySQL</h1></div><div class=td-content><h1 id=pg-90adba63667076abecda8b645b08e594>4.1 - CH01-数据类型</h1><h2 id=字段类型>字段类型</h2><h3 id=整型>整型</h3><p>TINYINT, SMALLINT, MEDIUMINT, INT, BIGINT 分别使用 8, 16, 24, 32, 64 位存储空间，一般情况下越小的列越好。</p><p>INT(11) 中的数字只是规定了交互工具显示字符的个数，对于存储和计算来说是没有意义的。</p><h3 id=浮点数>浮点数</h3><p>FLOAT 和 DOUBLE 为浮点类型，DECIMAL 为高精度小数类型。CPU 原生支持浮点运算，但是不支持 DECIMAl 类型的计算，因此 DECIMAL 的计算比浮点类型需要更高的代价。</p><p>FLOAT、DOUBLE 和 DECIMAL 都可以指定列宽，例如 DECIMAL(18, 9) 表示总共 18 位，取 9 位存储小数部分，剩下 9 位存储整数部分。</p><h3 id=字符串>字符串</h3><p>主要有 CHAR 和 VARCHAR 两种类型，一种是定长的，一种是变长的。</p><p>VARCHAR 这种变长类型能够节省空间，因为只需要存储必要的内容。但是在执行 UPDATE 时可能会使行变得比原来长，当超出一个页所能容纳的大小时，就要执行额外的操作。MyISAM 会将行拆成不同的片段存储，而 InnoDB 则需要分裂页来使行放进页内。</p><p>VARCHAR 会保留字符串末尾的空格，而 CHAR 会删除。</p><h3 id=时间和日期>时间和日期</h3><p>MySQL 提供了两种相似的日期时间类型: DATETIME 和 TIMESTAMP。</p><h4 id=1-datetime>1. DATETIME</h4><p>能够保存从 1001 年到 9999 年的日期和时间，精度为秒，使用 8 字节的存储空间。</p><p>它与时区无关。</p><p>默认情况下，MySQL 以一种可排序的、无歧义的格式显示 DATETIME 值，例如“2008-01-16 22:37:08”，这是 ANSI 标准定义的日期和时间表示方法。</p><h4 id=2-timestamp>2. TIMESTAMP</h4><p>和 UNIX 时间戳相同，保存从 1970 年 1 月 1 日午夜(格林威治时间)以来的秒数，使用 4 个字节，只能表示从 1970 年 到 2038 年。</p><p>它和时区有关，也就是说一个时间戳在不同的时区所代表的具体时间是不同的。</p><p>MySQL 提供了 FROM_UNIXTIME() 函数把 UNIX 时间戳转换为日期，并提供了 UNIX_TIMESTAMP() 函数把日期转换为 UNIX 时间戳。</p><p>默认情况下，如果插入时没有指定 TIMESTAMP 列的值，会将这个值设置为当前时间。</p><p>应该尽量使用 TIMESTAMP，因为它比 DATETIME 空间效率更高。</p><h2 id=选择优化的数据类型>选择优化的数据类型</h2><ul><li>更小的通常更好；更小的数据类型通常更快，因为它们占用更少的磁盘、内存和CPU缓存，并且处理时需要的CPU周期也更少；</li><li>简单就好；例如，整形比字符串操作代价更低；使用内建类型而不是字符串来存储日期和时间；用整形存储IP地址等；</li><li>尽量避免NULL；如果查询中包含可为NULL的列，对MySQL来说更难优化，因为可为NULL 的列使得索引、索引统计和值比较都更复杂。尽管把可为NULL的列改为NOT NULL带来的性能提升比较小，但如果计划在列上创建索引，就应该尽量避免设计成可为NULL的列；</li></ul><h3 id=字符串类型>字符串类型</h3><h4 id=varchar-和-char>VARCHAR 和 CHAR</h4><p>VARCHAR是最常见的字符串类型。VARCHAR节省了存储空间，所以对性能也有帮助。但是，由于行是可变的，在UPDATE时可能使行变得比原来更长，这就导致需要做额外的工作。如果一个行占用的空间增长，并且在页内没有更多的空间可以存储，MyISAM会将行拆成不同的片段存储；InnoDB则需要分裂页来使行可以放进页内。</p><p>下面这些情况使用VARCHAR是合适的：字符串的最大长度比平均长度大很多；列的更新很少，所以碎片不是问题；使用了像UTF-8这样复杂的字符集，每个字符都使用不同的字节数进行存储。</p><p>当存储CHAR值时，MySQL会删除所有的末尾空格。CHAR值会根据需要采用空格进行填充以方便比较。</p><p>CHAR适合存储很短的字符串，或者所有值都接近同一个长度，如密码的MD5值。对于经常变更的数据，CHAR也比VARCHAR更好，因为CHAR不容易产生碎片（行间碎片？）。</p><h4 id=varchar5和varchar200>VARCHAR(5)和VARCHAR(200)</h4><blockquote><p>使用VARCHAR(5)和VARCHAR(200)存储"hello"的空间开销是一样的。那么使用更短的列有什么优势吗？</p></blockquote><p>事实证明有很大的优势。更长的列会消耗更多的内存，因为MySQL通常会分配固定大小的内存块来保存内部值。尤其是使用内存临时表进行排序或其他操作时会特别糟糕。在利用磁盘临时表进行排序时也同样糟糕。</p><p>所以最好的策略是只分配真正需要的空间。</p><h4 id=blob-和-text>BLOB 和 TEXT</h4><p>BLOB和TEXT都是为存储很大的数据而设计的数据类型，分别采用二进制和字符方式存储。</p><p>与其他类型不同，MySQL把每个BLOB和TEXT值当做一个独立的对象去处理。当BLOB和TEXT值太大时，InnoDB会使用专门的“外部”存储区域来进行存储，此时每个值在行内需要1~4个字节存储一个指针，然后在外部存储区域存储实际的值。</p><p>MySQL对BLOB和TEXT列进行排序与其他类型是不同的：它只对每个列的最前max_sort_length个字节而不是整个字符串做排序。同样的，MySQL也不能将BLOB或TEXT列全部长度的字符串进行索引。</p><h3 id=选择标识符identifier>选择标识符（identifier）</h3><p>整数类型通常是标识列的最佳选择，因为它们很快并且可以使用AUTO_INCREMENT。 如果可能，应该避免使用字符串类型作为标识列，因为它们很耗空间，并且比数字类型慢。 对于完全随机的字符串也需要多加注意，例如MD5(),SHA1()或者UUID()产生的字符串。这些函数生成的新值会任意分布在很大的空间内，这会导致INSERT以及一些SELECT语句变得很慢：</p><ul><li>因为插入值会随机的写入到索引的不同位置，所以使得INSERT语句更慢。这会导致叶分裂、磁盘随机访问。</li><li>SELECT语句会变的更慢，因为逻辑上相邻的行会分布在磁盘和内存的不同地方。</li><li>随机值导致缓存对所有类型的查询语句效果都很差，因为会使得缓存赖以工作的局部性原理失效。</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-87823f5c8c995312533c60e735d79427>4.2 - CH02-存储引擎</h1><h2 id=innodb>InnoDB</h2><p>是 MySQL 默认的事务型存储引擎，<strong>只有在需要它不支持的特性时，才考虑使用其它存储引擎</strong>。</p><p>实现了四个标准的隔离级别，默认级别是可重复读(REPEATABLE READ)。在可重复读隔离级别下，通过多版本并发控制(MVCC)+ 间隙锁(Next-Key Locking)防止幻读。</p><p>主索引是聚簇索引，在索引中保存了数据，从而避免直接读取磁盘，因此对查询性能有很大的提升。</p><p>内部做了很多优化，包括从磁盘读取数据时采用的可预测性读、能够加快读操作并且自动创建的自适应哈希索引、能够加速插入操作的插入缓冲区等。</p><p>支持真正的在线热备份。其它存储引擎不支持在线热备份，要获取一致性视图需要停止对所有表的写入，而在读写混合场景中，停止写入可能也意味着停止读取。</p><h2 id=myisam>MyISAM</h2><p>设计简单，数据以紧密格式存储。对于只读数据，或者表比较小、可以容忍修复操作，则依然可以使用它。</p><p>提供了大量的特性，包括压缩表、空间数据索引等。</p><p><strong>不支持事务</strong>。</p><p>不支持行级锁，只能对整张表加锁，读取时会对需要读到的所有表加共享锁，写入时则对表加排它锁。但在表有读取操作的同时，也可以往表中插入新的记录，这被称为并发插入(CONCURRENT INSERT)。</p><p>可以手工或者自动执行检查和修复操作，但是和事务恢复以及崩溃恢复不同，可能导致一些数据丢失，而且修复操作是非常慢的。</p><p>如果指定了 DELAY_KEY_WRITE 选项，在每次修改执行完成时，不会立即将修改的索引数据写入磁盘，而是会写到内存中的键缓冲区，只有在清理键缓冲区或者关闭表的时候才会将对应的索引块写入磁盘。这种方式可以极大的提升写入性能，但是在数据库或者主机崩溃时会造成索引损坏，需要执行修复操作。</p><h2 id=对比>对比</h2><ul><li>事务: InnoDB 是事务型的，可以使用 Commit 和 Rollback 语句。</li><li>并发: MyISAM 只支持表级锁，而 InnoDB 还支持行级锁。</li><li>外键: InnoDB 支持外键。</li><li>备份: InnoDB 支持在线热备份。</li><li>崩溃恢复: MyISAM 崩溃后发生损坏的概率比 InnoDB 高很多，而且恢复的速度也更慢。</li><li>其它特性: MyISAM 支持压缩表和空间数据索引。</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-e59a8b6bc16ee47aa4e9119f76c58aa2>4.3 - CH03-索引B+树</h1><h2 id=b-tree-原理>B+ Tree 原理</h2><h3 id=1-数据结构>1. 数据结构</h3><p>B Tree 指的是 Balance Tree，也就是平衡树。平衡树是一颗查找树，并且所有叶子节点位于同一层。</p><p>B+ Tree 是基于 B Tree 和叶子节点顺序访问指针进行实现，它具有 B Tree 的平衡性，并且通过顺序访问指针来提高区间查询的性能。</p><p>在 B+ Tree 中，一个节点中的 key 从左到右非递减排列，如果某个指针的左右相邻 key 分别是 key i 和 key i+1，且不为 null，则该指针指向节点的所有 key 大于等于 key i 且小于等于 key i+1。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210503192121.png style=display:block;width:50% alt=NAME align=center></div><h3 id=2-操作>2. 操作</h3><p>进行查找操作时，首先在根节点进行二分查找，找到一个 key 所在的指针，然后递归地在指针所指向的节点进行查找。直到查找到叶子节点，然后在叶子节点上进行二分查找，找出 key 所对应的 data。</p><p>插入删除操作记录会破坏平衡树的平衡性，因此在插入删除操作之后，需要对树进行一个分裂、合并、旋转等操作来维护平衡性。</p><h3 id=3-与红黑树的比较>3. 与红黑树的比较</h3><p>红黑树等平衡树也可以用来实现索引，但是文件系统及数据库系统普遍采用 B+ Tree 作为索引结构，主要有以下两个原因:</p><p>(一)更少的查找次数</p><p>平衡树查找操作的时间复杂度等于树高 h，而树高大致为 O(h)=O(logdN)，其中 d 为每个节点的出度。</p><p>红黑树的出度为 2，而 B+ Tree 的出度一般都非常大，所以红黑树的树高 h 很明显比 B+ Tree 大非常多，检索的次数也就更多。</p><p>(二)利用计算机预读特性</p><p>为了减少磁盘 I/O，磁盘往往不是严格按需读取，而是每次都会预读。预读过程中，磁盘进行顺序读取，顺序读取不需要进行磁盘寻道，并且只需要很短的旋转时间，因此速度会非常快。</p><p>操作系统一般将内存和磁盘分割成固态大小的块，每一块称为一页，内存与磁盘以页为单位交换数据。数据库系统将索引的一个节点的大小设置为页的大小，使得一次 I/O 就能完全载入一个节点，并且可以利用预读特性，相邻的节点也能够被预先载入。</p><h2 id=mysql-索引>MySQL 索引</h2><p>索引是在存储引擎层实现的，而不是在服务器层实现的，所以不同存储引擎具有不同的索引类型和实现。</p><h3 id=1-btree-索引>1. B+Tree 索引</h3><p>是大多数 MySQL 存储引擎的默认索引类型。</p><p>因为不再需要进行全表扫描，只需要对树进行搜索即可，因此查找速度快很多。除了用于查找，还可以用于排序和分组。</p><p>可以指定多个列作为索引列，多个索引列共同组成键。</p><p>适用于全键值、键值范围和键前缀查找，其中键前缀查找只适用于最左前缀查找。如果不是按照索引列的顺序进行查找，则无法使用索引。</p><p>InnoDB 的 B+Tree 索引分为主索引和辅助索引。</p><p>主索引的叶子节点 data 域记录着完整的数据记录，这种索引方式被称为聚簇索引。因为无法把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210503192439.png style=display:block;width:50% alt=NAME align=center></div><p>辅助索引的叶子节点的 data 域记录着主键的值，因此在使用辅助索引进行查找时，需要先查找到主键值，然后再到主索引中进行查找。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210503192458.png style=display:block;width:50% alt=NAME align=center></div><h3 id=2-哈希索引>2. 哈希索引</h3><p>哈希索引能以 O(1) 时间进行查找，但是失去了有序性，它具有以下限制:</p><ul><li>无法用于排序与分组；</li><li>只支持精确查找，无法用于部分查找和范围查找。</li></ul><p>InnoDB 存储引擎有一个特殊的功能叫“自适应哈希索引”，当某个索引值被使用的非常频繁时，会在 B+Tree 索引之上再创建一个哈希索引，这样就让 B+Tree 索引具有哈希索引的一些优点，比如快速的哈希查找。</p><h3 id=3-全文索引>3. 全文索引</h3><p>MyISAM 存储引擎支持全文索引，用于查找文本中的关键词，而不是直接比较是否相等。查找条件使用 MATCH AGAINST，而不是普通的 WHERE。</p><p>全文索引一般使用倒排索引实现，它记录着关键词到其所在文档的映射。</p><p>InnoDB 存储引擎在 MySQL 5.6.4 版本中也开始支持全文索引。</p><h3 id=4-空间数据索引>4. 空间数据索引</h3><p>MyISAM 存储引擎支持空间数据索引(R-Tree)，可以用于地理数据存储。空间数据索引会从所有维度来索引数据，可以有效地使用任意维度来进行组合查询。</p><p>必须使用 GIS 相关的函数来维护数据。</p><h2 id=索引优化>索引优化</h2><h3 id=1-独立的列>1. 独立的列</h3><p>在进行查询时，索引列不能是表达式的一部分，也不能是函数的参数，否则无法使用索引。</p><p>例如下面的查询不能使用 actor_id 列的索引:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>SELECT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>actor_id</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>FROM</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>sakila</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>actor</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>WHERE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>actor_id</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>+</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#0000cf;font-weight:700>1</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#0000cf;font-weight:700>5</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><h3 id=2-多列索引>2. 多列索引</h3><p>在需要使用多个列作为条件进行查询时，使用多列索引比使用多个单列索引性能更好。例如下面的语句中，最好把 actor_id 和 film_id 设置为多列索引。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>SELECT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>film_id</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>actor_</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>id</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>FROM</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>sakila</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>film_actor</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>WHERE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>actor_id</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#0000cf;font-weight:700>1</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>AND</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>film_id</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><h3 id=3-索引列的顺序>3. 索引列的顺序</h3><p>让选择性最强的索引列放在前面，索引的选择性是指: 不重复的索引值和记录总数的比值。最大值为 1，此时每个记录都有唯一的索引与其对应。选择性越高，查询效率也越高。</p><h4 id=4-前缀索引>4. 前缀索引</h4><p>对于 BLOB、TEXT 和 VARCHAR 类型的列，必须使用前缀索引，只索引开始的部分字符。</p><p>对于前缀长度的选取需要根据索引选择性来确定。</p><h4 id=5-覆盖索引>5. 覆盖索引</h4><p>索引包含所有需要查询的字段的值。</p><p>具有以下优点:</p><ul><li>索引通常远小于数据行的大小，只读取索引能大大减少数据访问量。</li><li>一些存储引擎(例如 MyISAM)在内存中只缓存索引，而数据依赖于操作系统来缓存。因此，只访问索引可以不使用系统调用(通常比较费时)。</li><li>对于 InnoDB 引擎，若辅助索引能够覆盖查询，则无需访问主索引。</li></ul><h2 id=索引的有点>索引的有点</h2><p>大大减少了服务器需要扫描的数据行数。</p><p>帮助服务器避免进行排序和分组，也就不需要创建临时表(B+Tree 索引是有序的，可以用于 ORDER BY 和 GROUP BY 操作。临时表主要是在排序和分组过程中创建，因为不需要排序和分组，也就不需要创建临时表)。</p><p>将随机 I/O 变为顺序 I/O(B+Tree 索引是有序的，也就将相邻的数据都存储在一起)。</p><h3 id=索引的使用场景>索引的使用场景</h3><ul><li>对于非常小的表、大部分情况下简单的全表扫描比建立索引更高效。</li><li>对于中到大型的表，索引就非常有效。</li><li>但是对于特大型的表，建立和维护索引的代价将会随之增长。这种情况下，需要用到一种技术可以直接区分出需要查询的一组数据，而不是一条记录一条记录地匹配，例如可以使用分区技术。</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-e153ee081a2e00565371b72f637f2039>4.4 - CH04-性能优化</h1><h2 id=使用-explain-进行分析>使用 Explain 进行分析</h2><p>Explain 用来分析 SELECT 查询语句，开发人员可以通过分析 Explain 结果来优化查询语句。</p><p>Explain 结果中的字段含义:</p><ul><li><strong>select_type</strong> : 查询类型，有简单查询、联合查询、子查询等</li><li>table：当前数据表</li><li>partitions：</li><li>type：访问类型，表示MySQL在表中查找所需行的方式。<ul><li>ALL：Full Table Scan， MySQL将遍历全表以找到匹配的行；</li><li>index：Full Index Scan，index与ALL区别为index类型只遍历索引树；</li><li>range：只检索给定范围的行，使用一个索引来选择行；</li><li>ref：表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值；</li><li>eq_ref：类似ref，区别就在使用的索引是唯一索引，对于每个索引键值，表中只有一条记录匹配，简单来说，就是多表连接中使用primary key或者 unique key作为关联条件；</li><li>const system：当MySQL对查询某部分进行优化，并转换为一个常量时，使用这些类型访问。如将主键置于where列表中，MySQL就能将该查询转换为一个常量,system是const类型的特例，当查询的表只有一行的情况下，使用system；</li><li>NULL：MySQL在优化过程中分解语句，执行时甚至不用访问表或索引，例如从一个索引列里选取最小值可以通过单独索引查找完成。</li></ul></li><li><strong>possible_keys</strong>：此次查询中可能会被选用的索引，不一定真正用到。</li><li><strong>key</strong>：此次查询中真正使用到的索引。当为复合索引时，不确定是否被充分使用。</li><li><strong>key_len</strong>：表示索引中使用的字节数，用来计算索引是否被充分使用，不损失精确性的情况下，长度越短越好。<ul><li>key_len=字符长度*字节数+类型+是否允许为空</li><li>索引是否充分使用：复合索引每个列都需要计算，所有索引列都生效了才是充分利用。</li><li>计算规则：<ul><li>字节数相关：长度、字符编码、类型（int+0，char+0，varchar+2）、是否允许为空（空+1，非空+0）；</li><li>int类型字节数为4；</li><li>char和varchar的长度是指字符数，一个字符在编码gbk为2个字节、utf-8为3个字节，需要：字符数*字节。</li></ul></li><li>name varchar(50)：表示是varchar类型，长度为50，允许为空，假设是utf8编码<ul><li>key_len=50*3+2+1=153</li></ul></li><li>emp_no int(255)：表示int类型，字节数为4，允许为空，跟长度和编码无关<ul><li>key_len=4+0=4</li></ul></li></ul></li><li><strong>ref</strong>：</li><li><strong>rows</strong> : 预估扫描的行数</li><li>filtered：</li><li><strong>Extra</strong>：<ul><li><strong>Using where</strong>：意味着全表扫描或者在查找使用索引的情况下，但是还有查询条件不在索引字段当中。<ul><li>查询条件中的相关列，不是索引字段， 全表扫描后，通过Using where过滤获取所需的数据**。**</li><li>由于索引未覆盖所有查询条件，在存储引擎返回记录后，仍然需要过滤数据。</li><li>WHERE筛选条件不是索引的前导列，导致不走索引，而走全表扫描。</li></ul></li><li><strong>Using index</strong>：表示直接访问索引就能够获取到所需要的数据（覆盖索引），不需要通过索引回表；</li><li><strong>Using index condition</strong>：会先条件过滤索引，过滤完索引后找到所有符合索引条件的数据行，随后用 WHERE 子句中的其他条件去过滤这些数据行；</li><li><strong>Using where; Using index</strong>：表示在索引的扫描过程中，也是需要过滤数据的（Index First Key 、Index Last Key），其实表扫描和索引扫描也是很类似的。只是发生的层面不一样。</li><li><strong>Using temporary</strong>：表示MySQL需要使用临时表来存储结果集，常见于排序和分组查询。</li><li><strong>Using filesort</strong>： MySQL中无法利用索引完成的排序操作称为“文件排序”。</li></ul></li></ul><blockquote><p>Extra 细节参考：https://www.cnblogs.com/kerrycode/p/9909093.html</p></blockquote><h2 id=优化数据访问>优化数据访问</h2><h3 id=0-引擎逻辑>0. 引擎逻辑</h3><ul><li>当全表扫描速度比索引速度快时，MySQL会使用全表扫描，此时索引失效。</li><li>表中存在多个索引时，即使where条件满足某个索引策略，MySQL查询优化器也不一定会使用该索引，可能使用其他索引，取决于性能。另外，当某个索引没有命中也不一定会走全表扫描，可能走其他索引。</li><li>理论上索引对顺序是敏感的，也就是说where子句的字段列表需要讲究顺序，但是由于MySQL的查询优化器会自动调整where子句的条件顺序以匹配适合的索引，因此，允许我们不去刻意关注where子句的条件顺序。</li></ul><h3 id=1-减少请求的数据量>1. 减少请求的数据量</h3><ul><li>只返回必要的列: 最好不要使用 SELECT * 语句。</li><li>只返回必要的行: 使用 LIMIT 语句来限制返回的数据。</li><li>缓存重复查询的数据: 使用缓存可以避免在数据库中进行查询，特别在要查询的数据经常被重复查询时，缓存带来的查询性能提升将会是非常明显的。</li></ul><h3 id=2-减少服务器端扫描的行数>2. 减少服务器端扫描的行数</h3><p>最有效的方式是使用索引来覆盖查询。</p><p>覆盖索引：SQL只需要通过遍历索引树就可以返回所需要查询的数据，而不必通过辅助索引查到主键值之后再去查询数据（回表操作）。</p><h3 id=3-遵循最左前缀匹配>3. 遵循最左前缀匹配</h3><p>联合索引命中必须遵循“最左前缀法则”。即SQL查询Where条件字段必须从索引的最左前列开始匹配，不能跳过索引中的列。联合索引又称复合索引，类似于书籍的目录，多级的目录结构中子目录依赖于父级目录存在，也是遵循“最左前缀法则”。</p><table><thead><tr><th>联合索引</th><th>INDEX idx_empno_birthdate_gender(emp_no,birth_date,gender)</th></tr></thead><tbody><tr><td>等价建立的索引</td><td>实际上联合索引idx_empno_birthdate_gender等价建立了三个索引：<br>- index_1(emp_no)<br>- index_2(emp_no,birth_date)<br>- index_3(emp_no,birth_date,gender)</td></tr><tr><td>联合索引命中的where条件字段列表</td><td>- index_1命中：emp_no 或 emp_no,gender<br>- index_2命中：emp_no,birth_date<br>- index_3命中：emp_no,birth_date,gender<br>以上where子句查询条件联合索引idx_empno_birthdate_gender都会命中，只是使用的程度不一样（走的子索引不一样），因此，联合索引有“是否充分使用”衡量指标（key_len），当然使用最充分的条件是：所有字段都命中，即使用了index_3。</td></tr></tbody></table><h3 id=4-范围查询字段放最后>4. 范围查询字段放最后</h3><p>联合索引定义时，尽量将范围查询字段放在最后（放在最后联合索引使用最充分，放在中间联合索引使用不充分）。使用联合索引时范围列（当前范围列索引生效）后面的索引列无法生效，同时索引最多用于一个范围列，如果查询条件中有多个范围列，也只能用到一个范围列索引。</p><h3 id=5-不对索引字段进行逻辑操作>5. 不对索引字段进行逻辑操作</h3><p>在索引字段上进行计算、函数、类型转换（自动\手动）都会导致索引失效。</p><h3 id=6-尽量全值匹配>6. 尽量全值匹配</h3><p>全值匹配也就是精确匹配不使用like查询（模糊匹配），使用like会使查询效率降低。</p><h3 id=7-like查询左侧尽量不要加>7. Like查询，左侧尽量不要加%</h3><p>like 以%开头，当前列索引无效(当为联合索引时，当前列和后续列索引不生效，可能导致索引使用不充分)；当like前缀没有%，后缀有%时，索引有效。</p><h3 id=8-注意nullnot-null-可能对索引有影响>8. 注意null/not null 可能对索引有影响</h3><p>在索引列上使用 IS NULL 或 IS NOT NULL条件，可能对索引有所影响。</p><ul><li>字段定义默认为NULL时，NULL索引生效，NOT NULL索引不生效；</li><li>字段定义明确为NOT NULL ，不允许为空时，NULL/NOT NULL索引列，索引均失效；</li></ul><p>列字段尽量设置为NOT NULL，MySQL难以对使用NULL的列进行查询优化，允许Null会使索引值以及索引统计更加复杂。允许NULL值的列需要更多的存储空间，还需要MySQL内部进行特殊处理。</p><h3 id=9-尽量减少使用不等于>9. 尽量减少使用不等于</h3><p>不等于操作符是不会使用索引的。不等于操作符包括：not，&lt;>，!=。</p><p>优化方法：数值型 key&lt;>0 改为 key>0 or key&lt;0。</p><h3 id=10-字符类型务必加上引号>10. 字符类型务必加上引号</h3><p>若varchar类型字段值不加单引号，可能会发生数据类型隐式转化，自动转换为int型，使索引无效。</p><h3 id=11-or关键字左右尽量都为索引列>11. OR关键字左右尽量都为索引列</h3><p>当OR左右查询字段只有一个是索引，会使该索引失效，只有当OR左右查询字段均为索引列时，这些索引才会生效。OR改UNION效率高。</p><h3 id=12-or关键字替换为-union>12. OR关键字替换为 UNION</h3><p>应尽量避免在 WHERE 子句中使用 OR 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，可以使用 UNION 合并查询：select id from t where num=10 union all select id from t where num=20。</p><p>他们的速度只同是否使用索引有关，如果查询需要用到联合索引，用 UNION all 执行的效率更高。多个 OR 的字句没有用到索引，改写成 UNION 的形式再试图与索引匹配。一个关键的问题是否用到索引。</p><h3 id=13-避免使用-in-或-not-in>13. 避免使用 IN 或 NOT IN</h3><p>IN 和 NOT IN 也要慎用，否则会导致全表扫描。对于连续的数值，能用 BETWEEN 就不要用 IN：select id from t where num between 1 and 3。</p><p>或者使用 JOIN 子查询或 EXISTS。</p><p>select num from a where num in(select num from b) 替换为 select num from a where exists(select 1 from b where num=a.num)。</p><h3 id=14-控制索引数量>14. 控制索引数量</h3><p>索引固然可以提高相应的 SELECT 的效率，但同时也降低了 INSERT 及 UPDATE 的效。因为 INSERT 或 UPDATE 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。一个表的索引数最好不要超过 6 个，若太多则应考虑一些不常使用到的列上建的索引是否有必要。</p><h3 id=15-避免更新-clustered-索引数据列>15. 避免更新 clustered 索引数据列</h3><p>因为 clustered 索引数据列的顺序就是表记录的物理存储顺序，一旦该列值改变将导致整个表记录的顺序的调整，会耗费相当大的资源。若应用系统需要频繁更新 clustered 索引数据列，那么需要考虑是否应将该索引建为 clustered 索引。</p><h3 id=16-尽量使用数字型字段>16. 尽量使用数字型字段</h3><p>若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。</p><h3 id=17-尽可能的使用-varchar-nvarchar>17. 尽可能的使用 varchar, nvarchar</h3><p>使用 varchar, nvarchar 代替 char, nchar。因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。</p><h3 id=18-仅返回需要的列>18. 仅返回需要的列</h3><p>最好不要使用返回所有：<code>select * from t</code> ，用具体的字段列表代替 “*”，不要返回用不到的任何字段。</p><h3 id=19-使用表别名-alias>19. 使用表别名 ALIAS</h3><p>当在 SQL 语句中连接多个表时，请使用表的别名并把别名前缀于每个 Column 上。这样一来，就可以减少解析的时间并减少那些由 Column 歧义引起的语法错误。</p><h3 id=20-使用临时表暂存中间结果>20. 使用“临时表”暂存中间结果</h3><p>简化 SQL 语句的重要方法就是采用临时表暂存中间结果。但是临时表的好处远远不止这些，将临时结果暂存在临时表，后面的查询就在 tempdb 中了，这可以避免程序中多次扫描主表，也大大减少了程序执行中“共享锁”阻塞“更新锁”，减少了阻塞，提高了并发性能。</p><h3 id=21-查询语句使用-nolock>21. 查询语句使用 nolock</h3><p>一些 SQL 查询语句应加上 nolock，读、写是会相互阻塞的，为了提高并发性能。对于一些查询，可以加上 nolock，这样读的时候可以允许写，但缺点是可能读到未提交的脏数据。</p><p>使用 nolock 有3条原则：</p><ul><li>查询的结果用于“插、删、改”的不能加 nolock；</li><li>查询的表属于频繁发生页分裂的，慎用 nolock ；</li><li>使用临时表一样可以保存“数据前影”，起到类似 Oracle 的 undo 表空间的功能，能采用临时表提高并发性能的，不要用 nolock。</li></ul><h3 id=22-控制查询涉及的表数量>22. 控制查询涉及的表数量</h3><p>不要有超过 5 个以上的表连接（JOIN），考虑使用临时表或表变量存放中间结果。少用子查询，视图嵌套不要过深，一般视图嵌套不要超过 2 个为宜。</p><h3 id=23-预计算>23. 预计算</h3><p>将需要查询的结果预先计算好放在表中，查询的时候再Select。这在SQL7.0以前是最重要的手段，例如医院的住院费计算。</p><h3 id=23-in-列表时值的顺序>23. IN 列表时值的顺序</h3><p>在IN后面值的列表中，将出现最频繁的值放在最前面，出现得最少的放在最后面，减少判断的次数。</p><h3 id=24-尽量将数据的处理工作放在服务器上减少网络的开销如使用存储过程>24. 尽量将数据的处理工作放在服务器上，减少网络的开销，如使用存储过程。</h3><p>存储过程是编译好、优化过、并且被组织到一个执行规划里、且存储在数据库中的 SQL 语句，是控制流语言的集合，速度当然快。反复执行的动态 SQL，可以使用临时存储过程，该过程（临时表）被放在 Tempdb 中。</p><h3 id=25-服务器线程数量>25. 服务器线程数量</h3><p>当服务器的内存够多时，配制<strong>线程数量 = 最大连接数+5</strong>，这样能发挥最大的效率；</p><p>否则使用<strong>配制线程数量&lt; 最大连接数</strong>，启用 SQL SERVER 的线程池来解决，如果还是<strong>数量 = 最大连接数+5</strong>，严重的损害服务器的性能。</p><h3 id=26-exists-判断是否存在>26. EXISTS 判断是否存在</h3><p>尽量使用 EXISTS 代替 select count(1) 来判断是否存在记录。count 函数只有在统计表中所有行数时使用，而且 count(1) 比 count(*) 更有效率。</p><h3 id=27-尽量使用-不要使用->27. 尽量使用 “>=”，不要使用 “>”</h3><h3 id=28-批量执行插入或更新不要逐条执行>28. 批量执行插入或更新，不要逐条执行</h3><p>JDBC 设置参数 <code>rewriteBatchedStatements=true</code>。</p><h3 id=29-存储过程避免循环>29. 存储过程避免循环</h3><p>例如：列出上个月的每一天，用 connect by 去递归查询一下，绝不会去用循环从上个月第一天到最后一天。</p><h3 id=30-选择最有效率的表名顺序>30. 选择最有效率的表名顺序</h3><p>只在基于规则的优化器中有效：</p><p>Oracle 的解析器按照从右到左的顺序处理 FROM 子句中的表名，FROM 子句中写在最后的表（基础表 driving table）将被最先处理，在 FROM 子句中包含多个表的情况下，你必须选择记录条数最少的表作为基础表。</p><p>如果有 3 个以上的表连接查询，那就需要选择交叉表（intersection table）作为基础表，交叉表是指那个被其他表所引用的表。</p><h3 id=31-过滤掉无需-group-by-的字段>31. 过滤掉无需 GROUP BY 的字段</h3><p>可以通过将不需要的记录在 GROUP BY 之前过滤掉。下面两个查询返回相同结果，但第二个明显就快了许多。</p><p>低效：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>SELECT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>JOB</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>AVG</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>SAL</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> 
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>FROM</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>EMP</span><span style=color:#f8f8f8;text-decoration:underline> 
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>GROUP</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>BY</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>JOB</span><span style=color:#f8f8f8;text-decoration:underline> 
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>HAVING</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>JOB</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#4e9a06>&#39;PRESIDENT&#39;</span><span style=color:#f8f8f8;text-decoration:underline> 
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>OR</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>JOB</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#4e9a06>&#39;MANAGER&#39;</span><span style=color:#f8f8f8;text-decoration:underline> 
</span></span></span></code></pre></div><p>高效：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>SELECT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>JOB</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>AVG</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>SAL</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> 
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>FROM</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>EMP</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>WHERE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>JOB</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#4e9a06>&#39;PRESIDENT&#39;</span><span style=color:#f8f8f8;text-decoration:underline> 
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>OR</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>JOB</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#4e9a06>&#39;MANAGER&#39;</span><span style=color:#f8f8f8;text-decoration:underline> 
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>GROUP</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>BY</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>JOB</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><h3 id=32-sql-语句用大写>32. SQL 语句用大写</h3><p>Oracle 中总是先解析 SQL 语句，把小写的字母转换成大写的再执行。</p><h3 id=36-避免存储过程死锁>36. 避免存储过程死锁</h3><ul><li><p>在你的存储过程和触发器中访问同一个表时总是以相同的顺序；</p></li><li><p>事务应经可能地缩短，在一个事务中应尽可能减少涉及到的数据量；</p></li><li><p>永远不要在事务中等待用户输入。</p></li></ul><h3 id=37-表变量优先于临时表>37. 表变量优先于临时表</h3><p>应尽量避免使用临时表，相反，可以使用表变量代替。大多数时候（99%），表变量驻扎在内存中，因此速度比临时表更快，临时表驻扎在 TempDb 数据库中，因此临时表上的操作需要跨数据库通信，速度自然慢。</p><h3 id=38-避免使用触发器>38. 避免使用触发器</h3><ul><li>触发一个触发器，执行一个触发器事件本身就是一个耗费资源的过程；</li><li>如果能够使用约束实现的，尽量不要使用触发器；</li><li>不要为不同的触发事件（Insert、Update 和 Delete）使用相同的触发器；</li><li>不要在触发器中使用事务型代码。</li></ul><h3 id=39-索引创建规则>39. 索引创建规则</h3><ul><li>表的主键、外键必须有索引；</li><li>数据量超过 300 的表应该有索引；</li><li>经常与其他表进行连接的表，在连接字段上应该建立索引；</li><li>经常出现在 WHERE 子句中的字段，特别是大表的字段，应该建立索引；</li><li>索引应该建在选择性高的字段上；</li><li>索引应该建在小字段上，对于大的文本字段甚至超长字段，不要建索引；</li><li>复合索引的建立需要进行仔细分析，尽量考虑用单字段索引代替；</li><li>正确选择复合索引中的主列字段，一般是选择性较好的字段；</li><li>复合索引的几个字段是否经常同时以 AND 方式出现在 WHERE 子句中？单字段查询是否极少甚至没有？如果是，则可以建立复合索引；否则考虑单字段索引；</li><li>如果复合索引中包含的字段经常单独出现在 WHERE 子句中，则分解为多个单字段索引；</li><li>如果复合索引所包含的字段超过 3 个，那么仔细考虑其必要性，考虑减少复合的字段；</li><li>如果既有单字段索引，又有这几个字段上的复合索引，一般可以删除复合索引；</li><li>频繁进行数据操作的表，不要建立太多的索引；</li><li>删除无用的索引，避免对执行计划造成负面影响；</li><li>表上建立的每个索引都会增加存储开销，索引对于插入、删除、更新操作也会增加处理上的开销。另外，过多的复合索引，在有单字段索引的情况下，一般都是没有存在价值的；相反，还会降低数据增加删除时的性能，特别是对频繁更新的表来说，负面影响更大。</li><li>尽量不要对数据库中某个含有大量重复的值的字段建立索引。</li></ul><h3 id=40-主键设置>40. 主键设置</h3><p>应该为数据库里的每张表都设置一个 ID 做为其主键，而且最好的是一个 INT 型的（推荐使用 UNSIGNED），并设置上自动增加的 AUTO_INCREMENT 标志。</p><h3 id=41-使用-innodb>41. 使用 InnoDB</h3><ul><li><strong>myisam：</strong><ul><li>应用时以读和插入操作为主，只有少量的更新和删除，并且对事务的完整性，并发性要求不是很高的。</li></ul></li><li>InnoDB：<ul><li>事务处理，以及并发条件下要求数据的一致性。除了插入和查询外，包括很多的更新和删除。（InnoDB 有效地降低删除和更新导致的锁定）。</li><li>对于支持事务的 InnoDB类 型的表来说，影响速度的主要原因是 AUTOCOMMIT 默认设置是打开的，而且程序没有显式调用 BEGIN 开始事务，导致每插入一条都自动提交，严重影响了速度。可以在执行 SQL 前调用 begin，多条 SQL 形成一个事物（即使 autocommit 打开也可以），将大大提高性能。</li></ul></li></ul><h3 id=42-选择合适的字段类型>42. 选择合适的字段类型</h3><p>**原则：**更小通常更好，简单就好，所有字段都得有默认值，尽量避免 NULL。</p><p>例如：数据库表设计时候更小的占磁盘空间尽可能使用更小的整数类型。(mediumint 就比 int 更合适)</p><p>比如时间字段：datetime 和 timestamp。datetime 占用8个字节，timestamp 占用4个字节，只用了一半。而 timestamp 表示的范围是 1970—2037 适合做更新时间。</p><p>MySQL可以很好的支持大数据量的存取，但是一般说来，数据库中的表越小，在它上面执行的查询也就会越快。</p><p>因此，在创建表的时候，为了获得更好的性能，我们可以将表中字段的宽度设得尽可能小。</p><p>例如：在定义邮政编码这个字段时，如果将其设置为 CHAR(255)，显然给数据库增加了不必要的空间。甚至使用VARCHAR 这种类型也是多余的，因为 CHAR(6) 就可以很好的完成任务了。</p><p>同样的，如果可以的话，我们应该使用 MEDIUMINT 而不是 BIGIN 来定义整型字段，应该尽量把字段设置为 NOT NULL，这样在将来执行查询的时候，数据库不用去比较 NULL 值。</p><p>对于某些文本字段，例如“省份”或者“性别”，我们可以将它们定义为 ENUM 类型。因为在 MySQL 中，ENUM 类型被当作数值型数据来处理，而数值型数据被处理起来的速度要比文本类型快得多。这样，我们又可以提高数据库的性能。</p><h2 id=重构查询方式>重构查询方式</h2><h3 id=1-切分大查询>1. 切分大查询</h3><p>一个大查询如果一次性执行的话，可能一次锁住很多数据、占满整个事务日志、耗尽系统资源、阻塞很多小的但重要的查询。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#000>DELEFT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>FROM</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>messages</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>WHERE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>create</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>DATE_SUB</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>NOW</span><span style=color:#000;font-weight:700>(),</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87>INTERVAL</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#0000cf;font-weight:700>3</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>MONTH</span><span style=color:#000;font-weight:700>);</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#000>rows_affected</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#0000cf;font-weight:700>0</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>do</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#a40000>{</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>    </span><span style=color:#000>rows_affected</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>do_query</span><span style=color:#000;font-weight:700>(</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>    </span><span style=color:#4e9a06>&#34;DELETE FROM messages WHERE create  &lt; DATE_SUB(NOW(), INTERVAL 3 MONTH) LIMIT 10000&#34;</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#a40000>}</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>while</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>rows_affected</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>&gt;</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#0000cf;font-weight:700>0</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><h3 id=2-分解大连接查询>2. 分解大连接查询</h3><p>将一个大连接查询分解成对每一个表进行一次单表查询，然后将结果在应用程序中进行关联，这样做的好处有:</p><ul><li>让缓存更高效。对于连接查询，如果其中一个表发生变化，那么整个查询缓存就无法使用。而分解后的多个查询，即使其中一个表发生变化，对其它表的查询缓存依然可以使用。</li><li>分解成多个单表查询，这些单表查询的缓存结果更可能被其它查询使用到，从而减少冗余记录的查询。</li><li>减少锁竞争；</li><li>在应用层进行连接，可以更容易对数据库进行拆分，从而更容易做到高性能和可伸缩。</li><li>查询本身效率也可能会有所提升。例如下面的例子中，使用 IN() 代替连接查询，可以让 MySQL 按照 ID 顺序进行查询，这可能比随机的连接要更高效。</li></ul><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>SELECT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>*</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>FROM</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>tab</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>JOIN</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>tag_post</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>ON</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>tag_post</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>tag_id</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#000>tag</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>id</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>JOIN</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>post</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>ON</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>tag_post</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>post_id</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#000>post</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>id</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>WHERE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>tag</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>tag</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#4e9a06>&#39;mysql&#39;</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>SELECT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>*</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>FROM</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>tag</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>WHERE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>tag</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#4e9a06>&#39;mysql&#39;</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>SELECT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>*</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>FROM</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>tag_post</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>WHERE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>tag_id</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#0000cf;font-weight:700>1234</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>SELECT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>*</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>FROM</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>post</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>WHERE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>post</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>id</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>IN</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>123</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>456</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>567</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>9098</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>8904</span><span style=color:#000;font-weight:700>);</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><h2 id=语句执行顺序>语句执行顺序</h2><p>以下是 SQL 中各个子句的语法顺序，前面括号内的数字代表了它们的逻辑执行顺序：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>(6)SELECT [DISTINCT | ALL] col1, col2, agg_func(col3) AS alias
</span></span><span style=display:flex><span>(1)  FROM t1 JOIN t2
</span></span><span style=display:flex><span>(2)    ON (join_conditions)
</span></span><span style=display:flex><span>(3) WHERE where_conditions
</span></span><span style=display:flex><span>(4) GROUP BY col1, col2
</span></span><span style=display:flex><span>(5)HAVING having_condition
</span></span><span style=display:flex><span>(7) UNION [ALL]
</span></span><span style=display:flex><span>   ...
</span></span><span style=display:flex><span>(8) ORDER BY col1 ASC,col2 DESC
</span></span><span style=display:flex><span>(9)OFFSET m ROWS FETCH NEXT num_rows ROWS ONLY;
</span></span></code></pre></div><p>也就是说，SQL 并不是按照编写顺序先执行 SELECT，然后再执行 FROM 子句。从逻辑上讲，SQL 语句的执行顺序如下：</p><ol><li>首先，FROM 和 JOIN 是 SQL 语句执行的第一步。它们的逻辑结果是一个笛卡尔积，决定了接下来要操作的数据集。注意逻辑执行顺序并不代表物理执行顺序，实际上数据库在获取表中的数据之前会使用 ON 和 WHERE 过滤条件进行优化访问；</li><li>其次，应用 ON 条件对上一步的结果进行过滤并生成新的数据集；</li><li>然后，执行 WHERE 子句对上一步的数据集再次进行过滤。WHERE 和 ON 大多数情况下的效果相同，但是外连接查询有所区别，我们将会在下文给出示例；</li><li>接着，基于 GROUP BY 子句指定的表达式进行分组；同时，对于每个分组计算聚合函数 agg_func 的结果。经过 GROUP BY 处理之后，数据集的结构就发生了变化，只保留了分组字段和聚合函数的结果；</li><li>如果存在 GROUP BY 子句，可以利用 HAVING 针对分组后的结果进一步进行过滤，通常是针对聚合函数的结果进行过滤；</li><li>接下来，SELECT 可以指定要返回的列；如果指定了 DISTINCT 关键字，需要对结果集进行去重操作。另外还会为指定了 AS 的字段生成别名；</li><li>如果还有集合操作符（UNION、INTERSECT、EXCEPT）和其他的 SELECT 语句，执行该查询并且合并两个结果集。对于集合操作中的多个 SELECT 语句，数据库通常可以支持并发执行；</li><li>然后，应用 ORDER BY 子句对结果进行排序。如果存在 GROUP BY 子句或者 DISTINCT 关键字，只能使用分组字段和聚合函数进行排序；否则，可以使用 FROM 和 JOIN 表中的任何字段排序；</li><li>最后，OFFSET 和 FETCH（LIMIT、TOP）限定了最终返回的行数。</li></ol><p>了解 SQL 逻辑执行顺序可以帮助我们进行 SQL 优化。例如 WHERE 子句在 HAVING 子句之前执行，因此我们应该尽量使用 WHERE 进行数据过滤，避免无谓的操作；除非业务需要针对聚合函数的结果进行过滤。</p><p>除此之外，理解 SQL 的逻辑执行顺序还可以帮助我们避免一些常见的错误，例如以下语句：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>-- 错误示例
</span></span><span style=display:flex><span>SELECT emp_name AS empname
</span></span><span style=display:flex><span>  FROM employee
</span></span><span style=display:flex><span> WHERE empname =&#39;张飞&#39;;
</span></span></code></pre></div><p>该语句的错误在于 WHERE 条件中引用了列别名；从上面的逻辑顺序可以看出，执行 WHERE 条件时还没有执行 SELECT 子句，也就没有生成字段的别名。</p><p>另外一个需要注意的操作就是 GROUP BY，例如：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>-- GROUP BY 错误示例
</span></span><span style=display:flex><span>SELECT dept_id, emp_name, AVG(salary)
</span></span><span style=display:flex><span>  FROM employee
</span></span><span style=display:flex><span> GROUP BY dept_id;
</span></span></code></pre></div><p>由于经过 GROUP BY 处理之后结果集只保留了分组字段和聚合函数的结果，示例中的 emp_name 字段已经不存在；从业务逻辑上来说，按照部门分组统计之后再显示某个员工的姓名没有意义。如果需要同时显示员工信息和所在部门的汇总，可以使用窗口函数。</p><blockquote><p>如果使用了 GROUP BY 分组，之后的 SELECT、ORDER BY 等只能引用分组字段或者聚合函数；否则，可以引用 FROM 和 JOIN 表中的任何字段。</p></blockquote><p>还有一些逻辑问题可能不会直接导致查询出错，但是会返回不正确的结果；例如外连接查询中的 ON 和 WHERE 条件。以下是一个左外连接查询的示例：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>SELECT e.emp_name, d.dept_name
</span></span><span style=display:flex><span>  FROM employee e
</span></span><span style=display:flex><span>  LEFT JOIN department d ON (e.dept_id = d.dept_id)
</span></span><span style=display:flex><span> WHERE e.emp_name =&#39;张飞&#39;;
</span></span><span style=display:flex><span>emp_name|dept_name|
</span></span><span style=display:flex><span>--------|---------|
</span></span><span style=display:flex><span>张飞     |行政管理部|
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>SELECT e.emp_name, d.dept_name
</span></span><span style=display:flex><span>  FROM employee e
</span></span><span style=display:flex><span>  LEFT JOIN department d ON (e.dept_id = d.dept_id AND e.emp_name =&#39;张飞&#39;);
</span></span><span style=display:flex><span>emp_name|dept_name|
</span></span><span style=display:flex><span>--------|---------|
</span></span><span style=display:flex><span>刘备     |   [NULL]|
</span></span><span style=display:flex><span>关羽     |   [NULL]|
</span></span><span style=display:flex><span>张飞     |行政管理部|
</span></span><span style=display:flex><span>诸葛亮   |   [NULL]|
</span></span><span style=display:flex><span>...
</span></span></code></pre></div><p>第一个查询在 ON 子句中指定了连接的条件，同时通过 WHERE 子句找出了“张飞”的信息。</p><p>第二个查询将所有的过滤条件都放在 ON 子句中，结果返回了所有的员工信息。这是因为左外连接会返回左表中的全部数据，即使 ON 子句中指定了员工姓名也不会生效；而 WHERE 条件在逻辑上是对连接操作之后的结果进行过滤。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-29d040819faa80f395ba725e176690a3>4.5 - CH05-分库分表</h1><h2 id=水平切分>水平切分</h2><p>水平切分又称为 Sharding，它是将同一个表中的记录拆分到多个结构相同的表中。</p><p>当一个表的数据不断增多时，Sharding 是必然的选择，它可以将数据分布到集群的不同节点上，从而缓存单个数据库的压力。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210503194243.png style=display:block;width:50% alt=NAME align=center></div><h2 id=垂直切分>垂直切分</h2><p>垂直切分是将一张表按列切分成多个表，通常是按照列的关系密集程度进行切分，也可以利用垂直切分将经常被使用的列和不经常被使用的列切分到不同的表中。</p><p>在数据库的层面使用垂直切分将按数据库中表的密集程度部署到不同的库中，例如将原来的电商数据库垂直切分成商品数据库、用户数据库等。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210503194255.png style=display:block;width:50% alt=NAME align=center></div><h2 id=sharding-策略>Sharding 策略</h2><ul><li>哈希取模: hash(key) % NUM_DB</li><li>范围: 可以是 ID 范围也可以是时间范围</li><li>映射表: 使用单独的一个数据库来存储映射关系</li></ul><h2 id=sharding-存在的问题及解决方案>Sharding 存在的问题及解决方案</h2><h3 id=1-事务问题>1. 事务问题</h3><p>使用分布式事务来解决，比如 XA 接口。</p><h3 id=2-链接>2. 链接</h3><p>可以将原来的 JOIN 分解成多个单表查询，然后在用户程序中进行 JOIN。</p><h3 id=3-id-唯一性>3. ID 唯一性</h3><ul><li>使用全局唯一 ID: GUID</li><li>为每个分片指定一个 ID 范围</li><li>分布式 ID 生成器 (如 Twitter 的 Snowflake 算法)</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-18dd619a88421627df2c9f215cacaecc>4.6 - CH06-复制分离</h1><h2 id=主从复制>主从复制</h2><p>主要涉及三个线程: binlog 线程、I/O 线程和 SQL 线程。</p><ul><li><strong>binlog 线程</strong> : 负责将主服务器上的数据更改写入二进制日志中。</li><li><strong>I/O 线程</strong> : 负责从主服务器上读取二进制日志，并写入从服务器的中继日志中。</li><li><strong>SQL 线程</strong> : 负责读取中继日志并重放其中的 SQL 语句。</li></ul><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210503194809.png style=display:block;width:50% alt=NAME align=center></div><h2 id=读写分离>读写分离</h2><p>主服务器处理写操作以及实时性要求比较高的读操作，而从服务器处理读操作。</p><p>读写分离能提高性能的原因在于:</p><ul><li>主从服务器负责各自的读和写，极大程度缓解了锁的争用；</li><li>从服务器可以使用 MyISAM，提升查询性能以及节约系统开销；</li><li>增加冗余，提高可用性。</li></ul><p>读写分离常用代理方式来实现，代理服务器接收应用层传来的读写请求，然后决定转发到哪个服务器。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210503194848.png style=display:block;width:50% alt=NAME align=center></div></div><div class=td-content style=page-break-before:always><h1 id=pg-280203572e4e446020b171753e2c2a12>4.7 - CH07-执行过程</h1><h2 id=前言>前言</h2><p>天天和数据库打交道，一天能写上几十条 SQL 语句，但你知道我们的系统是如何和数据库交互的吗？MySQL 如何帮我们存储数据、又是如何帮我们管理事务？&mldr;.是不是感觉真的除了写几个 「select * from dual」外基本脑子一片空白？这篇文章就将带你走进 MySQL 的世界，让你彻底了解系统到底是如何和 MySQL 交互的，MySQL 在接受到我们发送的 SQL 语句时又分别做了哪些事情。</p><h2 id=mysql-驱动>MySQL 驱动</h2><p>我们的系统在和 MySQL 数据库进行通信的时候，总不可能是平白无故的就能接收和发送请求，就算是你没有做什么操作，那总该是有其他的“人”帮我们做了一些事情，基本上使用过 MySQL 数据库的程序员多多少少都会知道 MySQL 驱动这个概念的。就是这个 MySQL 驱动在底层帮我们做了对数据库的连接，只有建立了连接了，才能够有后面的交互。看下图表示</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210503195039.png style=display:block;width:50% alt=NAME align=center></div><p>这样的话，在系统和 MySQL 进行交互之前，MySQL 驱动会帮我们建立好连接，然后我们只需要发送 SQL 语句就可以执行 CRUD 了。一次 SQL 请求就会建立一个连接，多个请求就会建立多个连接，那么问题来了，我们系统肯定不是一个人在使用的，换句话说肯定是存在多个请求同时去争抢连接的情况。我们的 web 系统一般都是部署在 tomcat 容器中的，而 tomcat 是可以并发处理多个请求的，这就会导致多个请求会去建立多个连接，然后使用完再都去关闭，这样会有什么问题呢？如下图</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210503195111.png style=display:block;width:50% alt=NAME align=center></div><p>java 系统在通过 MySQL 驱动和 MySQL 数据库连接的时候是基于 TCP/IP 协议的，所以如果每个请求都是新建连接和销毁连接，那这样势必会造成不必要的浪费和性能的下降，也就说上面的多线程请求的时候频繁的创建和销毁连接显然是不合理的。必然会大大降低我们系统的性能，但是如果给你提供一些固定的用来连接的线程，这样是不是不需要反复的创建和销毁连接了呢？相信懂行的朋友会会心一笑，没错，说的就是数据库连接池。</p><p><strong>数据库连接池</strong>：维护一定的连接数，方便系统获取连接，使用就去池子中获取，用完放回去就可以了，我们不需要关心连接的创建与销毁，也不需要关心线程池是怎么去维护这些连接的。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210503195148.png style=display:block;width:50% alt=NAME align=center></div><p>常见的数据库连接池有 HakariCP、Druid、C3P0、DBCP，连接池实现原理在这里就不深入讨论了，采用连接池大大节省了不断创建与销毁线程的开销，这就是有名的「池化」思想，不管是线程池还是 HTTP 连接池，都能看到它的身影。</p><h2 id=数据库连接池>数据库连接池</h2><p>到这里，我们已经知道的是我们的系统在访问 MySQL 数据库的时候，建立的连接并不是每次请求都会去创建的，而是从数据库连接池中去获取，这样就解决了因为反复的创建和销毁连接而带来的性能损耗问题了。不过这里有个小问题，业务系统是并发的，而 MySQL 接受请求的线程呢，只有一个？</p><p>其实 MySQL 的架构体系中也已经提供了这样的一个池子，也是数据库连池。双方都是通过数据库连接池来管理各个连接的，这样一方面线程之前不需要是争抢连接，更重要的是不需要反复的创建的销毁连接。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210503195232.png style=display:block;width:50% alt=NAME align=center></div><p>至此系统和 MySQL 数据库之间的连接问题已经说明清楚了。那么 MySQL 数据库中的这些连接是怎么来处理的，又是谁来处理呢？</p><h2 id=网络连接必须由线程来处理>网络连接必须由线程来处理</h2><p>对计算基础稍微有一点了解的的同学都是知道的，网络中的连接都是由线程来处理的，所谓网络连接说白了就是一次请求，每次请求都会有相应的线程去处理的。也就是说对于 SQL 语句的请求在 MySQL 中是由一个个的线程去处理的。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210503195303.png style=display:block;width:50% alt=NAME align=center></div><p>那这些线程会怎么去处理这些请求？会做哪些事情？</p><h2 id=sql-接口>SQL 接口</h2><p>MySQL 中处理请求的线程在获取到请求以后获取 SQL 语句去交给 SQL 接口去处理。</p><h2 id=查询解析器>查询解析器</h2><p>假如现在有这样的一个 SQL</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>SELECT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>stuName</span><span style=color:#000;font-weight:700>,</span><span style=color:#000>age</span><span style=color:#000;font-weight:700>,</span><span style=color:#000>sex</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>FROM</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>students</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>WHERE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>id</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#0000cf;font-weight:700>1</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><p>但是这个 SQL 是写给我们人看的，机器哪里知道你在说什么？这个时候解析器就上场了。他会将 SQL 接口传递过来的 SQL 语句进行解析，翻译成 MySQL 自己能认识的语言，至于怎么解析的就不需要在深究了，无非是自己一套相关的规则。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210503195353.png style=display:block;width:50% alt=NAME align=center></div><p>现在 SQL 已经被解析成 MySQL 认识的样子的，那下一步是不是就是执行吗？理论上是这样子的，但是 MySQL 的强大远不止于此，他还会帮我们选择最优的查询路径。</p><p>什么叫最优查询路径？就是 MySQL 会按照自己认为的效率最高的方式去执行查询.</p><p>具体是怎么做到的呢？这就要说到 MySQL 的查询优化器了</p><h2 id=mysql-查询优化器>MySQL 查询优化器</h2><p>查询优化器内部具体怎么实现的我们不需要是关心，我需要知道的是 MySQL 会帮我去使用他自己认为的最好的方式去优化这条 SQL 语句，并生成一条条的执行计划，比如你创建了多个索引，MySQL 会依据成本最小原则来选择使用对应的索引，这里的成本主要包括两个方面, IO 成本和 CPU 成本</p><p><strong>IO 成本</strong>: 即从磁盘把数据加载到内存的成本，默认情况下，读取数据页的 IO 成本是 1，MySQL 是以页的形式读取数据的，即当用到某个数据时，并不会只读取这个数据，而会把这个数据相邻的数据也一起读到内存中，这就是有名的程序局部性原理，所以 MySQL 每次会读取一整页，一页的成本就是 1。所以 IO 的成本主要和页的大小有关</p><p><strong>CPU 成本</strong>：将数据读入内存后，还要检测数据是否满足条件和排序等 CPU 操作的成本，显然它与行数有关，默认情况下，检测记录的成本是 0.2。</p><p>MySQL 优化器 会计算 「IO 成本 + CPU」 成本最小的那个索引来执行</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210503195422.png style=display:block;width:50% alt=NAME align=center></div><p>优化器执行选出最优索引等步骤后，会去调用存储引擎接口，开始去执行被 MySQL 解析过和优化过的 SQL 语句</p><h2 id=存储引擎>存储引擎</h2><p>查询优化器会调用存储引擎的接口，去执行 SQL，也就是说真正执行 SQL 的动作是在存储引擎中完成的。数据是被存放在内存或者是磁盘中的（存储引擎是一个非常重要的组件，后面会详细介绍）</p><h2 id=执行器>执行器</h2><p>执行器是一个非常重要的组件，因为前面那些组件的操作最终必须通过执行器去调用存储引擎接口才能被执行。执行器最终最根据一系列的执行计划去调用存储引擎的接口去完成 SQL 的执行</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210503195448.png style=display:block;width:50% alt=NAME align=center></div><h2 id=初识存储引擎>初识存储引擎</h2><p>我们以一个更新的SQL语句来说明，SQL 如下</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>UPDATE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>students</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>SET</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>stuName</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#4e9a06>&#39;小强&#39;</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>WHERE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>id</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#0000cf;font-weight:700>1</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><p>当我们系统发出这样的查询去交给 MySQL 的时候，MySQL 会按照我们上面介绍的一系列的流程最终通过执行器调用存储引擎去执行，流程图就是上面那个。在执行这个 SQL 的时候 SQL 语句对应的数据要么是在内存中，要么是在磁盘中，如果直接在磁盘中操作，那这样的随机IO读写的速度肯定让人无法接受的，所以每次在执行 SQL 的时候都会将其数据加载到内存中，这块内存就是 InnoDB 中一个非常重要的组件：<strong>缓冲池 Buffer Pool</strong></p><h2 id=buffer-pool>Buffer Pool</h2><p>Buffer Pool （缓冲池）是 InnoDB 存储引擎中非常重要的内存结构，顾名思义，缓冲池其实就是类似 Redis 一样的作用，起到一个缓存的作用，因为我们都知道 MySQL 的数据最终是存储在磁盘中的，如果没有这个 Buffer Pool 那么我们每次的数据库请求都会磁盘中查找，这样必然会存在 IO 操作，这肯定是无法接受的。但是有了 Buffer Pool 就是我们第一次在查询的时候会将查询的结果存到 Buffer Pool 中，这样后面再有请求的时候就会先从缓冲池中去查询，如果没有再去磁盘中查找，然后在放到 Buffer Pool 中，如下图</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210503195538.png style=display:block;width:50% alt=NAME align=center></div><p>按照上面的那幅图，这条 SQL 语句的执行步骤大致是这样子的</p><ul><li>innodb 存储引擎会在缓冲池中查找 id=1 的这条数据是否存在</li><li>发现不存在，那么就会去磁盘中加载，并将其存放在缓冲池中</li><li>该条记录会被加上一个独占锁（总不能你在修改的时候别人也在修改吧，这个机制本篇文章不重点介绍，以后会专门写文章来详细讲解）</li></ul><h2 id=undo-日志文件记录数据被修改前的样子>undo 日志文件：记录数据被修改前的样子</h2><p>undo 顾名思义，就是没有做，没发生的意思。undo log 就是没有发生事情（原本事情是什么）的一些日志</p><p>我们刚刚已经说了，在准备更新一条语句的时候，该条语句已经被加载到 Buffer pool 中了，实际上这里还有这样的操作，就是在将该条语句加载到 Buffer Pool 中的时候同时会往 undo 日志文件中插入一条日志，也就是将 id=1 的这条记录的原来的值记录下来。</p><p><strong>这样做的目的是什么</strong>？</p><p>Innodb 存储引擎的最大特点就是支持事务，如果本次更新失败，也就是事务提交失败，那么该事务中的所有的操作都必须回滚到执行前的样子，也就是说当事务失败的时候，也不会对原始数据有影响，看图说话</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210503195600.png style=display:block;width:50% alt=NAME align=center></div><p>这里说句额外话，其实 MySQL 也是一个系统，就好比我们平时开发的 java 的功能系统一样，MySQL 使用的是自己相应的语言开发出来的一套系统而已，它根据自己需要的功能去设计对应的功能，它即然能做到哪些事情，那么必然是设计者们当初这么定义或者是根据实际的场景变更演化而来的。所以大家放平心态，把 MySQL 当作一个系统去了解熟悉他。</p><p>到这一步，我们的执行的 SQL 语句已经被加载到 Buffer Pool 中了，然后开始更新这条语句，更新的操作实际是在Buffer Pool中执行的，那问题来了，按照我们平时开发的一套理论缓冲池中的数据和数据库中的数据不一致时候，我们就认为缓存中的数据是脏数据，那此时 Buffer Pool 中的数据岂不是成了脏数据？没错，目前这条数据就是脏数据，Buffer Pool 中的记录是小强 数据库中的记录是旺财 ，这种情况 MySQL是怎么处理的呢，继续往下看</p><h2 id=redo-日志文件记录数据被修改后的样子>redo 日志文件：记录数据被修改后的样子</h2><p>除了从磁盘中加载文件和将操作前的记录保存到 undo 日志文件中，其他的操作是在内存中完成的，内存中的数据的特点就是：断电丢失。如果此时 MySQL 所在的服务器宕机了，那么 Buffer Pool 中的数据会全部丢失的。这个时候 redo 日志文件就需要来大显神通了</p><p><strong>画外音：redo 日志文件是 InnoDB 特有的，他是存储引擎级别的，不是 MySQL 级别的</strong></p><p>redo 记录的是数据修改之后的值，不管事务是否提交都会记录下来，例如，此时将要做的是update students set stuName=&lsquo;小强&rsquo; where id=1; 那么这条操作就会被记录到 redo log buffer 中，啥？怎么又出来一个 redo log buffer ,很简单，MySQL 为了提高效率，所以将这些操作都先放在内存中去完成，然后会在某个时机将其持久化到磁盘中。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210503195621.png style=display:block;width:50% alt=NAME align=center></div><p>截至目前，我们应该都熟悉了 MySQL 的执行器调用存储引擎是怎么将一条 SQL 加载到缓冲池和记录哪些日志的，流程如下：</p><ul><li>准备更新一条 SQL 语句</li><li>MySQL（innodb）会先去缓冲池（BufferPool）中去查找这条数据，没找到就会去磁盘中查找，如果查找到就会将这条数据加载到缓冲池（BufferPool）中</li><li>在加载到 Buffer Pool 的同时，会将这条数据的原始记录保存到 undo 日志文件中</li><li>innodb 会在 Buffer Pool 中执行更新操作</li><li>更新后的数据会记录在 redo log buffer 中</li></ul><p>上面说的步骤都是在正常情况下的操作，但是程序的设计和优化并不仅是为了这些正常情况而去做的，也是为了<strong>那些临界区和极端情况下出现的问题去优化</strong>设计的</p><p>这个时候如果服务器宕机了，那么缓存中的数据还是丢失了。真烦，竟然数据总是丢失，那能不能不要放在内存中，直接保存到磁盘呢？很显然不行，因为在上面也已经介绍了，在内存中的操作目的是为了提高效率。</p><p>此时，如果 MySQL 真的宕机了，那么没关系的，因为 MySQL 会认为本次事务是失败的，所以数据依旧是更新前的样子，并不会有任何的影响。</p><p>好了，语句也更新好了那么需要将更新的值提交啊，也就是需要提交本次的事务了，因为只要事务成功提交了，才会将最后的变更保存到数据库，在提交事务前仍然会具有相关的其他操作</p><p>将 redo Log Buffer 中的数据持久化到磁盘中，就是将 redo log buffer 中的数据写入到 redo log 磁盘文件中，一般情况下，redo log Buffer 数据写入磁盘的策略是立即刷入磁盘（具体策略情况在下面小总结出会详细介绍）,上图</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210503195634.png style=display:block;width:50% alt=NAME align=center></div><p>如果 redo log Buffer 刷入磁盘后，数据库服务器宕机了，那我们更新的数据怎么办？此时数据是在内存中，数据岂不是丢失了？不，这次数据就不会丢失了，因为 redo log buffer 中的数据已经被写入到磁盘了，已经被持久化了，就算数据库宕机了，在下次重启的时候 MySQL 也会将 redo 日志文件内容恢复到 Buffer Pool 中（这边我的理解是和 Redis 的持久化机制是差不多的，在 Redis 启动的时候会检查 rdb 或者是 aof 或者是两者都检查，根据持久化的文件来将数据恢复到内存中）</p><p>到此为止，<strong>从执行器开始调用存储引擎接口做了哪些事情呢</strong>？</p><ul><li>准备更新一条 SQL 语句</li><li>MySQL（innodb）会先去缓冲池（BufferPool）中去查找这条数据，没找到就会去磁盘中查找，如果查找到就会将这条数据加载</li><li>到缓冲池（BufferPool）中 3.在加载到 Buffer Pool 的同时，会将这条数据的原始记录保存到 undo 日志文件中</li><li>innodb 会在 Buffer Pool 中执行更新操作</li><li>更新后的数据会记录在 redo log buffer 中</li><li>MySQL 提交事务的时候，会将 redo log buffer 中的数据写入到 redo 日志文件中 刷磁盘可以通过 innodb_flush_log_at_trx_commit 参数来设置<ul><li>值为 0 表示不刷入磁盘</li><li>值为 1 表示立即刷入磁盘</li><li>值为 2 表示先刷到 os cache</li></ul></li><li>myslq 重启的时候会将 redo 日志恢复到缓冲池中</li></ul><p>截止到目前位置，MySQL 的执行器调用存储引擎的接口去执行【执行计划】提供的 SQL 的时候 InnoDB 做了哪些事情也就基本差不多了，但是这还没完。下面还需要介绍下 MySQL 级别的日志文件 bin log</p><h2 id=bin-log-日志文件记录整个操作过程>bin log 日志文件：记录整个操作过程</h2><p>上面介绍到的redo log是 InnoDB 存储引擎特有的日志文件，而bin log属于是 MySQL 级别的日志。redo log记录的东西是偏向于物理性质的，如：“对什么数据，做了什么修改”。bin log是偏向于逻辑性质的，类似于：“对 students 表中的 id 为 1 的记录做了更新操作” 两者的主要特点总结如下:</p><table><thead><tr><th>性质</th><th>redo Log</th><th>bin Log</th></tr></thead><tbody><tr><td>文件大小</td><td>redo log 的大小是固定的（配置中也可以设置，一般默认的就足够了）</td><td>bin log 可通过配置参数max_bin log_size设置每个bin log文件的大小（但是一般不建议修改）。</td></tr><tr><td>实现方式</td><td>redo log是InnoDB引擎层实现的（也就是说是 Innodb 存储引起过独有的）</td><td>bin log是 MySQL 层实现的，所有引擎都可以使用 bin log日志</td></tr><tr><td>记录方式</td><td>redo log 采用循环写的方式记录，当写到结尾时，会回到开头循环写日志。</td><td>bin log 通过追加的方式记录，当文件大小大于给定值后，后续的日志会记录到新的文件上</td></tr><tr><td>使用场景</td><td>redo log适用于崩溃恢复(crash-safe)（这一点其实非常类似与 Redis 的持久化特征）</td><td>bin log 适用于主从复制和数据恢复</td></tr></tbody></table><p><strong>bin log文件是如何刷入磁盘的</strong>?</p><p>bin log 的刷盘是有相关的策略的，策略可以通过sync_bin log来修改，默认为 0，表示先写入 os cache，也就是说在提交事务的时候，数据不会直接到磁盘中，这样如果宕机bin log数据仍然会丢失。所以建议将sync_bin log设置为 1 表示直接将数据写入到磁盘文件中。</p><p>刷入 bin log 有以下几种模式</p><ul><li><strong>STATMENT</strong></li></ul><p>基于 SQL 语句的复制(statement-based replication, SBR)，每一条会修改数据的 SQL 语句会记录到 bin log 中</p><p>【优点】：不需要记录每一行的变化，减少了 bin log 日志量，节约了 IO , 从而提高了性能</p><p>【缺点】：在某些情况下会导致主从数据不一致，比如执行sysdate()、slepp()等</p><ul><li><strong>ROW</strong></li></ul><p>基于行的复制(row-based replication, RBR)，不记录每条SQL语句的上下文信息，仅需记录哪条数据被修改了</p><p>【优点】：不会出现某些特定情况下的存储过程、或 function、或 trigger 的调用和触发无法被正确复制的问题</p><p>【缺点】：会产生大量的日志，尤其是 alter table 的时候会让日志暴涨</p><ul><li><strong>MIXED</strong></li></ul><p>基于 STATMENT 和 ROW 两种模式的混合复制( mixed-based replication, MBR )，一般的复制使用 STATEMENT 模式保存 bin log ，对于 STATEMENT 模式无法复制的操作使用 ROW 模式保存 bin log</p><p>那既然bin log也是日志文件，那它是在什么记录数据的呢？</p><p>其实 MySQL 在提交事务的时候，不仅仅会将 redo log buffer 中的数据写入到redo log 文件中，同时也会将本次修改的数据记录到 bin log文件中，同时会将本次修改的bin log文件名和修改的内容在bin log中的位置记录到redo log中，最后还会在redo log最后写入 commit 标记，这样就表示本次事务被成功的提交了。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210503195659.png style=display:block;width:50% alt=NAME align=center></div><p>如果在数据被写入到bin log文件的时候，刚写完，数据库宕机了，数据会丢失吗？</p><p>首先可以确定的是，只要redo log最后没有 commit 标记，说明本次的事务一定是失败的。但是数据是没有丢失了，因为已经被记录到redo log的磁盘文件中了。在 MySQL 重启的时候，就会将 redo log 中的数据恢复（加载）到Buffer Pool中。</p><p>好了，到目前为止，一个更新操作我们基本介绍得差不多，但是你有没有感觉少了哪件事情还没有做？是不是你也发现这个时候被更新记录仅仅是在内存中执行的，哪怕是宕机又恢复了也仅仅是将更新后的记录加载到Buffer Pool中，这个时候 MySQL 数据库中的这条记录依旧是旧值，也就是说内存中的数据在我们看来依旧是脏数据，那这个时候怎么办呢？</p><p>其实 MySQL 会有一个后台线程，它会在某个时机将我们Buffer Pool中的脏数据刷到 MySQL 数据库中，这样就将内存和数据库的数据保持统一了。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210503195713.png style=display:block;width:50% alt=NAME align=center></div><h2 id=本文总结>本文总结</h2><p>到此，关于Buffer Pool、Redo Log Buffer 和undo log、redo log、bin log 概念以及关系就基本差不多了。</p><p>我们再回顾下</p><ul><li>Buffer Pool 是 MySQL 的一个非常重要的组件，因为针对数据库的增删改操作都是在 Buffer Pool 中完成的</li><li>Undo log 记录的是数据操作前的样子</li><li>redo log 记录的是数据被操作后的样子（redo log 是 Innodb 存储引擎特有）</li><li>bin log 记录的是整个操作记录（这个对于主从复制具有非常重要的意义）</li></ul><p>从准备更新一条数据到事务的提交的流程描述</p><ul><li>首先执行器根据 MySQL 的执行计划来查询数据，先是从缓存池中查询数据，如果没有就会去数据库中查询，如果查询到了就将其放到缓存池中</li><li>在数据被缓存到缓存池的同时，会写入 undo log 日志文件</li><li>更新的动作是在 BufferPool 中完成的，同时会将更新后的数据添加到 redo log buffer 中</li><li>完成以后就可以提交事务，在提交的同时会做以下三件事<ul><li>将redo log buffer中的数据刷入到 redo log 文件中</li><li>将本次操作记录写入到 bin log文件中</li><li>将 bin log 文件名字和更新内容在 bin log 中的位置记录到redo log中，同时在 redo log 最后添加 commit 标记</li></ul></li></ul><p>至此表示整个更新事务已经完成</p></div><div class=td-content style=page-break-before:always><h1 id=pg-2f770b4ebcff7b1cb1f0b0c93c9c266f>4.8 - CH08-参考规约</h1><h2 id=建表>建表</h2><ol><li><p><font color=red>强制：</font>表达是与否概念的字段，必须使用 is_xxx 的方式命名，数据类型是 unsigned tinyint （1 表示是，0 表示否）。 说明：任何字段如果为非负数，必须是 unsigned。 注意：POJO 类中的任何布尔类型的变量，都不要加 is 前缀，所以，需要在<code>&lt;resultMap></code>设置 从 is_xxx 到 Xxx 的映射关系。数据库表示是与否的值，使用 tinyint 类型，坚持 is_xxx 的 命名方式是为了明确其取值含义与取值范围。 正例：表达逻辑删除的字段名 is_deleted，1 表示删除，0 表示未删除。</p></li><li><p><font color=red>强制：</font>表名、字段名必须使用小写字母或数字，禁止出现数字开头，禁止两个下划线中间只 出现数字。数据库字段名的修改代价很大，因为无法进行预发布，所以字段名称需要慎重考虑。 说明：MySQL 在 Windows 下不区分大小写，但在 Linux 下默认是区分大小写。因此，数据库名、 表名、字段名，都不允许出现任何大写字母，避免节外生枝。 正例：aliyun_admin，rdc_config，level3_name 反例：AliyunAdmin，rdcConfig，level_3_name</p></li><li><p><font color=red>强制：</font>表名不使用复数名词。 说明：表名应该仅仅表示表里面的实体内容，不应该表示实体数量，对应于 DO 类名也是单数 形式，符合表达习惯。</p></li><li><p><font color=red>强制：</font>禁用保留字，如 desc、range、match、delayed 等，请参考 MySQL 官方保留字。</p></li><li><p><font color=red>强制：</font>主键索引名为 pk_字段名；唯一索引名为 uk_字段名；普通索引名则为 idx_字段名。 说明：pk_ 即 primary key；uk_ 即 unique key；idx_ 即 index 的简称。</p></li><li><p><font color=red>强制：</font>小数类型为 decimal，禁止使用 float 和 double。</p><ul><li>说明：float 和 double 在存储的时候，存在精度损失的问题，很可能在值的比较时，得到不 正确的结果。如果存储的数据范围超过 decimal 的范围，建议将数据拆成整数和小数分开存储。</li></ul></li><li><p><font color=red>强制：</font>如果存储的字符串长度几乎相等，使用 char 定长字符串类型。</p></li><li><p><font color=red>强制：</font>varchar 是可变长字符串，不预先分配存储空间，长度不要超过 5000，如果存储长 度大于此值，定义字段类型为 text，独立出来一张表，用主键来对应，避免影响其它字段索 引效率。</p></li><li><p><font color=red>强制：</font>表必备三字段：id, gmt_create, gmt_modified。</p><ul><li><p>说明：其中 id 必为主键，类型为 bigint unsigned、单表时自增、步长为 1。gmt_create,</p></li><li><p>gmt_modified 的类型均为 datetime 类型，前者现在时表示主动创建，后者过去分词表示被动更新。</p></li></ul></li><li><p><font color=blue>推荐：</font>表的命名最好是加上“业务名称_表的作用”。 正例：alipay_task / force_project / trade_config</p></li><li><p><font color=blue>推荐：</font>库名与应用名称尽量一致。</p></li><li><p><font color=blue>推荐：</font>如果修改字段含义或对字段表示的状态追加时，需要及时更新字段注释。</p></li><li><p><font color=blue>推荐：</font>字段允许适当冗余，以提高查询性能，但必须考虑数据一致。冗余字段应遵循： 1）不是频繁修改的字段。 2）不是 varchar 超长字段，更不能是 text 字段。 正例：商品类目名称使用频率高，字段长度短，名称基本一成不变，可在相关联的表中冗余存 储类目名称，避免关联查询。</p></li><li><p><font color=blue>推荐：</font>单表行数超过 500 万行或者单表容量超过 2GB，才推荐进行分库分表。 说明：如果预计三年后的数据量根本达不到这个级别，请不要在创建表时就分库分表。</p></li><li><p><font color=#1A7605>参考：</font>合适的字符存储长度，不但节约数据库表空间、节约索引存储，更重要的是提升检 索速度。 正例：如下表，其中无符号值可以避免误存负数，且扩大了表示范围。</p></li></ol><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211028223753.png style=display:block;width:60% alt=NAME align=center></div><h2 id=索引>索引</h2><ol><li><p><font color=red>强制：</font>业务上具有唯一特性的字段，即使是多个字段的组合，也必须建成唯一索引。 说明：不要以为唯一索引影响了 insert 速度，这个速度损耗可以忽略，但提高查找速度是明 显的；另外，即使在应用层做了非常完善的校验控制，只要没有唯一索引，根据墨菲定律，必 然有脏数据产生。</p></li><li><p><font color=red>强制：</font>超过三个表禁止 join。需要 join 的字段，数据类型必须绝对一致；多表关联查询时， 保证被关联的字段需要有索引。 说明：即使双表 join 也要注意表索引、SQL 性能。</p></li><li><p><font color=red>强制：</font>在 varchar 字段上建立索引时，必须指定索引长度，没必要对全字段建立索引，根据 实际文本区分度决定索引长度即可。</p><ul><li>说明：索引的长度与区分度是一对矛盾体，一般对字符串类型数据，长度为 20 的索引，区分 度会高达 90%以上，可以使用 <code>count(distinct left(列名, 索引长度))/count(*)</code> 的区分度 来确定。</li></ul></li><li><p><font color=red>强制：</font>页面搜索严禁左模糊或者全模糊，如果需要请走搜索引擎来解决。 说明：索引文件具有 B-Tree 的最左前缀匹配特性，如果左边的值未确定，那么无法使用此索 引。</p></li><li><p><font color=blue>推荐：</font>如果有 order by 的场景，请注意利用索引的有序性。order by 最后的字段是组合 索引的一部分，并且放在索引组合顺序的最后，避免出现 file_sort 的情况，影响查询性能。 正例：where a=? and b=? order by c; 索引：a_b_c</p><ul><li>反例：索引中有范围查找，那么索引有序性无法利用，如：WHERE a>10 ORDER BY b; 索引 a_b 无法排序。</li></ul></li><li><p><font color=blue>推荐：</font>利用覆盖索引来进行查询操作，避免回表。 说明：如果一本书需要知道第 11 章是什么标题，会翻开第 11 章对应的那一页吗？目录浏览 一下就好，这个目录就是起到覆盖索引的作用。 正例：能够建立索引的种类分为主键索引、唯一索引、普通索引三种，而覆盖索引只是一种查 询的一种效果，用 explain 的结果，extra 列会出现：using index。</p></li><li><p><font color=blue>推荐：</font>利用延迟关联或者子查询优化超多分页场景。 说明：MySQL 并不是跳过 offset 行，而是取 offset+N 行，然后返回放弃前 offset 行，返回 N 行，那当 offset 特别大的时候，效率就非常的低下，要么控制返回的总页数，要么对超过 特定阈值的页数进行 SQL 改写。 正例：先快速定位需要获取的 id 段，然后再关联：</p><ul><li><code>SELECT a.* FROM 表 1 a, (select id from 表 1 where 条件 LIMIT 100000,20 ) b where a.id=b.id</code></li></ul></li><li><p><font color=blue>推荐：</font> SQL 性能优化的目标：至少要达到 range 级别，要求是 ref 级别，如果可以是 consts 最好。 说明： 1）consts 单表中最多只有一个匹配行（主键或者唯一索引），在优化阶段即可读取到数据。 2）ref 指的是使用普通的索引（normal index）。 3）range 对索引进行范围检索。 反例：explain 表的结果，type=index，索引物理文件全扫描，速度非常慢，这个 index 级 别比较 range 还低，与全表扫描是小巫见大巫。</p></li><li><p><font color=blue>推荐：</font>建组合索引的时候，区分度最高的在最左边。 正例：如果 where a=? and b=? ，如果 a 列的几乎接近于唯一值，那么只需要单建 idx_a 索引即可。 说明：存在非等号和等号混合时，在建索引时，请把等号条件的列前置。如：where c>? and d=? 那么即使 c 的区分度更高，也必须把 d 放在索引的最前列，即索引 idx_d_c。</p></li><li><p><font color=blue>推荐：</font>防止因字段类型不同造成的隐式转换，导致索引失效。</p></li><li><p><font color=#1A7605>参考：</font>创建索引时避免有如下极端误解： 1）宁滥勿缺。认为一个查询就需要建一个索引。 2）宁缺勿滥。认为索引会消耗空间、严重拖慢更新和新增速度。 3）抵制惟一索引。认为业务的惟一性一律需要在应用层通过“先查后插”方式解决。</p></li></ol><h2 id=sql>SQL</h2><ol><li><p><font color=red>强制：</font>不要使用 count(列名)或 count(常量)来替代 count(<em>)，count(</em>)是 SQL92 定义的标准统计行数的语法，跟数据库无关，跟 NULL 和非 NULL 无关。 说明：count(*)会统计值为 NULL 的行，而 count(列名)不会统计此列为 NULL 值的行。</p></li><li><p><font color=red>强制：</font>count(distinct col) 计算该列除 NULL 之外的不重复行数，注意 count(distinct col1, col2) 如果其中一列全为 NULL，那么即使另一列有不同的值，也返回为 0。</p></li><li><p><font color=red>强制：</font>当某一列的值全是 NULL 时，count(col)的返回结果为 0，但 sum(col)的返回结果为NULL，因此使用 sum()时需注意 NPE 问题。</p><ul><li>正例：可以使用如下方式来避免 sum 的 NPE 问题：SELECT IF(ISNULL(SUM(g)),0,SUM(g)) FROM table;</li></ul></li><li><p><font color=red>强制：</font>使用 ISNULL()来判断是否为 NULL 值。</p><ul><li>说明：NULL 与任何值的直接比较都为 NULL。<ul><li>1） NULL&lt;>NULL 的返回结果是 NULL，而不是 false。</li><li>2） NULL=NULL 的返回结果是 NULL，而不是 true。</li><li>3） NULL&lt;>1 的返回结果是 NULL，而不是 true。</li></ul></li></ul></li><li><p><font color=red>强制：</font> 在代码中写分页查询逻辑时，若 count 为 0 应直接返回，避免执行后面的分页语句。</p></li><li><p><font color=red>强制：</font>不得使用外键与级联，一切外键概念必须在应用层解决。 说明：以学生和成绩的关系为例，学生表中的 student_id 是主键，那么成绩表中的 student_id 则为外键。如果更新学生表中的 student_id，同时触发成绩表中的 student_id 更新，即为 级联更新。外键与级联更新适用于单机低并发，不适合分布式、高并发集群；级联更新是强阻 塞，存在数据库更新风暴的风险；外键影响数据库的插入速度。</p></li><li><p><font color=red>强制：</font>禁止使用存储过程，存储过程难以调试和扩展，更没有移植性。</p></li><li><p><font color=red>强制：</font>数据订正（特别是删除、修改记录操作）时，要先 select，避免出现误删除，确认 无误才能执行更新语句。</p></li><li><p><font color=blue>推荐：</font>in 操作能避免则避免，若实在避免不了，需要仔细评估 in 后边的集合元素数量，控 制在 1000 个之内。</p></li><li><p><font color=#1A7605>参考：</font>如果有国际化需要，所有的字符存储与表示，均以 utf-8 编码，注意字符统计函数 的区别。 说明： SELECT LENGTH(&ldquo;轻松工作&rdquo;)； 返回为 12 SELECT CHARACTER_LENGTH(&ldquo;轻松工作&rdquo;)； 返回为 4 如果需要存储表情，那么选择 utf8mb4 来进行存储，注意它与 utf-8 编码的区别。</p></li><li><p><font color=#1A7605>参考：</font>TRUNCATE TABLE 比 DELETE 速度快，且使用的系统和事务日志资源少，但 TRUNCATE 无事务且不触发 trigger，有可能造成事故，故不建议在开发代码中使用此语句。 说明：TRUNCATE TABLE 在功能上与不带 WHERE 子句的 DELETE 语句相同。</p></li></ol><h2 id=orm>ORM</h2><ol><li><p><font color=red>强制：</font>在表查询中，一律不要使用 * 作为查询的字段列表，需要哪些字段必须明确写明。 说明：1）增加查询分析器解析成本。2）增减字段容易与 resultMap 配置不一致。3）无用字 段增加网络消耗，尤其是 text 类型的字段。</p></li><li><p><font color=red>强制：</font>POJO 类的布尔属性不能加 is，而数据库字段必须加 is_，要求在 resultMap 中进行 字段与属性之间的映射。 说明：参见定义 POJO 类以及数据库字段定义规定，在<resultmap>中增加映射，是必须的。 在 MyBatis Generator 生成的代码中，需要进行对应的修改。</p></li><li><p><font color=red>强制：</font>不要用 resultClass 当返回参数，即使所有类属性名与数据库字段一一对应，也需 要定义；反过来，每一个表也必然有一个 POJO 类与之对应。 说明：配置映射关系，使字段与 DO 类解耦，方便维护。</p></li><li><p><font color=red>强制：</font>sql.xml 配置参数使用：#{}，#param# 不要使用${} 此种方式容易出现 SQL 注入。</p></li><li><p><font color=red>强制：</font>iBATIS 自带的 queryForList(String statementName,int start,int size)不推荐使用。</p><ul><li><p>说明：其实现方式是在数据库取到 statementName 对应的 SQL 语句的所有记录，再通过 subList 取 start,size 的子集合。</p></li><li><p>正例：<code>Map&lt;String, Object> map = new HashMap&lt;>(); map.put("start", start); map.put("size", size);</code></p></li></ul></li><li><p><font color=red>强制：</font>不允许直接拿 HashMap 与 Hashtable 作为查询结果集的输出。</p><ul><li>说明：resultClass=”Hashtable”，会置入字段名和属性值，但是值的类型不可控。</li></ul></li><li><p><font color=red>强制：</font>更新数据表记录时，必须同时更新记录对应的 gmt_modified 字段值为当前时间。</p></li><li><p><font color=blue>推荐：</font>不要写一个大而全的数据更新接口。传入为 POJO 类，不管是不是自己的目标更新字 段，都进行 update table set c1=value1,c2=value2,c3=value3; 这是不对的。执行 SQL 时，不要更新无改动的字段，一是易出错；二是效率低；三是增加 binlog 存储。</p></li><li><p><font color=#1A7605>参考：</font>@Transactional 事务不要滥用。事务会影响数据库的 QPS，另外使用事务的地方需 要考虑各方面的回滚方案，包括缓存回滚、搜索引擎回滚、消息补偿、统计修正等。</p></li><li><p><font color=#1A7605>参考：</font><isequal>中的 compareValue 是与属性值对比的常量，一般是数字，表示相等时带 上此条件；<isnotempty>表示不为空且不为 null 时执行；<isnotnull>表示不为 null 值时执行。</p></li></ol></div><div class=td-content style=page-break-before:always><h1 id=pg-c98eb4e5d30b0012286d2018ebc8246d>5 - MySQL 实战</h1></div><div class=td-content><h1 id=pg-763a4cb19f42bf3fcb7e0895e1f01027>5.1 - CH01-基础架构</h1><h2 id=架构概览>架构概览</h2><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211025222340.png style=display:block;width:80% alt=NAME align=center></div><ul><li>服务层：<ul><li>包括连接器、查询缓存、分析器、优化器、执行器等，涵盖MySQL的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。</li></ul></li><li>存储层：<ul><li>负责数据的存储和提取。其架构模式是插件式的，支持InnoDB、MyISAM、Memory等多个存储引擎。现在最常用的存储引擎是InnoDB，它从MySQL 5.5.5版本开始成为了默认存储引擎。</li></ul></li></ul><h2 id=连接器>连接器</h2><p>第一步，你会先连接到这个数据库上，这时候接待你的就是连接器。连接器负责跟客户端建立连接、获取权限、维持和管理连接。连接命令一般是这么写的：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>mysql -h<span style=color:#000>$ip</span> -P<span style=color:#000>$port</span> -u<span style=color:#000>$user</span> -p
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic># 输入密码</span>
</span></span></code></pre></div><p>虽然密码也可以直接跟在-p后面写在命令行中，但这样可能会导致你的密码泄露。如果你连的是生产服务器，强烈建议你不要这么做。</p><p>连接命令中的mysql是客户端工具，用来跟服务端建立连接。在完成经典的TCP握手后，连接器就要开始认证你的身份，这个时候用的就是你输入的用户名和密码。</p><ul><li>如果用户名或密码不对，你就会收到一个"Access denied for user"的错误，然后客户端程序结束执行。</li><li>如果用户名密码认证通过，连接器会到权限表里面查出你拥有的权限。之后，这个连接里面的权限判断逻辑，都将依赖于此时读到的权限。</li></ul><p>这就意味着，一个用户成功建立连接后，即使你用管理员账号对这个用户的权限做了修改，也不会影响已经存在连接的权限。修改完成后，只有再新建的连接才会使用新的权限设置。</p><p>连接完成后，如果你没有后续的动作，这个连接就处于空闲状态，你可以在show processlist命令中看到它。文本中这个图是show processlist的结果，其中的Command列显示为“Sleep”的这一行，就表示现在系统里面有一个空闲连接。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211025222719.png style=display:block;width:80% alt=NAME align=center></div><p>客户端如果太长时间没动静，连接器就会自动将它断开。这个时间是由参数wait_timeout控制的，默认值是8小时。</p><p>如果在连接被断开之后，客户端再次发送请求的话，就会收到一个错误提醒： Lost connection to MySQL server during query。这时候如果你要继续，就需要重连，然后再执行请求了。</p><p>数据库里面，长连接是指连接成功后，如果客户端持续有请求，则一直使用同一个连接。短连接则是指每次执行完很少的几次查询就断开连接，下次查询再重新建立一个。</p><p>建立连接的过程通常是比较复杂的，所以我建议你在使用中要尽量减少建立连接的动作，也就是尽量使用长连接。</p><p>但是全部使用长连接后，你可能会发现，有些时候MySQL占用内存涨得特别快，这是因为MySQL在执行过程中临时使用的内存是管理在连接对象里面的。这些资源会在连接断开的时候才释放。所以如果长连接累积下来，可能导致内存占用太大，被系统强行杀掉（OOM），从现象看就是MySQL异常重启了。</p><p>怎么解决这个问题呢？你可以考虑以下两种方案。</p><ol><li>定期断开长连接。使用一段时间，或者程序里面判断执行过一个占用内存的大查询后，断开连接，之后要查询再重连。</li><li>如果你用的是MySQL 5.7或更新版本，可以在每次执行一个比较大的操作后，通过执行 mysql_reset_connection来重新初始化连接资源。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。</li></ol><h2 id=查询缓存>查询缓存</h2><p>连接建立完成后，你就可以执行select语句了。执行逻辑就会来到第二步：查询缓存。</p><p>MySQL拿到一个查询请求后，会先到查询缓存看看，之前是不是执行过这条语句。之前执行过的语句及其结果可能会以key-value对的形式，被直接缓存在内存中。key是查询的语句，value是查询的结果。如果你的查询能够直接在这个缓存中找到key，那么这个value就会被直接返回给客户端。</p><p>如果语句不在查询缓存中，就会继续后面的执行阶段。执行完成后，执行结果会被存入查询缓存中。你可以看到，如果查询命中缓存，MySQL不需要执行后面的复杂操作，就可以直接返回结果，这个效率会很高。</p><p><strong>但是大多数情况下我会建议你不要使用查询缓存，为什么呢？因为查询缓存往往弊大于利。</strong></p><p><strong>查询缓存的失效非常频繁，只要有对一个表的更新，这个表上所有的查询缓存都会被清空</strong>。因此很可能你费劲地把结果存起来，还没使用呢，就被一个更新全清空了。对于更新压力大的数据库来说，查询缓存的命中率会非常低。除非你的业务就是有一张静态表，很长时间才会更新一次。比如，一个系统配置表，那这张表上的查询才适合使用查询缓存。</p><p>好在MySQL也提供了这种“按需使用”的方式。你可以将参数<strong>query_cache_type设置成DEMAND</strong>，这样对于默认的SQL语句都不使用查询缓存。而对于你确定要使用查询缓存的语句，可以用SQL_CACHE显式指定，像下面这个语句一样：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>mysql&gt; <span style=color:#204a87;font-weight:700>select</span> SQL_CACHE * from T where <span style=color:#000>ID</span><span style=color:#ce5c00;font-weight:700>=</span>10；
</span></span></code></pre></div><p>需要注意的是，MySQL 8.0版本直接将查询缓存的整块功能删掉了，也就是说8.0开始彻底没有这个功能了。</p><h2 id=分析器>分析器</h2><p>如果没有命中查询缓存，就要开始真正执行语句了。首先，MySQL需要知道你要做什么，因此需要对SQL语句做解析。</p><p>分析器先会做“词法分析”。你输入的是由多个字符串和空格组成的一条SQL语句，MySQL需要识别出里面的字符串分别是什么，代表什么。</p><p>MySQL从你输入的"select"这个关键字识别出来，这是一个查询语句。它也要把字符串“T”识别成“表名T”，把字符串“ID”识别成“列ID”。</p><p>做完了这些识别以后，就要做“语法分析”。根据词法分析的结果，语法分析器会根据语法规则，判断你输入的这个SQL语句是否满足MySQL语法。</p><p>如果你的语句不对，就会收到“You have an error in your SQL syntax”的错误提醒，比如下面这个语句select少打了开头的字母“s”。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>mysql&gt; elect * from t where <span style=color:#000>ID</span><span style=color:#ce5c00;font-weight:700>=</span>1<span style=color:#000;font-weight:700>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>ERROR <span style=color:#0000cf;font-weight:700>1064</span> <span style=color:#ce5c00;font-weight:700>(</span>42000<span style=color:#ce5c00;font-weight:700>)</span>: You have an error in your SQL syntax<span style=color:#000;font-weight:700>;</span> check the manual that corresponds to your MySQL server version <span style=color:#204a87;font-weight:700>for</span> the right syntax to use near <span style=color:#4e9a06>&#39;elect * from t where ID=1&#39;</span> at line <span style=color:#0000cf;font-weight:700>1</span>
</span></span></code></pre></div><p>一般语法错误会提示第一个出现错误的位置，所以你要关注的是紧接“<strong>use near</strong>”的内容。</p><h2 id=优化器>优化器</h2><p>经过了分析器，MySQL就知道你要做什么了。在开始执行之前，还要先经过优化器的处理。</p><p>优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序。比如你执行下面这样的语句，这个语句是执行两个表的join：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>mysql&gt; <span style=color:#204a87;font-weight:700>select</span> * from t1 join t2 using<span style=color:#ce5c00;font-weight:700>(</span>ID<span style=color:#ce5c00;font-weight:700>)</span>  where t1.c<span style=color:#ce5c00;font-weight:700>=</span><span style=color:#0000cf;font-weight:700>10</span> and t2.d<span style=color:#ce5c00;font-weight:700>=</span>20<span style=color:#000;font-weight:700>;</span>
</span></span></code></pre></div><ul><li>既可以先从表t1里面取出c=10的记录的ID值，再根据ID值关联到表t2，再判断t2里面d的值是否等于20。</li><li>也可以先从表t2里面取出d=20的记录的ID值，再根据ID值关联到t1，再判断t1里面c的值是否等于10。</li></ul><p>这两种执行方法的逻辑结果是一样的，但是执行的效率会有不同，而优化器的作用就是决定选择使用哪一个方案。</p><p>优化器阶段完成后，这个语句的执行方案就确定下来了，然后进入执行器阶段。</p><h2 id=执行器>执行器</h2><p>MySQL通过分析器知道了你要做什么，通过优化器知道了该怎么做，于是就进入了执行器阶段，开始执行语句。</p><p>开始执行的时候，<strong>要先判断一下你对这个表T有没有执行查询的权限</strong>，如果没有，就会返回没有权限的错误，如下所示(在工程实现上，如果命中查询缓存，会在查询缓存放回结果的时候，做权限验证。查询也会在优化器之前调用precheck验证权限)。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>mysql&gt; <span style=color:#204a87;font-weight:700>select</span> * from T where <span style=color:#000>ID</span><span style=color:#ce5c00;font-weight:700>=</span>10<span style=color:#000;font-weight:700>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>ERROR <span style=color:#0000cf;font-weight:700>1142</span> <span style=color:#ce5c00;font-weight:700>(</span>42000<span style=color:#ce5c00;font-weight:700>)</span>: SELECT <span style=color:#204a87>command</span> denied to user <span style=color:#4e9a06>&#39;b&#39;</span>@<span style=color:#4e9a06>&#39;localhost&#39;</span> <span style=color:#204a87;font-weight:700>for</span> table <span style=color:#4e9a06>&#39;T&#39;</span>
</span></span></code></pre></div><p>如果有权限，就打开表继续执行。打开表的时候，执行器就会根据表的引擎定义，去使用这个引擎提供的接口。</p><p>比如我们这个例子中的表T中，ID字段没有索引，那么执行器的执行流程是这样的：</p><ol><li>调用InnoDB引擎接口取这个表的第一行，判断ID值是不是10，如果不是则跳过，如果是则将这行存在结果集中；</li><li>调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行。</li><li>执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。</li></ol><p>至此，这个语句就执行完成了。</p><p>对于有索引的表，执行的逻辑也差不多。第一次调用的是“取满足条件的第一行”这个接口，之后循环取“满足条件的下一行”这个接口，这些接口都是引擎中已经定义好的。</p><p>你会在数据库的慢查询日志中看到一个rows_examined的字段，表示这个语句执行过程中扫描了多少行。这个值就是在执行器每次调用引擎获取数据行的时候累加的。</p><p>在有些场景下，执行器调用一次，在引擎内部则扫描了多行，因此<strong>引擎扫描行数跟rows_examined并不是完全相同的。</strong></p></div><div class=td-content style=page-break-before:always><h1 id=pg-d94c10e940f788e4706645fab4ee4d18>5.2 - CH02-日志系统</h1><p>我们从一个表的一条更新语句说起，下面是这个表的创建语句，这个表有一个主键ID和一个整型字段c：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>mysql&gt; create table T(ID int primary key, c int);
</span></span></code></pre></div><p>如果要将ID=2这一行的值加1，SQL语句就会这么写：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>mysql&gt; update T set c=c+1 where ID=2;
</span></span></code></pre></div><p>前面我有跟你介绍过SQL语句基本的执行链路，这里我再把那张图拿过来，你也可以先简单看看这个图回顾下。首先，可以确定的说，查询语句的那一套流程，更新语句也是同样会走一遍。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211025224933.png style=display:block;width:80% alt=NAME align=center></div><p>执行语句前要先连接数据库，这是连接器的工作。</p><p>前面我们说过，在一个表上有更新的时候，跟这个表有关的查询缓存会失效，所以这条语句就会把表T上所有缓存结果都清空。这也就是我们一般不建议使用查询缓存的原因。</p><p>接下来，分析器会通过词法和语法解析知道这是一条更新语句。优化器决定要使用ID这个索引。然后，执行器负责具体执行，找到这一行，然后更新。</p><p>与查询流程不一样的是，更新流程还涉及两个重要的日志模块，它们正是我们今天要讨论的主角：<strong>redo log（重做日志）和 binlog（归档日志）</strong>。如果接触MySQL，那这两个词肯定是绕不过的，我后面的内容里也会不断地和你强调。不过话说回来，redo log和binlog在设计上有很多有意思的地方，这些设计思路也可以用到你自己的程序里。</p><h2 id=redo-log>redo log</h2><p>不知道你还记不记得《孔乙己》这篇文章，酒店掌柜有一个粉板，专门用来记录客人的赊账记录。如果赊账的人不多，那么他可以把顾客名和账目写在板上。但如果赊账的人多了，粉板总会有记不下的时候，这个时候掌柜一定还有一个专门记录赊账的账本。</p><p>如果有人要赊账或者还账的话，掌柜一般有两种做法：</p><ul><li>一种做法是直接把账本翻出来，把这次赊的账加上去或者扣除掉；</li><li>另一种做法是先在粉板上记下这次的账，等打烊以后再把账本翻出来核算。</li></ul><p>在生意红火柜台很忙时，掌柜一定会选择后者，因为前者操作实在是太麻烦了。首先，你得找到这个人的赊账总额那条记录。你想想，密密麻麻几十页，掌柜要找到那个名字，可能还得带上老花镜慢慢找，找到之后再拿出算盘计算，最后再将结果写回到账本上。</p><p>这整个过程想想都麻烦。相比之下，还是先在粉板上记一下方便。你想想，如果掌柜没有粉板的帮助，每次记账都得翻账本，效率是不是低得让人难以忍受？</p><p>同样，在MySQL里也有这个问题，如果每一次的更新操作都需要写进磁盘，然后磁盘也要找到对应的那条记录，然后再更新，整个过程IO成本、查找成本都很高。为了解决这个问题，MySQL的设计者就用了类似酒店掌柜粉板的思路来提升更新效率。</p><p><strong>而粉板和账本配合的整个过程，其实就是MySQL里经常说到的WAL技术，WAL的全称是Write-Ahead Logging，它的关键点就是先写日志，再写磁盘，也就是先写粉板，等不忙的时候再写账本。</strong></p><p><strong>具体来说，当有一条记录需要更新的时候，InnoDB引擎就会先把记录写到redo log（粉板）里面，并更新内存，这个时候更新就算完成了。同时，InnoDB引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做，这就像打烊以后掌柜做的事。</strong></p><p>如果今天赊账的不多，掌柜可以等打烊后再整理。但如果某天赊账的特别多，粉板写满了，又怎么办呢？这个时候掌柜只好放下手中的活儿，把粉板中的一部分赊账记录更新到账本中，然后把这些记录从粉板上擦掉，为记新账腾出空间。</p><p>与此类似，InnoDB的redo log是固定大小的，比如可以配置为一组4个文件，每个文件的大小是1GB，那么这块“粉板”总共就可以记录4GB的操作。从头开始写，写到末尾就又回到开头循环写，如下面这个图所示。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211025225326.png style=display:block;width:80% alt=NAME align=center></div><p>write pos是当前记录的位置，一边写一边后移，写到第3号文件末尾后就回到0号文件开头。checkpoint是当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到数据文件。</p><p>write pos和checkpoint之间的是“粉板”上还空着的部分，可以用来记录新的操作。如果write pos追上checkpoint，表示“粉板”满了，这时候不能再执行新的更新，得停下来先擦掉一些记录，把checkpoint推进一下。</p><p>有了redo log，InnoDB就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为<strong>crash-safe</strong>。</p><p>要理解crash-safe这个概念，可以想想我们前面赊账记录的例子。只要赊账记录记在了粉板上或写在了账本上，之后即使掌柜忘记了，比如突然停业几天，恢复生意后依然可以通过账本和粉板上的数据明确赊账账目。</p><h2 id=binlog>binlog</h2><p>前面我们讲过，MySQL整体来看，其实就有两块：一块是Server层，它主要做的是MySQL功能层面的事情；还有一块是引擎层，负责存储相关的具体事宜。上面我们聊到的粉板redo log是InnoDB引擎特有的日志，而Server层也有自己的日志，称为binlog（归档日志）。</p><p>我想你肯定会问，为什么会有两份日志呢？</p><p>因为最开始MySQL里并没有InnoDB引擎。MySQL自带的引擎是MyISAM，但是MyISAM没有crash-safe的能力，binlog日志只能用于归档。而InnoDB是另一个公司以插件形式引入MySQL的，既然只依靠binlog是没有crash-safe能力的，所以InnoDB使用另外一套日志系统——也就是redo log来实现crash-safe能力。</p><p>这两种日志有以下三点不同。</p><ol><li>redo log是InnoDB引擎特有的；binlog是MySQL的Server层实现的，所有引擎都可以使用。</li><li>redo log是物理日志，记录的是“在某个数据页上做了什么修改”；binlog是逻辑日志，记录的是这个语句的原始逻辑，比如“给ID=2这一行的c字段加1 ”。</li><li>redo log是循环写的，空间固定会用完；binlog是可以追加写入的。“追加写”是指binlog文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。</li></ol><p>有了对这两个日志的概念性理解，我们再来看执行器和InnoDB引擎在执行这个简单的update语句时的内部流程。</p><ol><li>执行器先找引擎取ID=2这一行。ID是主键，引擎直接用树搜索找到这一行。如果ID=2这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。</li><li>执行器拿到引擎给的行数据，把这个值加上1，比如原来是N，现在就是N+1，得到新的一行数据，再调用引擎接口写入这行新数据。</li><li>引擎将这行新数据更新到内存中，同时将这个更新操作记录到redo log里面，此时redo log处于prepare状态。然后告知执行器执行完成了，随时可以提交事务。</li><li>执行器生成这个操作的binlog，并把binlog写入磁盘。</li><li>执行器调用引擎的提交事务接口，引擎把刚刚写入的redo log改成提交（commit）状态，更新完成。</li></ol><p>这里我给出这个update语句的执行流程图，图中浅色框表示是在InnoDB内部执行的，深色框表示是在执行器中执行的。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211025225717.png style=display:block;width:80% alt=NAME align=center></div><p>你可能注意到了，最后三步看上去有点“绕”，将redo log的写入拆成了两个步骤：prepare和commit，这就是"两阶段提交"。</p><h2 id=两阶段提交>两阶段提交</h2><p>为什么必须有“两阶段提交”呢？这是为了让两份日志之间的逻辑一致。要说明这个问题，我们得从文章开头的那个问题说起：<strong>怎样让数据库恢复到半个月内任意一秒的状态？</strong></p><p>前面我们说过了，binlog会记录所有的逻辑操作，并且是采用“追加写”的形式。如果你的DBA承诺说半个月内可以恢复，那么备份系统中一定会保存最近半个月的所有binlog，同时系统会定期做整库备份。这里的“定期”取决于系统的重要性，可以是一天一备，也可以是一周一备。</p><p>当需要恢复到指定的某一秒时，比如某天下午两点发现中午十二点有一次误删表，需要找回数据，那你可以这么做：</p><ul><li>首先，找到最近的一次全量备份，如果你运气好，可能就是昨天晚上的一个备份，从这个备份恢复到临时库；</li><li>然后，从备份的时间点开始，将备份的binlog依次取出来，重放到中午误删表之前的那个时刻。</li></ul><p>这样你的临时库就跟误删之前的线上库一样了，然后你可以把表数据从临时库取出来，按需要恢复到线上库去。</p><p>好了，说完了数据恢复过程，我们回来说说，为什么日志需要“两阶段提交”。这里不妨用反证法来进行解释。</p><p>由于redo log和binlog是两个独立的逻辑，如果不用两阶段提交，要么就是先写完redo log再写binlog，或者采用反过来的顺序。我们看看这两种方式会有什么问题。</p><p>仍然用前面的update语句来做例子。假设当前ID=2的行，字段c的值是0，再假设执行update语句过程中在写完第一个日志后，第二个日志还没有写完期间发生了crash，会出现什么情况呢？</p><ol><li><strong>先写redo log后写binlog</strong>。假设在redo log写完，binlog还没有写完的时候，MySQL进程异常重启。由于我们前面说过的，redo log写完之后，系统即使崩溃，仍然能够把数据恢复回来，所以恢复后这一行c的值是1。
但是由于binlog没写完就crash了，这时候binlog里面就没有记录这个语句。因此，之后备份日志的时候，存起来的binlog里面就没有这条语句。
然后你会发现，如果需要用这个binlog来恢复临时库的话，由于这个语句的binlog丢失，这个临时库就会少了这一次更新，恢复出来的这一行c的值就是0，与原库的值不同。</li><li><strong>先写binlog后写redo log</strong>。如果在binlog写完之后crash，由于redo log还没写，崩溃恢复以后这个事务无效，所以这一行c的值是0。但是binlog里面已经记录了“把c从0改成1”这个日志。所以，在之后用binlog来恢复的时候就多了一个事务出来，恢复出来的这一行c的值就是1，与原库的值不同。</li></ol><p>可以看到，如果不使用“两阶段提交”，那么数据库的状态就有可能和用它的日志恢复出来的库的状态不一致。</p><p>你可能会说，这个概率是不是很低，平时也没有什么动不动就需要恢复临时库的场景呀？</p><p>其实不是的，不只是误操作后需要用这个过程来恢复数据。当你需要扩容的时候，也就是需要再多搭建一些备库来增加系统的读能力的时候，现在常见的做法也是用全量备份加上应用binlog来实现的，这个“不一致”就会导致你的线上出现主从数据库不一致的情况。</p><p>简单说，redo log和binlog都可以用于表示事务的提交状态，而两阶段提交就是让这两个状态保持逻辑上的一致。</p><h2 id=总结>总结</h2><p>物理日志redo log和逻辑日志binlog。</p><p>redo log用于保证crash-safe能力。innodb_flush_log_at_trx_commit这个参数设置成1的时候，表示每次事务的redo log都直接持久化到磁盘。这个参数我建议你设置成1，这样可以保证MySQL异常重启之后数据不丢失。</p><p>sync_binlog这个参数设置成1的时候，表示每次事务的binlog都持久化到磁盘。这个参数我也建议你设置成1，这样可以保证MySQL异常重启之后binlog不丢失。</p><p>两阶段提交是跨系统维持数据逻辑一致性时常用的一个方案，即使你不做数据库内核开发，日常开发中也有可能会用到。</p><blockquote><p>redo是物理的，binlog是逻辑的；现在由于redo是属于InnoDB引擎，所以必须要有binlog，因为你可以使用别的引擎。
保证数据库的一致性，必须要保证2份日志一致，使用的2阶段式提交；类似事务，不是成功就是失败，不能让中间环节出现，也就是一个成功，一个失败。</p></blockquote><h2 id=流程>流程</h2><ol><li>首先客户端通过tcp/ip发送一条sql语句到server层的SQL interface</li><li>SQL interface接到该请求后，先对该条语句进行解析，验证权限是否匹配</li><li>验证通过以后，分析器会对该语句分析,是否语法有错误等</li><li>接下来是优化器器生成相应的执行计划，选择最优的执行计划</li><li>之后会是执行器根据执行计划执行这条语句。在这一步会去open table,如果该table上有MDL，则等待。
如果没有，则加在该表上加短暂的MDL(S)
(如果opend_table太大,表明open_table_cache太小。需要不停的去打开frm文件)</li><li>进入到引擎层，首先会去innodb_buffer_pool里的data dictionary(元数据信息)得到表信息</li><li>通过元数据信息,去lock info里查出是否会有相关的锁信息，并把这条update语句需要的
锁信息写入到lock info里(锁这里还有待补充)</li><li>然后涉及到的老数据通过快照的方式存储到innodb_buffer_pool里的undo page里,并且记录undo log修改的redo
(如果data page里有就直接载入到undo page里，如果没有，则需要去磁盘里取出相应page的数据，载入到undo page里)</li><li>在innodb_buffer_pool的data page做update操作。并把操作的物理数据页修改记录到redo log buffer里
由于update这个事务会涉及到多个页面的修改，所以redo log buffer里会记录多条页面的修改信息。
因为group commit的原因，这次事务所产生的redo log buffer可能会跟随其它事务一同flush并且sync到磁盘上</li><li>同时修改的信息，会按照event的格式,记录到binlog_cache中。(这里注意binlog_cache_size是transaction级别的,不是session级别的参数,
一旦commit之后，dump线程会从binlog_cache里把event主动发送给slave的I/O线程)</li><li>之后把这条sql,需要在二级索引上做的修改，写入到change buffer page，等到下次有其他sql需要读取该二级索引时，再去与二级索引做merge
(随机I/O变为顺序I/O,但是由于现在的磁盘都是SSD,所以对于寻址来说,随机I/O和顺序I/O差距不大)</li><li>此时update语句已经完成，需要commit或者rollback。这里讨论commit的情况，并且双1</li><li>commit操作，由于存储引擎层与server层之间采用的是内部XA(保证两个事务的一致性,这里主要保证redo log和binlog的原子性),
所以提交分为prepare阶段与commit阶段</li><li>prepare阶段,将事务的xid写入，将binlog_cache里的进行flush以及sync操作(大事务的话这步非常耗时)</li><li>commit阶段，由于之前该事务产生的redo log已经sync到磁盘了。所以这步只是在redo log里标记commit</li><li>当binlog和redo log都已经落盘以后，如果触发了刷新脏页的操作，先把该脏页复制到doublewrite buffer里，把doublewrite buffer里的刷新到共享表空间，然后才是通过page cleaner线程把脏页写入到磁盘中</li></ol></div><div class=td-content style=page-break-before:always><h1 id=pg-1fed0fae3032d08ee3c0cb9fd99595b3>5.3 - CH03-事务隔离</h1><p>和数据库打交道的时候，我们总是会用到事务。最经典的例子就是转账，你要给朋友小王转100块钱，而此时你的银行卡只有100块钱。</p><p>转账过程具体到程序里会有一系列的操作，比如查询余额、做加减法、更新余额等，这些操作必须保证是一体的，不然等程序查完之后，还没做减法之前，你这100块钱，完全可以借着这个时间差再查一次，然后再给另外一个朋友转账，如果银行这么整，不就乱了么？这时就要用到“事务”这个概念了。</p><p>简单来说，事务就是要保证一组数据库操作，要么全部成功，要么全部失败。在MySQL中，事务支持是在引擎层实现的。你现在知道，MySQL是一个支持多引擎的系统，但并不是所有的引擎都支持事务。<strong>比如MySQL原生的MyISAM引擎就不支持事务，这也是MyISAM被InnoDB取代的重要原因之一。</strong></p><p>今天的文章里，我将会以InnoDB为例，剖析MySQL在事务支持方面的特定实现，并基于原理给出相应的实践建议，希望这些案例能加深你对MySQL事务原理的理解。</p><h2 id=隔离性与隔离级别>隔离性与隔离级别</h2><p>提到事务，你肯定会想到<strong>ACID（Atomicity、Consistency、Isolation、Durability</strong>，即原子性、一致性、隔离性、持久性），今天我们就来说说其中I，也就是“隔离性”。</p><p>当数据库上有多个事务同时执行的时候，就可能出现**脏读（dirty read）、不可重复读（non-repeatable read）、幻读（phantom read）**的问题，为了解决这些问题，就有了“<strong>隔离级别</strong>”的概念。</p><p>在谈隔离级别之前，你首先要知道，你隔离得越严实，效率就会越低。因此很多时候，我们都要在二者之间寻找一个平衡点。SQL标准的事务隔离级别包括：读未提交（read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（serializable ）。下面我逐一为你解释：</p><ul><li><strong>读未提交是指</strong>，一个事务还没提交时，它做的变更就能被别的事务看到。</li><li><strong>读提交是指</strong>，一个事务提交之后，它做的变更才会被其他事务看到。</li><li><strong>可重复读是指</strong>，一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。</li><li><strong>串行化</strong>，顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。</li></ul><p>其中“读提交”和“可重复读”比较难理解，所以我用一个例子说明这几种隔离级别。假设数据表T中只有一列，其中一行的值为1，下面是按照时间顺序执行两个事务的行为。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>mysql&gt; create table T<span style=color:#ce5c00;font-weight:700>(</span>c int<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#000>engine</span><span style=color:#ce5c00;font-weight:700>=</span>InnoDB<span style=color:#000;font-weight:700>;</span>
</span></span><span style=display:flex><span>insert into T<span style=color:#ce5c00;font-weight:700>(</span>c<span style=color:#ce5c00;font-weight:700>)</span> values<span style=color:#ce5c00;font-weight:700>(</span>1<span style=color:#ce5c00;font-weight:700>)</span><span style=color:#000;font-weight:700>;</span>
</span></span></code></pre></div><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211025233032.png style=display:block;width:60% alt=NAME align=center></div><p>我们来看看在不同的隔离级别下，事务A会有哪些不同的返回结果，也就是图里面V1、V2、V3的返回值分别是什么。</p><ul><li>若隔离级别是“<strong>读未提交</strong>”， 则V1的值就是2。这时候事务B虽然还没有提交，但是结果已经被A看到了。因此，V2、V3也都是2。</li><li>若隔离级别是“<strong>读提交</strong>”，则V1是1，V2的值是2。事务B的更新在提交后才能被A看到。所以， V3的值也是2。</li><li>若隔离级别是“<strong>可重复读</strong>”，则V1、V2是1，V3是2。之所以V2还是1，遵循的就是这个要求：事务在执行期间看到的数据前后必须是一致的。</li><li>若隔离级别是“<strong>串行化</strong>”，则在事务B执行“将1改成2”的时候，会被锁住。直到事务A提交后，事务B才可以继续执行。所以从A的角度看， V1、V2值是1，V3的值是2。</li></ul><blockquote><p>可见性是相对的，要区分我的事务、别人的事务：</p><ul><li>读未提交：别人改数据的事务尚未提交，我在我的事务中也能读到。</li><li>读已提交：别人改数据的事务已经提交，我在我的事务中才能读到。</li><li>可重复读：别人改数据的事务已经提交，我在我的事务中也不去读。</li><li>串行：我的事务尚未提交，别人就别想改数据。</li></ul><p>这4种隔离级别，并行性能依次降低，安全性依次提高。</p></blockquote><p>在实现上，数据库里面会创建一个视图，访问的时候以视图的逻辑结果为准。</p><ul><li>在“<strong>可重复读</strong>”隔离级别下，这个视图是在事务启动时创建的，整个事务存在期间都用这个视图。</li><li>在“<strong>读提交</strong>”隔离级别下，这个视图是在每个SQL语句开始执行的时候创建的。</li><li>这里需要注意的是，“<strong>读未提交</strong>”隔离级别下直接返回记录上的最新值，没有视图概念；</li><li>而“串行化”隔离级别下直接用加锁的方式来避免并行访问。</li></ul><p>我们可以看到在不同的隔离级别下，数据库行为是有所不同的。Oracle数据库的默认隔离级别其实就是“读提交”，因此对于一些从Oracle迁移到MySQL的应用，为保证数据库隔离级别的一致，你一定要记得将MySQL的隔离级别设置为“读提交”。</p><p>配置的方式是，将启动参数transaction-isolation的值设置成READ-COMMITTED。你可以用show variables来查看当前的值。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>mysql&gt; show variables like &#39;transaction_isolation&#39;;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>+-----------------------+----------------+
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>| Variable_name | Value |
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>+-----------------------+----------------+
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>| transaction_isolation | READ-COMMITTED |
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>+-----------------------+----------------+
</span></span></code></pre></div><p>总结来说，存在即合理，哪个隔离级别都有它自己的使用场景，你要根据自己的业务情况来定。我想<strong>你可能会问那什么时候需要“可重复读”的场景呢</strong>？我们来看一个数据校对逻辑的案例。</p><p>假设你在管理一个个人银行账户表。一个表存了每个月月底的余额，一个表存了账单明细。这时候你要做数据校对，也就是判断上个月的余额和当前余额的差额，是否与本月的账单明细一致。你一定希望在校对过程中，即使有用户发生了一笔新的交易，也不影响你的校对结果。</p><p>这时候使用“可重复读”隔离级别就很方便。事务启动时的视图可以认为是静态的，不受其他事务更新的影响。</p><h2 id=事务隔离的实现>事务隔离的实现</h2><p>理解了事务的隔离级别，我们再来看看事务隔离具体是怎么实现的。这里我们展开说明“可重复读”。</p><p>在MySQL中，实际上每条记录在更新的时候都会同时记录一条回滚操作。记录上的最新值，通过回滚操作，都可以得到前一个状态的值。</p><p>假设一个值从1被按顺序改成了2、3、4，在回滚日志里面就会有类似下面的记录。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211025233532.png style=display:block;width:80% alt=NAME align=center></div><p>当前值是4，但是在查询这条记录的时候，不同时刻启动的事务会有不同的read-view。如图中看到的，在视图A、B、C里面，这一个记录的值分别是1、2、4，<strong>同一条记录在系统中可以存在多个版本，就是数据库的多版本并发控制（MVCC）</strong>。对于read-view A，要得到1，就必须将当前值依次执行图中所有的回滚操作得到。</p><p>同时你会发现，即使现在有另外一个事务正在将4改成5，这个事务跟read-view A、B、C对应的事务是不会冲突的。</p><p>你一定会问，回滚日志总不能一直保留吧，什么时候删除呢？答案是，在不需要的时候才删除。也就是说，系统会判断，当没有事务再需要用到这些回滚日志时，回滚日志会被删除。</p><p>什么时候才不需要了呢？就是<strong>当系统里没有比这个回滚日志更早的read-view的时候。</strong></p><p>基于上面的说明，我们来讨论一下为什么建议你尽量不要使用长事务。</p><p>长事务意味着系统里面会存在很老的事务视图。由于这些事务随时可能访问数据库里面的任何数据，所以这个事务提交之前，数据库里面它可能用到的回滚记录都必须保留，这就会导致大量占用存储空间。</p><p>在MySQL 5.5及以前的版本，回滚日志是跟数据字典一起放在ibdata文件里的，即使长事务最终提交，回滚段被清理，文件也不会变小。我见过数据只有20GB，而回滚段有200GB的库。最终只好为了清理回滚段，重建整个库。</p><p>除了对回滚段的影响，长事务还占用锁资源，也可能拖垮整个库，这个我们会在后面讲锁的时候展开。</p><h2 id=事务的启动方式>事务的启动方式</h2><p>如前面所述，长事务有这些潜在风险，我当然是建议你尽量避免。其实很多时候业务开发同学并不是有意使用长事务，通常是由于误用所致。MySQL的事务启动方式有以下几种：</p><ol><li>显式启动事务语句， begin 或 start transaction。配套的提交语句是commit，回滚语句是rollback。</li><li>set autocommit=0，这个命令会将这个线程的自动提交关掉。意味着如果你只执行一个select语句，这个事务就启动了，而且并不会自动提交。这个事务持续存在直到你主动执行commit 或 rollback 语句，或者断开连接。</li></ol><p>有些客户端连接框架会默认连接成功后先执行一个set autocommit=0的命令。这就导致接下来的查询都在事务中，如果是长连接，就导致了意外的长事务。</p><p>因此，我会建议你总是使用set autocommit=1, 通过显式语句的方式来启动事务。</p><p>但是有的开发同学会纠结“多一次交互”的问题。对于一个需要频繁使用事务的业务，第二种方式每个事务在开始时都不需要主动执行一次 “begin”，减少了语句的交互次数。如果你也有这个顾虑，我建议你使用commit work and chain语法。</p><p>在autocommit为1的情况下，用begin显式启动的事务，如果执行commit则提交事务。如果执行 commit work and chain，则是提交事务并自动启动下一个事务，这样也省去了再次执行begin语句的开销。同时带来的好处是从程序开发的角度明确地知道每个语句是否处于事务中。</p><p>你可以在information_schema库的innodb_trx这个表中查询长事务，比如下面这个语句，用于查找持续时间超过60s的事务。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#204a87;font-weight:700>select</span> * from information_schema.innodb_trx where TIME_TO_SEC<span style=color:#ce5c00;font-weight:700>(</span>timediff<span style=color:#ce5c00;font-weight:700>(</span>now<span style=color:#ce5c00;font-weight:700>()</span>,trx_started<span style=color:#ce5c00;font-weight:700>))</span>&gt;60
</span></span></code></pre></div><h2 id=问题汇总>问题汇总</h2><ol><li>务的特性：原子性、一致性、隔离性、持久性</li><li>多事务同时执行的时候，可能会出现的问题：脏读、不可重复读、幻读</li><li>事务隔离级别：读未提交、读提交、可重复读、串行化</li><li>不同事务隔离级别的区别：
读未提交：一个事务还未提交，它所做的变更就可以被别的事务看到
读提交：一个事务提交之后，它所做的变更才可以被别的事务看到
可重复读：一个事务执行过程中看到的数据是一致的。未提交的更改对其他事务是不可见的
串行化：对应一个记录会加读写锁，出现冲突的时候，后访问的事务必须等前一个事务执行完成才能继续执行</li><li>配置方法：启动参数transaction-isolation</li><li>事务隔离的实现：每条记录在更新的时候都会同时记录一条回滚操作。同一条记录在系统中可以存在多个版本，这就是数据库的多版本并发控制（MVCC）。</li><li>回滚日志什么时候删除？系统会判断当没有事务需要用到这些回滚日志的时候，回滚日志会被删除。</li><li>什么时候不需要了？当系统里么有比这个回滚日志更早的read-view的时候。</li><li>为什么尽量不要使用长事务。长事务意味着系统里面会存在很老的事务视图，在这个事务提交之前，回滚记录都要保留，这会导致大量占用存储空间。除此之外，长事务还占用锁资源，可能会拖垮库。</li><li>事务启动方式：一、显式启动事务语句，begin或者start transaction,提交commit，回滚rollback；二、set autocommit=0，该命令会把这个线程的自动提交关掉。这样只要执行一个select语句，事务就启动，并不会自动提交，直到主动执行commit或rollback或断开连接。</li><li>建议使用方法一，如果考虑多一次交互问题，可以使用commit work and chain语法。在autocommit=1的情况下用begin显式启动事务，如果执行commit则提交事务。如果执行commit work and chain则提交事务并自动启动下一个事务。</li></ol><hr><ol><li>事务的概念是什么?</li><li>mysql的事务隔离级别读未提交, 读已提交, 可重复读, 串行各是什么意思?</li><li>读已提交, 可重复读是怎么通过视图构建实现的?</li><li>可重复读的使用场景举例? 对账的时候应该很有用?</li><li>事务隔离是怎么通过read-view(读视图)实现的?</li><li>并发版本控制(MCVV)的概念是什么, 是怎么实现的?</li><li>使用长事务的弊病? 为什么使用常事务可能拖垮整个库?</li><li>事务的启动方式有哪几种?</li><li>commit work and chain的语法是做什么用的?</li><li>怎么查询各个表中的长事务?</li><li>如何避免长事务的出现?</li></ol></div><div class=td-content style=page-break-before:always><h1 id=pg-1b4b5a489c633646179898f8f72f66d8>5.4 - CH04-索引-上</h1><p>索引的出现其实就是为了提高数据查询的效率，就像书的目录一样。一本500页的书，如果你想快速找到其中的某一个知识点，在不借助目录的情况下，那我估计你可得找一会儿。同样，对于数据库的表而言，索引其实就是它的“目录”。</p><h2 id=索引模型>索引模型</h2><p>索引的出现是为了提高查询效率，但是实现索引的方式却有很多种，所以这里也就引入了索引模型的概念。可以用于提高读写效率的数据结构很多，这里我先给你介绍三种常见、也比较简单的数据结构，它们分别是哈希表、有序数组和搜索树。</p><p>下面我主要从使用的角度，为你简单分析一下这三种模型的区别。</p><h3 id=哈希表>哈希表</h3><p>哈希表是一种以键-值（key-value）存储数据的结构，我们只要输入待查找的值即key，就可以找到其对应的值即Value。哈希的思路很简单，把值放在数组里，用一个哈希函数把key换算成一个确定的位置，然后把value放在数组的这个位置。</p><p>不可避免地，多个key值经过哈希函数的换算，会出现同一个值的情况。处理这种情况的一种方法是，拉出一个链表。</p><p>假设，你现在维护着一个身份证信息和姓名的表，需要根据身份证号查找对应的名字，这时对应的哈希索引的示意图如下所示：</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211026235041.png style=display:block;width:80% alt=NAME align=center></div><p>图中，User2和User4根据身份证号算出来的值都是N，但没关系，后面还跟了一个链表。假设，这时候你要查ID_card_n2对应的名字是什么，处理步骤就是：首先，将ID_card_n2通过哈希函数算出N；然后，按顺序遍历，找到User2。</p><p>需要注意的是，图中四个ID_card_n的值并不是递增的，这样做的好处是增加新的User时速度会很快，只需要往后追加。但缺点是，因为不是有序的，所以哈希索引做区间查询的速度是很慢的。</p><p>你可以设想下，如果你现在要找身份证号在[ID_card_X, ID_card_Y]这个区间的所有用户，就必须全部扫描一遍了。</p><p>所以，<strong>哈希表这种结构适用于只有等值查询的场景</strong>，比如Memcached及其他一些NoSQL引擎。</p><h3 id=有序数组>有序数组</h3><p>而<strong>有序数组在等值查询和范围查询场景中的性能就都非常优秀</strong>。还是上面这个根据身份证号查名字的例子，如果我们使用有序数组来实现的话，示意图如下所示：</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211026235242.png style=display:block;width:80% alt=NAME align=center></div><p>这里我们假设身份证号没有重复，这个数组就是按照身份证号递增的顺序保存的。这时候如果你要查ID_card_n2对应的名字，用二分法就可以快速得到，这个时间复杂度是O(log(N))。</p><p>同时很显然，这个索引结构支持范围查询。你要查身份证号在[ID_card_X, ID_card_Y]区间的User，可以先用二分法找到ID_card_X（如果不存在ID_card_X，就找到大于ID_card_X的第一个User），然后向右遍历，直到查到第一个大于ID_card_Y的身份证号，退出循环。</p><p>如果仅仅看查询效率，有序数组就是最好的数据结构了。但是，在需要更新数据的时候就麻烦了，你往中间插入一个记录就必须得挪动后面所有的记录，成本太高。</p><p>所以，<strong>有序数组索引只适用于静态存储引擎</strong>，比如你要保存的是2017年某个城市的所有人口信息，这类不会再修改的数据。</p><h3 id=二叉树>二叉树</h3><p>二叉搜索树也是课本里的经典数据结构了。还是上面根据身份证号查名字的例子，如果我们用二叉搜索树来实现的话，示意图如下所示：</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211026235354.png style=display:block;width:80% alt=NAME align=center></div><p>二叉搜索树的特点是：每个节点的左儿子小于父节点，父节点又小于右儿子。这样如果你要查ID_card_n2的话，按照图中的搜索顺序就是按照UserA -> UserC -> UserF -> User2这个路径得到。这个时间复杂度是O(log(N))。</p><p>当然为了维持O(log(N))的查询复杂度，你就需要保持这棵树是平衡二叉树。为了做这个保证，更新的时间复杂度也是O(log(N))。</p><p>树可以有二叉，也可以有多叉。多叉树就是每个节点有多个儿子，儿子之间的大小保证从左到右递增。二叉树是搜索效率最高的，但是实际上大多数的数据库存储却并不使用二叉树。其原因是，索引不止存在内存中，还要写到磁盘上。</p><p>你可以想象一下一棵100万节点的平衡二叉树，树高20。一次查询可能需要访问20个数据块。在机械硬盘时代，从磁盘随机读一个数据块需要10 ms左右的寻址时间。也就是说，对于一个100万行的表，如果使用二叉树来存储，单独访问一个行可能需要20个10 ms的时间，这个查询可真够慢的。</p><h3 id=n-叉树>N 叉树</h3><p>为了让一个查询尽量少地读磁盘，就必须让查询过程访问尽量少的数据块。那么，我们就不应该使用二叉树，而是要使用“N叉”树。这里，“N叉”树中的“N”取决于数据块的大小。</p><p>以InnoDB的一个整数字段索引为例，这个N差不多是1200。这棵树高是4的时候，就可以存1200的3次方个值，这已经17亿了。考虑到树根的数据块总是在内存中的，一个10亿行的表上一个整数字段的索引，查找一个值最多只需要访问3次磁盘。其实，树的第二层也有很大概率在内存中，那么访问磁盘的平均次数就更少了。</p><p>N叉树由于在读写上的性能优点，以及适配磁盘的访问模式，已经被广泛应用在数据库引擎中了。</p><h3 id=模型总结>模型总结</h3><p>不管是哈希还是有序数组，或者N叉树，它们都是不断迭代、不断优化的产物或者解决方案。数据库技术发展到今天，跳表、LSM树等数据结构也被用于引擎设计中，这里我就不再一一展开了。</p><p>你心里要有个概念，数据库底层存储的核心就是基于这些数据模型的。每碰到一个新数据库，我们需要先关注它的数据模型，这样才能从理论上分析出这个数据库的适用场景。</p><h2 id=innodb-索引模型>InnoDb 索引模型</h2><p>在MySQL中，索引是在存储引擎层实现的，所以并没有统一的索引标准，即不同存储引擎的索引的工作方式并不一样。而即使多个存储引擎支持同一种类型的索引，其底层的实现也可能不同。由于InnoDB存储引擎在MySQL数据库中使用最为广泛，所以下面我就以InnoDB为例，和你分析一下其中的索引模型。</p><p>在InnoDB中，表都是根据主键顺序以索引的形式存放的，这种存储方式的表称为索引组织表。又因为前面我们提到的，InnoDB使用了B+树索引模型，所以数据都是存储在B+树中的。</p><p>每一个索引在InnoDB里面对应一棵B+树。</p><p>假设，我们有一个主键列为ID的表，表中有字段k，并且在k上有索引。</p><p>这个表的建表语句是：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>mysql&gt; create table T(
</span></span><span style=display:flex><span>id int primary key, 
</span></span><span style=display:flex><span>k int not null, 
</span></span><span style=display:flex><span>name varchar(16),
</span></span><span style=display:flex><span>index (k))engine=InnoDB;
</span></span></code></pre></div><p>表中R1~R5的(ID,k)值分别为(100,1)、(200,2)、(300,3)、(500,5)和(600,6)，两棵树的示例示意图如下。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211026235901.png style=display:block;width:80% alt=NAME align=center></div><p>从图中不难看出，根据叶子节点的内容，索引类型分为<strong>主键索引和非主键索引</strong>。</p><p><strong>主键索引的叶子节点存的是整行数据</strong>。在InnoDB里，主键索引也被称为<strong>聚簇索引</strong>（clustered index）。</p><p><strong>非主键索引的叶子节点内容是主键的值</strong>。在InnoDB里，非主键索引也被称为<strong>二级索引</strong>（secondary index）。</p><p>根据上面的索引结构说明，我们来讨论一个问题：<strong>基于主键索引和普通索引的查询有什么区别？</strong></p><ul><li>如果语句是select * from T where ID=500，即主键查询方式，则只需要搜索ID这棵B+树；</li><li>如果语句是select * from T where k=5，即普通索引查询方式，则需要先搜索k索引树，得到ID的值为500，再到ID索引树搜索一次。<strong>这个过程称为回表</strong>。</li></ul><p>也就是说，<strong>基于非主键索引的查询需要多扫描一棵索引树</strong>。因此，我们在应用中应该尽量使用主键查询。</p><h2 id=索引维护>索引维护</h2><p>B+树为了维护索引有序性，在插入新值的时候需要做必要的维护。以上面这个图为例，如果插入新的行ID值为700，则只需要在R5的记录后面插入一个新记录。如果新插入的ID值为400，就相对麻烦了，需要逻辑上挪动后面的数据，空出位置。</p><p>而更糟的情况是，如果R5所在的数据页已经满了，根据B+树的算法，这时候需要申请一个新的数据页，然后挪动部分数据过去。这个过程称为页分裂。在这种情况下，性能自然会受影响。</p><p>除了性能外，页分裂操作还影响数据页的利用率。原本放在一个页的数据，现在分到两个页中，整体空间利用率降低大约50%。</p><p>当然有分裂就有合并。当相邻两个页由于删除了数据，利用率很低之后，会将数据页做合并。合并的过程，可以认为是分裂过程的逆过程。</p><p>基于上面的索引维护过程说明，我们来讨论一个案例：</p><blockquote><p>你可能在一些建表规范里面见到过类似的描述，要求建表语句里一定要有自增主键。当然事无绝对，我们来分析一下哪些场景下应该使用自增主键，而哪些场景下不应该。</p></blockquote><p>自增主键是指自增列上定义的主键，在建表语句中一般是这么定义的：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>NOT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>NULL</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>PRIMARY</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>KEY</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>AUTO_INCREMENT</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><p>插入新记录的时候可以不指定ID的值，系统会获取当前ID最大值加1作为下一条记录的ID值。</p><p>也就是说，<strong>自增主键的插入数据模式，正符合了我们前面提到的递增插入的场景。每次插入一条新记录，都是追加操作，都不涉及到挪动其他记录，也不会触发叶子节点的分裂。</strong></p><p>而有业务逻辑的字段做主键，则往往不容易保证有序插入，这样写数据成本相对较高。</p><p>除了考虑性能外，我们还可以从存储空间的角度来看。假设你的表中确实有一个唯一字段，比如字符串类型的身份证号，那应该用身份证号做主键，还是用自增字段做主键呢？</p><p>由于每个非主键索引的叶子节点上都是主键的值。如果用身份证号做主键，那么每个二级索引的叶子节点占用约20个字节，而如果用整型做主键，则只要4个字节，如果是长整型（bigint）则是8个字节。</p><p><strong>显然，主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小。</strong></p><p>所以，从性能和存储空间方面考量，自增主键往往是更合理的选择。</p><p>有没有什么场景适合用业务字段直接做主键的呢？还是有的。比如，有些业务的场景需求是这样的：</p><ol><li>只有一个索引；</li><li>该索引必须是唯一索引。</li></ol><p>你一定看出来了，这就是典型的KV场景。</p><p>由于没有其他索引，所以也就不用考虑其他索引的叶子节点大小的问题。</p><p>这时候我们就要优先考虑上一段提到的“尽量使用主键查询”原则，直接将这个索引设置为主键，可以避免每次查询需要搜索两棵树。</p><h2 id=总结>总结</h2><ol><li>索引的作用：提高数据查询效率</li><li>常见索引模型：哈希表、有序数组、搜索树</li><li>哈希表：键 - 值(key - value)。</li><li>哈希思路：把值放在数组里，用一个哈希函数把key换算成一个确定的位置，然后把value放在数组的这个位置</li><li>哈希冲突的处理办法：链表</li><li>哈希表适用场景：只有等值查询的场景</li><li>有序数组：按顺序存储。查询用二分法就可以快速查询，时间复杂度是：O(log(N))</li><li>有序数组查询效率高，更新效率低</li><li>有序数组的适用场景：静态存储引擎。</li><li>二叉搜索树：每个节点的左儿子小于父节点，父节点又小于右儿子</li><li>二叉搜索树：查询时间复杂度O(log(N))，更新时间复杂度O(log(N))</li><li>数据库存储大多不适用二叉树，因为树高过高，会适用N叉树</li><li>InnoDB中的索引模型：B+Tree</li><li>索引类型：主键索引、非主键索引
主键索引的叶子节点存的是整行的数据(聚簇索引)，非主键索引的叶子节点内容是主键的值(二级索引)</li><li>主键索引和普通索引的区别：主键索引只要搜索ID这个B+Tree即可拿到数据。普通索引先搜索索引拿到主键值，再到主键索引树搜索一次(回表)</li><li>一个数据页满了，按照B+Tree算法，新增加一个数据页，叫做页分裂，会导致性能下降。空间利用率降低大概50%。当相邻的两个数据页利用率很低的时候会做数据页合并，合并的过程是分裂过程的逆过程。</li><li>从性能和存储空间方面考量，自增主键往往是更合理的选择。</li></ol></div><div class=td-content style=page-break-before:always><h1 id=pg-557271842e3f9b6b61f8f0a1bbe2a7ca>5.5 - CH05-索引-下</h1><p>在开始这篇文章之前，我们先来看一下这个问题：</p><p>在下面这个表T中，如果我执行 <code>select * from T where k between 3 and 5</code>，需要执行几次树的搜索操作，会扫描多少行？</p><p>下面是这个表的初始化语句。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#000>mysql</span><span style=color:#ce5c00;font-weight:700>&gt;</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>create</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>table</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>T</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>(</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#000>ID</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87>int</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>primary</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>key</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#000>k</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87>int</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>NOT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>NULL</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>DEFAULT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#0000cf;font-weight:700>0</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> 
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#000>s</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87>varchar</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>16</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>NOT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>NULL</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>DEFAULT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#4e9a06>&#39;&#39;</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>index</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>k</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>k</span><span style=color:#000;font-weight:700>))</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#000>engine</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#000>InnoDB</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>insert</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>into</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>T</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>values</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>100</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#4e9a06>&#39;aa&#39;</span><span style=color:#000;font-weight:700>),(</span><span style=color:#0000cf;font-weight:700>200</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>2</span><span style=color:#000;font-weight:700>,</span><span style=color:#4e9a06>&#39;bb&#39;</span><span style=color:#000;font-weight:700>),(</span><span style=color:#0000cf;font-weight:700>300</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>3</span><span style=color:#000;font-weight:700>,</span><span style=color:#4e9a06>&#39;cc&#39;</span><span style=color:#000;font-weight:700>),(</span><span style=color:#0000cf;font-weight:700>500</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>5</span><span style=color:#000;font-weight:700>,</span><span style=color:#4e9a06>&#39;ee&#39;</span><span style=color:#000;font-weight:700>),(</span><span style=color:#0000cf;font-weight:700>600</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>6</span><span style=color:#000;font-weight:700>,</span><span style=color:#4e9a06>&#39;ff&#39;</span><span style=color:#000;font-weight:700>),(</span><span style=color:#0000cf;font-weight:700>700</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>7</span><span style=color:#000;font-weight:700>,</span><span style=color:#4e9a06>&#39;gg&#39;</span><span style=color:#000;font-weight:700>);</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211027000655.png style=display:block;width:80% alt=NAME align=center></div><p>现在，我们一起来看看这条SQL查询语句的执行流程：</p><ol><li>在k索引树上找到k=3的记录，取得 ID = 300；</li><li>再到ID索引树查到ID=300对应的R3；</li><li>在k索引树取下一个值k=5，取得ID=500；</li><li>再回到ID索引树查到ID=500对应的R4；</li><li>在k索引树取下一个值k=6，不满足条件，循环结束。</li></ol><p>在这个过程中，<strong>回到主键索引树搜索的过程，我们称为回表</strong>。可以看到，这个查询过程读了k索引树的3条记录（步骤1、3和5），回表了两次（步骤2和4）。</p><p>在这个例子中，由于查询结果所需要的数据只在主键索引上有，所以不得不回表。那么，有没有可能经过索引优化，避免回表过程呢？</p><h2 id=覆盖索引>覆盖索引</h2><p>如果执行的语句是 <code>select ID from T where k between 3 and 5</code>，这时只需要查ID的值，而ID的值已经在k索引树上了，因此可以直接提供查询结果，不需要回表。也就是说，在这个查询里面，索引k已经“覆盖了”我们的查询需求，我们称为覆盖索引。</p><p><strong>由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段。</strong></p><p>需要注意的是，在引擎内部使用覆盖索引在索引k上其实读了三个记录，R3~R5（对应的索引k上的记录项），但是对于MySQL的Server层来说，它就是找引擎拿到了两条记录，因此MySQL认为扫描行数是2。</p><blockquote><p>备注：关于如何查看扫描行数的问题，我将会在第16章《如何正确地显示随机消息？》中，和你详细讨论。</p></blockquote><p>基于上面覆盖索引的说明，我们来讨论一个问题：<strong>在一个市民信息表上，是否有必要将身份证号和名字建立联合索引？</strong></p><p>假设这个市民表的定义是这样的：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>CREATE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>TABLE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>tuser</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>(</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>id</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87>int</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>11</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>NOT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>NULL</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>id_card</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87>varchar</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>32</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>DEFAULT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>NULL</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>name</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87>varchar</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>32</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>DEFAULT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>NULL</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>age</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87>int</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>11</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>DEFAULT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>NULL</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>ismale</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>tinyint</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>DEFAULT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>NULL</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>PRIMARY</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>KEY</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>(</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>id</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000;font-weight:700>),</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>KEY</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>id_card</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>(</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>id_card</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000;font-weight:700>),</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>KEY</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>name_age</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>(</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>name</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000;font-weight:700>,</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>age</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>ENGINE</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#000>InnoDB</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><p>我们知道，身份证号是市民的唯一标识。也就是说，如果有根据身份证号查询市民信息的需求，我们只要在身份证号字段上建立索引就够了。而再建立一个（身份证号、姓名）的联合索引，是不是浪费空间？</p><p>如果现在有一个高频请求，要根据市民的身份证号查询他的姓名，这个联合索引就有意义了。它可以在这个高频请求上用到覆盖索引，不再需要回表查整行记录，减少语句的执行时间。</p><p>当然，索引字段的维护总是有代价的。因此，在建立冗余索引来支持覆盖索引时就需要权衡考虑了。这正是业务DBA，或者称为业务数据架构师的工作。</p><h2 id=最左前缀原则>最左前缀原则</h2><p>看到这里你一定有一个疑问，如果为每一种查询都设计一个索引，索引是不是太多了。如果我现在要按照市民的身份证号去查他的家庭地址呢？虽然这个查询需求在业务中出现的概率不高，但总不能让它走全表扫描吧？反过来说，单独为一个不频繁的请求创建一个（身份证号，地址）的索引又感觉有点浪费。应该怎么做呢？</p><p>这里，我先和你说结论吧。<strong>B+树这种索引结构，可以利用索引的“最左前缀”，来定位记录。</strong></p><p>为了直观地说明这个概念，我们用（name，age）这个联合索引来分析。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211027001146.png style=display:block;width:80% alt=NAME align=center></div><p>可以看到，索引项是按照索引定义里面出现的字段顺序排序的。</p><p>当你的逻辑需求是查到所有名字是“张三”的人时，可以快速定位到ID4，然后向后遍历得到所有需要的结果。</p><p>如果你要查的是所有名字第一个字是“张”的人，你的SQL语句的条件是"where name like ‘张%’"。这时，你也能够用上这个索引，查找到第一个符合条件的记录是ID3，然后向后遍历，直到不满足条件为止。</p><p>可以看到，不只是索引的全部定义，只要满足最左前缀，就可以利用索引来加速检索。这个最左前缀可以是联合索引的最左N个字段，也可以是字符串索引的最左M个字符。</p><p>基于上面对最左前缀索引的说明，我们来讨论一个问题：<strong>在建立联合索引的时候，如何安排索引内的字段顺序。</strong></p><p>这里我们的评估标准是，索引的复用能力。因为可以支持最左前缀，所以当已经有了(a,b)这个联合索引后，一般就不需要单独在a上建立索引了。因此，<strong>第一原则是，如果通过调整顺序，可以少维护一个索引，那么这个顺序往往就是需要优先考虑采用的。</strong></p><p>所以现在你知道了，这段开头的问题里，我们要为高频请求创建(身份证号，姓名）这个联合索引，并用这个索引支持“根据身份证号查询地址”的需求。</p><p>那么，如果既有联合查询，又有基于a、b各自的查询呢？查询条件里面只有b的语句，是无法使用(a,b)这个联合索引的，这时候你不得不维护另外一个索引，也就是说你需要同时维护(a,b)、(b) 这两个索引。</p><p>这时候，我们要<strong>考虑的原则就是空间</strong>了。比如上面这个市民表的情况，name字段是比age字段大的 ，那我就建议你创建一个（name,age)的联合索引和一个(age)的单字段索引。</p><h2 id=索引下推>索引下推</h2><p>上一段我们说到满足最左前缀原则的时候，最左前缀可以用于在索引中定位记录。这时，你可能要问，那些不符合最左前缀的部分，会怎么样呢？</p><p>我们还是以市民表的联合索引（name, age）为例。如果现在有一个需求：检索出表中“名字第一个字是张，而且年龄是10岁的所有男孩”。那么，SQL语句是这么写的：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#000>mysql</span><span style=color:#ce5c00;font-weight:700>&gt;</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>select</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>*</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>from</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>tuser</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>where</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>name</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>like</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#4e9a06>&#39;张%&#39;</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>and</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>age</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#0000cf;font-weight:700>10</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>and</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>ismale</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><p>你已经知道了前缀索引规则，所以这个语句在搜索索引树的时候，只能用 “张”，找到第一个满足条件的记录ID3。当然，这还不错，总比全表扫描要好。</p><p>然后呢？</p><p>当然是判断其他条件是否满足。</p><p>在MySQL 5.6之前，只能从ID3开始一个个回表。到主键索引上找出数据行，再对比字段值。</p><p>而MySQL 5.6 引入的索引下推优化（index condition pushdown)， <strong>可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数</strong>。</p><p>图3和图4，是这两个过程的执行流程图。</p><p>无下推：</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211027001505.png style=display:block;width:80% alt=NAME align=center></div><p>有下推：</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211027001608.png style=display:block;width:80% alt=NAME align=center></div><p>在图3和4这两个图里面，每一个虚线箭头表示回表一次。</p><p>图3中，在(name,age)索引里面我特意去掉了age的值，这个过程InnoDB并不会去看age的值，只是按顺序把“name第一个字是’张’”的记录一条条取出来回表。因此，需要回表4次。</p><p>图4跟图3的区别是，InnoDB在(name,age)索引内部就判断了age是否等于10，对于不等于10的记录，直接判断并跳过。在我们的这个例子中，只需要对ID4、ID5这两条记录回表取数据判断，就只需要回表2次。</p><h2 id=总结>总结</h2><p>1、覆盖索引：如果查询条件使用的是普通索引（或是联合索引的最左原则字段），查询结果是联合索引的字段或是主键，不用回表操作，直接返回结果，减少IO磁盘读写读取正行数据。
2、最左前缀：联合索引的最左 N 个字段，也可以是字符串索引的最左 M 个字符。
3、联合索引：根据创建联合索引的顺序，以最左原则进行where检索，比如（age，name）以age=1 或 age= 1 and name=‘张三’可以使用索引，单以name=‘张三’ 不会使用索引，考虑到存储空间的问题，还请根据业务需求，将查找频繁的数据进行靠左创建索引。
4、索引下推：like &lsquo;hello%’and age >10 检索，MySQL5.6版本之前，会对匹配的数据进行回表查询。5.6版本后，会先过滤掉age&lt;10的数据，再进行回表查询，减少回表率，提升检索速度。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-b26ced95223bb69a1c58b680a8a4194b>5.6 - CH06-全局锁与表锁</h1><p>数据库锁设计的初衷是处理并发问题。作为多用户共享的资源，当出现并发访问的时候，数据库需要合理地控制资源的访问规则。而锁就是用来实现这些访问规则的重要数据结构。</p><p><strong>根据加锁的范围，MySQL里面的锁大致可以分成全局锁、表级锁和行锁三类</strong>。今天这篇文章，我会和你分享全局锁和表级锁。而关于行锁的内容，我会留着在下一篇文章中再和你详细介绍。</p><h2 id=全局锁>全局锁</h2><p>顾名思义，全局锁就是对整个数据库实例加锁。MySQL提供了一个加全局读锁的方法，命令是 Flush tables with read lock (FTWRL)。当你需要让整个库处于只读状态的时候，可以使用这个命令，之后其他线程的以下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结构等）和更新类事务的提交语句。</p><p>**全局锁的典型使用场景是，做全库逻辑备份。**也就是把整库每个表都select出来存成文本。</p><p>以前有一种做法，是通过FTWRL确保不会有其他线程对数据库做更新，然后对整个库做备份。注意，在备份过程中整个库完全处于只读状态。</p><p>但是让整库都只读，听上去就很危险：</p><ul><li>如果你在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆；</li><li>如果你在从库上备份，那么备份期间从库不能执行主库同步过来的binlog，会导致主从延迟。</li></ul><p>看来加全局锁不太好。但是细想一下，备份为什么要加锁呢？我们来看一下不加锁会有什么问题。</p><p>假设你现在要维护“极客时间”的购买系统，关注的是用户账户余额表和用户课程表。</p><p>现在发起一个逻辑备份。假设备份期间，有一个用户，他购买了一门课程，业务逻辑里就要扣掉他的余额，然后往已购课程里面加上一门课。</p><p>如果时间顺序上是先备份账户余额表(u_account)，然后用户购买，然后备份用户课程表(u_course)，会怎么样呢？你可以看一下这个图：</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211027002415.png style=display:block;width:80% alt=NAME align=center></div><p>可以看到，这个备份结果里，用户A的数据状态是“账户余额没扣，但是用户课程表里面已经多了一门课”。如果后面用这个备份来恢复数据的话，用户A就发现，自己赚了。</p><p>作为用户可别觉得这样可真好啊，你可以试想一下：如果备份表的顺序反过来，先备份用户课程表再备份账户余额表，又可能会出现什么结果？</p><p>也就是说，<strong>不加锁的话，备份系统备份的得到的库不是一个逻辑时间点，这个视图是逻辑不一致的。</strong></p><p>说到视图你肯定想起来了，我们在前面讲事务隔离的时候，其实是有一个方法能够拿到一致性视图的，对吧？</p><p>是的，就是在可重复读隔离级别下开启一个事务。</p><blockquote><p>备注：如果你对事务隔离级别的概念不是很清晰的话，可以再回顾一下第3篇文章《事务隔离》中的相关内容。</p></blockquote><p>官方自带的逻辑备份工具是mysqldump。当mysqldump使用参数–single-transaction的时候，导数据之前就会启动一个事务，来确保拿到一致性视图。而由于MVCC的支持，这个过程中数据是可以正常更新的。</p><p>你一定在疑惑，有了这个功能，为什么还需要FTWRL呢？**一致性读是好，但前提是引擎要支持这个隔离级别。**比如，对于MyISAM这种不支持事务的引擎，如果备份过程中有更新，总是只能取到最新的数据，那么就破坏了备份的一致性。这时，我们就需要使用FTWRL命令了。</p><p>所以，**single-transaction方法只适用于所有的表使用事务引擎的库。**如果有的表使用了不支持事务的引擎，那么备份就只能通过FTWRL方法。这往往是DBA要求业务开发人员使用InnoDB替代MyISAM的原因之一。</p><p>你也许会问，<strong>既然要全库只读，为什么不使用set global readonly=true的方式呢</strong>？确实readonly方式也可以让全库进入只读状态，但我还是会建议你用FTWRL方式，主要有两个原因：</p><ul><li>一是，在有些系统中，readonly的值会被用来做其他逻辑，比如用来判断一个库是主库还是备库。因此，修改global变量的方式影响面更大，我不建议你使用。</li><li>二是，在异常处理机制上有差异。如果执行FTWRL命令之后由于客户端发生异常断开，那么MySQL会自动释放这个全局锁，整个库回到可以正常更新的状态。而将整个库设置为readonly之后，如果客户端发生异常，则数据库就会一直保持readonly状态，这样会导致整个库长时间处于不可写状态，风险较高。</li></ul><p>业务的更新不只是增删改数据（DML)，还有可能是加字段等修改表结构的操作（DDL）。不论是哪种方法，一个库被全局锁上以后，你要对里面任何一个表做加字段操作，都是会被锁住的。</p><p>但是，即使没有被全局锁住，加字段也不是就能一帆风顺的，因为你还会碰到接下来我们要介绍的表级锁。</p><h2 id=表级锁>表级锁</h2><p>MySQL里面表级别的锁有两种：一种是表锁，一种是元数据锁（meta data lock，MDL)。</p><p>**表锁的语法是 lock tables … read/write。**与FTWRL类似，可以用unlock tables主动释放锁，也可以在客户端断开的时候自动释放。需要注意，lock tables语法除了会限制别的线程的读写外，也限定了本线程接下来的操作对象。</p><p>举个例子, 如果在某个线程A中执行lock tables t1 read, t2 write; 这个语句，则其他线程写t1、读写t2的语句都会被阻塞。同时，线程A在执行unlock tables之前，也只能执行读t1、读写t2的操作。连写t1都不允许，自然也不能访问其他表。</p><p>在还没有出现更细粒度的锁的时候，表锁是最常用的处理并发的方式。而对于InnoDB这种支持行锁的引擎，一般不使用lock tables命令来控制并发，毕竟锁住整个表的影响面还是太大。</p><p>**另一类表级的锁是MDL（metadata lock)。**MDL不需要显式使用，在访问一个表的时候会被自动加上。MDL的作用是，保证读写的正确性。你可以想象一下，如果一个查询正在遍历一个表中的数据，而执行期间另一个线程对这个表结构做变更，删了一列，那么查询线程拿到的结果跟表结构对不上，肯定是不行的。</p><p>因此，在MySQL 5.5版本中引入了MDL，当对一个表做增删改查操作的时候，加MDL读锁；当要对表做结构变更操作的时候，加MDL写锁。</p><ul><li>读锁之间不互斥，因此你可以有多个线程同时对一张表增删改查。</li><li>读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性。因此，如果有两个线程要同时给一个表加字段，其中一个要等另一个执行完才能开始执行。</li></ul><p>虽然MDL锁是系统默认会加的，但却是你不能忽略的一个机制。比如下面这个例子，我经常看到有人掉到这个坑里：给一个小表加个字段，导致整个库挂了。</p><p>你肯定知道，给一个表加字段，或者修改字段，或者加索引，需要扫描全表的数据。在对大表操作的时候，你肯定会特别小心，以免对线上服务造成影响。而实际上，即使是小表，操作不慎也会出问题。我们来看一下下面的操作序列，假设表t是一个小表。</p><blockquote><p>备注：这里的实验环境是MySQL 5.6。</p></blockquote><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211027221601.png style=display:block;width:80% alt=NAME align=center></div><p>我们可以看到session A先启动，这时候会对表t加一个MDL读锁。由于session B需要的也是MDL读锁，因此可以正常执行。</p><p>之后session C会被blocked，是因为session A的MDL读锁还没有释放，而session C需要MDL写锁，因此只能被阻塞。</p><p>如果只有session C自己被阻塞还没什么关系，但是之后所有要在表t上新申请MDL读锁的请求也会被session C阻塞。前面我们说了，所有对表的增删改查操作都需要先申请MDL读锁，就都被锁住，等于这个表现在完全不可读写了。</p><p>如果某个表上的查询语句频繁，而且客户端有重试机制，也就是说超时后会再起一个新session再请求的话，这个库的线程很快就会爆满。</p><p>你现在应该知道了，事务中的MDL锁，在语句执行开始时申请，但是语句结束后并不会马上释放，而会等到整个事务提交后再释放。</p><p>基于上面的分析，我们来讨论一个问题，<strong>如何安全地给小表加字段？</strong></p><p>首先我们要解决长事务，事务不提交，就会一直占着MDL锁。在MySQL的information_schema 库的 innodb_trx 表中，你可以查到当前执行中的事务。如果你要做DDL变更的表刚好有长事务在执行，要考虑先暂停DDL，或者kill掉这个长事务。</p><p>但考虑一下这个场景。如果你要变更的表是一个热点表，虽然数据量不大，但是上面的请求很频繁，而你不得不加个字段，你该怎么做呢？</p><p>这时候kill可能未必管用，因为新的请求马上就来了。比较理想的机制是，在alter table语句里面设定等待时间，如果在这个指定的等待时间里面能够拿到MDL写锁最好，拿不到也不要阻塞后面的业务语句，先放弃。之后开发人员或者DBA再通过重试命令重复这个过程。</p><p>MariaDB已经合并了AliSQL的这个功能，所以这两个开源分支目前都支持DDL NOWAIT/WAIT n这个语法。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>ALTER TABLE tbl_name NOWAIT add column ...
</span></span><span style=display:flex><span>ALTER TABLE tbl_name WAIT N add column ... 
</span></span></code></pre></div></div><div class=td-content style=page-break-before:always><h1 id=pg-8e6aafa223e735459e0969042de4d54f>5.7 - CH07-行级锁</h1><p>MySQL的行锁是在引擎层由各个引擎自己实现的。但并不是所有的引擎都支持行锁，比如MyISAM引擎就不支持行锁。</p><p>不支持行锁意味着并发控制只能使用表锁，对于这种引擎的表，同一张表上任何时刻只能有一个更新在执行，这就会影响到业务并发度。InnoDB是支持行锁的，这也是MyISAM被InnoDB替代的重要原因之一。</p><p>我们今天就主要来聊聊InnoDB的行锁，以及如何通过减少锁冲突来提升业务并发度。</p><p>顾名思义，行锁就是针对数据表中行记录的锁。这很好理解，比如事务A更新了一行，而这时候事务B也要更新同一行，则必须等事务A的操作完成后才能进行更新。</p><p>当然，数据库中还有一些没那么一目了然的概念和设计，这些概念如果理解和使用不当，容易导致程序出现非预期行为，比如两阶段锁。</p><h2 id=两阶段锁>两阶段锁</h2><p>在下面的操作序列中，事务B的update语句执行时会是什么现象呢？假设字段id是表t的主键。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211027222159.png style=display:block;width:80% alt=NAME align=center></div><p>这个问题的结论取决于事务A在执行完两条update语句后，持有哪些锁，以及在什么时候释放。你可以验证一下：<strong>实际上事务B的update语句会被阻塞，直到事务A执行commit之后，事务B才能继续执行</strong>。</p><p>知道了这个答案，你一定知道了事务A持有的两个记录的行锁，都是在commit的时候才释放的。</p><p>也就是说，<strong>在InnoDB事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。这个就是两阶段锁协议。</strong></p><p>知道了这个设定，对我们使用事务有什么帮助呢？那就是，如果你的事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放。我给你举个例子。</p><p>假设你负责实现一个电影票在线交易业务，顾客A要在影院B购买电影票。我们简化一点，这个业务需要涉及到以下操作：</p><ol><li>从顾客A账户余额中扣除电影票价；</li><li>给影院B的账户余额增加这张电影票价；</li><li>记录一条交易日志。</li></ol><p>也就是说，要完成这个交易，我们需要update两条记录，并insert一条记录。当然，为了保证交易的原子性，我们要把这三个操作放在一个事务中。那么，你会怎样安排这三个语句在事务中的顺序呢？</p><p>试想如果同时有另外一个顾客C要在影院B买票，那么这两个事务冲突的部分就是语句2了。因为它们要更新同一个影院账户的余额，需要修改同一行数据。</p><p>根据两阶段锁协议，不论你怎样安排语句顺序，所有的操作需要的行锁都是在事务提交的时候才释放的。所以，如果你把语句2安排在最后，比如按照3、1、2这样的顺序，那么影院账户余额这一行的锁时间就最少。这就最大程度地减少了事务之间的锁等待，提升了并发度。</p><p>好了，现在由于你的正确设计，影院余额这一行的行锁在一个事务中不会停留很长时间。但是，这并没有完全解决你的困扰。</p><p>如果这个影院做活动，可以低价预售一年内所有的电影票，而且这个活动只做一天。于是在活动时间开始的时候，你的MySQL就挂了。你登上服务器一看，CPU消耗接近100%，但整个数据库每秒就执行不到100个事务。这是什么原因呢？</p><p>这里，我就要说到死锁和死锁检测了。</p><h2 id=死锁与检测>死锁与检测</h2><p>当并发系统中不同线程出现循环资源依赖，涉及的线程都在等待别的线程释放资源时，就会导致这几个线程都进入无限等待的状态，称为死锁。这里我用数据库中的行锁举个例子。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211027222546.png style=display:block;width:80% alt=NAME align=center></div><p>这时候，事务A在等待事务B释放id=2的行锁，而事务B在等待事务A释放id=1的行锁。 事务A和事务B在互相等待对方的资源释放，就是进入了死锁状态。当出现死锁以后，有两种策略：</p><ul><li>一种策略是，直接进入等待，直到超时。这个超时时间可以通过参数innodb_lock_wait_timeout来设置。</li><li>另一种策略是，发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数innodb_deadlock_detect设置为on，表示开启这个逻辑。</li></ul><p>在InnoDB中，innodb_lock_wait_timeout的默认值是50s，意味着如果采用第一个策略，当出现死锁以后，第一个被锁住的线程要过50s才会超时退出，然后其他线程才有可能继续执行。对于在线服务来说，这个等待时间往往是无法接受的。</p><p>但是，我们又不可能直接把这个时间设置成一个很小的值，比如1s。这样当出现死锁的时候，确实很快就可以解开，但如果不是死锁，而是简单的锁等待呢？所以，超时时间设置太短的话，会出现很多误伤。</p><p>所以，正常情况下我们还是要采用第二种策略，即：主动死锁检测，而且innodb_deadlock_detect的默认值本身就是on。主动死锁检测在发生死锁的时候，是能够快速发现并进行处理的，但是它也是有额外负担的。</p><p>你可以想象一下这个过程：每当一个事务被锁的时候，就要看看它所依赖的线程有没有被别人锁住，如此循环，最后判断是否出现了循环等待，也就是死锁。</p><p>那如果是我们上面说到的所有事务都要更新同一行的场景呢？</p><p>每个新来的被堵住的线程，都要判断会不会由于自己的加入导致了死锁，这是一个时间复杂度是O(n)的操作。假设有1000个并发线程要同时更新同一行，那么死锁检测操作就是100万这个量级的。虽然最终检测的结果是没有死锁，但是这期间要消耗大量的CPU资源。因此，你就会看到CPU利用率很高，但是每秒却执行不了几个事务。</p><p>根据上面的分析，我们来讨论一下，怎么解决由这种热点行更新导致的性能问题呢？问题的症结在于，死锁检测要耗费大量的CPU资源。</p><p>**一种头痛医头的方法，就是如果你能确保这个业务一定不会出现死锁，可以临时把死锁检测关掉。**但是这种操作本身带有一定的风险，因为业务设计的时候一般不会把死锁当做一个严重错误，毕竟出现死锁了，就回滚，然后通过业务重试一般就没问题了，这是业务无损的。而关掉死锁检测意味着可能会出现大量的超时，这是业务有损的。</p><p>**另一个思路是控制并发度。**根据上面的分析，你会发现如果并发能够控制住，比如同一行同时最多只有10个线程在更新，那么死锁检测的成本很低，就不会出现这个问题。一个直接的想法就是，在客户端做并发控制。但是，你会很快发现这个方法不太可行，因为客户端很多。我见过一个应用，有600个客户端，这样即使每个客户端控制到只有5个并发线程，汇总到数据库服务端以后，峰值并发数也可能要达到3000。</p><p>因此，这个并发控制要做在数据库服务端。如果你有中间件，可以考虑在中间件实现；如果你的团队有能修改MySQL源码的人，也可以做在MySQL里面。基本思路就是，对于相同行的更新，在进入引擎之前排队。这样在InnoDB内部就不会有大量的死锁检测工作了。</p><p>可能你会问，<strong>如果团队里暂时没有数据库方面的专家，不能实现这样的方案，能不能从设计上优化这个问题呢？</strong></p><p>你可以考虑通过将一行改成逻辑上的多行来减少锁冲突。还是以影院账户为例，可以考虑放在多条记录上，比如10个记录，影院的账户总额等于这10个记录的值的总和。这样每次要给影院账户加金额的时候，随机选其中一条记录来加。这样每次冲突概率变成原来的1/10，可以减少锁等待个数，也就减少了死锁检测的CPU消耗。</p><p>这个方案看上去是无损的，但其实这类方案需要根据业务逻辑做详细设计。如果账户余额可能会减少，比如退票逻辑，那么这时候就需要考虑当一部分行记录变成0的时候，代码要有特殊处理。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-5a6f17ddd74c080d6a6db2bc41956240>5.8 - CH08-MVCC</h1><p>如果是可重复读隔离级别，事务T启动的时候会创建一个视图read-view，之后事务T执行期间，即使有其他事务修改了数据，事务T看到的仍然跟在启动时看到的一样。也就是说，一个在可重复读隔离级别下执行的事务，好像与世无争，不受外界影响。</p><p>但是，在上一篇文章中，和你分享行锁的时候又提到，一个事务要更新一行，如果刚好有另外一个事务拥有这一行的行锁，它又不能这么超然了，会被锁住，进入等待状态。问题是，既然进入了等待状态，那么等到这个事务自己获取到行锁要更新数据的时候，它读到的值又是什么呢？</p><p>我给你举一个例子吧。下面是一个只有两行的表的初始化语句。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span><span style=color:#000>mysql</span><span style=color:#ce5c00;font-weight:700>&gt;</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>CREATE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>TABLE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>t</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>(</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>id</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>int</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>11</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>NOT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>NULL</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>k</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>int</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>11</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>DEFAULT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>NULL</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>PRIMARY</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>KEY</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>(</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>id</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>ENGINE</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#000>InnoDB</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>insert</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>into</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>t</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>id</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>k</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>values</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>),(</span><span style=color:#0000cf;font-weight:700>2</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>2</span><span style=color:#000;font-weight:700>);</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211027223351.png style=display:block;width:80% alt=NAME align=center></div><p>这里，我们需要注意的是<strong>事务的启动时机</strong>。</p><p>begin/start transaction 命令并不是一个事务的起点，在执行到它们之后的第一个操作InnoDB表的语句（第一个快照读语句），事务才真正启动。如果你想要马上启动一个事务，可以使用start transaction with consistent snapshot 这个命令。</p><p>还需要注意的是，在整个专栏里面，我们的例子中如果没有特别说明，都是默认autocommit=1。</p><p>在这个例子中，事务C没有显式地使用begin/commit，表示这个update语句本身就是一个事务，语句完成的时候会自动提交。事务B在更新了行之后查询; 事务A在一个只读事务中查询，并且时间顺序上是在事务B的查询之后。</p><p>这时，如果我告诉你事务B查到的k的值是3，而事务A查到的k的值是1，你是不是感觉有点晕呢？</p><p>所以，今天这篇文章，我其实就是想和你说明白这个问题，希望借由把这个疑惑解开的过程，能够帮助你对InnoDB的事务和锁有更进一步的理解。</p><p>在MySQL里，有两个“视图”的概念：</p><ul><li>一个是view。它是一个用查询语句定义的虚拟表，在调用的时候执行查询语句并生成结果。创建视图的语法是create view &mldr; ，而它的查询方法与表一样。</li><li>另一个是InnoDB在实现MVCC时用到的一致性读视图，即consistent read view，用于支持RC（Read Committed，读提交）和RR（Repeatable Read，可重复读）隔离级别的实现。</li></ul><p>它没有物理结构，<strong>作用是事务执行期间用来定义“我能看到什么数据”</strong>。</p><p>在第3篇文章《事务隔离》中，我跟你解释过一遍MVCC的实现逻辑。今天为了说明查询和更新的区别，我换一个方式来说明，把read view拆开。你可以结合这两篇文章的说明来更深一步地理解MVCC。</p><h2 id=mvcc-快照>MVCC 快照</h2><p>在可重复读隔离级别下，事务在启动的时候就“拍了个快照”。注意，这个快照是基于整库的。</p><p>这时，你会说这看上去不太现实啊。如果一个库有100G，那么我启动一个事务，MySQL就要拷贝100G的数据出来，这个过程得多慢啊。可是，我平时的事务执行起来很快啊。</p><p>实际上，我们并不需要拷贝出这100G的数据。我们先来看看这个快照是怎么实现的。</p><p>InnoDB里面每个事务有一个唯一的事务ID，叫作transaction id。它是在事务开始的时候向InnoDB的事务系统申请的，是按申请顺序严格递增的。</p><p>而每行数据也都是有多个版本的。每次事务更新数据的时候，都会生成一个新的数据版本，并且把transaction id赋值给这个数据版本的事务ID，记为row trx_id。同时，旧的数据版本要保留，并且在新的数据版本中，能够有信息可以直接拿到它。</p><p>也就是说，数据表中的一行记录，其实可能有多个版本(row)，每个版本有自己的row trx_id。</p><p>如图2所示，就是一个记录被多个事务连续更新后的状态。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/68d08d277a6f7926a41cc5541d3dfced.png style=display:block;width:80% alt=NAME align=center></div><p>图中虚线框里是同一行数据的4个版本，当前最新版本是V4，k的值是22，它是被transaction id 为25的事务更新的，因此它的row trx_id也是25。</p><p>你可能会问，前面的文章不是说，语句更新会生成undo log（回滚日志）吗？那么，<strong>undo log在哪呢？</strong></p><p>实际上，图2中的三个虚线箭头，就是undo log；而V1、V2、V3并不是物理上真实存在的，而是每次需要的时候根据当前版本和undo log计算出来的。比如，需要V2的时候，就是通过V4依次执行U3、U2算出来。</p><p>明白了多版本和row trx_id的概念后，我们再来想一下，InnoDB是怎么定义那个“100G”的快照的。</p><p>按照可重复读的定义，一个事务启动的时候，能够看到所有已经提交的事务结果。但是之后，这个事务执行期间，其他事务的更新对它不可见。</p><p>因此，一个事务只需要在启动的时候声明说，“以我启动的时刻为准，如果一个数据版本是在我启动之前生成的，就认；如果是我启动以后才生成的，我就不认，我必须要找到它的上一个版本”。</p><p>当然，如果“上一个版本”也不可见，那就得继续往前找。还有，如果是这个事务自己更新的数据，它自己还是要认的。</p><p>在实现上， InnoDB为每个事务构造了一个数组，用来保存这个事务启动瞬间，当前正在“活跃”的所有事务ID。“活跃”指的就是，启动了但还没提交。</p><p><strong>数组里面事务ID的最小值记为低水位，当前系统里面已经创建过的事务ID的最大值加1记为高水位。</strong></p><p>这个视图数组和高水位，就组成了当前事务的一致性视图（read-view）。</p><p>而数据版本的可见性规则，就是基于数据的row trx_id和这个一致性视图的对比结果得到的。</p><p>这个视图数组把所有的row trx_id 分成了几种不同的情况。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211027224047.png style=display:block;width:80% alt=NAME align=center></div><p>这样，对于当前事务的启动瞬间来说，一个数据版本的row trx_id，有以下几种可能：</p><ol><li>如果落在绿色部分，表示这个版本是已提交的事务或者是当前事务自己生成的，这个数据是可见的；</li><li>如果落在红色部分，表示这个版本是由将来启动的事务生成的，是肯定不可见的；</li><li>如果落在黄色部分，那就包括两种情况
a. 若 row trx_id在数组中，表示这个版本是由还没提交的事务生成的，不可见；
b. 若 row trx_id不在数组中，表示这个版本是已经提交了的事务生成的，可见。</li></ol><p>比如，对于图2中的数据来说，如果有一个事务，它的低水位是18，那么当它访问这一行数据时，就会从V4通过U3计算出V3，所以在它看来，这一行的值是11。</p><p>你看，有了这个声明后，系统里面随后发生的更新，是不是就跟这个事务看到的内容无关了呢？因为之后的更新，生成的版本一定属于上面的2或者3(a)的情况，而对它来说，这些新的数据版本是不存在的，所以这个事务的快照，就是“静态”的了。</p><p>所以你现在知道了，<strong>InnoDB利用了“所有数据都有多个版本”的这个特性，实现了“秒级创建快照”的能力。</strong></p><p>接下来，我们继续看一下图1中的三个事务，分析下事务A的语句返回的结果，为什么是k=1。</p><p>这里，我们不妨做如下假设：</p><ol><li>事务A开始前，系统里面只有一个活跃事务ID是99；</li><li>事务A、B、C的版本号分别是100、101、102，且当前系统里只有这四个事务；</li><li>三个事务开始前，(1,1）这一行数据的row trx_id是90。</li></ol><p>这样，事务A的视图数组就是[99,100], 事务B的视图数组是[99,100,101], 事务C的视图数组是[99,100,101,102]。</p><p>为了简化分析，我先把其他干扰语句去掉，只画出跟事务A查询逻辑有关的操作：</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211027224220.png style=display:block;width:80% alt=NAME align=center></div><p>从图中可以看到，第一个有效更新是事务C，把数据从(1,1)改成了(1,2)。这时候，这个数据的最新版本的row trx_id是102，而90这个版本已经成为了历史版本。</p><p>第二个有效更新是事务B，把数据从(1,2)改成了(1,3)。这时候，这个数据的最新版本（即row trx_id）是101，而102又成为了历史版本。</p><p>你可能注意到了，在事务A查询的时候，其实事务B还没有提交，但是它生成的(1,3)这个版本已经变成当前版本了。但这个版本对事务A必须是不可见的，否则就变成脏读了。</p><p>好，现在事务A要来读数据了，它的视图数组是[99,100]。当然了，读数据都是从当前版本读起的。所以，事务A查询语句的读数据流程是这样的：</p><ul><li>找到(1,3)的时候，判断出row trx_id=101，比高水位大，处于红色区域，不可见；</li><li>接着，找到上一个历史版本，一看row trx_id=102，比高水位大，处于红色区域，不可见；</li><li>再往前找，终于找到了（1,1)，它的row trx_id=90，比低水位小，处于绿色区域，可见。</li></ul><p>这样执行下来，虽然期间这一行数据被修改过，但是事务A不论在什么时候查询，看到这行数据的结果都是一致的，所以我们称之为一致性读。</p><p>这个判断规则是从代码逻辑直接转译过来的，但是正如你所见，用于人肉分析可见性很麻烦。</p><p>所以，我来给你翻译一下。一个数据版本，对于一个事务视图来说，除了自己的更新总是可见以外，有三种情况：</p><ol><li>版本未提交，不可见；</li><li>版本已提交，但是是在视图创建后提交的，不可见；</li><li>版本已提交，而且是在视图创建前提交的，可见。</li></ol><p>现在，我们用这个规则来判断图4中的查询结果，事务A的查询语句的视图数组是在事务A启动的时候生成的，这时候：</p><ul><li>(1,3)还没提交，属于情况1，不可见；</li><li>(1,2)虽然提交了，但是是在视图数组创建之后提交的，属于情况2，不可见；</li><li>(1,1)是在视图数组创建之前提交的，可见。</li></ul><p>你看，去掉数字对比后，只用时间先后顺序来判断，分析起来是不是轻松多了。所以，后面我们就都用这个规则来分析。</p><h2 id=更新逻辑>更新逻辑</h2><p>细心的同学可能有疑问了：<strong>事务B的update语句，如果按照一致性读，好像结果不对哦？</strong></p><p>你看图5中，事务B的视图数组是先生成的，之后事务C才提交，不是应该看不见(1,2)吗，怎么能算出(1,3)来？</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211027224244.png style=display:block;width:80% alt=NAME align=center></div><p>是的，如果事务B在更新之前查询一次数据，这个查询返回的k的值确实是1。</p><p>但是，当它要去更新数据的时候，就不能再在历史版本上更新了，否则事务C的更新就丢失了。因此，事务B此时的set k=k+1是在（1,2）的基础上进行的操作。</p><p>所以，这里就用到了这样一条规则：<strong>更新数据都是先读后写的，而这个读，只能读当前的值，称为“当前读”（current read）。</strong></p><p>因此，在更新的时候，当前读拿到的数据是(1,2)，更新后生成了新版本的数据(1,3)，这个新版本的row trx_id是101。</p><p>所以，在执行事务B查询语句的时候，一看自己的版本号是101，最新数据的版本号也是101，是自己的更新，可以直接使用，所以查询得到的k的值是3。</p><p>这里我们提到了一个概念，叫作当前读。其实，除了update语句外，select语句如果加锁，也是当前读。</p><p>所以，如果把事务A的查询语句select * from t where id=1修改一下，加上lock in share mode 或 for update，也都可以读到版本号是101的数据，返回的k的值是3。下面这两个select语句，就是分别加了读锁（S锁，共享锁）和写锁（X锁，排他锁）。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>mysql&gt; select k from t where id=1 lock in share mode;
</span></span><span style=display:flex><span>mysql&gt; select k from t where id=1 for update;
</span></span></code></pre></div><p>再往前一步，假设事务C不是马上提交的，而是变成了下面的事务C’，会怎么样呢？</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211027224257.png style=display:block;width:80% alt=NAME align=center></div><p>事务C’的不同是，更新后并没有马上提交，在它提交前，事务B的更新语句先发起了。前面说过了，虽然事务C’还没提交，但是(1,2)这个版本也已经生成了，并且是当前的最新版本。那么，事务B的更新语句会怎么处理呢？</p><p>这时候，我们在上一篇文章中提到的“两阶段锁协议”就要上场了。事务C’没提交，也就是说(1,2)这个版本上的写锁还没释放。而事务B是当前读，必须要读最新版本，而且必须加锁，因此就被锁住了，必须等到事务C’释放这个锁，才能继续它的当前读。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211027224308.png style=display:block;width:80% alt=NAME align=center></div><p>到这里，我们把一致性读、当前读和行锁就串起来了。</p><p>现在，我们再回到文章开头的问题：<strong>事务的可重复读的能力是怎么实现的？</strong></p><p>可重复读的核心就是一致性读（consistent read）；而事务更新数据的时候，只能用当前读。如果当前的记录的行锁被其他事务占用的话，就需要进入锁等待。</p><p>而读提交的逻辑和可重复读的逻辑类似，它们最主要的区别是：</p><ul><li>在可重复读隔离级别下，只需要在事务开始的时候创建一致性视图，之后事务里的其他查询都共用这个一致性视图；</li><li>在读提交隔离级别下，每一个语句执行前都会重新算出一个新的视图。</li></ul><p>那么，我们再看一下，在读提交隔离级别下，事务A和事务B的查询语句查到的k，分别应该是多少呢？</p><p>这里需要说明一下，“start transaction with consistent snapshot; ”的意思是从这个语句开始，创建一个持续整个事务的一致性快照。所以，在读提交隔离级别下，这个用法就没意义了，等效于普通的start transaction。</p><p>下面是读提交时的状态图，可以看到这两个查询语句的创建视图数组的时机发生了变化，就是图中的read view框。（注意：这里，我们用的还是事务C的逻辑直接提交，而不是事务C’）</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211027224320.png style=display:block;width:80% alt=NAME align=center></div><p>这时，事务A的查询语句的视图数组是在执行这个语句的时候创建的，时序上(1,2)、(1,3)的生成时间都在创建这个视图数组的时刻之前。但是，在这个时刻：</p><ul><li>(1,3)还没提交，属于情况1，不可见；</li><li>(1,2)提交了，属于情况3，可见。</li></ul><p>所以，这时候事务A查询语句返回的是k=2。</p><p>显然地，事务B查询结果k=3。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-b3a9aaf767396fa16fcdb3ef3e2418e2>5.9 - CH09-索引选择</h1><p>在不同的业务场景下，应该选择普通索引，还是唯一索引？</p><p>假设你在维护一个市民系统，每个人都有一个唯一的身份证号，而且业务代码已经保证了不会写入两个重复的身份证号。如果市民系统需要按照身份证号查姓名，就会执行类似这样的SQL语句：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>select name from CUser where id_card = &#39;xxxxxxxyyyyyyzzzzz&#39;;
</span></span></code></pre></div><p>所以，你一定会考虑在id_card字段上建索引。</p><p>由于身份证号字段比较大，我不建议你把身份证号当做主键，那么现在你有两个选择，要么给id_card字段创建唯一索引，要么创建一个普通索引。如果业务代码已经保证了不会写入重复的身份证号，那么这两个选择逻辑上都是正确的。</p><p>现在我要问你的是，从性能的角度考虑，你选择唯一索引还是普通索引呢？选择的依据是什么呢？</p><p>简单起见，我们还是用第4篇文章“索引-上”中的例子来说明，假设字段 k 上的值都不重复。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211027225842.png style=display:block;width:80% alt=NAME align=center></div><p>接下来，我们就从这两种索引对查询语句和更新语句的性能影响来进行分析。</p><h2 id=查询过程>查询过程</h2><p>假设，执行查询的语句是 select id from T where k=5。这个查询语句在索引树上查找的过程，先是通过B+树从树根开始，按层搜索到叶子节点，也就是图中右下角的这个数据页，然后可以认为数据页内部通过二分法来定位记录。</p><ul><li>对于普通索引来说，查找到满足条件的第一个记录(5,500)后，需要查找下一个记录，直到碰到第一个不满足k=5条件的记录。</li><li>对于唯一索引来说，由于索引定义了唯一性，查找到第一个满足条件的记录后，就会停止继续检索。</li></ul><p>那么，这个不同带来的性能差距会有多少呢？答案是，微乎其微。</p><p>你知道的，InnoDB的数据是按数据页为单位来读写的。也就是说，当需要读一条记录的时候，并不是将这个记录本身从磁盘读出来，而是以页为单位，将其整体读入内存。在InnoDB中，每个数据页的大小默认是16KB。</p><p>因为引擎是按页读写的，所以说，当找到k=5的记录的时候，它所在的数据页就都在内存里了。那么，对于普通索引来说，要多做的那一次“查找和判断下一条记录”的操作，就只需要一次指针寻找和一次计算。</p><p>当然，如果k=5这个记录刚好是这个数据页的最后一个记录，那么要取下一个记录，必须读取下一个数据页，这个操作会稍微复杂一些。</p><p>但是，我们之前计算过，对于整型字段，一个数据页可以放近千个key，因此出现这种情况的概率会很低。所以，我们计算平均性能差异时，仍可以认为这个操作成本对于现在的CPU来说可以忽略不计。</p><h2 id=更新过程>更新过程</h2><p>为了说明普通索引和唯一索引对更新语句性能的影响这个问题，我需要先跟你介绍一下change buffer。</p><p>当需要更新一个数据页时，如果数据页在内存中就直接更新，而如果这个数据页还没有在内存中的话，在不影响数据一致性的前提下，InooDB会将这些更新操作缓存在change buffer中，这样就不需要从磁盘中读入这个数据页了。在下次查询需要访问这个数据页的时候，将数据页读入内存，然后执行change buffer中与这个页有关的操作。通过这种方式就能保证这个数据逻辑的正确性。</p><p>需要说明的是，虽然名字叫作change buffer，实际上它是可以持久化的数据。也就是说，change buffer在内存中有拷贝，也会被写入到磁盘上。</p><p>将change buffer中的操作应用到原数据页，得到最新结果的过程称为merge。除了访问这个数据页会触发merge外，系统有后台线程会定期merge。在数据库正常关闭（shutdown）的过程中，也会执行merge操作。</p><p>显然，如果能够将更新操作先记录在change buffer，减少读磁盘，语句的执行速度会得到明显的提升。而且，数据读入内存是需要占用buffer pool的，所以这种方式还能够避免占用内存，提高内存利用率。</p><p>那么，<strong>什么条件下可以使用change buffer呢？</strong></p><p>对于唯一索引来说，所有的更新操作都要先判断这个操作是否违反唯一性约束。比如，要插入(4,400)这个记录，就要先判断现在表中是否已经存在k=4的记录，而这必须要将数据页读入内存才能判断。如果都已经读入到内存了，那直接更新内存会更快，就没必要使用change buffer了。</p><p>因此，唯一索引的更新就不能使用change buffer，实际上也只有普通索引可以使用。</p><p>change buffer用的是buffer pool里的内存，因此不能无限增大。change buffer的大小，可以通过参数innodb_change_buffer_max_size来动态设置。这个参数设置为50的时候，表示change buffer的大小最多只能占用buffer pool的50%。</p><p>现在，你已经理解了change buffer的机制，那么我们再一起来看看<strong>如果要在这张表中插入一个新记录(4,400)的话，InnoDB的处理流程是怎样的。</strong></p><p>第一种情况是，<strong>这个记录要更新的目标页在内存中</strong>。这时，InnoDB的处理流程如下：</p><ul><li>对于唯一索引来说，找到3和5之间的位置，判断到没有冲突，插入这个值，语句执行结束；</li><li>对于普通索引来说，找到3和5之间的位置，插入这个值，语句执行结束。</li></ul><p>这样看来，普通索引和唯一索引对更新语句性能影响的差别，只是一个判断，只会耗费微小的CPU时间。</p><p>但，这不是我们关注的重点。</p><p>第二种情况是，<strong>这个记录要更新的目标页不在内存中</strong>。这时，InnoDB的处理流程如下：</p><ul><li>对于唯一索引来说，需要将数据页读入内存，判断到没有冲突，插入这个值，语句执行结束；</li><li>对于普通索引来说，则是将更新记录在change buffer，语句执行就结束了。</li></ul><p>将数据从磁盘读入内存涉及随机IO的访问，是数据库里面成本最高的操作之一。change buffer因为减少了随机磁盘访问，所以对更新性能的提升是会很明显的。</p><p>之前我就碰到过一件事儿，有个DBA的同学跟我反馈说，他负责的某个业务的库内存命中率突然从99%降低到了75%，整个系统处于阻塞状态，更新语句全部堵住。而探究其原因后，我发现这个业务有大量插入数据的操作，而他在前一天把其中的某个普通索引改成了唯一索引。</p><h2 id=change-buffer的使用场景>change buffer的使用场景</h2><p>通过上面的分析，你已经清楚了使用change buffer对更新过程的加速作用，也清楚了change buffer只限于用在普通索引的场景下，而不适用于唯一索引。那么，现在有一个问题就是：普通索引的所有场景，使用change buffer都可以起到加速作用吗？</p><p>因为merge的时候是真正进行数据更新的时刻，而change buffer的主要目的就是将记录的变更动作缓存下来，所以在一个数据页做merge之前，change buffer记录的变更越多（也就是这个页面上要更新的次数越多），收益就越大。</p><p>因此，对于写多读少的业务来说，页面在写完以后马上被访问到的概率比较小，此时change buffer的使用效果最好。这种业务模型常见的就是账单类、日志类的系统。</p><p>反过来，假设一个业务的更新模式是写入之后马上会做查询，那么即使满足了条件，将更新先记录在change buffer，但之后由于马上要访问这个数据页，会立即触发merge过程。这样随机访问IO的次数不会减少，反而增加了change buffer的维护代价。所以，对于这种业务模式来说，change buffer反而起到了副作用。</p><h2 id=索引选择和实践>索引选择和实践</h2><p>回到我们文章开头的问题，普通索引和唯一索引应该怎么选择。其实，这两类索引在查询能力上是没差别的，主要考虑的是对更新性能的影响。所以，我建议你尽量选择普通索引。</p><p>如果所有的更新后面，都马上伴随着对这个记录的查询，那么你应该关闭change buffer。而在其他情况下，change buffer都能提升更新性能。</p><p>在实际使用中，你会发现，普通索引和change buffer的配合使用，对于数据量大的表的更新优化还是很明显的。</p><p>特别地，在使用机械硬盘时，change buffer这个机制的收效是非常显著的。所以，当你有一个类似“历史数据”的库，并且出于成本考虑用的是机械硬盘时，那你应该特别关注这些表里的索引，尽量使用普通索引，然后把change buffer 尽量开大，以确保这个“历史数据”表的数据写入速度。</p><h1 id=change-buffer-和-redo-log>change buffer 和 redo log</h1><p>理解了change buffer的原理，你可能会联想到我在前面文章中和你介绍过的redo log和WAL。</p><p>在前面文章的评论中，我发现有同学混淆了redo log和change buffer。WAL 提升性能的核心机制，也的确是尽量减少随机读写，这两个概念确实容易混淆。所以，这里我把它们放到了同一个流程里来说明，便于你区分这两个概念。</p><blockquote><p>备注：这里，你可以再回顾下第2篇文章《日志系统》中的相关内容。</p></blockquote><p>现在，我们要在表上执行这个插入语句：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>mysql&gt; insert into t(id,k) values(id1,k1),(id2,k2);
</span></span></code></pre></div><p>这里，我们假设当前k索引树的状态，查找到位置后，k1所在的数据页在内存(InnoDB buffer pool)中，k2所在的数据页不在内存中。如图2所示是带change buffer的更新状态图。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211027230531.png style=display:block;width:80% alt=NAME align=center></div><p>分析这条更新语句，你会发现它涉及了四个部分：内存、redo log（ib_log_fileX）、 数据表空间（t.ibd）、系统表空间（ibdata1）。</p><blockquote><p>系统表空间用来放系统信息，比如数据字典，对应的磁盘文件是ibdata1,
数据表空间就是一个个的表数据文件，对应的磁盘文件就是 表名.ibd</p></blockquote><p>这条更新语句做了如下的操作（按照图中的数字顺序）：</p><ol><li>Page 1在内存中，直接更新内存；</li><li>Page 2没有在内存中，就在内存的change buffer区域，记录下“我要往Page 2插入一行”这个信息</li><li>将上述两个动作记入redo log中（图中3和4）。</li></ol><p>做完上面这些，事务就可以完成了。所以，你会看到，执行这条更新语句的成本很低，就是写了两处内存，然后写了一处磁盘（两次操作合在一起写了一次磁盘），而且还是顺序写的。</p><p>同时，图中的两个虚线箭头，是后台操作，不影响更新的响应时间。</p><p>那在这之后的读请求，要怎么处理呢？</p><p>比如，我们现在要执行 select * from t where k in (k1, k2)。这里，我画了这两个读请求的流程图。</p><p>如果读语句发生在更新语句后不久，内存中的数据都还在，那么此时的这两个读操作就与系统表空间（ibdata1）和 redo log（ib_log_fileX）无关了。所以，我在图中就没画出这两部分。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211027230605.png style=display:block;width:80% alt=NAME align=center></div><p>从图中可以看到：</p><ol><li>读Page 1的时候，直接从内存返回。有几位同学在前面文章的评论中问到，WAL之后如果读数据，是不是一定要读盘，是不是一定要从redo log里面把数据更新以后才可以返回？其实是不用的。你可以看一下图3的这个状态，虽然磁盘上还是之前的数据，但是这里直接从内存返回结果，结果是正确的。</li><li>要读Page 2的时候，需要把Page 2从磁盘读入内存中，然后应用change buffer里面的操作日志，生成一个正确的版本并返回结果。</li></ol><p>可以看到，直到需要读Page 2的时候，这个数据页才会被读入内存。</p><p>所以，如果要简单地对比这两个机制在提升更新性能上的收益的话，<strong>redo log 主要节省的是随机写磁盘的IO消耗（转成顺序写），而change buffer主要节省的则是随机读磁盘的IO消耗。</strong></p></div><div class=td-content style=page-break-before:always><h1 id=pg-f15574a70dd70677547f9af779af61e7>5.10 - CH10-优化器</h1><p>前面我们介绍过索引，你已经知道了在MySQL中一张表其实是可以支持多个索引的。但是，你写SQL语句的时候，并没有主动指定使用哪个索引。也就是说，使用哪个索引是由MySQL来确定的。</p><p>不知道你有没有碰到过这种情况，一条本来可以执行得很快的语句，却由于MySQL选错了索引，而导致执行速度变得很慢？</p><p>我们一起来看一个例子吧。</p><p>我们先建一个简单的表，表里有a、b两个字段，并分别建上索引：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span><span style=color:#204a87;font-weight:700>CREATE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>TABLE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>t</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>(</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>id</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>int</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>11</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>NOT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>NULL</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>a</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>int</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>11</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>DEFAULT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>NULL</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>b</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>int</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>11</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>DEFAULT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>NULL</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>PRIMARY</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>KEY</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>(</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>id</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000;font-weight:700>),</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>KEY</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>a</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>(</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>a</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000;font-weight:700>),</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>KEY</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>b</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>(</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>b</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>ENGINE</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#000>InnoDB</span><span style=color:#a40000>；</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><p>然后，我们往表t中插入10万行记录，取值按整数递增，即：(1,1,1)，(2,2,2)，(3,3,3) 直到(100000,100000,100000)。</p><p>我是用存储过程来插入数据的，这里我贴出来方便你复现：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>delimiter ;;
</span></span><span style=display:flex><span>create procedure idata()
</span></span><span style=display:flex><span>begin
</span></span><span style=display:flex><span>  declare i int;
</span></span><span style=display:flex><span>  set i=1;
</span></span><span style=display:flex><span>  while(i&lt;=100000)do
</span></span><span style=display:flex><span>    insert into t values(i, i, i);
</span></span><span style=display:flex><span>    set i=i+1;
</span></span><span style=display:flex><span>  end while;
</span></span><span style=display:flex><span>end;;
</span></span><span style=display:flex><span>delimiter ;
</span></span><span style=display:flex><span>call idata();
</span></span></code></pre></div><p>接下来，我们分析一条SQL语句：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>mysql&gt; select * from t where a between 10000 and 20000;
</span></span></code></pre></div><p>你一定会说，这个语句还用分析吗，很简单呀，a上有索引，肯定是要使用索引a的。</p><p>你说得没错，图1显示的就是使用explain命令看到的这条语句的执行情况。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211027231729.png style=display:block;width:80% alt=NAME align=center></div><p>从图1看上去，这条查询语句的执行也确实符合预期，key这个字段值是’a’，表示优化器选择了索引a。</p><p>不过别急，这个案例不会这么简单。在我们已经准备好的包含了10万行数据的表上，我们再做如下操作。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211027231740.png style=display:block;width:80% alt=NAME align=center></div><p>这里，session A的操作你已经很熟悉了，它就是开启了一个事务。随后，session B把数据都删除后，又调用了 idata这个存储过程，插入了10万行数据。</p><p>这时候，session B的查询语句select * from t where a between 10000 and 20000就不会再选择索引a了。我们可以通过慢查询日志（slow log）来查看一下具体的执行情况。</p><p>为了说明优化器选择的结果是否正确，我增加了一个对照，即：使用force index(a)来让优化器强制使用索引a（这部分内容，我还会在这篇文章的后半部分中提到）。</p><p>下面的三条SQL语句，就是这个实验过程。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>set long_query_time=0;
</span></span><span style=display:flex><span>select * from t where a between 10000 and 20000; /*Q1*/
</span></span><span style=display:flex><span>select * from t force index(a) where a between 10000 and 20000;/*Q2*/
</span></span></code></pre></div><ul><li>第一句，是将慢查询日志的阈值设置为0，表示这个线程接下来的语句都会被记录入慢查询日志中；</li><li>第二句，Q1是session B原来的查询；</li><li>第三句，Q2是加了force index(a)来和session B原来的查询语句执行情况对比。</li></ul><p>如图3所示是这三条SQL语句执行完成后的慢查询日志。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211027231751.png style=display:block;width:80% alt=NAME align=center></div><p>可以看到，Q1扫描了10万行，显然是走了全表扫描，执行时间是40毫秒。Q2扫描了10001行，执行了21毫秒。也就是说，我们在没有使用force index的时候，MySQL用错了索引，导致了更长的执行时间。</p><p>这个例子对应的是我们平常不断地删除历史数据和新增数据的场景。这时，MySQL竟然会选错索引，是不是有点奇怪呢？今天，我们就从这个奇怪的结果说起吧。</p><h2 id=优化器的逻辑>优化器的逻辑</h2><p>在第一篇文章中，我们就提到过，选择索引是优化器的工作。</p><p>而优化器选择索引的目的，是找到一个最优的执行方案，并用最小的代价去执行语句。在数据库里面，扫描行数是影响执行代价的因素之一。扫描的行数越少，意味着访问磁盘数据的次数越少，消耗的CPU资源越少。</p><p>当然，扫描行数并不是唯一的判断标准，优化器还会结合是否使用临时表、是否排序等因素进行综合判断。</p><p>我们这个简单的查询语句并没有涉及到临时表和排序，所以MySQL选错索引肯定是在判断扫描行数的时候出问题了。</p><p>那么，问题就是：<strong>扫描行数是怎么判断的？</strong></p><p>MySQL在真正开始执行语句之前，并不能精确地知道满足这个条件的记录有多少条，而只能根据统计信息来估算记录数。</p><p>这个统计信息就是索引的“区分度”。显然，一个索引上不同的值越多，这个索引的区分度就越好。而一个索引上不同的值的个数，我们称之为“基数”（cardinality）。也就是说，这个基数越大，索引的区分度越好。</p><p>我们可以使用show index方法，看到一个索引的基数。如图4所示，就是表t的show index 的结果 。虽然这个表的每一行的三个字段值都是一样的，但是在统计信息中，这三个索引的基数值并不同，而且其实都不准确。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211027231812.png style=display:block;width:80% alt=NAME align=center></div><p>那么，**MySQL是怎样得到索引的基数的呢？**这里，我给你简单介绍一下MySQL采样统计的方法。</p><p>为什么要采样统计呢？因为把整张表取出来一行行统计，虽然可以得到精确的结果，但是代价太高了，所以只能选择“采样统计”。</p><p>采样统计的时候，InnoDB默认会选择N个数据页，统计这些页面上的不同值，得到一个平均值，然后乘以这个索引的页面数，就得到了这个索引的基数。</p><p>而数据表是会持续更新的，索引统计信息也不会固定不变。所以，当变更的数据行数超过1/M的时候，会自动触发重新做一次索引统计。</p><p>在MySQL中，有两种存储索引统计的方式，可以通过设置参数innodb_stats_persistent的值来选择：</p><ul><li>设置为on的时候，表示统计信息会持久化存储。这时，默认的N是20，M是10。</li><li>设置为off的时候，表示统计信息只存储在内存中。这时，默认的N是8，M是16。</li></ul><p>由于是采样统计，所以不管N是20还是8，这个基数都是很容易不准的。</p><p>但，这还不是全部。</p><p>你可以从图4中看到，这次的索引统计值（cardinality列）虽然不够精确，但大体上还是差不多的，选错索引一定还有别的原因。</p><p>其实索引统计只是一个输入，对于一个具体的语句来说，优化器还要判断，执行这个语句本身要扫描多少行。</p><p>接下来，我们再一起看看优化器预估的，这两个语句的扫描行数是多少。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211027231823.png style=display:block;width:80% alt=NAME align=center></div><p>rows这个字段表示的是预计扫描行数。</p><p>其中，Q1的结果还是符合预期的，rows的值是104620；但是Q2的rows值是37116，偏差就大了。而图1中我们用explain命令看到的rows是只有10001行，是这个偏差误导了优化器的判断。</p><p>到这里，可能你的第一个疑问不是为什么不准，而是优化器为什么放着扫描37000行的执行计划不用，却选择了扫描行数是100000的执行计划呢？</p><p>这是因为，如果使用索引a，每次从索引a上拿到一个值，都要回到主键索引上查出整行数据，这个代价优化器也要算进去的。</p><p>而如果选择扫描10万行，是直接在主键索引上扫描的，没有额外的代价。</p><p>优化器会估算这两个选择的代价，从结果看来，优化器认为直接扫描主键索引更快。当然，从执行时间看来，这个选择并不是最优的。</p><p>使用普通索引需要把回表的代价算进去，在图1执行explain的时候，也考虑了这个策略的代价 ，但图1的选择是对的。也就是说，这个策略并没有问题。</p><p>所以冤有头债有主，MySQL选错索引，这件事儿还得归咎到没能准确地判断出扫描行数。至于为什么会得到错误的扫描行数，这个原因就作为课后问题，留给你去分析了。</p><p>既然是统计信息不对，那就修正。analyze table t 命令，可以用来重新统计索引信息。我们来看一下执行效果。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211027231835.png style=display:block;width:80% alt=NAME align=center></div><p>这回对了。</p><p>所以在实践中，如果你发现explain的结果预估的rows值跟实际情况差距比较大，可以采用这个方法来处理。</p><p>其实，如果只是索引统计不准确，通过analyze命令可以解决很多问题，但是前面我们说了，优化器可不止是看扫描行数。</p><p>依然是基于这个表t，我们看看另外一个语句：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>mysql&gt; select * from t where (a between 1 and 1000)  and (b between 50000 and 100000) order by b limit 1;
</span></span></code></pre></div><p>从条件上看，这个查询没有符合条件的记录，因此会返回空集合。</p><p>在开始执行这条语句之前，你可以先设想一下，如果你来选择索引，会选择哪一个呢？</p><p>为了便于分析，我们先来看一下a、b这两个索引的结构图。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211027231848.png style=display:block;width:80% alt=NAME align=center></div><p>如果使用索引a进行查询，那么就是扫描索引a的前1000个值，然后取到对应的id，再到主键索引上去查出每一行，然后根据字段b来过滤。显然这样需要扫描1000行。</p><p>如果使用索引b进行查询，那么就是扫描索引b的最后50001个值，与上面的执行过程相同，也是需要回到主键索引上取值再判断，所以需要扫描50001行。</p><p>所以你一定会想，如果使用索引a的话，执行速度明显会快很多。那么，下面我们就来看看到底是不是这么一回事儿。</p><p>图8是执行explain的结果。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>mysql&gt; explain select * from t where (a between 1 and 1000) and (b between 50000 and 100000) order by b limit 1;
</span></span></code></pre></div><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211027231858.png style=display:block;width:80% alt=NAME align=center></div><p>可以看到，返回结果中key字段显示，这次优化器选择了索引b，而rows字段显示需要扫描的行数是50198。</p><p>从这个结果中，你可以得到两个结论：</p><ol><li>扫描行数的估计值依然不准确；</li><li>这个例子里MySQL又选错了索引。</li></ol><h2 id=索引选择异常和处理>索引选择异常和处理</h2><p>其实大多数时候优化器都能找到正确的索引，但偶尔你还是会碰到我们上面举例的这两种情况：原本可以执行得很快的SQL语句，执行速度却比你预期的慢很多，你应该怎么办呢？</p><p>**一种方法是，像我们第一个例子一样，采用force index强行选择一个索引。**MySQL会根据词法解析的结果分析出可能可以使用的索引作为候选项，然后在候选列表中依次判断每个索引需要扫描多少行。如果force index指定的索引在候选索引列表中，就直接选择这个索引，不再评估其他索引的执行代价。</p><p>我们来看看第二个例子。刚开始分析时，我们认为选择索引a会更好。现在，我们就来看看执行效果：</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211027231920.png style=display:block;width:80% alt=NAME align=center></div><p>可以看到，原本语句需要执行2.23秒，而当你使用force index(a)的时候，只用了0.05秒，比优化器的选择快了40多倍。</p><p>也就是说，优化器没有选择正确的索引，force index起到了“矫正”的作用。</p><p>不过很多程序员不喜欢使用force index，一来这么写不优美，二来如果索引改了名字，这个语句也得改，显得很麻烦。而且如果以后迁移到别的数据库的话，这个语法还可能会不兼容。</p><p>但其实使用force index最主要的问题还是变更的及时性。因为选错索引的情况还是比较少出现的，所以开发的时候通常不会先写上force index。而是等到线上出现问题的时候，你才会再去修改SQL语句、加上force index。但是修改之后还要测试和发布，对于生产系统来说，这个过程不够敏捷。</p><p>所以，数据库的问题最好还是在数据库内部来解决。那么，在数据库里面该怎样解决呢？</p><p>既然优化器放弃了使用索引a，说明a还不够合适，所以**第二种方法就是，我们可以考虑修改语句，引导MySQL使用我们期望的索引。**比如，在这个例子里，显然把“order by b limit 1” 改成 “order by b,a limit 1” ，语义的逻辑是相同的。</p><p>我们来看看改之后的效果：</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211027231932.png style=display:block;width:80% alt=NAME align=center></div><p>之前优化器选择使用索引b，是因为它认为使用索引b可以避免排序（b本身是索引，已经是有序的了，如果选择索引b的话，不需要再做排序，只需要遍历），所以即使扫描行数多，也判定为代价更小。</p><p>现在order by b,a 这种写法，要求按照b,a排序，就意味着使用这两个索引都需要排序。因此，扫描行数成了影响决策的主要条件，于是此时优化器选了只需要扫描1000行的索引a。</p><p>当然，这种修改并不是通用的优化手段，只是刚好在这个语句里面有limit 1，因此如果有满足条件的记录， order by b limit 1和order by b,a limit 1 都会返回b是最小的那一行，逻辑上一致，才可以这么做。</p><p>如果你觉得修改语义这件事儿不太好，这里还有一种改法，图11是执行效果。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>mysql&gt; select * from  (select * from t where (a between 1 and 1000)  and (b between 50000 and 100000) order by b limit 100)alias limit 1;
</span></span></code></pre></div><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211027231946.png style=display:block;width:80% alt=NAME align=center></div><p>在这个例子里，我们用limit 100让优化器意识到，使用b索引代价是很高的。其实是我们根据数据特征诱导了一下优化器，也不具备通用性。</p><p><strong>第三种方法是，在有些场景下，我们可以新建一个更合适的索引，来提供给优化器做选择，或删掉误用的索引。</strong></p><p>不过，在这个例子中，我没有找到通过新增索引来改变优化器行为的方法。这种情况其实比较少，尤其是经过DBA索引优化过的库，再碰到这个bug，找到一个更合适的索引一般比较难。</p><p>如果我说还有一个方法是删掉索引b，你可能会觉得好笑。但实际上我碰到过两次这样的例子，最终是DBA跟业务开发沟通后，发现这个优化器错误选择的索引其实根本没有必要存在，于是就删掉了这个索引，优化器也就重新选择到了正确的索引。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-b5f4fe77f26d63013e450536e7f82498>5.11 - CH11-字符串索引</h1><h2 id=前缀索引>前缀索引</h2><p>假设，你现在维护一个支持邮箱登录的系统，用户表是这么定义的：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>mysql&gt; create table SUser(
</span></span><span style=display:flex><span>ID bigint unsigned primary key,
</span></span><span style=display:flex><span>email varchar(64), 
</span></span><span style=display:flex><span>... 
</span></span><span style=display:flex><span>)engine=innodb; 
</span></span></code></pre></div><p>由于要使用邮箱登录，所以业务代码中一定会出现类似于这样的语句：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>mysql&gt; select f1, f2 from SUser where email=&#39;xxx&#39;;
</span></span></code></pre></div><p>从第4和第5篇讲解索引的文章中，我们可以知道，如果email这个字段上没有索引，那么这个语句就只能做全表扫描。</p><p>同时，MySQL是支持前缀索引的，也就是说，你可以定义字符串的一部分作为索引。默认地，如果你创建索引的语句不指定前缀长度，那么索引就会包含整个字符串。</p><p>比如，这两个在email字段上创建索引的语句：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>mysql&gt; alter table SUser add index index1(email);
</span></span><span style=display:flex><span>或
</span></span><span style=display:flex><span>mysql&gt; alter table SUser add index index2(email(6));
</span></span></code></pre></div><p>第一个语句创建的index1索引里面，包含了每个记录的整个字符串；而第二个语句创建的index2索引里面，对于每个记录都是只取前6个字节。</p><p>那么，这两种不同的定义在数据结构和存储上有什么区别呢？如图2和3所示，就是这两个索引的示意图。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211103213607.png style=display:block;width:80% alt=NAME align=center></div><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211103213614.png style=display:block;width:80% alt=NAME align=center></div><p>从图中你可以看到，由于email(6)这个索引结构中每个邮箱字段都只取前6个字节（即：zhangs），所以占用的空间会更小，这就是使用前缀索引的优势。</p><p>但，这同时带来的损失是，可能会增加额外的记录扫描次数。</p><p>接下来，我们再看看下面这个语句，在这两个索引定义下分别是怎么执行的。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>select id,name,email from SUser where email=&#39;zhangssxyz@xxx.com&#39;;
</span></span></code></pre></div><p><strong>如果使用的是index1</strong>（即email整个字符串的索引结构），执行顺序是这样的：</p><ol><li>从index1索引树找到满足索引值是’zhangssxyz@xxx.com’的这条记录，取得ID2的值；</li><li>到主键上查到主键值是ID2的行，判断email的值是正确的，将这行记录加入结果集；</li><li>取index1索引树上刚刚查到的位置的下一条记录，发现已经不满足email=&lsquo;<a href=mailto:zhangssxyz@xxx.com>zhangssxyz@xxx.com</a>’的条件了，循环结束。</li></ol><p>这个过程中，只需要回主键索引取一次数据，所以系统认为只扫描了一行。</p><p><strong>如果使用的是index2</strong>（即email(6)索引结构），执行顺序是这样的：</p><ol><li>从index2索引树找到满足索引值是’zhangs’的记录，找到的第一个是ID1；</li><li>到主键上查到主键值是ID1的行，判断出email的值不是’zhangssxyz@xxx.com’，这行记录丢弃；</li><li>取index2上刚刚查到的位置的下一条记录，发现仍然是’zhangs’，取出ID2，再到ID索引上取整行然后判断，这次值对了，将这行记录加入结果集；</li><li>重复上一步，直到在idxe2上取到的值不是’zhangs’时，循环结束。</li></ol><p>在这个过程中，要回主键索引取4次数据，也就是扫描了4行。</p><p>通过这个对比，你很容易就可以发现，使用前缀索引后，可能会导致查询语句读数据的次数变多。</p><p>但是，对于这个查询语句来说，如果你定义的index2不是email(6)而是email(7），也就是说取email字段的前7个字节来构建索引的话，即满足前缀’zhangss’的记录只有一个，也能够直接查到ID2，只扫描一行就结束了。</p><p>也就是说<strong>使用前缀索引，定义好长度，就可以做到既节省空间，又不用额外增加太多的查询成本。</strong></p><p>于是，你就有个问题：当要给字符串创建前缀索引时，有什么方法能够确定我应该使用多长的前缀呢？</p><p>实际上，我们在建立索引时关注的是区分度，区分度越高越好。因为区分度越高，意味着重复的键值越少。因此，我们可以通过统计索引上有多少个不同的值来判断要使用多长的前缀。</p><p>首先，你可以使用下面这个语句，算出这个列上有多少个不同的值：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>mysql&gt; select count(distinct email) as L from SUser;
</span></span></code></pre></div><p>然后，依次选取不同长度的前缀来看这个值，比如我们要看一下4~7个字节的前缀索引，可以用这个语句：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>mysql&gt; select 
</span></span><span style=display:flex><span>  count(distinct left(email,4)）as L4,
</span></span><span style=display:flex><span>  count(distinct left(email,5)）as L5,
</span></span><span style=display:flex><span>  count(distinct left(email,6)）as L6,
</span></span><span style=display:flex><span>  count(distinct left(email,7)）as L7,
</span></span><span style=display:flex><span>from SUser;
</span></span></code></pre></div><p>当然，使用前缀索引很可能会损失区分度，所以你需要预先设定一个可以接受的损失比例，比如5%。然后，在返回的L4~L7中，找出不小于 L * 95%的值，假设这里L6、L7都满足，你就可以选择前缀长度为6。</p><h2 id=前缀索引对覆盖索引的影响>前缀索引对覆盖索引的影响</h2><p>前面我们说了使用前缀索引可能会增加扫描行数，这会影响到性能。其实，前缀索引的影响不止如此，我们再看一下另外一个场景。</p><p>你先来看看这个SQL语句：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>select id,email from SUser where email=&#39;zhangssxyz@xxx.com&#39;;
</span></span></code></pre></div><p>与前面例子中的SQL语句</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>select id,name,email from SUser where email=&#39;zhangssxyz@xxx.com&#39;;
</span></span></code></pre></div><p>相比，这个语句只要求返回id和email字段。</p><p>所以，如果使用index1（即email整个字符串的索引结构）的话，可以利用覆盖索引，从index1查到结果后直接就返回了，不需要回到ID索引再去查一次。而如果使用index2（即email(6)索引结构）的话，就不得不回到ID索引再去判断email字段的值。</p><p>即使你将index2的定义修改为email(18)的前缀索引，这时候虽然index2已经包含了所有的信息，但InnoDB还是要回到id索引再查一下，因为系统并不确定前缀索引的定义是否截断了完整信息。</p><p>也就是说，使用前缀索引就用不上覆盖索引对查询性能的优化了，这也是你在选择是否使用前缀索引时需要考虑的一个因素。</p><h2 id=其他方式>其他方式</h2><p>对于类似于邮箱这样的字段来说，使用前缀索引的效果可能还不错。但是，遇到前缀的区分度不够好的情况时，我们要怎么办呢？</p><p>比如，我们国家的身份证号，一共18位，其中前6位是地址码，所以同一个县的人的身份证号前6位一般会是相同的。</p><p>假设你维护的数据库是一个市的公民信息系统，这时候如果对身份证号做长度为6的前缀索引的话，这个索引的区分度就非常低了。</p><p>按照我们前面说的方法，可能你需要创建长度为12以上的前缀索引，才能够满足区分度要求。</p><p>但是，索引选取的越长，占用的磁盘空间就越大，相同的数据页能放下的索引值就越少，搜索的效率也就会越低。</p><p>那么，如果我们能够确定业务需求里面只有按照身份证进行等值查询的需求，还有没有别的处理方法呢？这种方法，既可以占用更小的空间，也能达到相同的查询效率。</p><p>答案是，有的。</p><h3 id=倒序存储>倒序存储</h3><p>如果你存储身份证号的时候把它倒过来存，每次查询的时候，你可以这么写：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>mysql&gt; select field_list from t where id_card = reverse(&#39;input_id_card_string&#39;);
</span></span></code></pre></div><p>由于身份证号的最后6位没有地址码这样的重复逻辑，所以最后这6位很可能就提供了足够的区分度。当然了，实践中你不要忘记使用count(distinct)方法去做个验证。</p><h3 id=使用-hash-字段>使用 hash 字段</h3><p>你可以在表上再创建一个整数字段，来保存身份证的校验码，同时在这个字段上创建索引。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>mysql&gt; alter table t add id_card_crc int unsigned, add index(id_card_crc);
</span></span></code></pre></div><p>然后每次插入新记录的时候，都同时用crc32()这个函数得到校验码填到这个新字段。由于校验码可能存在冲突，也就是说两个不同的身份证号通过crc32()函数得到的结果可能是相同的，所以你的查询语句where部分要判断id_card的值是否精确相同。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>mysql&gt; select field_list from t where id_card_crc=crc32(&#39;input_id_card_string&#39;) and id_card=&#39;input_id_card_string&#39;
</span></span></code></pre></div><p>这样，索引的长度变成了4个字节，比原来小了很多。</p><p>接下来，我们再一起看看<strong>使用倒序存储和使用hash字段这两种方法的异同点。</strong></p><p>首先，它们的相同点是，都不支持范围查询。倒序存储的字段上创建的索引是按照倒序字符串的方式排序的，已经没有办法利用索引方式查出身份证号码在[ID_X, ID_Y]的所有市民了。同样地，hash字段的方式也只能支持等值查询。</p><p>它们的区别，主要体现在以下三个方面：</p><ol><li>从占用的额外空间来看，倒序存储方式在主键索引上，不会消耗额外的存储空间，而hash字段方法需要增加一个字段。当然，倒序存储方式使用4个字节的前缀长度应该是不够的，如果再长一点，这个消耗跟额外这个hash字段也差不多抵消了。</li><li>在CPU消耗方面，倒序方式每次写和读的时候，都需要额外调用一次reverse函数，而hash字段的方式需要额外调用一次crc32()函数。如果只从这两个函数的计算复杂度来看的话，reverse函数额外消耗的CPU资源会更小些。</li><li>从查询效率上看，使用hash字段方式的查询性能相对更稳定一些。因为crc32算出来的值虽然有冲突的概率，但是概率非常小，可以认为每次查询的平均扫描行数接近1。而倒序存储方式毕竟还是用的前缀索引的方式，也就是说还是会增加扫描行数。</li></ol></div><div class=td-content style=page-break-before:always><h1 id=pg-dde8ff71211369b0042c90065fcda5a8>5.12 - CH12-刷脏页</h1><h2 id=内存--磁盘>内存 => 磁盘</h2><p>在前面第2篇文章“日志系统”中，我为你介绍了WAL机制。现在你知道了，InnoDB在处理更新语句的时候，只做了写日志这一个磁盘操作。这个日志叫作redo log（重做日志），也就是《孔乙己》里咸亨酒店掌柜用来记账的粉板，在更新内存写完redo log后，就返回给客户端，本次更新成功。</p><p>做下类比的话，掌柜记账的账本是数据文件，记账用的粉板是日志文件（redo log），掌柜的记忆就是内存。</p><p>掌柜总要找时间把账本更新一下，这对应的就是把内存里的数据写入磁盘的过程，术语就是flush。在这个flush操作执行之前，孔乙己的赊账总额，其实跟掌柜手中账本里面的记录是不一致的。因为孔乙己今天的赊账金额还只在粉板上，而账本里的记录是老的，还没把今天的赊账算进去。</p><p><strong>当内存数据页跟磁盘数据页内容不一致的时候，我们称这个内存页为“脏页”。内存数据写入到磁盘后，内存和磁盘上的数据页的内容就一致了，称为“干净页”</strong>。</p><p>不论是脏页还是干净页，都在内存中。在这个例子里，内存对应的就是掌柜的记忆。</p><p>接下来，我们用一个示意图来展示一下“孔乙己赊账”的整个操作过程。假设原来孔乙己欠账10文，这次又要赊9文。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211103214834.png style=display:block;width:80% alt=NAME align=center></div><p>回到文章开头的问题，你不难想象，平时执行很快的更新操作，其实就是在写内存和日志，而MySQL偶尔“抖”一下的那个瞬间，可能就是在刷脏页（flush）。</p><p>那么，什么情况会引发数据库的flush过程呢？</p><p>我们还是继续用咸亨酒店掌柜的这个例子，想一想：掌柜在什么情况下会把粉板上的赊账记录改到账本上？</p><h3 id=1-redo-log-过多>1. redo log 过多</h3><p>第一种场景是，粉板满了，记不下了。这时候如果再有人来赊账，掌柜就只得放下手里的活儿，将粉板上的记录擦掉一些，留出空位以便继续记账。当然在擦掉之前，他必须先将正确的账目记录到账本中才行。
这个场景，对应的就是InnoDB的redo log写满了。这时候系统会停止所有更新操作，把checkpoint往前推进，redo log留出空间可以继续写。我在第二讲画了一个redo log的示意图，这里我改成环形，便于大家理解。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211103214911.png style=display:block;width:80% alt=NAME align=center></div><p>checkpoint可不是随便往前修改一下位置就可以的。比如图2中，把checkpoint位置从CP推进到CP’，就需要将两个点之间的日志（浅绿色部分），对应的所有脏页都flush到磁盘上。之后，图中从write pos到CP’之间就是可以再写入的redo log的区域。</p><h3 id=2-内存不足>2. 内存不足</h3><p>第二种场景是，这一天生意太好，要记住的事情太多，掌柜发现自己快记不住了，赶紧找出账本把孔乙己这笔账先加进去。
这种场景，对应的就是系统内存不足。当需要新的内存页，而内存不够用的时候，就要淘汰一些数据页，空出内存给别的数据页使用。如果淘汰的是“脏页”，就要先将脏页写到磁盘。
你一定会说，这时候难道不能直接把内存淘汰掉，下次需要请求的时候，从磁盘读入数据页，然后拿redo log出来应用不就行了？这里其实是从性能考虑的。如果刷脏页一定会写盘，就保证了每个数据页有两种状态：</p><ul><li>一种是内存里存在，内存里就肯定是正确的结果，直接返回；</li><li>另一种是内存里没有数据，就可以肯定数据文件上是正确的结果，读入内存后返回。
这样的效率最高。</li></ul><h3 id=3-系统空闲>3. 系统空闲</h3><p>第三种场景是，生意不忙的时候，或者打烊之后。这时候柜台没事，掌柜闲着也是闲着，不如更新账本。
这种场景，对应的就是MySQL认为系统“空闲”的时候。当然，MySQL“这家酒店”的生意好起来可是会很快就能把粉板记满的，所以“掌柜”要合理地安排时间，即使是“生意好”的时候，也要见缝插针地找时间，只要有机会就刷一点“脏页”。</p><h3 id=4-正常关闭>4. 正常关闭</h3><p>第四种场景是，年底了咸亨酒店要关门几天，需要把账结清一下。这时候掌柜要把所有账都记到账本上，这样过完年重新开张的时候，就能就着账本明确账目情况了。
这种场景，对应的就是MySQL正常关闭的情况。这时候，MySQL会把内存的脏页都flush到磁盘上，这样下次MySQL启动的时候，就可以直接从磁盘上读数据，启动速度会很快。</p><h2 id=性能影响>性能影响</h2><p>其中，第三种情况是属于MySQL空闲时的操作，这时系统没什么压力，而第四种场景是数据库本来就要关闭了。这两种情况下，你不会太关注“性能”问题。所以这里，我们主要来分析一下前两种场景下的性能问题。</p><p>第一种是“redo log写满了，要flush脏页”，这种情况是InnoDB要尽量避免的。因为出现这种情况的时候，整个系统就不能再接受更新了，所有的更新都必须堵住。如果你从监控上看，这时候更新数会跌为0。</p><p>第二种是“内存不够用了，要先将脏页写到磁盘”，这种情况其实是常态。<strong>InnoDB用缓冲池（buffer pool）管理内存，缓冲池中的内存页有三种状态：</strong></p><ul><li>第一种是，还没有使用的；</li><li>第二种是，使用了并且是干净页；</li><li>第三种是，使用了并且是脏页。</li></ul><p>InnoDB的策略是尽量使用内存，因此对于一个长时间运行的库来说，未被使用的页面很少。</p><p>而当要读入的数据页没有在内存的时候，就必须到缓冲池中申请一个数据页。这时候只能把最久不使用的数据页从内存中淘汰掉：如果要淘汰的是一个干净页，就直接释放出来复用；但如果是脏页呢，就必须将脏页先刷到磁盘，变成干净页后才能复用。</p><p>所以，刷脏页虽然是常态，但是出现以下这两种情况，都是会明显影响性能的：</p><ol><li>一个查询要淘汰的脏页个数太多，会导致查询的响应时间明显变长；</li><li>日志写满，更新全部堵住，写性能跌为0，这种情况对敏感业务来说，是不能接受的。</li></ol><p>所以，InnoDB需要有控制脏页比例的机制，来尽量避免上面的这两种情况。</p><h2 id=控制策略>控制策略</h2><p>接下来，我就来和你说说InnoDB脏页的控制策略，以及和这些策略相关的参数。</p><p>首先，你要正确地告诉InnoDB所在主机的IO能力，这样InnoDB才能知道需要全力刷脏页的时候，可以刷多快。</p><p>这就要用到innodb_io_capacity这个参数了，它会告诉InnoDB你的磁盘能力。这个值我建议你设置成磁盘的IOPS。磁盘的IOPS可以通过fio这个工具来测试，下面的语句是我用来测试磁盘随机读写的命令：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>fio -filename=$filename -direct=1 -iodepth 1 -thread -rw=randrw -ioengine=psync -bs=16k -size=500M -numjobs=10 -runtime=10 -group_reporting -name=mytest 
</span></span></code></pre></div><p>其实，因为没能正确地设置innodb_io_capacity参数，而导致的性能问题也比比皆是。之前，就曾有其他公司的开发负责人找我看一个库的性能问题，说MySQL的写入速度很慢，TPS很低，但是数据库主机的IO压力并不大。经过一番排查，发现罪魁祸首就是这个参数的设置出了问题。</p><p>他的主机磁盘用的是SSD，但是innodb_io_capacity的值设置的是300。于是，InnoDB认为这个系统的能力就这么差，所以刷脏页刷得特别慢，甚至比脏页生成的速度还慢，这样就造成了脏页累积，影响了查询和更新性能。</p><p>虽然我们现在已经定义了“全力刷脏页”的行为，但平时总不能一直是全力刷吧？毕竟磁盘能力不能只用来刷脏页，还需要服务用户请求。所以接下来，我们就一起看看InnoDB怎么控制引擎按照“全力”的百分比来刷脏页。</p><p>根据我前面提到的知识点，试想一下，<strong>如果你来设计策略控制刷脏页的速度，会参考哪些因素呢？</strong></p><p>这个问题可以这么想，如果刷太慢，会出现什么情况？首先是内存脏页太多，其次是redo log写满。</p><p>所以，InnoDB的刷盘速度就是要参考这两个因素：一个是脏页比例，一个是redo log写盘速度。</p><p>InnoDB会根据这两个因素先单独算出两个数字。</p><p>参数innodb_max_dirty_pages_pct是脏页比例上限，默认值是75%。InnoDB会根据当前的脏页比例（假设为M），算出一个范围在0到100之间的数字，计算这个数字的伪代码类似这样：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>F1(M)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  if M&gt;=innodb_max_dirty_pages_pct then
</span></span><span style=display:flex><span>      return 100;
</span></span><span style=display:flex><span>  return 100*M/innodb_max_dirty_pages_pct;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>InnoDB每次写入的日志都有一个序号，当前写入的序号跟checkpoint对应的序号之间的差值，我们假设为N。InnoDB会根据这个N算出一个范围在0到100之间的数字，这个计算公式可以记为F2(N)。F2(N)算法比较复杂，你只要知道N越大，算出来的值越大就好了。</p><p>然后，<strong>根据上述算得的F1(M)和F2(N)两个值，取其中较大的值记为R，之后引擎就可以按照innodb_io_capacity定义的能力乘以R%来控制刷脏页的速度。</strong></p><p>上述的计算流程比较抽象，不容易理解，所以我画了一个简单的流程图。图中的F1、F2就是上面我们通过脏页比例和redo log写入速度算出来的两个值。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211103215329.png style=display:block;width:80% alt=NAME align=center></div><p>现在你知道了，InnoDB会在后台刷脏页，而刷脏页的过程是要将内存页写入磁盘。所以，无论是你的查询语句在需要内存的时候可能要求淘汰一个脏页，还是由于刷脏页的逻辑会占用IO资源并可能影响到了你的更新语句，都可能是造成你从业务端感知到MySQL“抖”了一下的原因。</p><p>要尽量避免这种情况，你就要合理地设置innodb_io_capacity的值，并且<strong>平时要多关注脏页比例，不要让它经常接近75%</strong>。</p><p>其中，脏页比例是通过Innodb_buffer_pool_pages_dirty/Innodb_buffer_pool_pages_total得到的，具体的命令参考下面的代码：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>mysql&gt; select VARIABLE_VALUE into @a from global_status where VARIABLE_NAME = &#39;Innodb_buffer_pool_pages_dirty&#39;;
</span></span><span style=display:flex><span>select VARIABLE_VALUE into @b from global_status where VARIABLE_NAME = &#39;Innodb_buffer_pool_pages_total&#39;;
</span></span><span style=display:flex><span>select @a/@b;
</span></span></code></pre></div><p>接下来，我们再看一个有趣的策略。</p><p>一旦一个查询请求需要在执行过程中先flush掉一个脏页时，这个查询就可能要比平时慢了。而MySQL中的一个机制，可能让你的查询会更慢：在准备刷一个脏页的时候，如果这个数据页旁边的数据页刚好是脏页，就会把这个“邻居”也带着一起刷掉；而且这个把“邻居”拖下水的逻辑还可以继续蔓延，也就是对于每个邻居数据页，如果跟它相邻的数据页也还是脏页的话，也会被放到一起刷。</p><p>在InnoDB中，innodb_flush_neighbors 参数就是用来控制这个行为的，值为1的时候会有上述的“连坐”机制，值为0时表示不找邻居，自己刷自己的。</p><p>找“邻居”这个优化在机械硬盘时代是很有意义的，可以减少很多随机IO。机械硬盘的随机IOPS一般只有几百，相同的逻辑操作减少随机IO就意味着系统性能的大幅度提升。</p><p>而如果使用的是SSD这类IOPS比较高的设备的话，我就建议你把innodb_flush_neighbors的值设置成0。因为这时候IOPS往往不是瓶颈，而“只刷自己”，就能更快地执行完必要的刷脏页操作，减少SQL语句响应时间。</p><p>在MySQL 8.0中，innodb_flush_neighbors参数的默认值已经是0了。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-7d71d54ed4346590dcce5e8857f0ecab>5.13 - CH13-空间回收</h1><p>经常会有同学来问我，我的数据库占用空间太大，我把一个最大的表删掉了一半的数据，怎么表文件的大小还是没变？</p><p>那么今天，我就和你聊聊数据库表的空间回收，看看如何解决这个问题。</p><p>这里，我们还是针对MySQL中应用最广泛的InnoDB引擎展开讨论。一个InnoDB表包含两部分，即：表结构定义和数据。在MySQL 8.0版本以前，表结构是存在以.frm为后缀的文件里。而MySQL 8.0版本，则已经允许把表结构定义放在系统数据表中了。因为表结构定义占用的空间很小，所以我们今天主要讨论的是表数据。</p><p>接下来，我会先和你说明为什么简单地删除表数据达不到表空间回收的效果，然后再和你介绍正确回收空间的方法。</p><h2 id=innodb_file_per_table>innodb_file_per_table</h2><p>表数据既可以存在共享表空间里，也可以是单独的文件。这个行为是由参数innodb_file_per_table控制的：</p><ol><li>这个参数设置为OFF表示的是，表的数据放在系统共享表空间，也就是跟数据字典放在一起；</li><li>这个参数设置为ON表示的是，每个InnoDB表数据存储在一个以 .ibd为后缀的文件中。</li></ol><p>从MySQL 5.6.6版本开始，它的默认值就是ON了。</p><p>我建议你不论使用MySQL的哪个版本，都将这个值设置为ON。因为，一个表单独存储为一个文件更容易管理，而且在你不需要这个表的时候，通过drop table命令，系统就会直接删除这个文件。而如果是放在共享表空间中，即使表删掉了，空间也是不会回收的。</p><p>所以，<strong>将innodb_file_per_table设置为ON，是推荐做法，我们接下来的讨论都是基于这个设置展开的。</strong></p><p>我们在删除整个表的时候，可以使用drop table命令回收表空间。但是，我们遇到的更多的删除数据的场景是删除某些行，这时就遇到了我们文章开头的问题：表中的数据被删除了，但是表空间却没有被回收。</p><p>我们要彻底搞明白这个问题的话，就要从数据删除流程说起了。</p><h2 id=数据删除流程>数据删除流程</h2><p>我们先再来看一下InnoDB中一个索引的示意图。在前面4、5章中，我和你介绍索引时曾经提到过，InnoDB里的数据都是用B+树的结构组织的。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211103215748.png style=display:block;width:80% alt=NAME align=center></div><p>假设，我们要删掉R4这个记录，InnoDB引擎只会把R4这个记录标记为删除。如果之后要再插入一个ID在300和600之间的记录时，可能会复用这个位置。但是，磁盘文件的大小并不会缩小。</p><p>现在，你已经知道了InnoDB的数据是按页存储的，那么如果我们删掉了一个数据页上的所有记录，会怎么样？</p><p>答案是，整个数据页就可以被复用了。</p><p>但是，<strong>数据页的复用跟记录的复用是不同的。</strong></p><p>记录的复用，只限于符合范围条件的数据。比如上面的这个例子，R4这条记录被删除后，如果插入一个ID是400的行，可以直接复用这个空间。但如果插入的是一个ID是800的行，就不能复用这个位置了。</p><p>而当整个页从B+树里面摘掉以后，可以复用到任何位置。以图1为例，如果将数据页page A上的所有记录删除以后，page A会被标记为可复用。这时候如果要插入一条ID=50的记录需要使用新页的时候，page A是可以被复用的。</p><p>如果相邻的两个数据页利用率都很小，系统就会把这两个页上的数据合到其中一个页上，另外一个数据页就被标记为可复用。</p><p>进一步地，如果我们用delete命令把整个表的数据删除呢？结果就是，所有的数据页都会被标记为可复用。但是磁盘上，文件不会变小。</p><p>你现在知道了，delete命令其实只是把记录的位置，或者数据页标记为了“可复用”，但磁盘文件的大小是不会变的。也就是说，通过delete命令是不能回收表空间的。这些可以复用，而没有被使用的空间，看起来就像是“空洞”。</p><p>实际上，<strong>不止是删除数据会造成空洞，插入数据也会。</strong></p><p>如果数据是按照索引递增顺序插入的，那么索引是紧凑的。但如果数据是随机插入的，就可能造成索引的数据页分裂。</p><p>假设图1中page A已经满了，这时我要再插入一行数据，会怎样呢？</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/8083f05a4a4c0372833a6e01d5a8e6ea.png style=display:block;width:80% alt=NAME align=center></div><p>可以看到，由于page A满了，再插入一个ID是550的数据时，就不得不再申请一个新的页面page B来保存数据了。页分裂完成后，page A的末尾就留下了空洞（注意：实际上，可能不止1个记录的位置是空洞）。</p><p>另外，更新索引上的值，可以理解为删除一个旧的值，再插入一个新值。不难理解，这也是会造成空洞的。</p><p>也就是说，经过大量增删改的表，都是可能是存在空洞的。所以，如果能够把这些空洞去掉，就能达到收缩表空间的目的。</p><p>而重建表，就可以达到这样的目的。</p><h2 id=重建表>重建表</h2><p>试想一下，如果你现在有一个表A，需要做空间收缩，为了把表中存在的空洞去掉，你可以怎么做呢？</p><p>你可以新建一个与表A结构相同的表B，然后按照主键ID递增的顺序，把数据一行一行地从表A里读出来再插入到表B中。</p><p>由于表B是新建的表，所以表A主键索引上的空洞，在表B中就都不存在了。显然地，表B的主键索引更紧凑，数据页的利用率也更高。如果我们把表B作为临时表，数据从表A导入表B的操作完成后，用表B替换A，从效果上看，就起到了收缩表A空间的作用。</p><p>这里，你可以使用alter table A engine=InnoDB命令来重建表。在MySQL 5.5版本之前，这个命令的执行流程跟我们前面描述的差不多，区别只是这个临时表B不需要你自己创建，MySQL会自动完成转存数据、交换表名、删除旧表的操作。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211103220108.png style=display:block;width:80% alt=NAME align=center></div><p>显然，花时间最多的步骤是往临时表插入数据的过程，如果在这个过程中，有新的数据要写入到表A的话，就会造成数据丢失。因此，在整个DDL过程中，表A中不能有更新。也就是说，这个DDL不是Online的。</p><p>而在<strong>MySQL 5.6版本开始引入的Online DDL，对这个操作流程做了优化。</strong></p><p>我给你简单描述一下引入了Online DDL之后，重建表的流程：</p><ol><li>建立一个临时文件，扫描表A主键的所有数据页；</li><li>用数据页中表A的记录生成B+树，存储到临时文件中；</li><li>生成临时文件的过程中，将所有对A的操作记录在一个日志文件（row log）中，对应的是图中state2的状态；</li><li>临时文件生成后，将日志文件中的操作应用到临时文件，得到一个逻辑数据上与表A相同的数据文件，对应的就是图中state3的状态；</li><li>用临时文件替换表A的数据文件。</li></ol><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211103220204.png style=display:block;width:80% alt=NAME align=center></div><p>可以看到，与图3过程的不同之处在于，由于日志文件记录和重放操作这个功能的存在，这个方案在重建表的过程中，允许对表A做增删改操作。这也就是Online DDL名字的来源。</p><p>我记得有同学在第6篇讲表锁的文章“全局锁与表锁”的评论区留言说，DDL之前是要拿MDL写锁的，这样还能叫Online DDL吗？</p><p>确实，图4的流程中，alter语句在启动的时候需要获取MDL写锁，但是这个写锁在真正拷贝数据之前就退化成读锁了。</p><p>为什么要退化呢？为了实现Online，MDL读锁不会阻塞增删改操作。</p><p>那为什么不干脆直接解锁呢？为了保护自己，禁止其他线程对这个表同时做DDL。</p><p>而对于一个大表来说，Online DDL最耗时的过程就是拷贝数据到临时表的过程，这个步骤的执行期间可以接受增删改操作。所以，相对于整个DDL过程来说，锁的时间非常短。对业务来说，就可以认为是Online的。</p><p>需要补充说明的是，上述的这些重建方法都会扫描原表数据和构建临时文件。对于很大的表来说，这个操作是很消耗IO和CPU资源的。因此，如果是线上服务，你要很小心地控制操作时间。如果想要比较安全的操作的话，我推荐你使用GitHub开源的gh-ost来做。</p><h2 id=online-与-inplace>online 与 inplace</h2><p>说到Online，我还要再和你澄清一下它和另一个跟DDL有关的、容易混淆的概念inplace的区别。</p><p>你可能注意到了，在图3中，我们把表A中的数据导出来的存放位置叫作tmp_table。这是一个临时表，是在server层创建的。</p><p>在图4中，根据表A重建出来的数据是放在“tmp_file”里的，这个临时文件是InnoDB在内部创建出来的。整个DDL过程都在InnoDB内部完成。对于server层来说，没有把数据挪动到临时表，是一个“原地”操作，这就是“inplace”名称的来源。</p><p>所以，我现在问你，如果你有一个1TB的表，现在磁盘间是1.2TB，能不能做一个inplace的DDL呢？</p><p>答案是不能。因为，tmp_file也是要占用临时空间的。</p><p>我们重建表的这个语句alter table t engine=InnoDB，其实隐含的意思是：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>alter table t engine=innodb,ALGORITHM=inplace;
</span></span></code></pre></div><p>跟inplace对应的就是拷贝表的方式了，用法是：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>alter table t engine=innodb,ALGORITHM=copy;
</span></span></code></pre></div><p>当你使用ALGORITHM=copy的时候，表示的是强制拷贝表，对应的流程就是图3的操作过程。</p><p>但我这样说你可能会觉得，inplace跟Online是不是就是一个意思？</p><p>其实不是的，只是在重建表这个逻辑中刚好是这样而已。</p><p>比如，如果我要给InnoDB表的一个字段加全文索引，写法是：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>alter table t add FULLTEXT(field_name);
</span></span></code></pre></div><p>这个过程是inplace的，但会阻塞增删改操作，是非Online的。</p><p>如果说这两个逻辑之间的关系是什么的话，可以概括为：</p><ol><li>DDL过程如果是Online的，就一定是inplace的；</li><li>反过来未必，也就是说inplace的DDL，有可能不是Online的。截止到MySQL 8.0，添加全文索引（FULLTEXT index）和空间索引(SPATIAL index)就属于这种情况。</li></ol><p>最后，我们再延伸一下。</p><p>在第10篇文章“索引选择”的评论区中，有同学问到使用optimize table、analyze table和alter table这三种方式重建表的区别。这里，我顺便再简单和你解释一下。</p><ul><li>从MySQL 5.6版本开始，alter table t engine = InnoDB（也就是recreate）默认的就是上面图4的流程了；</li><li>analyze table t 其实不是重建表，只是对表的索引信息做重新统计，没有修改数据，这个过程中加了MDL读锁；</li><li>optimize table t 等于recreate+analyze。</li></ul><h2 id=add-index-三种处理方式>add index 三种处理方式</h2><h3 id=copy-table方式>Copy Table方式</h3><p>这是InnoDB最早支持的创建索引的方式。顾名思义，创建索引是通过临时表拷贝的方式实现的。</p><p>新建一个带有新索引的临时表，将原表数据全部拷贝到临时表，然后Rename，完成创建索引的操作。</p><p>这个方式创建索引，创建过程中，原表是可读的。但是会消耗一倍的存储空间。</p><h3 id=inplace方式>Inplace方式</h3><p>这是原生MySQL 5.5，以及innodb_plugin中提供的创建索引的方式。所谓Inplace，也就是索引创建在原表上直接进行，不会拷贝临时表。相对于Copy Table方式，这是一个进步。</p><p>Inplace方式创建索引，创建过程中，原表同样可读的，但是不可写。</p><h3 id=online方式>Online方式</h3><p>这是MySQL 5.6.7中提供的创建索引的方式。无论是Copy Table方式，还是Inplace方式，创建索引的过程中，原表只能允许读取，不可写。对应用有较大的限制，因此MySQL最新版本中，InnoDB支持了所谓的Online方式创建索引。</p><p>InnoDB的Online Add Index，首先是Inplace方式创建索引，无需使用临时表。在遍历聚簇索引，收集记录并插入到新索引的过程中，原表记录可修改。而修改的记录保存在Row Log中。当聚簇索引遍历完毕，并全部插入到新索引之后，重放Row Log中的记录修改，使得新索引与聚簇索引记录达到一致状态。</p><p>与Copy Table方式相比，Online Add Index采用的是Inplace方式，无需Copy Table，减少了空间开销；与此同时，Online Add Index只有在重放Row Log最后一个Block时锁表，减少了锁表的时间。</p><p>与Inplace方式相比，Online Add Index吸收了Inplace方式的优势，却减少了锁表的时间。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-1110a052c9014ea2f2ce98636dc8222e>5.14 - CH14-Count 实现</h1><p>在开发系统的时候，你可能经常需要计算一个表的行数，比如一个交易系统的所有变更记录总数。这时候你可能会想，一条select count(*) from t 语句不就解决了吗？</p><p>但是，你会发现随着系统中记录数越来越多，这条语句执行得也会越来越慢。然后你可能就想了，MySQL怎么这么笨啊，记个总数，每次要查的时候直接读出来，不就好了吗。</p><p>那么今天，我们就来聊聊count(*)语句到底是怎样实现的，以及MySQL为什么会这么实现。然后，我会再和你说说，如果应用中有这种频繁变更并需要统计表行数的需求，业务设计上可以怎么做。</p><h2 id=count-实现方式>count(*) 实现方式</h2><p>你首先要明确的是，在不同的MySQL引擎中，count(*)有不同的实现方式。</p><ul><li>MyISAM引擎把一个表的总行数存在了磁盘上，因此执行count(*)的时候会直接返回这个数，效率很高；</li><li>而InnoDB引擎就麻烦了，它执行count(*)的时候，需要把数据一行一行地从引擎里面读出来，然后累积计数。</li></ul><p>这里需要注意的是，我们在这篇文章里讨论的是没有过滤条件的count(*)，如果加了where 条件的话，MyISAM表也是不能返回得这么快的。</p><p>在前面的文章中，我们一起分析了为什么要使用InnoDB，因为不论是在事务支持、并发能力还是在数据安全方面，InnoDB都优于MyISAM。我猜你的表也一定是用了InnoDB引擎。这就是当你的记录数越来越多的时候，计算一个表的总行数会越来越慢的原因。</p><p>那<strong>为什么InnoDB不跟MyISAM一样，也把数字存起来呢？</strong></p><p>这是因为即使是在同一个时刻的多个查询，由于多版本并发控制（MVCC）的原因，InnoDB表“应该返回多少行”也是不确定的。这里，我用一个算count(*)的例子来为你解释一下。</p><p>假设表t中现在有10000条记录，我们设计了三个用户并行的会话。</p><ul><li>会话A先启动事务并查询一次表的总行数；</li><li>会话B启动事务，插入一行后记录后，查询表的总行数；</li><li>会话C先启动一个单独的语句，插入一行记录后，查询表的总行数。</li></ul><p>我们假设从上到下是按照时间顺序执行的，同一行语句是在同一时刻执行的。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/5e716ba1d464c8224c1c1f36135d0e97.png style=display:block;width:80% alt=NAME align=center></div><p>你会看到，在最后一个时刻，三个会话A、B、C会同时查询表t的总行数，但拿到的结果却不同。</p><p>这和InnoDB的事务设计有关系，可重复读是它默认的隔离级别，在代码上就是通过多版本并发控制，也就是MVCC来实现的。每一行记录都要判断自己是否对这个会话可见，因此对于count(*)请求来说，InnoDB只好把数据一行一行地读出依次判断，可见的行才能够用于计算“基于这个查询”的表的总行数。</p><p>当然，现在这个看上去笨笨的MySQL，在执行count(*)操作的时候还是做了优化的。</p><p>你知道的，InnoDB是索引组织表，主键索引树的叶子节点是数据，而普通索引树的叶子节点是主键值。所以，普通索引树比主键索引树小很多。对于count(*)这样的操作，遍历哪个索引树得到的结果逻辑上都是一样的。因此，MySQL优化器会找到最小的那棵树来遍历。<strong>在保证逻辑正确的前提下，尽量减少扫描的数据量，是数据库系统设计的通用法则之一。</strong></p><p>如果你用过show table status 命令的话，就会发现这个命令的输出结果里面也有一个TABLE_ROWS用于显示这个表当前有多少行，这个命令执行挺快的，那这个TABLE_ROWS能代替count(*)吗？</p><p>你可能还记得在第10篇文章“索引选择”中提到过，索引统计的值是通过采样来估算的。实际上，TABLE_ROWS就是从这个采样估算得来的，因此它也很不准。有多不准呢，官方文档说误差可能达到40%到50%。<strong>所以，show table status命令显示的行数也不能直接使用。</strong></p><p>到这里我们小结一下：</p><ul><li>MyISAM表虽然count(*)很快，但是不支持事务；</li><li>show table status命令虽然返回很快，但是不准确；</li><li>InnoDB表直接count(*)会遍历全表，虽然结果准确，但会导致性能问题。</li></ul><p>那么，回到文章开头的问题，如果你现在有一个页面经常要显示交易系统的操作记录总数，到底应该怎么办呢？答案是，我们只能自己计数。</p><p>接下来，我们讨论一下，看看自己计数有哪些方法，以及每种方法的优缺点有哪些。</p><p>这里，我先和你说一下这些方法的基本思路：你需要自己找一个地方，把操作记录表的行数存起来。</p><h2 id=用缓存系统保存计数>用缓存系统保存计数</h2><p>对于更新很频繁的库来说，你可能会第一时间想到，用缓存系统来支持。</p><p>你可以用一个Redis服务来保存这个表的总行数。这个表每被插入一行Redis计数就加1，每被删除一行Redis计数就减1。这种方式下，读和更新操作都很快，但你再想一下这种方式存在什么问题吗？</p><p>没错，缓存系统可能会丢失更新。</p><p>Redis的数据不能永久地留在内存里，所以你会找一个地方把这个值定期地持久化存储起来。但即使这样，仍然可能丢失更新。试想如果刚刚在数据表中插入了一行，Redis中保存的值也加了1，然后Redis异常重启了，重启后你要从存储redis数据的地方把这个值读回来，而刚刚加1的这个计数操作却丢失了。</p><p>当然了，这还是有解的。比如，Redis异常重启以后，到数据库里面单独执行一次count(*)获取真实的行数，再把这个值写回到Redis里就可以了。异常重启毕竟不是经常出现的情况，这一次全表扫描的成本，还是可以接受的。</p><p>但实际上，<strong>将计数保存在缓存系统中的方式，还不只是丢失更新的问题。即使Redis正常工作，这个值还是逻辑上不精确的。</strong></p><p>你可以设想一下有这么一个页面，要显示操作记录的总数，同时还要显示最近操作的100条记录。那么，这个页面的逻辑就需要先到Redis里面取出计数，再到数据表里面取数据记录。</p><p>我们是这么定义不精确的：</p><ol><li>一种是，查到的100行结果里面有最新插入记录，而Redis的计数里还没加1；</li><li>另一种是，查到的100行结果里没有最新插入的记录，而Redis的计数里已经加了1。</li></ol><p>这两种情况，都是逻辑不一致的。</p><p>我们一起来看看这个时序图。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211103221109.png style=display:block;width:80% alt=NAME align=center></div><p>图2中，会话A是一个插入交易记录的逻辑，往数据表里插入一行R，然后Redis计数加1；会话B就是查询页面显示时需要的数据。</p><p>在图2的这个时序里，在T3时刻会话B来查询的时候，会显示出新插入的R这个记录，但是Redis的计数还没加1。这时候，就会出现我们说的数据不一致。</p><p>你一定会说，这是因为我们执行新增记录逻辑时候，是先写数据表，再改Redis计数。而读的时候是先读Redis，再读数据表，这个顺序是相反的。那么，如果保持顺序一样的话，是不是就没问题了？我们现在把会话A的更新顺序换一下，再看看执行结果。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211103221121.png style=display:block;width:80% alt=NAME align=center></div><p>你会发现，这时候反过来了，会话B在T3时刻查询的时候，Redis计数加了1了，但还查不到新插入的R这一行，也是数据不一致的情况。</p><p>在并发系统里面，我们是无法精确控制不同线程的执行时刻的，因为存在图中的这种操作序列，所以，我们说即使Redis正常工作，这个计数值还是逻辑上不精确的。</p><h2 id=用数据库保存计数>用数据库保存计数</h2><p>根据上面的分析，用缓存系统保存计数有丢失数据和计数不精确的问题。那么，<strong>如果我们把这个计数直接放到数据库里单独的一张计数表C中，又会怎么样呢？</strong></p><p>首先，这解决了崩溃丢失的问题，InnoDB是支持崩溃恢复不丢数据的。</p><p>然后，我们再看看能不能解决计数不精确的问题。</p><p>你会说，这不一样吗？无非就是把图3中对Redis的操作，改成了对计数表C的操作。只要出现图3的这种执行序列，这个问题还是无解的吧？</p><p>这个问题还真不是无解的。</p><p>我们这篇文章要解决的问题，都是由于InnoDB要支持事务，从而导致InnoDB表不能把count(*)直接存起来，然后查询的时候直接返回形成的。</p><p>所谓以子之矛攻子之盾，现在我们就利用“事务”这个特性，把问题解决掉。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211103221157.png style=display:block;width:80% alt=NAME align=center></div><p>我们来看下现在的执行结果。虽然会话B的读操作仍然是在T3执行的，但是因为这时候更新事务还没有提交，所以计数值加1这个操作对会话B还不可见。</p><p>因此，会话B看到的结果里， 查计数值和“最近100条记录”看到的结果，逻辑上就是一致的。</p><h2 id=不同的-count-用法>不同的 count 用法</h2><p>在前面文章的评论区，有同学留言问到：在select count(?) from t这样的查询语句里面，<code>count(*)</code>、count(主键id)、count(字段)和count(1)等不同用法的性能，有哪些差别。今天谈到了count(*)的性能问题，我就借此机会和你详细说明一下这几种用法的性能差别。</p><p>需要注意的是，下面的讨论还是基于InnoDB引擎的。</p><p>这里，首先你要弄清楚count()的语义。count()是一个聚合函数，对于返回的结果集，一行行地判断，如果count函数的参数不是NULL，累计值就加1，否则不加。最后返回累计值。</p><p>所以，count(*)、count(主键id)和count(1) 都表示返回满足条件的结果集的总行数；而count(字段），则表示返回满足条件的数据行里面，参数“字段”不为NULL的总个数。</p><p>至于分析性能差别的时候，你可以记住这么几个原则：</p><ol><li>server层要什么就给什么；</li><li>InnoDB只给必要的值；</li><li>现在的优化器只优化了count(*)的语义为“取行数”，其他“显而易见”的优化并没有做。</li></ol><p>这是什么意思呢？接下来，我们就一个个地来看看。</p><p><strong>对于count(主键id)来说</strong>，InnoDB引擎会遍历整张表，把每一行的id值都取出来，返回给server层。server层拿到id后，判断是不可能为空的，就按行累加。</p><p><strong>对于count(1)来说</strong>，InnoDB引擎遍历整张表，但不取值。server层对于返回的每一行，放一个数字“1”进去，判断是不可能为空的，按行累加。</p><p>单看这两个用法的差别的话，你能对比出来，count(1)执行得要比count(主键id)快。因为从引擎返回id会涉及到解析数据行，以及拷贝字段值的操作。</p><p><strong>对于count(字段)来说</strong>：</p><ol><li>如果这个“字段”是定义为not null的话，一行行地从记录里面读出这个字段，判断不能为null，按行累加；</li><li>如果这个“字段”定义允许为null，那么执行的时候，判断到有可能是null，还要把值取出来再判断一下，不是null才累加。</li></ol><p>也就是前面的第一条原则，server层要什么字段，InnoDB就返回什么字段。</p><p><strong>但是count(*)是例外</strong>，并不会把全部字段取出来，而是专门做了优化，不取值。count(*)肯定不是null，按行累加。</p><p>看到这里，你一定会说，优化器就不能自己判断一下吗，主键id肯定非空啊，为什么不能按照count(*)来处理，多么简单的优化啊。</p><p>当然，MySQL专门针对这个语句进行优化，也不是不可以。但是这种需要专门优化的情况太多了，而且MySQL已经优化过count(*)了，你直接使用这种用法就可以了。</p><p>所以结论是：按照效率排序的话，count(字段)&lt;count(主键id)&lt;count(1)≈<code>count(*)</code>，所以我建议你，尽量使用count(*)。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-a9a6c55b68fda9e4efeb68fc40c903fb>5.15 - CH15-日志与索引</h1><h2 id=日志相关问题>日志相关问题</h2><p>我在第2篇文章中，和你讲到binlog（归档日志）和redo log（重做日志）配合崩溃恢复的时候，用的是反证法，说明了如果没有两阶段提交，会导致MySQL出现主备数据不一致等问题。</p><p>在这篇文章下面，很多同学在问，在两阶段提交的不同瞬间，MySQL如果发生异常重启，是怎么保证数据完整性的？</p><p>现在，我们就从这个问题开始吧。</p><p>我再放一次两阶段提交的图，方便你学习下面的内容。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211117230056.png style=display:block;width:80% alt=NAME align=center></div><p>这里，我要先和你解释一个误会式的问题。有同学在评论区问到，这个图不是一个update语句的执行流程吗，怎么还会调用commit语句？</p><p>他产生这个疑问的原因，是把<strong>两个“commit”的概念</strong>混淆了：</p><ul><li>他说的“commit语句”，是指MySQL语法中，用于提交一个事务的命令。一般跟begin/start transaction 配对使用。</li><li>而我们图中用到的这个“commit步骤”，指的是事务提交过程中的一个小步骤，也是最后一步。当这个步骤执行完成后，这个事务就提交完成了。</li><li>“commit语句”执行的时候，会包含“commit 步骤”。</li></ul><p>而我们这个例子里面，没有显式地开启事务，因此这个update语句自己就是一个事务，在执行完成后提交事务时，就会用到这个“commit步骤“。</p><p>接下来，我们就一起分析一下<strong>在两阶段提交的不同时刻，MySQL异常重启会出现什么现象。</strong></p><p>如果在图中时刻A的地方，也就是写入redo log 处于prepare阶段之后、写binlog之前，发生了崩溃（crash），由于此时binlog还没写，redo log也还没提交，所以崩溃恢复的时候，这个事务会回滚。这时候，binlog还没写，所以也不会传到备库。到这里，大家都可以理解。</p><p>大家出现问题的地方，主要集中在时刻B，也就是binlog写完，redo log还没commit前发生crash，那崩溃恢复的时候MySQL会怎么处理？</p><p>我们先来看一下崩溃恢复时的判断规则。</p><ol><li>如果redo log里面的事务是完整的，也就是已经有了commit标识，则直接提交；</li><li>如果redo log里面的事务只有完整的prepare，则判断对应的事务binlog是否存在并完整：
a. 如果是，则提交事务；
b. 否则，回滚事务。</li></ol><p>这里，时刻B发生crash对应的就是2(a)的情况，崩溃恢复过程中事务会被提交。</p><p>现在，我们继续延展一下这个问题。</p><h2 id=追问1mysql怎么知道binlog是完整的>追问1：MySQL怎么知道binlog是完整的?</h2><p>回答：一个事务的binlog是有完整格式的：</p><ul><li>statement格式的binlog，最后会有COMMIT；</li><li>row格式的binlog，最后会有一个XID event。</li></ul><p>另外，在MySQL 5.6.2版本以后，还引入了binlog-checksum参数，用来验证binlog内容的正确性。对于binlog日志由于磁盘原因，可能会在日志中间出错的情况，MySQL可以通过校验checksum的结果来发现。所以，MySQL还是有办法验证事务binlog的完整性的。</p><h2 id=追问2redo-log-和-binlog是怎么关联起来的>追问2：redo log 和 binlog是怎么关联起来的?</h2><p>回答：它们有一个共同的数据字段，叫XID。崩溃恢复的时候，会按顺序扫描redo log：</p><ul><li>如果碰到既有prepare、又有commit的redo log，就直接提交；</li><li>如果碰到只有parepare、而没有commit的redo log，就拿着XID去binlog找对应的事务。</li></ul><h2 id=追问3处于prepare阶段的redo-log加上完整binlog重启就能恢复mysql为什么要这么设计>追问3：处于prepare阶段的redo log加上完整binlog，重启就能恢复，MySQL为什么要这么设计?</h2><p>回答：其实，这个问题还是跟我们在反证法中说到的数据与备份的一致性有关。在时刻B，也就是binlog写完以后MySQL发生崩溃，这时候binlog已经写入了，之后就会被从库（或者用这个binlog恢复出来的库）使用。</p><p>所以，在主库上也要提交这个事务。采用这个策略，主库和备库的数据就保证了一致性。</p><h2 id=追问4如果这样的话为什么还要两阶段提交呢干脆先redo-log写完再写binlog崩溃恢复的时候必须得两个日志都完整才可以是不是一样的逻辑>追问4：如果这样的话，为什么还要两阶段提交呢？干脆先redo log写完，再写binlog。崩溃恢复的时候，必须得两个日志都完整才可以。是不是一样的逻辑？</h2><p>回答：其实，两阶段提交是经典的分布式系统问题，并不是MySQL独有的。</p><p>如果必须要举一个场景，来说明这么做的必要性的话，那就是事务的持久性问题。</p><p>对于InnoDB引擎来说，如果redo log提交完成了，事务就不能回滚（如果这还允许回滚，就可能覆盖掉别的事务的更新）。而如果redo log直接提交，然后binlog写入的时候失败，InnoDB又回滚不了，数据和binlog日志又不一致了。</p><p>两阶段提交就是为了给所有人一个机会，当每个人都说“我ok”的时候，再一起提交。</p><h2 id=追问5不引入两个日志也就没有两阶段提交的必要了只用binlog来支持崩溃恢复又能支持归档不就可以了>追问5：不引入两个日志，也就没有两阶段提交的必要了。只用binlog来支持崩溃恢复，又能支持归档，不就可以了？</h2><p>回答：这位同学的意思是，只保留binlog，然后可以把提交流程改成这样：… -> “数据更新到内存” -> “写 binlog” -> “提交事务”，是不是也可以提供崩溃恢复的能力？</p><p>答案是不可以。</p><p>如果说<strong>历史原因</strong>的话，那就是InnoDB并不是MySQL的原生存储引擎。MySQL的原生引擎是MyISAM，设计之初就有没有支持崩溃恢复。</p><p>InnoDB在作为MySQL的插件加入MySQL引擎家族之前，就已经是一个提供了崩溃恢复和事务支持的引擎了。</p><p>InnoDB接入了MySQL后，发现既然binlog没有崩溃恢复的能力，那就用InnoDB原有的redo log好了。</p><p>而如果说<strong>实现上的原因</strong>的话，就有很多了。就按照问题中说的，只用binlog来实现崩溃恢复的流程，我画了一张示意图，这里就没有redo log了。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211117230114.png style=display:block;width:80% alt=NAME align=center></div><p>这样的流程下，binlog还是不能支持崩溃恢复的。我说一个不支持的点吧：binlog没有能力恢复“数据页”。</p><p>如果在图中标的位置，也就是binlog2写完了，但是整个事务还没有commit的时候，MySQL发生了crash。</p><p>重启后，引擎内部事务2会回滚，然后应用binlog2可以补回来；但是对于事务1来说，系统已经认为提交完成了，不会再应用一次binlog1。</p><p>但是，InnoDB引擎使用的是WAL技术，执行事务的时候，写完内存和日志，事务就算完成了。如果之后崩溃，要依赖于日志来恢复数据页。</p><p>也就是说在图中这个位置发生崩溃的话，事务1也是可能丢失了的，而且是数据页级的丢失。此时，binlog里面并没有记录数据页的更新细节，是补不回来的。</p><p>你如果要说，那我优化一下binlog的内容，让它来记录数据页的更改可以吗？但，这其实就是又做了一个redo log出来。</p><p>所以，至少现在的binlog能力，还不能支持崩溃恢复。</p><h2 id=追问6那能不能反过来只用redo-log不要binlog>追问6：那能不能反过来，只用redo log，不要binlog？</h2><p>回答：如果只从崩溃恢复的角度来讲是可以的。你可以把binlog关掉，这样就没有两阶段提交了，但系统依然是crash-safe的。</p><p>但是，如果你了解一下业界各个公司的使用场景的话，就会发现在正式的生产库上，binlog都是开着的。因为binlog有着redo log无法替代的功能。</p><p>一个是归档。redo log是循环写，写到末尾是要回到开头继续写的。这样历史日志没法保留，redo log也就起不到归档的作用。</p><p>一个就是MySQL系统依赖于binlog。binlog作为MySQL一开始就有的功能，被用在了很多地方。其中，MySQL系统高可用的基础，就是binlog复制。</p><p>还有很多公司有异构系统（比如一些数据分析系统），这些系统就靠消费MySQL的binlog来更新自己的数据。关掉binlog的话，这些下游系统就没法输入了。</p><p>总之，由于现在包括MySQL高可用在内的很多系统机制都依赖于binlog，所以“鸠占鹊巢”redo log还做不到。你看，发展生态是多么重要。</p><h2 id=追问7redo-log一般设置多大>追问7：redo log一般设置多大？</h2><p>回答：redo log太小的话，会导致很快就被写满，然后不得不强行刷redo log，这样WAL机制的能力就发挥不出来了。</p><p>所以，如果是现在常见的几个TB的磁盘的话，就不要太小气了，直接将redo log设置为4个文件、每个文件1GB吧。</p><h2 id=追问8正常运行中的实例数据写入后的最终落盘是从redo-log更新过来的还是从buffer-pool更新过来的呢>追问8：正常运行中的实例，数据写入后的最终落盘，是从redo log更新过来的还是从buffer pool更新过来的呢？</h2><p>回答：这个问题其实问得非常好。这里涉及到了，“redo log里面到底是什么”的问题。</p><p>实际上，redo log并没有记录数据页的完整数据，所以它并没有能力自己去更新磁盘数据页，也就不存在“数据最终落盘，是由redo log更新过去”的情况。</p><ol><li>如果是正常运行的实例的话，数据页被修改以后，跟磁盘的数据页不一致，称为脏页。最终数据落盘，就是把内存中的数据页写盘。这个过程，甚至与redo log毫无关系。</li><li>在崩溃恢复场景中，InnoDB如果判断到一个数据页可能在崩溃恢复的时候丢失了更新，就会将它读到内存，然后让redo log更新内存内容。更新完成后，内存页变成脏页，就回到了第一种情况的状态。</li></ol><h2 id=追问9redo-log-buffer是什么是先修改内存还是先写redo-log文件>追问9：redo log buffer是什么？是先修改内存，还是先写redo log文件？</h2><p>回答：这两个问题可以一起回答。</p><p>在一个事务的更新过程中，日志是要写多次的。比如下面这个事务：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>begin;
</span></span><span style=display:flex><span>insert into t1 ...
</span></span><span style=display:flex><span>insert into t2 ...
</span></span><span style=display:flex><span>commit;
</span></span></code></pre></div><p>这个事务要往两个表中插入记录，插入数据的过程中，生成的日志都得先保存起来，但又不能在还没commit的时候就直接写到redo log文件里。</p><p>所以，redo log buffer就是一块内存，用来先存redo日志的。也就是说，在执行第一个insert的时候，数据的内存被修改了，redo log buffer也写入了日志。</p><p>但是，真正把日志写到redo log文件（文件名是 ib_logfile+数字），是在执行commit语句的时候做的。</p><p>（这里说的是事务执行过程中不会“主动去刷盘”，以减少不必要的IO消耗。但是可能会出现“被动写入磁盘”，比如内存不够、其他事务提交等情况。这个问题我们会在后面第22篇文章《MySQL有哪些“饮鸩止渴”的提高性能的方法？》中再详细展开）。</p><p>单独执行一个更新语句的时候，InnoDB会自己启动一个事务，在语句执行完成的时候提交。过程跟上面是一样的，只不过是“压缩”到了一个语句里面完成。</p><p>以上这些问题，就是把大家提过的关于redo log和binlog的问题串起来，做的一次集中回答。如果你还有问题，可以在评论区继续留言补充。</p><h1 id=业务设计问题>业务设计问题</h1><p>接下来，我再和你分享@ithunter 同学在第8篇文章的评论区提到的跟索引相关的一个问题。我觉得这个问题挺有趣、也挺实用的，其他同学也可能会碰上这样的场景，在这里解答和分享一下。</p><p>问题是这样的（我文字上稍微做了点修改，方便大家理解）：</p><blockquote><p>业务上有这样的需求，A、B两个用户，如果互相关注，则成为好友。设计上是有两张表，一个是like表，一个是friend表，like表有user_id、liker_id两个字段，我设置为复合唯一索引即uk_user_id_liker_id。语句执行逻辑是这样的：</p></blockquote><blockquote><p>以A关注B为例：
第一步，先查询对方有没有关注自己（B有没有关注A）
select * from like where user_id = B and liker_id = A;</p></blockquote><blockquote><p>如果有，则成为好友
insert into friend;</p></blockquote><blockquote><p>没有，则只是单向关注关系
insert into like;</p></blockquote><blockquote><p>但是如果A、B同时关注对方，会出现不会成为好友的情况。因为上面第1步，双方都没关注对方。第1步即使使用了排他锁也不行，因为记录不存在，行锁无法生效。请问这种情况，在MySQL锁层面有没有办法处理？</p></blockquote><p>首先，我要先赞一下这样的提问方式。虽然极客时间现在的评论区还不能追加评论，但如果大家能够一次留言就把问题讲清楚的话，其实影响也不大。所以，我希望你在留言提问的时候，也能借鉴这种方式。</p><p>接下来，我把@ithunter 同学说的表模拟出来，方便我们讨论。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span><span style=color:#204a87;font-weight:700>CREATE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>TABLE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#204a87;font-weight:700>like</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>(</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>id</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>int</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>11</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>NOT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>NULL</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>AUTO_INCREMENT</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>user_id</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>int</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>11</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>NOT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>NULL</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>liker_id</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>int</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>11</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>NOT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>NULL</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>PRIMARY</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>KEY</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>(</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>id</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000;font-weight:700>),</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>UNIQUE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>KEY</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>uk_user_id_liker_id</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>(</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>user_id</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000;font-weight:700>,</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>liker_id</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>ENGINE</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#000>InnoDB</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>CREATE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>TABLE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>friend</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>(</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#000>id</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>int</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>11</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>NOT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>NULL</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>AUTO_INCREMENT</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>friend_1_id</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>int</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>11</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>NOT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>NULL</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>firned_2_id</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>int</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>11</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>NOT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>NULL</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>UNIQUE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>KEY</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>uk_friend</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>(</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>friend_1_id</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000;font-weight:700>,</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>firned_2_id</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>PRIMARY</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>KEY</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>(</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>id</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>ENGINE</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#000>InnoDB</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><p>虽然这个题干中，并没有说到friend表的索引结构。但我猜测friend_1_id和friend_2_id也有索引，为便于描述，我给加上唯一索引。</p><p>顺便说明一下，“like”是关键字，我一般不建议使用关键字作为库名、表名、字段名或索引名。</p><p>我把他的疑问翻译一下，在并发场景下，同时有两个人，设置为关注对方，就可能导致无法成功加为朋友关系。</p><p>现在，我用你已经熟悉的时刻顺序表的形式，把这两个事务的执行语句列出来：</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211117230131.png style=display:block;width:80% alt=NAME align=center></div><p>由于一开始A和B之间没有关注关系，所以两个事务里面的select语句查出来的结果都是空。</p><p>因此，session 1的逻辑就是“既然B没有关注A，那就只插入一个单向关注关系”。session 2也同样是这个逻辑。</p><p>这个结果对业务来说就是bug了。因为在业务设定里面，这两个逻辑都执行完成以后，是应该在friend表里面插入一行记录的。</p><p>如提问里面说的，“第1步即使使用了排他锁也不行，因为记录不存在，行锁无法生效”。不过，我想到了另外一个方法，来解决这个问题。</p><p>首先，要给“like”表增加一个字段，比如叫作 relation_ship，并设为整型，取值1、2、3。</p><blockquote><p>值是1的时候，表示user_id 关注 liker_id;
值是2的时候，表示liker_id 关注 user_id;
值是3的时候，表示互相关注。</p></blockquote><p>然后，当 A关注B的时候，逻辑改成如下所示的样子：</p><p>应用代码里面，比较A和B的大小，如果A&lt;B，就执行下面的逻辑</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span><span style=color:#000>mysql</span><span style=color:#ce5c00;font-weight:700>&gt;</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>begin</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#8f5902;font-style:italic>/*启动事务*/</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>insert</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>into</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#204a87;font-weight:700>like</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>user_id</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>liker_id</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>relation_ship</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>values</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>A</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>B</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>on</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>duplicate</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>key</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>update</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>relation_ship</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#000>relation_ship</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>|</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>select</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>relation_ship</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>from</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#204a87;font-weight:700>like</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>where</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>user_id</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#000>A</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>and</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>liker_id</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#000>B</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#8f5902;font-style:italic>/*代码中判断返回的 relation_ship，
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>  如果是1，事务结束，执行 commit
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>  如果是3，则执行下面这两个语句：
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>  */</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>insert</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>ignore</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>into</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>friend</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>friend_1_id</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>friend_2_id</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>values</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>A</span><span style=color:#000;font-weight:700>,</span><span style=color:#000>B</span><span style=color:#000;font-weight:700>);</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#000>commit</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><p>如果A>B，则执行下面的逻辑</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span><span style=color:#000>mysql</span><span style=color:#ce5c00;font-weight:700>&gt;</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>begin</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#8f5902;font-style:italic>/*启动事务*/</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>insert</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>into</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#204a87;font-weight:700>like</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>user_id</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>liker_id</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>relation_ship</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>values</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>B</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>A</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#0000cf;font-weight:700>2</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>on</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>duplicate</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>key</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>update</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>relation_ship</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#000>relation_ship</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>|</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#0000cf;font-weight:700>2</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>select</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>relation_ship</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>from</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#204a87;font-weight:700>like</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>where</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>user_id</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#000>B</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>and</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>liker_id</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#000>A</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#8f5902;font-style:italic>/*代码中判断返回的 relation_ship，
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>  如果是2，事务结束，执行 commit
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>  如果是3，则执行下面这两个语句：
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>*/</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>insert</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>ignore</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>into</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>friend</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>friend_1_id</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>friend_2_id</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>values</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>B</span><span style=color:#000;font-weight:700>,</span><span style=color:#000>A</span><span style=color:#000;font-weight:700>);</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#000>commit</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><p>这个设计里，让“like”表里的数据保证user_id &lt; liker_id，这样不论是A关注B，还是B关注A，在操作“like”表的时候，如果反向的关系已经存在，就会出现行锁冲突。</p><p>然后，insert … on duplicate语句，确保了在事务内部，执行了这个SQL语句后，就强行占住了这个行锁，之后的select 判断relation_ship这个逻辑时就确保了是在行锁保护下的读操作。</p><p>操作符 “|” 是按位或，连同最后一句insert语句里的ignore，是为了保证重复调用时的幂等性。</p><p>这样，即使在双方“同时”执行关注操作，最终数据库里的结果，也是like表里面有一条关于A和B的记录，而且relation_ship的值是3， 并且friend表里面也有了A和B的这条记录。</p><p>不知道你会不会吐槽：之前明明还说尽量不要使用唯一索引，结果这个例子一上来我就创建了两个。这里我要再和你说明一下，之前文章我们讨论的，是在“业务开发保证不会插入重复记录”的情况下，着重要解决性能问题的时候，才建议尽量使用普通索引。</p><p>而像这个例子里，按照这个设计，业务根本就是保证“我一定会插入重复数据，数据库一定要要有唯一性约束”，这时就没啥好说的了，唯一索引建起来吧。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-b807b194725472ab54d11fa9ec4d9df1>5.16 - CH16-Orderby 实现</h1><p>在你开发应用的时候，一定会经常碰到需要根据指定的字段排序来显示结果的需求。还是以我们前面举例用过的市民表为例，假设你要查询城市是“杭州”的所有人名字，并且按照姓名排序返回前1000个人的姓名、年龄。</p><p>假设这个表的部分定义是这样的：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span><span style=color:#204a87;font-weight:700>CREATE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>TABLE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>t</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>(</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>id</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>int</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>11</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>NOT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>NULL</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>city</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>varchar</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>16</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>NOT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>NULL</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>name</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>varchar</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>16</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>NOT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>NULL</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>age</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>int</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>11</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>NOT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>NULL</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>addr</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>varchar</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>128</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>DEFAULT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>NULL</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>PRIMARY</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>KEY</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>(</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>id</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000;font-weight:700>),</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>KEY</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>city</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>(</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>city</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>ENGINE</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#000>InnoDB</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><p>这时，你的SQL语句可以这么写：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>select city,name,age from t where city=&#39;杭州&#39; order by name limit 1000  ;
</span></span></code></pre></div><p>这个语句看上去逻辑很清晰，但是你了解它的执行流程吗？今天，我就和你聊聊这个语句是怎么执行的，以及有什么参数会影响执行的行为。</p><h2 id=全字段排序>全字段排序</h2><p>前面我们介绍过索引，所以你现在就很清楚了，为避免全表扫描，我们需要在city字段加上索引。</p><p>在city字段上创建索引之后，我们用explain命令来看看这个语句的执行情况。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211103222013.png style=display:block;width:80% alt=NAME align=center></div><p>Extra这个字段中的“Using filesort”表示的就是需要排序，MySQL会给每个线程分配一块内存用于排序，称为sort_buffer。</p><p>为了说明这个SQL查询语句的执行过程，我们先来看一下city这个索引的示意图。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211103222025.png style=display:block;width:80% alt=NAME align=center></div><p>从图中可以看到，满足city=&lsquo;杭州’条件的行，是从ID_X到ID_(X+N)的这些记录。</p><p>通常情况下，这个语句执行流程如下所示 ：</p><ol><li>初始化sort_buffer，确定放入name、city、age这三个字段；</li><li>从索引city找到第一个满足city=&lsquo;杭州’条件的主键id，也就是图中的ID_X；</li><li>到主键id索引取出整行，取name、city、age三个字段的值，存入sort_buffer中；</li><li>从索引city取下一个记录的主键id；</li><li>重复步骤3、4直到city的值不满足查询条件为止，对应的主键id也就是图中的ID_Y；</li><li>对sort_buffer中的数据按照字段name做快速排序；</li><li>按照排序结果取前1000行返回给客户端。</li></ol><p>我们暂且把这个排序过程，称为全字段排序，执行流程的示意图如下所示，下一篇文章中我们还会用到这个排序。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211103222037.png style=display:block;width:80% alt=NAME align=center></div><p>图中“按name排序”这个动作，可能在内存中完成，也可能需要使用外部排序，这取决于排序所需的内存和参数sort_buffer_size。</p><p>sort_buffer_size，就是MySQL为排序开辟的内存（sort_buffer）的大小。如果要排序的数据量小于sort_buffer_size，排序就在内存中完成。但如果排序数据量太大，内存放不下，则不得不利用磁盘临时文件辅助排序。</p><p>你可以用下面介绍的方法，来确定一个排序语句是否使用了临时文件。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span><span style=color:#8f5902;font-style:italic>/* 打开optimizer_trace，只对本线程有效 */</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>SET</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>optimizer_trace</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#4e9a06>&#39;enabled=on&#39;</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline> 
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#8f5902;font-style:italic>/* @a保存Innodb_rows_read的初始值 */</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>select</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>VARIABLE_VALUE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>into</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>@</span><span style=color:#000>a</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>from</span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#000>performance_schema</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>session_status</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>where</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>variable_name</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#4e9a06>&#39;Innodb_rows_read&#39;</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#8f5902;font-style:italic>/* 执行语句 */</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>select</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>city</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>name</span><span style=color:#000;font-weight:700>,</span><span style=color:#000>age</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>from</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>t</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>where</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>city</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#4e9a06>&#39;杭州&#39;</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>order</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>by</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>name</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>limit</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#0000cf;font-weight:700>1000</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline> 
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#8f5902;font-style:italic>/* 查看 OPTIMIZER_TRACE 输出 */</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>SELECT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>*</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>FROM</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>information_schema</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000;font-weight:700>.</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>OPTIMIZER_TRACE</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#a40000>\</span><span style=color:#000>G</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#8f5902;font-style:italic>/* @b保存Innodb_rows_read的当前值 */</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>select</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>VARIABLE_VALUE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>into</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>@</span><span style=color:#000>b</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>from</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>performance_schema</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>session_status</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>where</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>variable_name</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#4e9a06>&#39;Innodb_rows_read&#39;</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#8f5902;font-style:italic>/* 计算Innodb_rows_read差值 */</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>select</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>@</span><span style=color:#000>b</span><span style=color:#ce5c00;font-weight:700>-@</span><span style=color:#000>a</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><p>这个方法是通过查看 OPTIMIZER_TRACE 的结果来确认的，你可以从 number_of_tmp_files中看到是否使用了临时文件。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211103222050.png style=display:block;width:80% alt=NAME align=center></div><p>number_of_tmp_files表示的是，排序过程中使用的临时文件数。你一定奇怪，为什么需要12个文件？内存放不下时，就需要使用外部排序，外部排序一般使用归并排序算法。可以这么简单理解，<strong>MySQL将需要排序的数据分成12份，每一份单独排序后存在这些临时文件中。然后把这12个有序文件再合并成一个有序的大文件。</strong></p><p>如果sort_buffer_size超过了需要排序的数据量的大小，number_of_tmp_files就是0，表示排序可以直接在内存中完成。</p><p>否则就需要放在临时文件中排序。sort_buffer_size越小，需要分成的份数越多，number_of_tmp_files的值就越大。</p><p>接下来，我再和你解释一下图4中其他两个值的意思。</p><p>我们的示例表中有4000条满足city=&lsquo;杭州’的记录，所以你可以看到 examined_rows=4000，表示参与排序的行数是4000行。</p><p>sort_mode 里面的packed_additional_fields的意思是，排序过程对字符串做了“紧凑”处理。即使name字段的定义是varchar(16)，在排序过程中还是要按照实际长度来分配空间的。</p><p>同时，最后一个查询语句select @b-@a 的返回结果是4000，表示整个执行过程只扫描了4000行。</p><p>这里需要注意的是，为了避免对结论造成干扰，我把internal_tmp_disk_storage_engine设置成MyISAM。否则，select @b-@a的结果会显示为4001。</p><p>这是因为查询OPTIMIZER_TRACE这个表时，需要用到临时表，而internal_tmp_disk_storage_engine的默认值是InnoDB。如果使用的是InnoDB引擎的话，把数据从临时表取出来的时候，会让Innodb_rows_read的值加1。</p><h2 id=rowid-排序>rowid 排序</h2><p>在上面这个算法过程里面，只对原表的数据读了一遍，剩下的操作都是在sort_buffer和临时文件中执行的。但这个算法有一个问题，就是如果查询要返回的字段很多的话，那么sort_buffer里面要放的字段数太多，这样内存里能够同时放下的行数很少，要分成很多个临时文件，排序的性能会很差。</p><p>所以如果单行很大，这个方法效率不够好。</p><p>那么，<strong>如果MySQL认为排序的单行长度太大会怎么做呢？</strong></p><p>接下来，我来修改一个参数，让MySQL采用另外一种算法。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>SET max_length_for_sort_data = 16;
</span></span></code></pre></div><p>max_length_for_sort_data，是MySQL中专门控制用于排序的行数据的长度的一个参数。它的意思是，如果单行的长度超过这个值，MySQL就认为单行太大，要换一个算法。</p><p>city、name、age 这三个字段的定义总长度是36，我把max_length_for_sort_data设置为16，我们再来看看计算过程有什么改变。</p><p>新的算法放入sort_buffer的字段，只有要排序的列（即name字段）和主键id。</p><p>但这时，排序的结果就因为少了city和age字段的值，不能直接返回了，整个执行流程就变成如下所示的样子：</p><ol><li>初始化sort_buffer，确定放入两个字段，即name和id；</li><li>从索引city找到第一个满足city=&lsquo;杭州’条件的主键id，也就是图中的ID_X；</li><li>到主键id索引取出整行，取name、id这两个字段，存入sort_buffer中；</li><li>从索引city取下一个记录的主键id；</li><li>重复步骤3、4直到不满足city=&lsquo;杭州’条件为止，也就是图中的ID_Y；</li><li>对sort_buffer中的数据按照字段name进行排序；</li><li>遍历排序结果，取前1000行，并按照id的值回到原表中取出city、name和age三个字段返回给客户端。</li></ol><p>这个执行流程的示意图如下，我把它称为rowid排序。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211103222113.png style=display:block;width:80% alt=NAME align=center></div><p>对比图3的全字段排序流程图你会发现，rowid排序多访问了一次表t的主键索引，就是步骤7。</p><p>需要说明的是，最后的“结果集”是一个逻辑概念，实际上MySQL服务端从排序后的sort_buffer中依次取出id，然后到原表查到city、name和age这三个字段的结果，不需要在服务端再耗费内存存储结果，是直接返回给客户端的。</p><p>根据这个说明过程和图示，你可以想一下，这个时候执行select @b-@a，结果会是多少呢？</p><p>现在，我们就来看看结果有什么不同。</p><p>首先，图中的examined_rows的值还是4000，表示用于排序的数据是4000行。但是select @b-@a这个语句的值变成5000了。</p><p>因为这时候除了排序过程外，在排序完成后，还要根据id去原表取值。由于语句是limit 1000，因此会多读1000行。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211103222125.png style=display:block;width:80% alt=NAME align=center></div><p>从OPTIMIZER_TRACE的结果中，你还能看到另外两个信息也变了。</p><ul><li>sort_mode变成了&lt;sort_key, rowid>，表示参与排序的只有name和id这两个字段。</li><li>number_of_tmp_files变成10了，是因为这时候参与排序的行数虽然仍然是4000行，但是每一行都变小了，因此需要排序的总数据量就变小了，需要的临时文件也相应地变少了。</li></ul><h2 id=实现对比>实现对比</h2><p>我们来分析一下，从这两个执行流程里，还能得出什么结论。</p><p>如果MySQL实在是担心排序内存太小，会影响排序效率，才会采用rowid排序算法，这样排序过程中一次可以排序更多行，但是需要再回到原表去取数据。</p><p>如果MySQL认为内存足够大，会优先选择全字段排序，把需要的字段都放到sort_buffer中，这样排序后就会直接从内存里面返回查询结果了，不用再回到原表去取数据。</p><p>这也就体现了MySQL的一个设计思想：<strong>如果内存够，就要多利用内存，尽量减少磁盘访问。</strong></p><p>对于InnoDB表来说，rowid排序会要求回表多造成磁盘读，因此不会被优先选择。</p><p>这个结论看上去有点废话的感觉，但是你要记住它，下一篇文章我们就会用到。</p><p>看到这里，你就了解了，MySQL做排序是一个成本比较高的操作。那么你会问，是不是所有的order by都需要排序操作呢？如果不排序就能得到正确的结果，那对系统的消耗会小很多，语句的执行时间也会变得更短。</p><p>其实，并不是所有的order by语句，都需要排序操作的。从上面分析的执行过程，我们可以看到，MySQL之所以需要生成临时表，并且在临时表上做排序操作，<strong>其原因是原来的数据都是无序的。</strong></p><p>你可以设想下，如果能够保证从city这个索引上取出来的行，天然就是按照name递增排序的话，是不是就可以不用再排序了呢？</p><p>确实是这样的。</p><p>所以，我们可以在这个市民表上创建一个city和name的联合索引，对应的SQL语句是：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>alter table t add index city_user(city, name);
</span></span></code></pre></div><p>作为与city索引的对比，我们来看看这个索引的示意图。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211103222145.png style=display:block;width:80% alt=NAME align=center></div><p>在这个索引里面，我们依然可以用树搜索的方式定位到第一个满足city=&lsquo;杭州’的记录，并且额外确保了，接下来按顺序取“下一条记录”的遍历过程中，只要city的值是杭州，name的值就一定是有序的。</p><p>这样整个查询过程的流程就变成了：</p><ol><li>从索引(city,name)找到第一个满足city=&lsquo;杭州’条件的主键id；</li><li>到主键id索引取出整行，取name、city、age三个字段的值，作为结果集的一部分直接返回；</li><li>从索引(city,name)取下一个记录主键id；</li><li>重复步骤2、3，直到查到第1000条记录，或者是不满足city=&lsquo;杭州’条件时循环结束。</li></ol><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211103222157.png style=display:block;width:80% alt=NAME align=center></div><p>可以看到，这个查询过程不需要临时表，也不需要排序。接下来，我们用explain的结果来印证一下。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211103222207.png style=display:block;width:80% alt=NAME align=center></div><p>从图中可以看到，Extra字段中没有Using filesort了，也就是不需要排序了。而且由于(city,name)这个联合索引本身有序，所以这个查询也不用把4000行全都读一遍，只要找到满足条件的前1000条记录就可以退出了。也就是说，在我们这个例子里，只需要扫描1000次。</p><p>既然说到这里了，我们再往前讨论，<strong>这个语句的执行流程有没有可能进一步简化呢？</strong> 不知道你还记不记得，我在第5篇文章“索引-下”中，和你介绍的覆盖索引。</p><p>这里我们可以再稍微复习一下。<strong>覆盖索引是指，索引上的信息足够满足查询请求，不需要再回到主键索引上去取数据。</strong></p><p>按照覆盖索引的概念，我们可以再优化一下这个查询语句的执行流程。</p><p>针对这个查询，我们可以创建一个city、name和age的联合索引，对应的SQL语句就是：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>alter table t add index city_user_age(city, name, age);
</span></span></code></pre></div><p>这时，对于city字段的值相同的行来说，还是按照name字段的值递增排序的，此时的查询语句也就不再需要排序了。这样整个查询语句的执行流程就变成了：</p><ol><li>从索引(city,name,age)找到第一个满足city=&lsquo;杭州’条件的记录，取出其中的city、name和age这三个字段的值，作为结果集的一部分直接返回；</li><li>从索引(city,name,age)取下一个记录，同样取出这三个字段的值，作为结果集的一部分直接返回；</li><li>重复执行步骤2，直到查到第1000条记录，或者是不满足city=&lsquo;杭州’条件时循环结束。</li></ol><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211103222220.png style=display:block;width:80% alt=NAME align=center></div><p>然后，我们再来看看explain的结果。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211103222235.png style=display:block;width:80% alt=NAME align=center></div><p>可以看到，Extra字段里面多了“Using index”，表示的就是使用了覆盖索引，性能上会快很多。</p><p>当然，这里并不是说要为了每个查询能用上覆盖索引，就要把语句中涉及的字段都建上联合索引，毕竟索引还是有维护代价的。这是一个需要权衡的决定。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-02e6b423705190731118b8e6ba37b6be>5.17 - CH17-随机查询</h1><p>我在上一篇文章，为你讲解完order by语句的几种执行模式后，就想到了之前一个做英语学习App的朋友碰到过的一个性能问题。今天这篇文章，我就从这个性能问题说起，和你说说MySQL中的另外一种排序需求，希望能够加深你对MySQL排序逻辑的理解。</p><p>这个英语学习App首页有一个随机显示单词的功能，也就是根据每个用户的级别有一个单词表，然后这个用户每次访问首页的时候，都会随机滚动显示三个单词。他们发现随着单词表变大，选单词这个逻辑变得越来越慢，甚至影响到了首页的打开速度。</p><p>现在，如果让你来设计这个SQL语句，你会怎么写呢？</p><p>为了便于理解，我对这个例子进行了简化：去掉每个级别的用户都有一个对应的单词表这个逻辑，直接就是从一个单词表中随机选出三个单词。这个表的建表语句和初始数据的命令如下：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span><span style=color:#000>mysql</span><span style=color:#ce5c00;font-weight:700>&gt;</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>CREATE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>TABLE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>words</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>(</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>id</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>int</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>11</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>NOT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>NULL</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>AUTO_INCREMENT</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>word</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>varchar</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>64</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>DEFAULT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>NULL</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>PRIMARY</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>KEY</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>(</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>id</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>ENGINE</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#000>InnoDB</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#000>delimiter</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>;;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>create</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>procedure</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>idata</span><span style=color:#000;font-weight:700>()</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#000>begin</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>declare</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>i</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>int</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>set</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>i</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#0000cf;font-weight:700>0</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>while</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>i</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>10000</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>do</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>    </span><span style=color:#204a87;font-weight:700>insert</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>into</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>words</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>word</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>values</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>concat</span><span style=color:#000;font-weight:700>(</span><span style=color:#204a87;font-weight:700>char</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>97</span><span style=color:#ce5c00;font-weight:700>+</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>i</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>div</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#0000cf;font-weight:700>1000</span><span style=color:#000;font-weight:700>)),</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>char</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>97</span><span style=color:#ce5c00;font-weight:700>+</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>i</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>%</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#0000cf;font-weight:700>1000</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>div</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#0000cf;font-weight:700>100</span><span style=color:#000;font-weight:700>)),</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>char</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>97</span><span style=color:#ce5c00;font-weight:700>+</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>i</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>%</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#0000cf;font-weight:700>100</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>div</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#0000cf;font-weight:700>10</span><span style=color:#000;font-weight:700>)),</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>char</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>97</span><span style=color:#ce5c00;font-weight:700>+</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>i</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>%</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#0000cf;font-weight:700>10</span><span style=color:#000;font-weight:700>))));</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>    </span><span style=color:#204a87;font-weight:700>set</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>i</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#000>i</span><span style=color:#ce5c00;font-weight:700>+</span><span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#000>end</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>while</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#000>end</span><span style=color:#000;font-weight:700>;;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#000>delimiter</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>call</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>idata</span><span style=color:#000;font-weight:700>();</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><p>为了便于量化说明，我在这个表里面插入了10000行记录。接下来，我们就一起看看要随机选择3个单词，有什么方法实现，存在什么问题以及如何改进。</p><h2 id=内存临时表>内存临时表</h2><p>首先，你会想到用order by rand()来实现这个逻辑。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>mysql&gt; select word from words order by rand() limit 3;
</span></span></code></pre></div><p>这个语句的意思很直白，随机排序取前3个。虽然这个SQL语句写法很简单，但执行流程却有点复杂的。</p><p>我们先用explain命令来看看这个语句的执行情况。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211103225138.png style=display:block;width:80% alt=NAME align=center></div><p>Extra字段显示Using temporary，表示的是需要使用临时表；Using filesort，表示的是需要执行排序操作。</p><p>因此这个Extra的意思就是，需要临时表，并且需要在临时表上排序。</p><p>这里，你可以先回顾一下上一章中全字段排序和rowid排序的内容。我把上一篇文章的两个流程图贴过来，方便你复习。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211103225151.png style=display:block;width:80% alt=NAME align=center></div><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211103225158.png style=display:block;width:80% alt=NAME align=center></div><p>然后，我再问你一个问题，你觉得对于临时内存表的排序来说，它会选择哪一种算法呢？回顾一下上一篇文章的一个结论：<strong>对于InnoDB表来说</strong>，执行全字段排序会减少磁盘访问，因此会被优先选择。</p><p>我强调了“InnoDB表”，你肯定想到了，<strong>对于内存表，回表过程只是简单地根据数据行的位置，直接访问内存得到数据，根本不会导致多访问磁盘</strong>。优化器没有了这一层顾虑，那么它会优先考虑的，就是用于排序的行越少越好了，所以，MySQL这时就会选择rowid排序。</p><p>理解了这个算法选择的逻辑，我们再来看看语句的执行流程。同时，通过今天的这个例子，我们来尝试分析一下语句的扫描行数。</p><p>这条语句的执行流程是这样的：</p><ol><li>创建一个临时表。这个临时表使用的是memory引擎，表里有两个字段，第一个字段是double类型，为了后面描述方便，记为字段R，第二个字段是varchar(64)类型，记为字段W。并且，这个表没有建索引。</li><li>从words表中，按主键顺序取出所有的word值。对于每一个word值，调用rand()函数生成一个大于0小于1的随机小数，并把这个随机小数和word分别存入临时表的R和W字段中，到此，扫描行数是10000。</li><li>现在临时表有10000行数据了，接下来你要在这个没有索引的内存临时表上，按照字段R排序。</li><li>初始化 sort_buffer。sort_buffer中有两个字段，一个是double类型，另一个是整型。</li><li>从内存临时表中一行一行地取出R值和位置信息（我后面会和你解释这里为什么是“位置信息”），分别存入sort_buffer中的两个字段里。这个过程要对内存临时表做全表扫描，此时扫描行数增加10000，变成了20000。</li><li>在sort_buffer中根据R的值进行排序。注意，这个过程没有涉及到表操作，所以不会增加扫描行数。</li><li>排序完成后，取出前三个结果的位置信息，依次到内存临时表中取出word值，返回给客户端。这个过程中，访问了表的三行数据，总扫描行数变成了20003。</li></ol><p>接下来，我们通过慢查询日志（slow log）来验证一下我们分析得到的扫描行数是否正确。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span># Query_time: 0.900376  Lock_time: 0.000347 Rows_sent: 3 Rows_examined: 20003
</span></span><span style=display:flex><span>SET timestamp=1541402277;
</span></span><span style=display:flex><span>select word from words order by rand() limit 3;
</span></span></code></pre></div><p>其中，Rows_examined：20003就表示这个语句执行过程中扫描了20003行，也就验证了我们分析得出的结论。</p><p>这里插一句题外话，在平时学习概念的过程中，你可以经常这样做，先通过原理分析算出扫描行数，然后再通过查看慢查询日志，来验证自己的结论。我自己就是经常这么做，这个过程很有趣，分析对了开心，分析错了但是弄清楚了也很开心。</p><p>现在，我来把完整的排序执行流程图画出来。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211103225218.png style=display:block;width:80% alt=NAME align=center></div><p>图中的pos就是位置信息，你可能会觉得奇怪，这里的“位置信息”是个什么概念？在上一篇文章中，我们对InnoDB表排序的时候，明明用的还是ID字段。</p><p>这时候，我们就要回到一个基本概念：<strong>MySQL的表是用什么方法来定位“一行数据”的。</strong></p><p>在前面第4、5篇介绍索引的文章中，有几位同学问到，如果把一个InnoDB表的主键删掉，是不是就没有主键，就没办法回表了？</p><p>其实不是的。如果你创建的表没有主键，或者把一个表的主键删掉了，那么InnoDB会自己生成一个长度为6字节的rowid来作为主键。</p><p>这也就是排序模式里面，rowid名字的来历。实际上它表示的是：每个引擎用来唯一标识数据行的信息。</p><ul><li>对于有主键的InnoDB表来说，这个rowid就是主键ID；</li><li>对于没有主键的InnoDB表来说，这个rowid就是由系统生成的；</li><li>MEMORY引擎不是索引组织表。在这个例子里面，你可以认为它就是一个数组。因此，这个rowid其实就是数组的下标。</li></ul><p>到这里，我来稍微小结一下：<strong>order by rand()使用了内存临时表，内存临时表排序的时候使用了rowid排序方法。</strong></p><h2 id=磁盘临时表>磁盘临时表</h2><p>那么，是不是所有的临时表都是内存表呢？</p><p>其实不是的。tmp_table_size这个配置限制了内存临时表的大小，默认值是16M。如果临时表大小超过了tmp_table_size，那么内存临时表就会转成磁盘临时表。</p><p>磁盘临时表使用的引擎默认是InnoDB，是由参数internal_tmp_disk_storage_engine控制的。</p><p>当使用磁盘临时表的时候，对应的就是一个没有显式索引的InnoDB表的排序过程。</p><p>为了复现这个过程，我把tmp_table_size设置成1024，把sort_buffer_size设置成 32768, 把 max_length_for_sort_data 设置成16。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span><span style=color:#204a87;font-weight:700>set</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>tmp_table_size</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#0000cf;font-weight:700>1024</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>set</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>sort_buffer_size</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#0000cf;font-weight:700>32768</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>set</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>max_length_for_sort_data</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#0000cf;font-weight:700>16</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#8f5902;font-style:italic>/* 打开 optimizer_trace，只对本线程有效 */</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>SET</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>optimizer_trace</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#4e9a06>&#39;enabled=on&#39;</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline> 
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#8f5902;font-style:italic>/* 执行语句 */</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>select</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>word</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>from</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>words</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>order</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>by</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>rand</span><span style=color:#000;font-weight:700>()</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>limit</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#0000cf;font-weight:700>3</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#8f5902;font-style:italic>/* 查看 OPTIMIZER_TRACE 输出 */</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>SELECT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>*</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>FROM</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>information_schema</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000;font-weight:700>.</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>OPTIMIZER_TRACE</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#a40000>\</span><span style=color:#000>G</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211103225241.png style=display:block;width:80% alt=NAME align=center></div><p>然后，我们来看一下这次OPTIMIZER_TRACE的结果。</p><p>因为将max_length_for_sort_data设置成16，小于word字段的长度定义，所以我们看到sort_mode里面显示的是rowid排序，这个是符合预期的，参与排序的是随机值R字段和rowid字段组成的行。</p><p>这时候你可能心算了一下，发现不对。R字段存放的随机值就8个字节，rowid是6个字节（至于为什么是6字节，就留给你课后思考吧），数据总行数是10000，这样算出来就有140000字节，超过了sort_buffer_size 定义的 32768字节了。但是，number_of_tmp_files的值居然是0，难道不需要用临时文件吗？</p><p>这个SQL语句的排序确实没有用到临时文件，采用是MySQL 5.6版本引入的一个新的排序算法，即：优先队列排序算法。接下来，我们就看看为什么没有使用临时文件的算法，也就是归并排序算法，而是采用了优先队列排序算法。</p><p>其实，我们现在的SQL语句，只需要取R值最小的3个rowid。但是，如果使用归并排序算法的话，虽然最终也能得到前3个值，但是这个算法结束后，已经将10000行数据都排好序了。</p><p>也就是说，后面的9997行也是有序的了。但，我们的查询并不需要这些数据是有序的。所以，想一下就明白了，这浪费了非常多的计算量。</p><p>而优先队列算法，就可以精确地只得到三个最小值，执行流程如下：</p><ol><li>对于这10000个准备排序的(R,rowid)，先取前三行，构造成一个堆；</li></ol><p>（对数据结构印象模糊的同学，可以先设想成这是一个由三个元素组成的数组）</p><ol><li>取下一个行(R’,rowid’)，跟当前堆里面最大的R比较，如果R’小于R，把这个(R,rowid)从堆中去掉，换成(R’,rowid’)；</li><li>重复第2步，直到第10000个(R’,rowid’)完成比较。</li></ol><p>这里我简单画了一个优先队列排序过程的示意图。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211103225254.png style=display:block;width:80% alt=NAME align=center></div><p>图6是模拟6个(R,rowid)行，通过优先队列排序找到最小的三个R值的行的过程。整个排序过程中，为了最快地拿到当前堆的最大值，总是保持最大值在堆顶，因此这是一个最大堆。</p><p>图5的OPTIMIZER_TRACE结果中，filesort_priority_queue_optimization这个部分的chosen=true，就表示使用了优先队列排序算法，这个过程不需要临时文件，因此对应的number_of_tmp_files是0。</p><p>这个流程结束后，我们构造的堆里面，就是这个10000行里面R值最小的三行。然后，依次把它们的rowid取出来，去临时表里面拿到word字段，这个过程就跟上一篇文章的rowid排序的过程一样了。</p><p>我们再看一下上面一篇文章的SQL查询语句：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>select city,name,age from t where city=&#39;杭州&#39; order by name limit 1000  ;
</span></span></code></pre></div><p>你可能会问，这里也用到了limit，为什么没用优先队列排序算法呢？原因是，这条SQL语句是limit 1000，如果使用优先队列算法的话，需要维护的堆的大小就是1000行的(name,rowid)，超过了我设置的sort_buffer_size大小，所以只能使用归并排序算法。</p><p>总之，不论是使用哪种类型的临时表，order by rand()这种写法都会让计算过程非常复杂，需要大量的扫描行数，因此排序过程的资源消耗也会很大。</p><p>再回到我们文章开头的问题，怎么正确地随机排序呢？</p><h2 id=随机排序方法>随机排序方法</h2><p>我们先把问题简化一下，如果只随机选择1个word值，可以怎么做呢？思路上是这样的：</p><ol><li>取得这个表的主键id的最大值M和最小值N;</li><li>用随机函数生成一个最大值到最小值之间的数 X = (M-N)*rand() + N;</li><li>取不小于X的第一个ID的行。</li></ol><p>我们把这个算法，暂时称作随机算法1。这里，我直接给你贴一下执行语句的序列:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>mysql&gt; select max(id),min(id) into @M,@N from t ;
</span></span><span style=display:flex><span>set @X= floor((@M-@N+1)*rand() + @N);
</span></span><span style=display:flex><span>select * from t where id &gt;= @X limit 1;
</span></span></code></pre></div><p>这个方法效率很高，因为取max(id)和min(id)都是不需要扫描索引的，而第三步的select也可以用索引快速定位，可以认为就只扫描了3行。但实际上，这个算法本身并不严格满足题目的随机要求，因为ID中间可能有空洞，因此选择不同行的概率不一样，不是真正的随机。</p><p>比如你有4个id，分别是1、2、4、5，如果按照上面的方法，那么取到 id=4的这一行的概率是取得其他行概率的两倍。</p><p>如果这四行的id分别是1、2、40000、40001呢？这个算法基本就能当bug来看待了。</p><p>所以，为了得到严格随机的结果，你可以用下面这个流程:</p><ol><li>取得整个表的行数，并记为C。</li><li>取得 Y = floor(C * rand())。 floor函数在这里的作用，就是取整数部分。</li><li>再用limit Y,1 取得一行。</li></ol><p>我们把这个算法，称为随机算法2。下面这段代码，就是上面流程的执行语句的序列。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>mysql&gt; select count(*) into @C from t;
</span></span><span style=display:flex><span>set @Y = floor(@C * rand());
</span></span><span style=display:flex><span>set @sql = concat(&#34;select * from t limit &#34;, @Y, &#34;,1&#34;);
</span></span><span style=display:flex><span>prepare stmt from @sql;
</span></span><span style=display:flex><span>execute stmt;
</span></span><span style=display:flex><span>DEALLOCATE prepare stmt;
</span></span></code></pre></div><p>由于limit 后面的参数不能直接跟变量，所以我在上面的代码中使用了prepare+execute的方法。你也可以把拼接SQL语句的方法写在应用程序中，会更简单些。</p><p>这个随机算法2，解决了算法1里面明显的概率不均匀问题。</p><p>MySQL处理limit Y,1 的做法就是按顺序一个一个地读出来，丢掉前Y个，然后把下一个记录作为返回结果，因此这一步需要扫描Y+1行。再加上，第一步扫描的C行，总共需要扫描C+Y+1行，执行代价比随机算法1的代价要高。</p><p>当然，随机算法2跟直接order by rand()比起来，执行代价还是小很多的。</p><p>你可能问了，如果按照这个表有10000行来计算的话，C=10000，要是随机到比较大的Y值，那扫描行数也跟20000差不多了，接近order by rand()的扫描行数，为什么说随机算法2的代价要小很多呢？我就把这个问题留给你去课后思考吧。</p><p>现在，我们再看看，如果我们按照随机算法2的思路，要随机取3个word值呢？你可以这么做：</p><ol><li>取得整个表的行数，记为C；</li><li>根据相同的随机方法得到Y1、Y2、Y3；</li><li>再执行三个limit Y, 1语句得到三行数据。</li></ol><p>我们把这个算法，称作随机算法3。下面这段代码，就是上面流程的执行语句的序列。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>mysql&gt; select count(*) into @C from t;
</span></span><span style=display:flex><span>set @Y1 = floor(@C * rand());
</span></span><span style=display:flex><span>set @Y2 = floor(@C * rand());
</span></span><span style=display:flex><span>set @Y3 = floor(@C * rand());
</span></span><span style=display:flex><span>select * from t limit @Y1，1； //在应用代码里面取Y1、Y2、Y3值，拼出SQL后执行
</span></span><span style=display:flex><span>select * from t limit @Y2，1；
</span></span><span style=display:flex><span>select * from t limit @Y3，1；
</span></span></code></pre></div></div><div class=td-content style=page-break-before:always><h1 id=pg-c97a922d5ae648249382bedaf569f0b9>5.18 - CH18-性能案例</h1><h2 id=案例一条件字段函数操作>案例一：条件字段函数操作</h2><p>假设你现在维护了一个交易系统，其中交易记录表tradelog包含交易流水号（tradeid）、交易员id（operator）、交易时间（t_modified）等字段。为了便于描述，我们先忽略其他字段。这个表的建表语句如下：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span><span style=color:#000>mysql</span><span style=color:#ce5c00;font-weight:700>&gt;</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>CREATE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>TABLE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>tradelog</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>(</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>id</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>int</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>11</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>NOT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>NULL</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>tradeid</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>varchar</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>32</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>DEFAULT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>NULL</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>operator</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>int</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>11</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>DEFAULT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>NULL</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>t_modified</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>datetime</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>DEFAULT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>NULL</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>PRIMARY</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>KEY</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>(</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>id</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000;font-weight:700>),</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>KEY</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>tradeid</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>(</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>tradeid</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000;font-weight:700>),</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>KEY</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>t_modified</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>(</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>t_modified</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>ENGINE</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#000>InnoDB</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>DEFAULT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>CHARSET</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#000>utf8mb4</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><p>假设，现在已经记录了从2016年初到2018年底的所有数据，运营部门有一个需求是，要统计发生在所有年份中7月份的交易记录总数。这个逻辑看上去并不复杂，你的SQL语句可能会这么写：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>mysql&gt; select count(*) from tradelog where month(t_modified)=7;
</span></span></code></pre></div><p>由于t_modified字段上有索引，于是你就很放心地在生产库中执行了这条语句，但却发现执行了特别久，才返回了结果。</p><p>如果你问DBA同事为什么会出现这样的情况，他大概会告诉你：如果对字段做了函数计算，就用不上索引了，这是MySQL的规定。</p><p>现在你已经学过了InnoDB的索引结构了，可以再追问一句为什么？为什么条件是where t_modified=&lsquo;2018-7-1’的时候可以用上索引，而改成where month(t_modified)=7的时候就不行了？</p><p>下面是这个t_modified索引的示意图。方框上面的数字就是month()函数对应的值。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211103232841.png style=display:block;width:80% alt=NAME align=center></div><p>如果你的SQL语句条件用的是where t_modified=&lsquo;2018-7-1’的话，引擎就会按照上面绿色箭头的路线，快速定位到 t_modified=&lsquo;2018-7-1’需要的结果。</p><p>实际上，B+树提供的这个快速定位能力，来源于同一层兄弟节点的有序性。</p><p>但是，如果计算month()函数的话，你会看到传入7的时候，在树的第一层就不知道该怎么办了。</p><p>也就是说，<strong>对索引字段做函数操作，可能会破坏索引值的有序性，因此优化器就决定放弃走树搜索功能。</strong></p><p>需要注意的是，优化器并不是要放弃使用这个索引。</p><p>在这个例子里，放弃了树搜索功能，优化器可以选择遍历主键索引，也可以选择遍历索引t_modified，优化器对比索引大小后发现，索引t_modified更小，遍历这个索引比遍历主键索引来得更快。因此最终还是会选择索引t_modified。</p><p>接下来，我们使用explain命令，查看一下这条SQL语句的执行结果。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211103232853.png style=display:block;width:80% alt=NAME align=center></div><p>key=&ldquo;t_modified"表示的是，使用了t_modified这个索引；我在测试表数据中插入了10万行数据，rows=100335，说明这条语句扫描了整个索引的所有值；Extra字段的Using index，表示的是使用了覆盖索引。</p><p>也就是说，由于在t_modified字段加了month()函数操作，导致了全索引扫描。为了能够用上索引的快速定位能力，我们就要把SQL语句改成基于字段本身的范围查询。按照下面这个写法，优化器就能按照我们预期的，用上t_modified索引的快速定位能力了。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>mysql&gt; select count(*) from tradelog where
</span></span><span style=display:flex><span>    -&gt; (t_modified &gt;= &#39;2016-7-1&#39; and t_modified&lt;&#39;2016-8-1&#39;) or
</span></span><span style=display:flex><span>    -&gt; (t_modified &gt;= &#39;2017-7-1&#39; and t_modified&lt;&#39;2017-8-1&#39;) or 
</span></span><span style=display:flex><span>    -&gt; (t_modified &gt;= &#39;2018-7-1&#39; and t_modified&lt;&#39;2018-8-1&#39;);
</span></span></code></pre></div><p>当然，如果你的系统上线时间更早，或者后面又插入了之后年份的数据的话，你就需要再把其他年份补齐。</p><p>到这里我给你说明了，由于加了month()函数操作，MySQL无法再使用索引快速定位功能，而只能使用全索引扫描。</p><p>不过优化器在个问题上确实有“偷懒”行为，即使是对于不改变有序性的函数，也不会考虑使用索引。比如，对于select * from tradelog where id + 1 = 10000这个SQL语句，这个加1操作并不会改变有序性，但是MySQL优化器还是不能用id索引快速定位到9999这一行。所以，需要你在写SQL语句的时候，手动改写成 where id = 10000 -1才可以。</p><h2 id=案例二隐式类型转换>案例二：隐式类型转换</h2><p>接下来我再跟你说一说，另一个经常让程序员掉坑里的例子。</p><p>我们一起看一下这条SQL语句：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>mysql&gt; select * from tradelog where tradeid=110717;
</span></span></code></pre></div><p>交易编号tradeid这个字段上，本来就有索引，但是explain的结果却显示，这条语句需要走全表扫描。你可能也发现了，tradeid的字段类型是varchar(32)，而输入的参数却是整型，所以需要做类型转换。</p><p>那么，现在这里就有两个问题：</p><ol><li>数据类型转换的规则是什么？</li><li>为什么有数据类型转换，就需要走全索引扫描？</li></ol><p>先来看第一个问题，你可能会说，数据库里面类型这么多，这种数据类型转换规则更多，我记不住，应该怎么办呢？</p><p>这里有一个简单的方法，看 select “10” > 9的结果：</p><ol><li>如果规则是“将字符串转成数字”，那么就是做数字比较，结果应该是1；</li><li>如果规则是“将数字转成字符串”，那么就是做字符串比较，结果应该是0。</li></ol><p>验证结果如图3所示。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211103232914.png style=display:block;width:80% alt=NAME align=center></div><p>从图中可知，select “10” > 9返回的是1，所以你就能确认MySQL里的转换规则了：在MySQL中，字符串和数字做比较的话，是将字符串转换成数字。</p><p>这时，你再看这个全表扫描的语句：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>mysql&gt; select * from tradelog where tradeid=110717;
</span></span></code></pre></div><p>就知道对于优化器来说，这个语句相当于：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>mysql&gt; select * from tradelog where  CAST(tradid AS signed int) = 110717;
</span></span></code></pre></div><p>也就是说，这条语句触发了我们上面说到的规则：对索引字段做函数操作，优化器会放弃走树搜索功能。</p><p>现在，我留给你一个小问题，id的类型是int，如果执行下面这个语句，是否会导致全表扫描呢？</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>select * from tradelog where id=&#34;83126&#34;;
</span></span></code></pre></div><p>你可以先自己分析一下，再到数据库里面去验证确认。</p><p>接下来，我们再来看一个稍微复杂点的例子。</p><h2 id=案例三隐式字符编码转换>案例三：隐式字符编码转换</h2><p>假设系统里还有另外一个表trade_detail，用于记录交易的操作细节。为了便于量化分析和复现，我往交易日志表tradelog和交易详情表trade_detail这两个表里插入一些数据。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span><span style=color:#000>mysql</span><span style=color:#ce5c00;font-weight:700>&gt;</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>CREATE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>TABLE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>trade_detail</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>(</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>id</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>int</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>11</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>NOT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>NULL</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>tradeid</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>varchar</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>32</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>DEFAULT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>NULL</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>trade_step</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>int</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>11</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>DEFAULT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>NULL</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#8f5902;font-style:italic>/*操作步骤*/</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>step_info</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>varchar</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>32</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>DEFAULT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>NULL</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#8f5902;font-style:italic>/*步骤信息*/</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>PRIMARY</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>KEY</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>(</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>id</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000;font-weight:700>),</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>KEY</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>tradeid</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>(</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>tradeid</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>ENGINE</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#000>InnoDB</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>DEFAULT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>CHARSET</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#000>utf8</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>insert</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>into</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>tradelog</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>values</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#4e9a06>&#39;aaaaaaaa&#39;</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#0000cf;font-weight:700>1000</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>now</span><span style=color:#000;font-weight:700>());</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>insert</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>into</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>tradelog</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>values</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>2</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#4e9a06>&#39;aaaaaaab&#39;</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#0000cf;font-weight:700>1000</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>now</span><span style=color:#000;font-weight:700>());</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>insert</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>into</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>tradelog</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>values</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>3</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#4e9a06>&#39;aaaaaaac&#39;</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#0000cf;font-weight:700>1000</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>now</span><span style=color:#000;font-weight:700>());</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>insert</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>into</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>trade_detail</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>values</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#4e9a06>&#39;aaaaaaaa&#39;</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#4e9a06>&#39;add&#39;</span><span style=color:#000;font-weight:700>);</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>insert</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>into</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>trade_detail</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>values</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>2</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#4e9a06>&#39;aaaaaaaa&#39;</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#0000cf;font-weight:700>2</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#4e9a06>&#39;update&#39;</span><span style=color:#000;font-weight:700>);</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>insert</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>into</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>trade_detail</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>values</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>3</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#4e9a06>&#39;aaaaaaaa&#39;</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#0000cf;font-weight:700>3</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#4e9a06>&#39;commit&#39;</span><span style=color:#000;font-weight:700>);</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>insert</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>into</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>trade_detail</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>values</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>4</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#4e9a06>&#39;aaaaaaab&#39;</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#4e9a06>&#39;add&#39;</span><span style=color:#000;font-weight:700>);</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>insert</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>into</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>trade_detail</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>values</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>5</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#4e9a06>&#39;aaaaaaab&#39;</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#0000cf;font-weight:700>2</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#4e9a06>&#39;update&#39;</span><span style=color:#000;font-weight:700>);</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>insert</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>into</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>trade_detail</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>values</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>6</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#4e9a06>&#39;aaaaaaab&#39;</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#0000cf;font-weight:700>3</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#4e9a06>&#39;update again&#39;</span><span style=color:#000;font-weight:700>);</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>insert</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>into</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>trade_detail</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>values</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>7</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#4e9a06>&#39;aaaaaaab&#39;</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#0000cf;font-weight:700>4</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#4e9a06>&#39;commit&#39;</span><span style=color:#000;font-weight:700>);</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>insert</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>into</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>trade_detail</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>values</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>8</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#4e9a06>&#39;aaaaaaac&#39;</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#4e9a06>&#39;add&#39;</span><span style=color:#000;font-weight:700>);</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>insert</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>into</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>trade_detail</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>values</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>9</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#4e9a06>&#39;aaaaaaac&#39;</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#0000cf;font-weight:700>2</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#4e9a06>&#39;update&#39;</span><span style=color:#000;font-weight:700>);</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>insert</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>into</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>trade_detail</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>values</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>10</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#4e9a06>&#39;aaaaaaac&#39;</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#0000cf;font-weight:700>3</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#4e9a06>&#39;update again&#39;</span><span style=color:#000;font-weight:700>);</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>insert</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>into</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>trade_detail</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>values</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>11</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#4e9a06>&#39;aaaaaaac&#39;</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#0000cf;font-weight:700>4</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#4e9a06>&#39;commit&#39;</span><span style=color:#000;font-weight:700>);</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><p>这时候，如果要查询id=2的交易的所有操作步骤信息，SQL语句可以这么写：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>mysql&gt; select d.* from tradelog l, trade_detail d where d.tradeid=l.tradeid and l.id=2; /*语句Q1*/
</span></span></code></pre></div><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211103232936.png style=display:block;width:80% alt=NAME align=center></div><p>我们一起来看下这个结果：</p><ol><li>第一行显示优化器会先在交易记录表tradelog上查到id=2的行，这个步骤用上了主键索引，rows=1表示只扫描一行；</li><li>第二行key=NULL，表示没有用上交易详情表trade_detail上的tradeid索引，进行了全表扫描。</li></ol><p>在这个执行计划里，是从tradelog表中取tradeid字段，再去trade_detail表里查询匹配字段。因此，我们把tradelog称为驱动表，把trade_detail称为被驱动表，把tradeid称为关联字段。</p><p>接下来，我们看下这个explain结果表示的执行流程：</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211103232946.png style=display:block;width:80% alt=NAME align=center></div><p>图中：</p><ul><li>第1步，是根据id在tradelog表里找到L2这一行；</li><li>第2步，是从L2中取出tradeid字段的值；</li><li>第3步，是根据tradeid值到trade_detail表中查找条件匹配的行。explain的结果里面第二行的key=NULL表示的就是，这个过程是通过遍历主键索引的方式，一个一个地判断tradeid的值是否匹配。</li></ul><p>进行到这里，你会发现第3步不符合我们的预期。因为表trade_detail里tradeid字段上是有索引的，我们本来是希望通过使用tradeid索引能够快速定位到等值的行。但，这里并没有。</p><p>如果你去问DBA同学，他们可能会告诉你，因为这两个表的字符集不同，一个是utf8，一个是utf8mb4，所以做表连接查询的时候用不上关联字段的索引。这个回答，也是通常你搜索这个问题时会得到的答案。</p><p>但是你应该再追问一下，为什么字符集不同就用不上索引呢？</p><p>我们说问题是出在执行步骤的第3步，如果单独把这一步改成SQL语句的话，那就是：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>mysql&gt; select * from trade_detail where tradeid=$L2.tradeid.value; 
</span></span></code></pre></div><p>其中，$L2.tradeid.value的字符集是utf8mb4。</p><p>参照前面的两个例子，你肯定就想到了，字符集utf8mb4是utf8的超集，所以当这两个类型的字符串在做比较的时候，MySQL内部的操作是，先把utf8字符串转成utf8mb4字符集，再做比较。</p><blockquote><p>这个设定很好理解，utf8mb4是utf8的超集。类似地，在程序设计语言里面，做自动类型转换的时候，为了避免数据在转换过程中由于截断导致数据错误，也都是“按数据长度增加的方向”进行转换的。</p></blockquote><p>因此， 在执行上面这个语句的时候，需要将被驱动数据表里的字段一个个地转换成utf8mb4，再跟L2做比较。</p><p>也就是说，实际上这个语句等同于下面这个写法：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>select * from trade_detail  where CONVERT(traideid USING utf8mb4)=$L2.tradeid.value; 
</span></span></code></pre></div><p>CONVERT()函数，在这里的意思是把输入的字符串转成utf8mb4字符集。</p><p>这就再次触发了我们上面说到的原则：对索引字段做函数操作，优化器会放弃走树搜索功能。</p><p>到这里，你终于明确了，字符集不同只是条件之一，<strong>连接过程中要求在被驱动表的索引字段上加函数操作</strong>，是直接导致对被驱动表做全表扫描的原因。</p><p>作为对比验证，我给你提另外一个需求，“查找trade_detail表里id=4的操作，对应的操作者是谁”，再来看下这个语句和它的执行计划。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>mysql&gt;select l.operator from tradelog l , trade_detail d where d.tradeid=l.tradeid and d.id=4;
</span></span></code></pre></div><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211103233001.png style=display:block;width:80% alt=NAME align=center></div><p>这个语句里trade_detail 表成了驱动表，但是explain结果的第二行显示，这次的查询操作用上了被驱动表tradelog里的索引(tradeid)，扫描行数是1。</p><p>这也是两个tradeid字段的join操作，为什么这次能用上被驱动表的tradeid索引呢？我们来分析一下。</p><p>假设驱动表trade_detail里id=4的行记为R4，那么在连接的时候（图5的第3步），被驱动表tradelog上执行的就是类似这样的SQL 语句：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>select operator from tradelog  where traideid =$R4.tradeid.value; 
</span></span></code></pre></div><p>这时候$R4.tradeid.value的字符集是utf8, 按照字符集转换规则，要转成utf8mb4，所以这个过程就被改写成：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>select operator from tradelog  where traideid =CONVERT($R4.tradeid.value USING utf8mb4); 
</span></span></code></pre></div><p>你看，这里的CONVERT函数是加在输入参数上的，这样就可以用上被驱动表的traideid索引。</p><p>理解了原理以后，就可以用来指导操作了。如果要优化语句</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>select d.* from tradelog l, trade_detail d where d.tradeid=l.tradeid and l.id=2;
</span></span></code></pre></div><p>的执行过程，有两种做法：</p><ul><li>比较常见的优化方法是，把trade_detail表上的tradeid字段的字符集也改成utf8mb4，这样就没有字符集转换的问题了。</li></ul><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>alter table trade_detail modify tradeid varchar(32) CHARACTER SET utf8mb4 default null;
</span></span></code></pre></div><ul><li>如果能够修改字段的字符集的话，是最好不过了。但如果数据量比较大， 或者业务上暂时不能做这个DDL的话，那就只能采用修改SQL语句的方法了。</li></ul><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>mysql&gt; select d.* from tradelog l , trade_detail d where d.tradeid=CONVERT(l.tradeid USING utf8) and l.id=2; 
</span></span></code></pre></div><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211103233015.png style=display:block;width:80% alt=NAME align=center></div><p>这里，我主动把 l.tradeid转成utf8，就避免了被驱动表上的字符编码转换，从explain结果可以看到，这次索引走对了。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-119f403b73cc8648488456e693930f29>5.19 - CH19-单行优化</h1><p>一般情况下，如果我跟你说查询性能优化，你首先会想到一些复杂的语句，想到查询需要返回大量的数据。但有些情况下，“查一行”，也会执行得特别慢。今天，我就跟你聊聊这个有趣的话题，看看什么情况下，会出现这个现象。</p><p>需要说明的是，如果MySQL数据库本身就有很大的压力，导致数据库服务器CPU占用率很高或ioutil（IO利用率）很高，这种情况下所有语句的执行都有可能变慢，不属于我们今天的讨论范围。</p><p>为了便于描述，我还是构造一个表，基于这个表来说明今天的问题。这个表有两个字段id和c，并且我在里面插入了10万行记录。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#000>mysql</span><span style=color:#ce5c00;font-weight:700>&gt;</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>CREATE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>TABLE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>t</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>(</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>id</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87>int</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>11</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>NOT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>NULL</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#204a87;font-weight:700>c</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87>int</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>11</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>DEFAULT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>NULL</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>PRIMARY</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>KEY</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>(</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>id</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>ENGINE</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#000>InnoDB</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>delimiter</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>;;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>create</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>procedure</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>idata</span><span style=color:#000;font-weight:700>()</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>begin</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>declare</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>i</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87>int</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>set</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>i</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#000>while</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>i</span><span style=color:#ce5c00;font-weight:700>&lt;=</span><span style=color:#0000cf;font-weight:700>100000</span><span style=color:#000;font-weight:700>)</span><span style=color:#204a87;font-weight:700>do</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>    </span><span style=color:#204a87;font-weight:700>insert</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>into</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>t</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>values</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>i</span><span style=color:#000;font-weight:700>,</span><span style=color:#000>i</span><span style=color:#000;font-weight:700>);</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>    </span><span style=color:#204a87;font-weight:700>set</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>i</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#000>i</span><span style=color:#ce5c00;font-weight:700>+</span><span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>end</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>while</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>end</span><span style=color:#000;font-weight:700>;;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>delimiter</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>call</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>idata</span><span style=color:#000;font-weight:700>();</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><p>接下来，我会用几个不同的场景来举例，有些是前面的文章中我们已经介绍过的知识点，你看看能不能一眼看穿，来检验一下吧。</p><h2 id=第一类查询长时间不返回>第一类：查询长时间不返回</h2><p>如图1所示，在表t执行下面的SQL语句：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#000>mysql</span><span style=color:#ce5c00;font-weight:700>&gt;</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>select</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>*</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>from</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>t</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>where</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>id</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><p>查询结果长时间不返回。</p><p>一般碰到这种情况的话，大概率是表 t 被锁住了。接下来分析原因的时候，一般都是首先执行一下show processlist命令，看看当前语句处于什么状态。</p><p>然后我们再针对每种状态，去分析它们产生的原因、如何复现，以及如何处理。</p><h3 id=等-dml-锁>等 DML 锁</h3><p>如图2所示，就是使用show processlist命令查看Waiting for table metadata lock的示意图。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211115215653.png style=display:block;width:80% alt=NAME align=center></div><p>出现<strong>这个状态表示的是，现在有一个线程正在表t上请求或者持有MDL写锁，把select语句堵住了。</strong></p><p>在第6篇文章中，我给你介绍过一种复现方法。但需要说明的是，那个复现过程是基于MySQL 5.6版本的。而MySQL 5.7版本修改了MDL的加锁策略，所以就不能复现这个场景了。</p><p>不过，在MySQL 5.7版本下复现这个场景，也很容易。如图3所示，我给出了简单的复现步骤。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211115215741.png style=display:block;width:80% alt=NAME align=center></div><p>session A 通过lock table命令持有表t的MDL写锁，而session B的查询需要获取MDL读锁。所以，session B进入等待状态。</p><p>这类问题的处理方式，就是找到谁持有MDL写锁，然后把它kill掉。</p><p>但是，由于在show processlist的结果里面，session A的Command列是“Sleep”，导致查找起来很不方便。不过有了performance_schema和sys系统库以后，就方便多了。（MySQL启动时需要设置performance_schema=on，相比于设置为off会有10%左右的性能损失)</p><p>通过查询sys.schema_table_lock_waits这张表，我们就可以直接找出造成阻塞的process id，把这个连接用kill 命令断开即可。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211115215754.png style=display:block;width:80% alt=NAME align=center></div><h3 id=等-flush>等 flush</h3><p>接下来，我给你举另外一种查询被堵住的情况。</p><p>我在表t上，执行下面的SQL语句：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#000>mysql</span><span style=color:#ce5c00;font-weight:700>&gt;</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>select</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>*</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>from</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>information_schema</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>processlist</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>where</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>id</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><p>这里，我先卖个关子。</p><p>你可以看一下图5。我查出来这个线程的状态是Waiting for table flush，你可以设想一下这是什么原因。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211115215811.png style=display:block;width:80% alt=NAME align=center></div><p>这个状态表示的是，现在有一个线程正要对表t做flush操作。MySQL里面对表做flush操作的用法，一般有以下两个：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#000>flush</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>tables</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>t</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>with</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>read</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>lock</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#000>flush</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>tables</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>with</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>read</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>lock</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><p>这两个flush语句，如果指定表t的话，代表的是只关闭表t；如果没有指定具体的表名，则表示关闭MySQL里所有打开的表。</p><p>但是正常这两个语句执行起来都很快，除非它们也被别的线程堵住了。</p><p>所以，出现Waiting for table flush状态的可能情况是：有一个flush tables命令被别的语句堵住了，然后它又堵住了我们的select语句。</p><p>现在，我们一起来复现一下这种情况，<strong>复现步骤</strong>如图6所示：</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211115215823.png style=display:block;width:80% alt=NAME align=center></div><p>在session A中，我故意每行都调用一次sleep(1)，这样这个语句默认要执行10万秒，在这期间表t一直是被session A“打开”着。然后，session B的flush tables t命令再要去关闭表t，就需要等session A的查询结束。这样，session C要再次查询的话，就会被flush 命令堵住了。</p><p>图7是这个复现步骤的show processlist结果。这个例子的排查也很简单，你看到这个show processlist的结果，肯定就知道应该怎么做了。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211115215832.png style=display:block;width:80% alt=NAME align=center></div><h3 id=等行锁>等行锁</h3><p>现在，经过了表级锁的考验，我们的select 语句终于来到引擎里了。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>mysql&gt; select * from t where id=1 lock in share mode; 
</span></span></code></pre></div><p>上面这条语句的用法你也很熟悉了，我们在第8篇文章介绍当前读时提到过。</p><p>由于访问id=1这个记录时要加读锁，如果这时候已经有一个事务在这行记录上持有一个写锁，我们的select语句就会被堵住。</p><p>复现步骤和现场如下：</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211115215908.png style=display:block;width:80% alt=NAME align=center></div><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211115215916.png style=display:block;width:80% alt=NAME align=center></div><p>显然，session A启动了事务，占有写锁，还不提交，是导致session B被堵住的原因。</p><p>这个问题并不难分析，但问题是怎么查出是谁占着这个写锁。如果你用的是MySQL 5.7版本，可以通过sys.innodb_lock_waits 表查到。</p><p>查询方法是：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#000>mysql</span><span style=color:#ce5c00;font-weight:700>&gt;</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>select</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>*</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>from</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>t</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>sys</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>innodb_lock_waits</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>where</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>locked_table</span><span style=color:#ce5c00;font-weight:700>=`</span><span style=color:#4e9a06>&#39;test&#39;</span><span style=color:#000;font-weight:700>.</span><span style=color:#4e9a06>&#39;t&#39;</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#a40000>\</span><span style=color:#204a87;font-weight:700>G</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211115220719.png style=display:block;width:80% alt=NAME align=center></div><p>可以看到，这个信息很全，4号线程是造成堵塞的罪魁祸首。而干掉这个罪魁祸首的方式，就是KILL QUERY 4或KILL 4。</p><p>不过，这里不应该显示“KILL QUERY 4”。这个命令表示停止4号线程当前正在执行的语句，而这个方法其实是没有用的。因为占有行锁的是update语句，这个语句已经是之前执行完成了的，现在执行KILL QUERY，无法让这个事务去掉id=1上的行锁。</p><p>实际上，KILL 4才有效，也就是说直接断开这个连接。这里隐含的一个逻辑就是，连接被断开的时候，会自动回滚这个连接里面正在执行的线程，也就释放了id=1上的行锁。</p><h3 id=查询慢>查询慢</h3><p>经过了重重封“锁”，我们再来看看一些查询慢的例子。</p><p>先来看一条你一定知道原因的SQL语句：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#000>mysql</span><span style=color:#ce5c00;font-weight:700>&gt;</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>select</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>*</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>from</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>t</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>where</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>c</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#0000cf;font-weight:700>50000</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>limit</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><p>由于字段c上没有索引，这个语句只能走id主键顺序扫描，因此需要扫描5万行。</p><p>作为确认，你可以看一下慢查询日志。注意，这里为了把所有语句记录到slow log里，我在连接后先执行了 set long_query_time=0，将慢查询日志的时间阈值设置为0。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211115220739.png style=display:block;width:80% alt=NAME align=center></div><p>Rows_examined显示扫描了50000行。你可能会说，不是很慢呀，11.5毫秒就返回了，我们线上一般都配置超过1秒才算慢查询。但你要记住：<strong>坏查询不一定是慢查询</strong>。我们这个例子里面只有10万行记录，数据量大起来的话，执行时间就线性涨上去了。</p><p>扫描行数多，所以执行慢，这个很好理解。</p><p>但是接下来，我们再看一个只扫描一行，但是执行很慢的语句。</p><p>如图12所示，是这个例子的slow log。可以看到，执行的语句是</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#000>mysql</span><span style=color:#ce5c00;font-weight:700>&gt;</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>select</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>*</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>from</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>t</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>where</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>id</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#0000cf;font-weight:700>1</span><span style=color:#a40000>；</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><p>虽然扫描行数是1，但执行时间却长达800毫秒。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211115220750.png style=display:block;width:80% alt=NAME align=center></div><p>是不是有点奇怪呢，这些时间都花在哪里了？</p><p>如果我把这个slow log的截图再往下拉一点，你可以看到下一个语句，select * from t where id=1 lock in share mode，执行时扫描行数也是1行，执行时间是0.2毫秒。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211115220801.png style=display:block;width:80% alt=NAME align=center></div><p>看上去是不是更奇怪了？按理说lock in share mode还要加锁，时间应该更长才对啊。</p><p>可能有的同学已经有答案了。如果你还没有答案的话，我再给你一个提示信息，图14是这两个语句的执行输出结果。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211115220812.png style=display:block;width:80% alt=NAME align=center></div><p>第一个语句的查询结果里c=1，带lock in share mode的语句返回的是c=1000001。看到这里应该有更多的同学知道原因了。如果你还是没有头绪的话，也别着急。我先跟你说明一下复现步骤，再分析原因。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211115220822.png style=display:block;width:80% alt=NAME align=center></div><p>你看到了，session A先用start transaction with consistent snapshot命令启动了一个事务，之后session B才开始执行update 语句。</p><p>session B执行完100万次update语句后，id=1这一行处于什么状态呢？你可以从图16中找到答案。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211115221034.png style=display:block;width:80% alt=NAME align=center></div><p>session B更新完100万次，生成了100万个回滚日志(undo log)。</p><p>带lock in share mode的SQL语句，是当前读，因此会直接读到1000001这个结果，所以速度很快；而select * from t where id=1这个语句，是一致性读，因此需要从1000001开始，依次执行undo log，执行了100万次以后，才将1这个结果返回。</p><p>注意，undo log里记录的其实是“把2改成1”，“把3改成2”这样的操作逻辑，画成减1的目的是方便你看图。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-7e8bb06b45a4ba47027135fe453d090e>5.20 - CH20-幻读</h1><p>为了便于说明问题，这一篇文章，我们就先使用一个小一点儿的表。建表和初始化语句如下：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>CREATE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>TABLE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>t</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>(</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>id</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87>int</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>11</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>NOT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>NULL</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#204a87;font-weight:700>c</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87>int</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>11</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>DEFAULT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>NULL</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>d</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87>int</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>11</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>DEFAULT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>NULL</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>PRIMARY</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>KEY</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>(</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>id</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000;font-weight:700>),</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>KEY</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#204a87;font-weight:700>c</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>(</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#204a87;font-weight:700>c</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>ENGINE</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#000>InnoDB</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>insert</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>into</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>t</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>values</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>0</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>0</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>0</span><span style=color:#000;font-weight:700>),</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>5</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>5</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>5</span><span style=color:#000;font-weight:700>),</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>10</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>10</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>10</span><span style=color:#000;font-weight:700>),</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>15</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>15</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>15</span><span style=color:#000;font-weight:700>),</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>20</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>20</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>20</span><span style=color:#000;font-weight:700>),</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>25</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>25</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>25</span><span style=color:#000;font-weight:700>);</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><p>这个表除了主键id外，还有一个索引c，初始化语句在表中插入了6行数据。</p><p>上期我留给你的问题是，下面的语句序列，是怎么加锁的，加的锁又是什么时候释放的呢？</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>begin</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>select</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>*</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>from</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>t</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>where</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>d</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#0000cf;font-weight:700>5</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>for</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>update</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>commit</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><p>比较好理解的是，这个语句会命中d=5的这一行，对应的主键id=5，因此在select 语句执行完成后，id=5这一行会加一个写锁，而且由于两阶段锁协议，这个写锁会在执行commit语句的时候释放。</p><p>由于字段d上没有索引，因此这条查询语句会做全表扫描。那么，其他被扫描到的，但是不满足条件的5行记录上，会不会被加锁呢？</p><p>我们知道，InnoDB的默认事务隔离级别是可重复读，所以本文接下来没有特殊说明的部分，都是设定在可重复读隔离级别下。</p><h2 id=什么是幻读>什么是幻读</h2><p>现在，我们就来分析一下，如果只在id=5这一行加锁，而其他行的不加锁的话，会怎么样。</p><p>下面先来看一下这个场景：</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211115221647.png style=display:block;width:80% alt=NAME align=center></div><p>可以看到，session A里执行了三次查询，分别是Q1、Q2和Q3。它们的SQL语句相同，都是select * from t where d=5 for update。这个语句的意思你应该很清楚了，查所有d=5的行，而且使用的是当前读，并且加上写锁。现在，我们来看一下这三条SQL语句，分别会返回什么结果。</p><ol><li>Q1只返回id=5这一行；</li><li>在T2时刻，session B把id=0这一行的d值改成了5，因此T3时刻Q2查出来的是id=0和id=5这两行；</li><li>在T4时刻，session C又插入一行（1,1,5），因此T5时刻Q3查出来的是id=0、id=1和id=5的这三行。</li></ol><p>其中，Q3读到id=1这一行的现象，被称为“幻读”。也就是说，幻读指的是一个事务在前后两次查询同一个范围的时候，后一次查询看到了前一次查询没有看到的行。</p><p>这里，我需要对“幻读”做一个说明：</p><ol><li>在可重复读隔离级别下，普通的查询是快照读，是不会看到别的事务插入的数据的。因此，幻读在“当前读”下才会出现。</li><li>上面session B的修改结果，被session A之后的select语句用“当前读”看到，不能称为幻读。幻读仅专指“新插入的行”。</li></ol><p>如果只从第8篇文章我们学到的事务可见性规则来分析的话，上面这三条SQL语句的返回结果都没有问题。</p><p>因为这三个查询都是加了for update，都是当前读。而当前读的规则，就是要能读到所有已经提交的记录的最新值。并且，session B和sessionC的两条语句，执行后就会提交，所以Q2和Q3就是应该看到这两个事务的操作效果，而且也看到了，这跟事务的可见性规则并不矛盾。</p><p>但是，这是不是真的没问题呢？</p><h2 id=幻读带来的问题>幻读带来的问题</h2><p>**首先是语义上的。**session A在T1时刻就声明了，“我要把所有d=5的行锁住，不准别的事务进行读写操作”。而实际上，这个语义被破坏了。</p><p>如果现在这样看感觉还不明显的话，我再往session B和session C里面分别加一条SQL语句，你再看看会出现什么现象。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211115221723.png style=display:block;width:80% alt=NAME align=center></div><p>session B的第二条语句update t set c=5 where id=0，语义是“我把id=0、d=5这一行的c值，改成了5”。</p><p>由于在T1时刻，session A 还只是给id=5这一行加了行锁， 并没有给id=0这行加上锁。因此，session B在T2时刻，是可以执行这两条update语句的。这样，就破坏了 session A 里Q1语句要锁住所有d=5的行的加锁声明。</p><p>session C也是一样的道理，对id=1这一行的修改，也是破坏了Q1的加锁声明。</p><p><strong>其次，是数据一致性的问题。</strong></p><p>我们知道，锁的设计是为了保证数据的一致性。而这个一致性，不止是数据库内部数据状态在此刻的一致性，还包含了数据和日志在逻辑上的一致性。</p><p>为了说明这个问题，我给session A在T1时刻再加一个更新语句，即：update t set d=100 where d=5。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211115221739.png style=display:block;width:80% alt=NAME align=center></div><p>update的加锁语义和select &mldr;for update 是一致的，所以这时候加上这条update语句也很合理。session A声明说“要给d=5的语句加上锁”，就是为了要更新数据，新加的这条update语句就是把它认为加上了锁的这一行的d值修改成了100。</p><p>现在，我们来分析一下图3执行完成后，数据库里会是什么结果。</p><ol><li>经过T1时刻，id=5这一行变成 (5,5,100)，当然这个结果最终是在T6时刻正式提交的;</li><li>经过T2时刻，id=0这一行变成(0,5,5);</li><li>经过T4时刻，表里面多了一行(1,5,5);</li><li>其他行跟这个执行序列无关，保持不变。</li></ol><p>这样看，这些数据也没啥问题，但是我们再来看看这时候binlog里面的内容。</p><ol><li>T2时刻，session B事务提交，写入了两条语句；</li><li>T4时刻，session C事务提交，写入了两条语句；</li><li>T6时刻，session A事务提交，写入了update t set d=100 where d=5 这条语句。</li></ol><p>我统一放到一起的话，就是这样的：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>update</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>t</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>set</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>d</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#0000cf;font-weight:700>5</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>where</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>id</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#0000cf;font-weight:700>0</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#8f5902;font-style:italic>/*(0,0,5)*/</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>update</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>t</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>set</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>c</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#0000cf;font-weight:700>5</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>where</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>id</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#0000cf;font-weight:700>0</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#8f5902;font-style:italic>/*(0,5,5)*/</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>insert</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>into</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>t</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>values</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>5</span><span style=color:#000;font-weight:700>);</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#8f5902;font-style:italic>/*(1,1,5)*/</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>update</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>t</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>set</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>c</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#0000cf;font-weight:700>5</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>where</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>id</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#8f5902;font-style:italic>/*(1,5,5)*/</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>update</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>t</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>set</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>d</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#0000cf;font-weight:700>100</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>where</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>d</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#0000cf;font-weight:700>5</span><span style=color:#000;font-weight:700>;</span><span style=color:#8f5902;font-style:italic>/*所有d=5的行，d改成100*/</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><p>好，你应该看出问题了。这个语句序列，不论是拿到备库去执行，还是以后用binlog来克隆一个库，这三行的结果，都变成了 (0,5,100)、(1,5,100)和(5,5,100)。</p><p>也就是说，id=0和id=1这两行，发生了数据不一致。这个问题很严重，是不行的。</p><p>到这里，我们再回顾一下，<strong>这个数据不一致到底是怎么引入的？</strong></p><p>我们分析一下可以知道，这是我们假设“select * from t where d=5 for update这条语句只给d=5这一行，也就是id=5的这一行加锁”导致的。</p><p>所以我们认为，上面的设定不合理，要改。</p><p>那怎么改呢？我们把扫描过程中碰到的行，也都加上写锁，再来看看执行效果。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211115221753.png style=display:block;width:80% alt=NAME align=center></div><p>由于session A把所有的行都加了写锁，所以session B在执行第一个update语句的时候就被锁住了。需要等到T6时刻session A提交以后，session B才能继续执行。</p><p>这样对于id=0这一行，在数据库里的最终结果还是 (0,5,5)。在binlog里面，执行序列是这样的：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>insert</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>into</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>t</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>values</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>5</span><span style=color:#000;font-weight:700>);</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#8f5902;font-style:italic>/*(1,1,5)*/</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>update</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>t</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>set</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>c</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#0000cf;font-weight:700>5</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>where</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>id</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#8f5902;font-style:italic>/*(1,5,5)*/</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>update</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>t</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>set</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>d</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#0000cf;font-weight:700>100</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>where</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>d</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#0000cf;font-weight:700>5</span><span style=color:#000;font-weight:700>;</span><span style=color:#8f5902;font-style:italic>/*所有d=5的行，d改成100*/</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>update</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>t</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>set</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>d</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#0000cf;font-weight:700>5</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>where</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>id</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#0000cf;font-weight:700>0</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#8f5902;font-style:italic>/*(0,0,5)*/</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>update</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>t</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>set</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>c</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#0000cf;font-weight:700>5</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>where</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>id</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#0000cf;font-weight:700>0</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#8f5902;font-style:italic>/*(0,5,5)*/</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><p>可以看到，按照日志顺序执行，id=0这一行的最终结果也是(0,5,5)。所以，id=0这一行的问题解决了。</p><p>但同时你也可以看到，id=1这一行，在数据库里面的结果是(1,5,5)，而根据binlog的执行结果是(1,5,100)，也就是说幻读的问题还是没有解决。为什么我们已经这么“凶残”地，把所有的记录都上了锁，还是阻止不了id=1这一行的插入和更新呢？</p><p>原因很简单。在T3时刻，我们给所有行加锁的时候，id=1这一行还不存在，不存在也就加不上锁。</p><p>**也就是说，即使把所有的记录都加上锁，还是阻止不了新插入的记录，**这也是为什么“幻读”会被单独拿出来解决的原因。</p><p>到这里，其实我们刚说明完文章的标题 ：幻读的定义和幻读有什么问题。</p><p>接下来，我们再看看InnoDB怎么解决幻读的问题。</p><h2 id=如何解决幻读>如何解决幻读</h2><p>现在你知道了，产生幻读的原因是，行锁只能锁住行，但是新插入记录这个动作，要更新的是记录之间的“间隙”。因此，为了解决幻读问题，InnoDB只好引入新的锁，也就是间隙锁(Gap Lock)。</p><p>顾名思义，间隙锁，锁的就是两个值之间的空隙。比如文章开头的表t，初始化插入了6个记录，这就产生了7个间隙。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211115221815.png style=display:block;width:80% alt=NAME align=center></div><p>这样，当你执行 select * from t where d=5 for update的时候，就不止是给数据库中已有的6个记录加上了行锁，还同时加了7个间隙锁。这样就确保了无法再插入新的记录。</p><p>也就是说这时候，在一行行扫描的过程中，不仅将给行加上了行锁，还给行两边的空隙，也加上了间隙锁。</p><p>现在你知道了，数据行是可以加上锁的实体，数据行之间的间隙，也是可以加上锁的实体。但是间隙锁跟我们之前碰到过的锁都不太一样。</p><p>比如行锁，分成读锁和写锁。下图就是这两种类型行锁的冲突关系。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211115221825.png style=display:block;width:80% alt=NAME align=center></div><p>也就是说，跟行锁有冲突关系的是“另外一个行锁”。</p><p>但是间隙锁不一样，**跟间隙锁存在冲突关系的，是“往这个间隙中插入一个记录”这个操作。**间隙锁之间都不存在冲突关系。</p><p>这句话不太好理解，我给你举个例子：</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211115221835.png style=display:block;width:80% alt=NAME align=center></div><p>这里session B并不会被堵住。因为表t里并没有c=7这个记录，因此session A加的是间隙锁(5,10)。而session B也是在这个间隙加的间隙锁。它们有共同的目标，即：保护这个间隙，不允许插入值。但，它们之间是不冲突的。</p><p>间隙锁和行锁合称next-key lock，每个next-key lock是前开后闭区间。也就是说，我们的表t初始化以后，如果用select * from t for update要把整个表所有记录锁起来，就形成了7个next-key lock，分别是 (-∞,0]、(0,5]、(5,10]、(10,15]、(15,20]、(20, 25]、(25, +suprenum]。</p><blockquote><p>备注：这篇文章中，如果没有特别说明，我们把间隙锁记为开区间，把next-key lock记为前开后闭区间。</p></blockquote><p>你可能会问说，这个suprenum从哪儿来的呢？</p><p>这是因为+∞是开区间。实现上，InnoDB给每个索引加了一个不存在的最大值suprenum，这样才符合我们前面说的“都是前开后闭区间”。</p><p><strong>间隙锁和next-key lock的引入，帮我们解决了幻读的问题，但同时也带来了一些“困扰”。</strong></p><p>在前面的文章中，就有同学提到了这个问题。我把他的问题转述一下，对应到我们这个例子的表来说，业务逻辑这样的：任意锁住一行，如果这一行不存在的话就插入，如果存在这一行就更新它的数据，代码如下：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>begin</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>select</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>*</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>from</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>t</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>where</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>id</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#000>N</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>for</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>update</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#8f5902;font-style:italic>/*如果行不存在*/</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>insert</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>into</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>t</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>values</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>N</span><span style=color:#000;font-weight:700>,</span><span style=color:#000>N</span><span style=color:#000;font-weight:700>,</span><span style=color:#000>N</span><span style=color:#000;font-weight:700>);</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#8f5902;font-style:italic>/*如果行存在*/</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>update</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>t</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>set</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>d</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#000>N</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>set</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>id</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#000>N</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>commit</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><p>可能你会说，这个不是insert &mldr; on duplicate key update 就能解决吗？但其实在有多个唯一键的时候，这个方法是不能满足这位提问同学的需求的。至于为什么，我会在后面的文章中再展开说明。</p><p>现在，我们就只讨论这个逻辑。</p><p>这个同学碰到的现象是，这个逻辑一旦有并发，就会碰到死锁。你一定也觉得奇怪，这个逻辑每次操作前用for update锁起来，已经是最严格的模式了，怎么还会有死锁呢？</p><p>这里，我用两个session来模拟并发，并假设N=9。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/df37bf0bb9f85ea59f0540e24eb6bcbe.png style=display:block;width:80% alt=NAME align=center></div><p>图8 间隙锁导致的死锁</p><p>你看到了，其实都不需要用到后面的update语句，就已经形成死锁了。我们按语句执行顺序来分析一下：</p><ol><li>session A 执行select &mldr; for update语句，由于id=9这一行并不存在，因此会加上间隙锁(5,10);</li><li>session B 执行select &mldr; for update语句，同样会加上间隙锁(5,10)，间隙锁之间不会冲突，因此这个语句可以执行成功；</li><li>session B 试图插入一行(9,9,9)，被session A的间隙锁挡住了，只好进入等待；</li><li>session A试图插入一行(9,9,9)，被session B的间隙锁挡住了。</li></ol><p>至此，两个session进入互相等待状态，形成死锁。当然，InnoDB的死锁检测马上就发现了这对死锁关系，让session A的insert语句报错返回了。</p><p>你现在知道了，<strong>间隙锁的引入，可能会导致同样的语句锁住更大的范围，这其实是影响了并发度的</strong>。其实，这还只是一个简单的例子，在下一篇文章中我们还会碰到更多、更复杂的例子。</p><p>你可能会说，为了解决幻读的问题，我们引入了这么一大串内容，有没有更简单一点的处理方法呢。</p><p>我在文章一开始就说过，如果没有特别说明，今天和你分析的问题都是在可重复读隔离级别下的，间隙锁是在可重复读隔离级别下才会生效的。所以，你如果把隔离级别设置为读提交的话，就没有间隙锁了。但同时，你要解决可能出现的数据和日志不一致问题，需要把binlog格式设置为row。这，也是现在不少公司使用的配置组合。</p><p>前面文章的评论区有同学留言说，他们公司就使用的是读提交隔离级别加binlog_format=row的组合。他曾问他们公司的DBA说，你为什么要这么配置。DBA直接答复说，因为大家都这么用呀。</p><p>所以，这个同学在评论区就问说，这个配置到底合不合理。</p><p>关于这个问题本身的答案是，如果读提交隔离级别够用，也就是说，业务不需要可重复读的保证，这样考虑到读提交下操作数据的锁范围更小（没有间隙锁），这个选择是合理的。</p><p>但其实我想说的是，配置是否合理，跟业务场景有关，需要具体问题具体分析。</p><p>但是，如果DBA认为之所以这么用的原因是“大家都这么用”，那就有问题了，或者说，迟早会出问题。</p><p>比如说，大家都用读提交，可是逻辑备份的时候，mysqldump为什么要把备份线程设置成可重复读呢？（这个我在前面的文章中已经解释过了，你可以再回顾下第6篇文章的内容）</p><p>然后，在备份期间，备份线程用的是可重复读，而业务线程用的是读提交。同时存在两种事务隔离级别，会不会有问题？</p><p>进一步地，这两个不同的隔离级别现象有什么不一样的，关于我们的业务，“用读提交就够了”这个结论是怎么得到的？</p><p>如果业务开发和运维团队这些问题都没有弄清楚，那么“没问题”这个结论，本身就是有问题的。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-2ee15cd6d8af391cfa48aa5881a3b0ae>5.21 - CH21-加锁规则</h1><p>在上一篇文章中，我和你介绍了间隙锁和next-key lock的概念，但是并没有说明加锁规则。间隙锁的概念理解起来确实有点儿难，尤其在配合上行锁以后，很容易在判断是否会出现锁等待的问题上犯错。</p><p>所以今天，我们就先从这个加锁规则开始吧。</p><p>首先说明一下，这些加锁规则我没在别的地方看到过有类似的总结，以前我自己判断的时候都是想着代码里面的实现来脑补的。这次为了总结成不看代码的同学也能理解的规则，是我又重新刷了代码临时总结出来的。所以，<strong>这个规则有以下两条前提说明：</strong></p><ol><li>MySQL后面的版本可能会改变加锁策略，所以这个规则只限于截止到现在的最新版本，即5.x系列&lt;=5.7.24，8.0系列 &lt;=8.0.13。</li><li>如果大家在验证中有发现bad case的话，请提出来，我会再补充进这篇文章，使得一起学习本专栏的所有同学都能受益。</li></ol><p>因为间隙锁在可重复读隔离级别下才有效，所以本篇文章接下来的描述，若没有特殊说明，默认是可重复读隔离级别。</p><p><strong>我总结的加锁规则里面，包含了两个“原则”、两个“优化”和一个“bug”。</strong></p><ol><li>原则1：加锁的基本单位是next-key lock。希望你还记得，next-key lock是前开后闭区间。</li><li>原则2：查找过程中访问到的对象才会加锁。</li><li>优化1：索引上的等值查询，给唯一索引加锁的时候，next-key lock退化为行锁。</li><li>优化2：索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候，next-key lock退化为间隙锁。</li><li>一个bug：唯一索引上的范围查询会访问到不满足条件的第一个值为止。</li></ol><p>我还是以上篇文章的表t为例，和你解释一下这些规则。表t的建表语句和初始化语句如下。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>CREATE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>TABLE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>t</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>(</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>id</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87>int</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>11</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>NOT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>NULL</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#204a87;font-weight:700>c</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87>int</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>11</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>DEFAULT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>NULL</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>d</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87>int</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>11</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>DEFAULT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>NULL</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>PRIMARY</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>KEY</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>(</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>id</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000;font-weight:700>),</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>KEY</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#204a87;font-weight:700>c</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>(</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#204a87;font-weight:700>c</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>ENGINE</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#000>InnoDB</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>insert</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>into</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>t</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>values</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>0</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>0</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>0</span><span style=color:#000;font-weight:700>),(</span><span style=color:#0000cf;font-weight:700>5</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>5</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>5</span><span style=color:#000;font-weight:700>),</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>10</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>10</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>10</span><span style=color:#000;font-weight:700>),(</span><span style=color:#0000cf;font-weight:700>15</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>15</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>15</span><span style=color:#000;font-weight:700>),(</span><span style=color:#0000cf;font-weight:700>20</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>20</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>20</span><span style=color:#000;font-weight:700>),(</span><span style=color:#0000cf;font-weight:700>25</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>25</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>25</span><span style=color:#000;font-weight:700>);</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><p>接下来的例子基本都是配合着图片说明的，所以我建议你可以对照着文稿看，有些例子可能会“毁三观”，也建议你读完文章后亲手实践一下。</p><h2 id=案例一等值查询间隙锁>案例一：等值查询间隙锁</h2><p>第一个例子是关于等值条件操作间隙：</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211116215910.png style=display:block;width:80% alt=NAME align=center></div><p>由于表t中没有id=7的记录，所以用我们上面提到的加锁规则判断一下的话：</p><ol><li>根据原则1，加锁单位是next-key lock，session A加锁范围就是(5,10]；</li><li>同时根据优化2，这是一个等值查询(id=7)，而id=10不满足查询条件，next-key lock退化成间隙锁，因此最终加锁的范围是(5,10)。</li></ol><p>所以，session B要往这个间隙里面插入id=8的记录会被锁住，但是session C修改id=10这行是可以的。</p><h2 id=案例二非唯一索引等值锁>案例二：非唯一索引等值锁</h2><p>第二个例子是关于覆盖索引上的锁：</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211116215929.png style=display:block;width:80% alt=NAME align=center></div><p>看到这个例子，你是不是有一种“该锁的不锁，不该锁的乱锁”的感觉？我们来分析一下吧。</p><p>这里session A要给索引c上c=5的这一行加上读锁。</p><ol><li>根据原则1，加锁单位是next-key lock，因此会给(0,5]加上next-key lock。</li><li>要注意c是普通索引，因此仅访问c=5这一条记录是不能马上停下来的，需要向右遍历，查到c=10才放弃。根据原则2，访问到的都要加锁，因此要给(5,10]加next-key lock。</li><li>但是同时这个符合优化2：等值判断，向右遍历，最后一个值不满足c=5这个等值条件，因此退化成间隙锁(5,10)。</li><li>根据原则2 ，<strong>只有访问到的对象才会加锁</strong>，这个查询使用覆盖索引，并不需要访问主键索引，所以主键索引上没有加任何锁，这就是为什么session B的update语句可以执行完成。</li></ol><p>但session C要插入一个(7,7,7)的记录，就会被session A的间隙锁(5,10)锁住。</p><p>需要注意，在这个例子中，lock in share mode只锁覆盖索引，但是如果是for update就不一样了。 执行 for update时，系统会认为你接下来要更新数据，因此会顺便给主键索引上满足条件的行加上行锁。</p><p>这个例子说明，锁是加在索引上的；同时，它给我们的指导是，如果你要用lock in share mode来给行加读锁避免数据被更新的话，就必须得绕过覆盖索引的优化，在查询字段中加入索引中不存在的字段。比如，将session A的查询语句改成select d from t where c=5 lock in share mode。你可以自己验证一下效果。</p><h2 id=案例三主键索引范围锁>案例三：主键索引范围锁</h2><p>第三个例子是关于范围查询的。</p><p>举例之前，你可以先思考一下这个问题：对于我们这个表t，下面这两条查询语句，加锁范围相同吗？</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#000>mysql</span><span style=color:#ce5c00;font-weight:700>&gt;</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>select</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>*</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>from</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>t</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>where</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>id</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#0000cf;font-weight:700>10</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>for</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>update</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#000>mysql</span><span style=color:#ce5c00;font-weight:700>&gt;</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>select</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>*</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>from</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>t</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>where</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>id</span><span style=color:#ce5c00;font-weight:700>&gt;=</span><span style=color:#0000cf;font-weight:700>10</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>and</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>id</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>11</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>for</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>update</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><p>你可能会想，id定义为int类型，这两个语句就是等价的吧？其实，它们并不完全等价。</p><p>在逻辑上，这两条查语句肯定是等价的，但是它们的加锁规则不太一样。现在，我们就让session A执行第二个查询语句，来看看加锁效果。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211116215951.png style=display:block;width:80% alt=NAME align=center></div><p>现在我们就用前面提到的加锁规则，来分析一下session A 会加什么锁呢？</p><ol><li>开始执行的时候，要找到第一个id=10的行，因此本该是next-key lock(5,10]。 根据优化1， 主键id上的等值条件，退化成行锁，只加了id=10这一行的行锁。</li><li>范围查找就往后继续找，找到id=15这一行停下来，因此需要加next-key lock(10,15]。</li></ol><p>所以，session A这时候锁的范围就是主键索引上，行锁id=10和next-key lock(10,15]。这样，session B和session C的结果你就能理解了。</p><p>这里你需要注意一点，首次session A定位查找id=10的行的时候，是当做等值查询来判断的，而向右扫描到id=15的时候，用的是范围查询判断。</p><h2 id=案例四非唯一索引范围锁>案例四：非唯一索引范围锁</h2><p>接下来，我们再看两个范围查询加锁的例子，你可以对照着案例三来看。</p><p>需要注意的是，与案例三不同的是，案例四中查询语句的where部分用的是字段c。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211116220011.png style=display:block;width:80% alt=NAME align=center></div><p>这次session A用字段c来判断，加锁规则跟案例三唯一的不同是：在第一次用c=10定位记录的时候，索引c上加了(5,10]这个next-key lock后，由于索引c是非唯一索引，没有优化规则，也就是说不会蜕变为行锁，因此最终sesion A加的锁是，索引c上的(5,10] 和(10,15] 这两个next-key lock。</p><p>所以从结果上来看，sesson B要插入（8,8,8)的这个insert语句时就被堵住了。</p><p>这里需要扫描到c=15才停止扫描，是合理的，因为InnoDB要扫到c=15，才知道不需要继续往后找了。</p><h2 id=案例五唯一索引范围锁bug>案例五：唯一索引范围锁bug</h2><p>前面的四个案例，我们已经用到了加锁规则中的两个原则和两个优化，接下来再看一个关于加锁规则中bug的案例。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211116220032.png style=display:block;width:80% alt=NAME align=center></div><p>session A是一个范围查询，按照原则1的话，应该是索引id上只加(10,15]这个next-key lock，并且因为id是唯一键，所以循环判断到id=15这一行就应该停止了。</p><p>但是实现上，InnoDB会往前扫描到第一个不满足条件的行为止，也就是id=20。而且由于这是个范围扫描，因此索引id上的(15,20]这个next-key lock也会被锁上。</p><p>所以你看到了，session B要更新id=20这一行，是会被锁住的。同样地，session C要插入id=16的一行，也会被锁住。</p><p>照理说，这里锁住id=20这一行的行为，其实是没有必要的。因为扫描到id=15，就可以确定不用往后再找了。但实现上还是这么做了，因此我认为这是个bug。</p><p>我也曾找社区的专家讨论过，官方bug系统上也有提到，但是并未被verified。所以，认为这是bug这个事儿，也只能算我的一家之言，如果你有其他见解的话，也欢迎你提出来。</p><h2 id=案例六非唯一索引上存在等值的例子>案例六：非唯一索引上存在"等值"的例子</h2><p>接下来的例子，是为了更好地说明“间隙”这个概念。这里，我给表t插入一条新记录。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>mysql&gt; insert into t values(30,10,30);
</span></span></code></pre></div><p>新插入的这一行c=10，也就是说现在表里有两个c=10的行。那么，这时候索引c上的间隙是什么状态了呢？你要知道，由于非唯一索引上包含主键的值，所以是不可能存在“相同”的两行的。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211116220055.png style=display:block;width:80% alt=NAME align=center></div><p>可以看到，虽然有两个c=10，但是它们的主键值id是不同的（分别是10和30），因此这两个c=10的记录之间，也是有间隙的。</p><p>图中我画出了索引c上的主键id。为了跟间隙锁的开区间形式进行区别，我用(c=10,id=30)这样的形式，来表示索引上的一行。</p><p>现在，我们来看一下案例六。</p><p>这次我们用delete语句来验证。注意，delete语句加锁的逻辑，其实跟select &mldr; for update 是类似的，也就是我在文章开始总结的两个“原则”、两个“优化”和一个“bug”。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211116220106.png style=display:block;width:80% alt=NAME align=center></div><p>这时，session A在遍历的时候，先访问第一个c=10的记录。同样地，根据原则1，这里加的是(c=5,id=5)到(c=10,id=10)这个next-key lock。</p><p>然后，session A向右查找，直到碰到(c=15,id=15)这一行，循环才结束。根据优化2，这是一个等值查询，向右查找到了不满足条件的行，所以会退化成(c=10,id=10) 到 (c=15,id=15)的间隙锁。</p><p>也就是说，这个delete语句在索引c上的加锁范围，就是下图中蓝色区域覆盖的部分。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211116220118.png style=display:block;width:80% alt=NAME align=center></div><p>这个蓝色区域左右两边都是虚线，表示开区间，即(c=5,id=5)和(c=15,id=15)这两行上都没有锁。</p><h2 id=案例七limit-语句加锁>案例七：limit 语句加锁</h2><p>例子6也有一个对照案例，场景如下所示：</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211116220137.png style=display:block;width:80% alt=NAME align=center></div><p>这个例子里，session A的delete语句加了 limit 2。你知道表t里c=10的记录其实只有两条，因此加不加limit 2，删除的效果都是一样的，但是加锁的效果却不同。可以看到，session B的insert语句执行通过了，跟案例六的结果不同。</p><p>这是因为，案例七里的delete语句明确加了limit 2的限制，因此在遍历到(c=10, id=30)这一行之后，满足条件的语句已经有两条，循环就结束了。</p><p>因此，索引c上的加锁范围就变成了从（c=5,id=5)到（c=10,id=30)这个前开后闭区间，如下图所示：</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211116220148.png style=display:block;width:80% alt=NAME align=center></div><p>可以看到，(c=10,id=30）之后的这个间隙并没有在加锁范围里，因此insert语句插入c=12是可以执行成功的。</p><p>这个例子对我们实践的指导意义就是，<strong>在删除数据的时候尽量加limit</strong>。这样不仅可以控制删除数据的条数，让操作更安全，还可以减小加锁的范围。</p><h2 id=案例八一个死锁的例子>案例八：一个死锁的例子</h2><p>前面的例子中，我们在分析的时候，是按照next-key lock的逻辑来分析的，因为这样分析比较方便。最后我们再看一个案例，目的是说明：next-key lock实际上是间隙锁和行锁加起来的结果。</p><p>你一定会疑惑，这个概念不是一开始就说了吗？不要着急，我们先来看下面这个例子：</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211116220207.png style=display:block;width:80% alt=NAME align=center></div><p>现在，我们按时间顺序来分析一下为什么是这样的结果。</p><ol><li>session A 启动事务后执行查询语句加lock in share mode，在索引c上加了next-key lock(5,10] 和间隙锁(10,15)；</li><li>session B 的update语句也要在索引c上加next-key lock(5,10] ，进入锁等待；</li><li>然后session A要再插入(8,8,8)这一行，被session B的间隙锁锁住。由于出现了死锁，InnoDB让session B回滚。</li></ol><p>你可能会问，session B的next-key lock不是还没申请成功吗？</p><p>其实是这样的，session B的“加next-key lock(5,10] ”操作，实际上分成了两步，先是加(5,10)的间隙锁，加锁成功；然后加c=10的行锁，这时候才被锁住的。</p><p>也就是说，我们在分析加锁规则的时候可以用next-key lock来分析。但是要知道，具体执行的时候，是要分成间隙锁和行锁两段来执行的。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-dc8b53c2b34d4163603667083641eb15>5.22 - CH22-优化场景</h1><h2 id=短连接风暴>短连接风暴</h2><p>正常的短连接模式就是连接到数据库后，执行很少的SQL语句就断开，下次需要的时候再重连。如果使用的是短连接，在业务高峰期的时候，就可能出现连接数突然暴涨的情况。</p><p>我在第1篇文章中说过，MySQL建立连接的过程，成本是很高的。除了正常的网络连接三次握手外，还需要做登录权限判断和获得这个连接的数据读写权限。</p><p>在数据库压力比较小的时候，这些额外的成本并不明显。</p><p>但是，短连接模型存在一个风险，就是一旦数据库处理得慢一些，连接数就会暴涨。max_connections参数，用来控制一个MySQL实例同时存在的连接数的上限，超过这个值，系统就会拒绝接下来的连接请求，并报错提示“Too many connections”。对于被拒绝连接的请求来说，从业务角度看就是数据库不可用。</p><p>在机器负载比较高的时候，处理现有请求的时间变长，每个连接保持的时间也更长。这时，再有新建连接的话，就可能会超过max_connections的限制。</p><p>碰到这种情况时，一个比较自然的想法，就是调高max_connections的值。但这样做是有风险的。因为设计max_connections这个参数的目的是想保护MySQL，如果我们把它改得太大，让更多的连接都可以进来，那么系统的负载可能会进一步加大，大量的资源耗费在权限验证等逻辑上，结果可能是适得其反，已经连接的线程拿不到CPU资源去执行业务的SQL请求。</p><p>那么这种情况下，你还有没有别的建议呢？我这里还有两种方法，但要注意，这些方法都是有损的。</p><h3 id=第一种方法先处理掉那些占着连接但是不工作的线程><strong>第一种方法：先处理掉那些占着连接但是不工作的线程。</strong></h3><p>max_connections的计算，不是看谁在running，是只要连着就占用一个计数位置。对于那些不需要保持的连接，我们可以通过kill connection主动踢掉。这个行为跟事先设置wait_timeout的效果是一样的。设置wait_timeout参数表示的是，一个线程空闲wait_timeout这么多秒之后，就会被MySQL直接断开连接。</p><p>但是需要注意，在show processlist的结果里，踢掉显示为sleep的线程，可能是有损的。我们来看下面这个例子。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211116220520.png style=display:block;width:80% alt=NAME align=center></div><p>在上面这个例子里，如果断开session A的连接，因为这时候session A还没有提交，所以MySQL只能按照回滚事务来处理；而断开session B的连接，就没什么大影响。所以，如果按照优先级来说，你应该优先断开像session B这样的事务外空闲的连接。</p><p>但是，怎么判断哪些是事务外空闲的呢？session C在T时刻之后的30秒执行show processlist，看到的结果是这样的。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211116220531.png style=display:block;width:80% alt=NAME align=center></div><p>图中id=4和id=5的两个会话都是Sleep 状态。而要看事务具体状态的话，你可以查information_schema库的innodb_trx表。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211116220541.png style=display:block;width:80% alt=NAME align=center></div><p>这个结果里，trx_mysql_thread_id=4，表示id=4的线程还处在事务中。</p><p>因此，如果是连接数过多，你可以优先断开事务外空闲太久的连接；如果这样还不够，再考虑断开事务内空闲太久的连接。</p><p>从服务端断开连接使用的是kill connection + id的命令， 一个客户端处于sleep状态时，它的连接被服务端主动断开后，这个客户端并不会马上知道。直到客户端在发起下一个请求的时候，才会收到这样的报错“ERROR 2013 (HY000): Lost connection to MySQL server during query”。</p><p>从数据库端主动断开连接可能是有损的，尤其是有的应用端收到这个错误后，不重新连接，而是直接用这个已经不能用的句柄重试查询。这会导致从应用端看上去，“MySQL一直没恢复”。</p><p>你可能觉得这是一个冷笑话，但实际上我碰到过不下10次。</p><p>所以，如果你是一个支持业务的DBA，不要假设所有的应用代码都会被正确地处理。即使只是一个断开连接的操作，也要确保通知到业务开发团队。</p><h3 id=第二种方法减少连接过程的消耗><strong>第二种方法：减少连接过程的消耗。</strong></h3><p>有的业务代码会在短时间内先大量申请数据库连接做备用，如果现在数据库确认是被连接行为打挂了，那么一种可能的做法，是让数据库跳过权限验证阶段。</p><p>跳过权限验证的方法是：重启数据库，并使用–skip-grant-tables参数启动。这样，整个MySQL会跳过所有的权限验证阶段，包括连接过程和语句执行过程在内。</p><p>但是，这种方法特别符合我们标题里说的“饮鸩止渴”，风险极高，是我特别不建议使用的方案。尤其你的库外网可访问的话，就更不能这么做了。</p><p>在MySQL 8.0版本里，如果你启用–skip-grant-tables参数，MySQL会默认把 &ndash;skip-networking参数打开，表示这时候数据库只能被本地的客户端连接。可见，MySQL官方对skip-grant-tables这个参数的安全问题也很重视。</p><p>除了短连接数暴增可能会带来性能问题外，实际上，我们在线上碰到更多的是查询或者更新语句导致的性能问题。其中，查询问题比较典型的有两类，一类是由新出现的慢查询导致的，一类是由QPS（每秒查询数）突增导致的。而关于更新语句导致的性能问题，我会在下一篇文章和你展开说明。</p><h2 id=慢查询性能问题>慢查询性能问题</h2><p>在MySQL中，会引发性能问题的慢查询，大体有以下三种可能：</p><ol><li>索引没有设计好；</li><li>SQL语句没写好；</li><li>MySQL选错了索引。</li></ol><p>接下来，我们就具体分析一下这三种可能，以及对应的解决方案。</p><h3 id=导致慢查询的第一种可能是索引没有设计好><strong>导致慢查询的第一种可能是，索引没有设计好。</strong></h3><p>这种场景一般就是通过紧急创建索引来解决。MySQL 5.6版本以后，创建索引都支持Online DDL了，对于那种高峰期数据库已经被这个语句打挂了的情况，最高效的做法就是直接执行alter table 语句。</p><p>比较理想的是能够在备库先执行。假设你现在的服务是一主一备，主库A、备库B，这个方案的大致流程是这样的：</p><ol><li>在备库B上执行 set sql_log_bin=off，也就是不写binlog，然后执行alter table 语句加上索引；</li><li>执行主备切换；</li><li>这时候主库是B，备库是A。在A上执行 set sql_log_bin=off，然后执行alter table 语句加上索引。</li></ol><p>这是一个“古老”的DDL方案。平时在做变更的时候，你应该考虑类似gh-ost这样的方案，更加稳妥。但是在需要紧急处理时，上面这个方案的效率是最高的。</p><h3 id=导致慢查询的第二种可能是语句没写好><strong>导致慢查询的第二种可能是，语句没写好。</strong></h3><p>比如，我们犯了在第18篇文章中提到的那些错误，导致语句没有使用上索引。</p><p>这时，我们可以通过改写SQL语句来处理。MySQL 5.7提供了query_rewrite功能，可以把输入的一种语句改写成另外一种模式。</p><p>比如，语句被错误地写成了 select * from t where id + 1 = 10000，你可以通过下面的方式，增加一个语句改写规则。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>mysql&gt; insert into query_rewrite.rewrite_rules(pattern, replacement, pattern_database) values (&#34;select * from t where id + 1 = ?&#34;, &#34;select * from t where id = ? - 1&#34;, &#34;db1&#34;);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>call query_rewrite.flush_rewrite_rules();
</span></span></code></pre></div><p>这里，call query_rewrite.flush_rewrite_rules()这个存储过程，是让插入的新规则生效，也就是我们说的“查询重写”。你可以用图4中的方法来确认改写规则是否生效。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211116220624.png style=display:block;width:80% alt=NAME align=center></div><h3 id=导致慢查询的第三种可能mysql选错了索引><strong>导致慢查询的第三种可能，MySQL选错了索引。</strong></h3><p>这时候，应急方案就是给这个语句加上force index。</p><p>同样地，使用查询重写功能，给原来的语句加上force index，也可以解决这个问题。</p><p>上面我和你讨论的由慢查询导致性能问题的三种可能情况，实际上出现最多的是前两种，即：索引没设计好和语句没写好。而这两种情况，恰恰是完全可以避免的。比如，通过下面这个过程，我们就可以预先发现问题。</p><ol><li>上线前，在测试环境，把慢查询日志（slow log）打开，并且把long_query_time设置成0，确保每个语句都会被记录入慢查询日志；</li><li>在测试表里插入模拟线上的数据，做一遍回归测试；</li><li>观察慢查询日志里每类语句的输出，特别留意Rows_examined字段是否与预期一致。（我们在前面文章中已经多次用到过Rows_examined方法了，相信你已经动手尝试过了。如果还有不明白的，欢迎给我留言，我们一起讨论）。</li></ol><p>不要吝啬这段花在上线前的“额外”时间，因为这会帮你省下很多故障复盘的时间。</p><p>如果新增的SQL语句不多，手动跑一下就可以。而如果是新项目的话，或者是修改了原有项目的 表结构设计，全量回归测试都是必要的。这时候，你需要工具帮你检查所有的SQL语句的返回结果。比如，你可以使用开源工具<a href=https://www.percona.com/doc/percona-toolkit/3.0/pt-query-digest.html>pt-query-digest</a>。</p><h2 id=qps突增问题>QPS突增问题</h2><p>有时候由于业务突然出现高峰，或者应用程序bug，导致某个语句的QPS突然暴涨，也可能导致MySQL压力过大，影响服务。</p><p>我之前碰到过一类情况，是由一个新功能的bug导致的。当然，最理想的情况是让业务把这个功能下掉，服务自然就会恢复。</p><p>而下掉一个功能，如果从数据库端处理的话，对应于不同的背景，有不同的方法可用。我这里再和你展开说明一下。</p><ol><li>一种是由全新业务的bug导致的。假设你的DB运维是比较规范的，也就是说白名单是一个个加的。这种情况下，如果你能够确定业务方会下掉这个功能，只是时间上没那么快，那么就可以从数据库端直接把白名单去掉。</li><li>如果这个新功能使用的是单独的数据库用户，可以用管理员账号把这个用户删掉，然后断开现有连接。这样，这个新功能的连接不成功，由它引发的QPS就会变成0。</li><li>如果这个新增的功能跟主体功能是部署在一起的，那么我们只能通过处理语句来限制。这时，我们可以使用上面提到的查询重写功能，把压力最大的SQL语句直接重写成"select 1"返回。</li></ol><p>当然，这个操作的风险很高，需要你特别细致。它可能存在两个副作用：</p><ol><li>如果别的功能里面也用到了这个SQL语句模板，会有误伤；</li><li>很多业务并不是靠这一个语句就能完成逻辑的，所以如果单独把这一个语句以select 1的结果返回的话，可能会导致后面的业务逻辑一起失败。</li></ol><p>所以，方案3是用于止血的，跟前面提到的去掉权限验证一样，应该是你所有选项里优先级最低的一个方案。</p><p>同时你会发现，其实方案1和2都要依赖于规范的运维体系：虚拟化、白名单机制、业务账号分离。由此可见，更多的准备，往往意味着更稳定的系统。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-966a8aee076105d80306d2602993e6ba>5.23 - CH23-可靠保证</h1><p>今天这篇文章，我会继续和你介绍在业务高峰期临时提升性能的方法。从文章标题“MySQL是怎么保证数据不丢的？”，你就可以看出来，今天我和你介绍的方法，跟数据的可靠性有关。</p><p>在专栏前面文章和答疑篇中，我都着重介绍了WAL机制，得到的结论是：只要redo log和binlog保证持久化到磁盘，就能确保MySQL异常重启后，数据可以恢复。</p><p>评论区有同学又继续追问，redo log的写入流程是怎么样的，如何保证redo log真实地写入了磁盘。那么今天，我们就再一起看看MySQL写入binlog和redo log的流程。</p><h2 id=binlog的写入机制>binlog的写入机制</h2><p>其实，binlog的写入逻辑比较简单：事务执行过程中，先把日志写到binlog cache，事务提交的时候，再把binlog cache写到binlog文件中。</p><p>一个事务的binlog是不能被拆开的，因此不论这个事务多大，也要确保一次性写入。这就涉及到了binlog cache的保存问题。</p><p>系统给binlog cache分配了一片内存，每个线程一个，参数 binlog_cache_size用于控制单个线程内binlog cache所占内存的大小。如果超过了这个参数规定的大小，就要暂存到磁盘。</p><p>事务提交的时候，执行器把binlog cache里的完整事务写入到binlog中，并清空binlog cache。状态如图1所示。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/9ed86644d5f39efb0efec595abb92e3e.png style=display:block;width:80% alt=NAME align=center></div><p>可以看到，每个线程有自己binlog cache，但是共用同一份binlog文件。</p><ul><li>图中的write，指的就是指把日志写入到文件系统的page cache，并没有把数据持久化到磁盘，所以速度比较快。</li><li>图中的fsync，才是将数据持久化到磁盘的操作。一般情况下，我们认为fsync才占磁盘的IOPS。</li></ul><p>write 和fsync的时机，是由参数sync_binlog控制的：</p><ol><li>sync_binlog=0的时候，表示每次提交事务都只write，不fsync；</li><li>sync_binlog=1的时候，表示每次提交事务都会执行fsync；</li><li>sync_binlog=N(N>1)的时候，表示每次提交事务都write，但累积N个事务后才fsync。</li></ol><p>因此，在出现IO瓶颈的场景里，将sync_binlog设置成一个比较大的值，可以提升性能。在实际的业务场景中，考虑到丢失日志量的可控性，一般不建议将这个参数设成0，比较常见的是将其设置为100~1000中的某个数值。</p><p>但是，将sync_binlog设置为N，对应的风险是：如果主机发生异常重启，会丢失最近N个事务的binlog日志。</p><h2 id=redo-log的写入机制>redo log的写入机制</h2><p>接下来，我们再说说redo log的写入机制。</p><p>在专栏的第15篇答疑文章中，我给你介绍了redo log buffer。事务在执行过程中，生成的redo log是要先写到redo log buffer的。</p><p>然后就有同学问了，redo log buffer里面的内容，是不是每次生成后都要直接持久化到磁盘呢？</p><p>答案是，不需要。</p><p>如果事务执行期间MySQL发生异常重启，那这部分日志就丢了。由于事务并没有提交，所以这时日志丢了也不会有损失。</p><p>那么，另外一个问题是，事务还没提交的时候，redo log buffer中的部分日志有没有可能被持久化到磁盘呢？</p><p>答案是，确实会有。</p><p>这个问题，要从redo log可能存在的三种状态说起。这三种状态，对应的就是图2 中的三个颜色块。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211116221821.png style=display:block;width:80% alt=NAME align=center></div><p>这三种状态分别是：</p><ol><li>存在redo log buffer中，物理上是在MySQL进程内存中，就是图中的红色部分；</li><li>写到磁盘(write)，但是没有持久化（fsync)，物理上是在文件系统的page cache里面，也就是图中的黄色部分；</li><li>持久化到磁盘，对应的是hard disk，也就是图中的绿色部分。</li></ol><p>日志写到redo log buffer是很快的，wirte到page cache也差不多，但是持久化到磁盘的速度就慢多了。</p><p>为了控制redo log的写入策略，InnoDB提供了innodb_flush_log_at_trx_commit参数，它有三种可能取值：</p><ol><li>设置为0的时候，表示每次事务提交时都只是把redo log留在redo log buffer中;</li><li>设置为1的时候，表示每次事务提交时都将redo log直接持久化到磁盘；</li><li>设置为2的时候，表示每次事务提交时都只是把redo log写到page cache。</li></ol><p>InnoDB有一个后台线程，每隔1秒，就会把redo log buffer中的日志，调用write写到文件系统的page cache，然后调用fsync持久化到磁盘。</p><p>注意，事务执行中间过程的redo log也是直接写在redo log buffer中的，这些redo log也会被后台线程一起持久化到磁盘。也就是说，一个没有提交的事务的redo log，也是可能已经持久化到磁盘的。</p><p>实际上，除了后台线程每秒一次的轮询操作外，还有两种场景会让一个没有提交的事务的redo log写入到磁盘中。</p><ol><li>**一种是，redo log buffer占用的空间即将达到 innodb_log_buffer_size一半的时候，后台线程会主动写盘。**注意，由于这个事务并没有提交，所以这个写盘动作只是write，而没有调用fsync，也就是只留在了文件系统的page cache。</li><li>**另一种是，并行的事务提交的时候，顺带将这个事务的redo log buffer持久化到磁盘。**假设一个事务A执行到一半，已经写了一些redo log到buffer中，这时候有另外一个线程的事务B提交，如果innodb_flush_log_at_trx_commit设置的是1，那么按照这个参数的逻辑，事务B要把redo log buffer里的日志全部持久化到磁盘。这时候，就会带上事务A在redo log buffer里的日志一起持久化到磁盘。</li></ol><p>这里需要说明的是，我们介绍两阶段提交的时候说过，时序上redo log先prepare， 再写binlog，最后再把redo log commit。</p><p>如果把innodb_flush_log_at_trx_commit设置成1，那么redo log在prepare阶段就要持久化一次，因为有一个崩溃恢复逻辑是要依赖于prepare 的redo log，再加上binlog来恢复的。（如果你印象有点儿模糊了，可以再回顾下<a href=https://time.geekbang.org/column/article/73161>第15篇文章</a>中的相关内容）。</p><p>每秒一次后台轮询刷盘，再加上崩溃恢复这个逻辑，InnoDB就认为redo log在commit的时候就不需要fsync了，只会write到文件系统的page cache中就够了。</p><p>通常我们说MySQL的“双1”配置，指的就是sync_binlog和innodb_flush_log_at_trx_commit都设置成 1。也就是说，一个事务完整提交前，需要等待两次刷盘，一次是redo log（prepare 阶段），一次是binlog。</p><p>这时候，你可能有一个疑问，这意味着我从MySQL看到的TPS是每秒两万的话，每秒就会写四万次磁盘。但是，我用工具测试出来，磁盘能力也就两万左右，怎么能实现两万的TPS？</p><p>解释这个问题，就要用到组提交（group commit）机制了。</p><p>这里，我需要先和你介绍日志逻辑序列号（log sequence number，LSN）的概念。LSN是单调递增的，用来对应redo log的一个个写入点。每次写入长度为length的redo log， LSN的值就会加上length。</p><p>LSN也会写到InnoDB的数据页中，来确保数据页不会被多次执行重复的redo log。关于LSN和redo log、checkpoint的关系，我会在后面的文章中详细展开。</p><p>如图3所示，是三个并发事务(trx1, trx2, trx3)在prepare 阶段，都写完redo log buffer，持久化到磁盘的过程，对应的LSN分别是50、120 和160。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211116221837.png style=display:block;width:80% alt=NAME align=center></div><p>从图中可以看到，</p><ol><li>trx1是第一个到达的，会被选为这组的 leader；</li><li>等trx1要开始写盘的时候，这个组里面已经有了三个事务，这时候LSN也变成了160；</li><li>trx1去写盘的时候，带的就是LSN=160，因此等trx1返回时，所有LSN小于等于160的redo log，都已经被持久化到磁盘；</li><li>这时候trx2和trx3就可以直接返回了。</li></ol><p>所以，一次组提交里面，组员越多，节约磁盘IOPS的效果越好。但如果只有单线程压测，那就只能老老实实地一个事务对应一次持久化操作了。</p><p>在并发更新场景下，第一个事务写完redo log buffer以后，接下来这个fsync越晚调用，组员可能越多，节约IOPS的效果就越好。</p><p>为了让一次fsync带的组员更多，MySQL有一个很有趣的优化：拖时间。在介绍两阶段提交的时候，我曾经给你画了一个图，现在我把它截过来。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211116221853.png style=display:block;width:80% alt=NAME align=center></div><p>图中，我把“写binlog”当成一个动作。但实际上，写binlog是分成两步的：</p><ol><li>先把binlog从binlog cache中写到磁盘上的binlog文件；</li><li>调用fsync持久化。</li></ol><p>MySQL为了让组提交的效果更好，把redo log做fsync的时间拖到了步骤1之后。也就是说，上面的图变成了这样：</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211116221905.png style=display:block;width:80% alt=NAME align=center></div><p>这么一来，binlog也可以组提交了。在执行图5中第4步把binlog fsync到磁盘时，如果有多个事务的binlog已经写完了，也是一起持久化的，这样也可以减少IOPS的消耗。</p><p>不过通常情况下第3步执行得会很快，所以binlog的write和fsync间的间隔时间短，导致能集合到一起持久化的binlog比较少，因此binlog的组提交的效果通常不如redo log的效果那么好。</p><p>如果你想提升binlog组提交的效果，可以通过设置 binlog_group_commit_sync_delay 和 binlog_group_commit_sync_no_delay_count来实现。</p><ol><li>binlog_group_commit_sync_delay参数，表示延迟多少微秒后才调用fsync;</li><li>binlog_group_commit_sync_no_delay_count参数，表示累积多少次以后才调用fsync。</li></ol><p>这两个条件是或的关系，也就是说只要有一个满足条件就会调用fsync。</p><p>所以，当binlog_group_commit_sync_delay设置为0的时候，binlog_group_commit_sync_no_delay_count也无效了。</p><p>之前有同学在评论区问到，WAL机制是减少磁盘写，可是每次提交事务都要写redo log和binlog，这磁盘读写次数也没变少呀？</p><p>现在你就能理解了，WAL机制主要得益于两个方面：</p><ol><li>redo log 和 binlog都是顺序写，磁盘的顺序写比随机写速度要快；</li><li>组提交机制，可以大幅度降低磁盘的IOPS消耗。</li></ol><p>分析到这里，我们再来回答这个问题：<strong>如果你的MySQL现在出现了性能瓶颈，而且瓶颈在IO上，可以通过哪些方法来提升性能呢？</strong></p><p>针对这个问题，可以考虑以下三种方法：</p><ol><li>设置 binlog_group_commit_sync_delay 和 binlog_group_commit_sync_no_delay_count参数，减少binlog的写盘次数。这个方法是基于“额外的故意等待”来实现的，因此可能会增加语句的响应时间，但没有丢失数据的风险。</li><li>将sync_binlog 设置为大于1的值（比较常见是100~1000）。这样做的风险是，主机掉电时会丢binlog日志。</li><li>将innodb_flush_log_at_trx_commit设置为2。这样做的风险是，主机掉电的时候会丢数据。</li></ol><p>我不建议你把innodb_flush_log_at_trx_commit 设置成0。因为把这个参数设置成0，表示redo log只保存在内存中，这样的话MySQL本身异常重启也会丢数据，风险太大。而redo log写到文件系统的page cache的速度也是很快的，所以将这个参数设置成2跟设置成0其实性能差不多，但这样做MySQL异常重启时就不会丢数据了，相比之下风险会更小。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-269a373cc5da095b05f71f1689fd1e2e>5.24 - CH24-主备一致</h1><p>在前面的文章中，我不止一次地和你提到了binlog，大家知道binlog可以用来归档，也可以用来做主备同步，但它的内容是什么样的呢？为什么备库执行了binlog就可以跟主库保持一致了呢？今天我就正式地和你介绍一下它。</p><p>毫不夸张地说，MySQL能够成为现下最流行的开源数据库，binlog功不可没。</p><p>在最开始，MySQL是以容易学习和方便的高可用架构，被开发人员青睐的。而它的几乎所有的高可用架构，都直接依赖于binlog。虽然这些高可用架构已经呈现出越来越复杂的趋势，但都是从最基本的一主一备演化过来的。</p><p>今天这篇文章我主要为你介绍主备的基本原理。理解了背后的设计原理，你也可以从业务开发的角度，来借鉴这些设计思想。</p><h2 id=mysql主备的基本原理>MySQL主备的基本原理</h2><p>如图1所示就是基本的主备切换流程。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211116223248.png style=display:block;width:80% alt=NAME align=center></div><p>在状态1中，客户端的读写都直接访问节点A，而节点B是A的备库，只是将A的更新都同步过来，到本地执行。这样可以保持节点B和A的数据是相同的。</p><p>当需要切换的时候，就切成状态2。这时候客户端读写访问的都是节点B，而节点A是B的备库。</p><p>在状态1中，虽然节点B没有被直接访问，但是我依然建议你把节点B（也就是备库）设置成只读（readonly）模式。这样做，有以下几个考虑：</p><ol><li>有时候一些运营类的查询语句会被放到备库上去查，设置为只读可以防止误操作；</li><li>防止切换逻辑有bug，比如切换过程中出现双写，造成主备不一致；</li><li>可以用readonly状态，来判断节点的角色。</li></ol><p>你可能会问，我把备库设置成只读了，还怎么跟主库保持同步更新呢？</p><p>这个问题，你不用担心。因为readonly设置对超级(super)权限用户是无效的，而用于同步更新的线程，就拥有超级权限。</p><p>接下来，我们再看看<strong>节点A到B这条线的内部流程是什么样的</strong>。图2中画出的就是一个update语句在节点A执行，然后同步到节点B的完整流程图。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211116223301.png style=display:block;width:80% alt=NAME align=center></div><p>图2中，包含了我在上一篇文章中讲到的binlog和redo log的写入机制相关的内容，可以看到：主库接收到客户端的更新请求后，执行内部事务的更新逻辑，同时写binlog。</p><p>备库B跟主库A之间维持了一个长连接。主库A内部有一个线程，专门用于服务备库B的这个长连接。一个事务日志同步的完整过程是这样的：</p><ol><li>在备库B上通过change master命令，设置主库A的IP、端口、用户名、密码，以及要从哪个位置开始请求binlog，这个位置包含文件名和日志偏移量。</li><li>在备库B上执行start slave命令，这时候备库会启动两个线程，就是图中的io_thread和sql_thread。其中io_thread负责与主库建立连接。</li><li>主库A校验完用户名、密码后，开始按照备库B传过来的位置，从本地读取binlog，发给B。</li><li>备库B拿到binlog后，写到本地文件，称为中转日志（relay log）。</li><li>sql_thread读取中转日志，解析出日志里的命令，并执行。</li></ol><p>这里需要说明，后来由于多线程复制方案的引入，sql_thread演化成为了多个线程，跟我们今天要介绍的原理没有直接关系，暂且不展开。</p><p>分析完了这个长连接的逻辑，我们再来看一个问题：binlog里面到底是什么内容，为什么备库拿过去可以直接执行。</p><h2 id=binlog的三种格式对比>binlog的三种格式对比</h2><p>我在第15篇答疑文章中，和你提到过binlog有两种格式，一种是statement，一种是row。可能你在其他资料上还会看到有第三种格式，叫作mixed，其实它就是前两种格式的混合。</p><p>为了便于描述binlog的这三种格式间的区别，我创建了一个表，并初始化几行数据。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#000>mysql</span><span style=color:#ce5c00;font-weight:700>&gt;</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>CREATE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>TABLE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>t</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>(</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>id</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87>int</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>11</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>NOT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>NULL</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>a</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87>int</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>11</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>DEFAULT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>NULL</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>t_modified</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>timestamp</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>NOT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>NULL</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>DEFAULT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>CURRENT_TIMESTAMP</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>PRIMARY</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>KEY</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>(</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>id</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000;font-weight:700>),</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>KEY</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>a</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>(</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>a</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000;font-weight:700>),</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>KEY</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>t_modified</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000;font-weight:700>(</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>t_modified</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>ENGINE</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#000>InnoDB</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>insert</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>into</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>t</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>values</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>,</span><span style=color:#4e9a06>&#39;2018-11-13&#39;</span><span style=color:#000;font-weight:700>);</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>insert</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>into</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>t</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>values</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>2</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>2</span><span style=color:#000;font-weight:700>,</span><span style=color:#4e9a06>&#39;2018-11-12&#39;</span><span style=color:#000;font-weight:700>);</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>insert</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>into</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>t</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>values</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>3</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>3</span><span style=color:#000;font-weight:700>,</span><span style=color:#4e9a06>&#39;2018-11-11&#39;</span><span style=color:#000;font-weight:700>);</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>insert</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>into</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>t</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>values</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>4</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>4</span><span style=color:#000;font-weight:700>,</span><span style=color:#4e9a06>&#39;2018-11-10&#39;</span><span style=color:#000;font-weight:700>);</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>insert</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>into</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>t</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>values</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>5</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>5</span><span style=color:#000;font-weight:700>,</span><span style=color:#4e9a06>&#39;2018-11-09&#39;</span><span style=color:#000;font-weight:700>);</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><p>如果要在表中删除一行数据的话，我们来看看这个delete语句的binlog是怎么记录的。</p><p>注意，下面这个语句包含注释，如果你用MySQL客户端来做这个实验的话，要记得加-c参数，否则客户端会自动去掉注释。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#000>mysql</span><span style=color:#ce5c00;font-weight:700>&gt;</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>delete</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>from</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>t</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#8f5902;font-style:italic>/*comment*/</span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>where</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>a</span><span style=color:#ce5c00;font-weight:700>&gt;=</span><span style=color:#0000cf;font-weight:700>4</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>and</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>t_modified</span><span style=color:#ce5c00;font-weight:700>&lt;=</span><span style=color:#4e9a06>&#39;2018-11-10&#39;</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>limit</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><p>当binlog_format=statement时，binlog里面记录的就是SQL语句的原文。你可以用</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#000>mysql</span><span style=color:#ce5c00;font-weight:700>&gt;</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>show</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>binlog</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>events</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>in</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#4e9a06>&#39;master.000001&#39;</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><p>命令看binlog中的内容。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211116223328.png style=display:block;width:80% alt=NAME align=center></div><p>现在，我们来看一下图3的输出结果。</p><ul><li>第一行SET @@SESSION.GTID_NEXT=&lsquo;ANONYMOUS’你可以先忽略，后面文章我们会在介绍主备切换的时候再提到；</li><li>第二行是一个BEGIN，跟第四行的commit对应，表示中间是一个事务；</li><li>第三行就是真实执行的语句了。可以看到，在真实执行的delete命令之前，还有一个“use ‘test’”命令。这条命令不是我们主动执行的，而是MySQL根据当前要操作的表所在的数据库，自行添加的。这样做可以保证日志传到备库去执行的时候，不论当前的工作线程在哪个库里，都能够正确地更新到test库的表t。
use &rsquo;test’命令之后的delete 语句，就是我们输入的SQL原文了。可以看到，binlog“忠实”地记录了SQL命令，甚至连注释也一并记录了。</li><li>最后一行是一个COMMIT。你可以看到里面写着xid=61。你还记得这个XID是做什么用的吗？如果记忆模糊了，可以再回顾一下第15篇文章中的相关内容。</li></ul><p>为了说明statement 和 row格式的区别，我们来看一下这条delete命令的执行效果图：</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211116223340.png style=display:block;width:80% alt=NAME align=center></div><p>可以看到，运行这条delete命令产生了一个warning，原因是当前binlog设置的是statement格式，并且语句中有limit，所以这个命令可能是unsafe的。</p><p>为什么这么说呢？这是因为delete 带limit，很可能会出现主备数据不一致的情况。比如上面这个例子：</p><ol><li>如果delete语句使用的是索引a，那么会根据索引a找到第一个满足条件的行，也就是说删除的是a=4这一行；</li><li>但如果使用的是索引t_modified，那么删除的就是 t_modified=&lsquo;2018-11-09’也就是a=5这一行。</li></ol><p>由于statement格式下，记录到binlog里的是语句原文，因此可能会出现这样一种情况：在主库执行这条SQL语句的时候，用的是索引a；而在备库执行这条SQL语句的时候，却使用了索引t_modified。因此，MySQL认为这样写是有风险的。</p><p>那么，如果我把binlog的格式改为binlog_format=‘row’， 是不是就没有这个问题了呢？我们先来看看这时候binog中的内容吧。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211116223352.png style=display:block;width:80% alt=NAME align=center></div><p>可以看到，与statement格式的binlog相比，前后的BEGIN和COMMIT是一样的。但是，row格式的binlog里没有了SQL语句的原文，而是替换成了两个event：Table_map和Delete_rows。</p><ol><li>Table_map event，用于说明接下来要操作的表是test库的表t;</li><li>Delete_rows event，用于定义删除的行为。</li></ol><p>其实，我们通过图5是看不到详细信息的，还需要借助mysqlbinlog工具，用下面这个命令解析和查看binlog中的内容。因为图5中的信息显示，这个事务的binlog是从8900这个位置开始的，所以可以用start-position参数来指定从这个位置的日志开始解析。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>mysqlbinlog  -vv data/master.000001 --start-position=8900;
</span></span></code></pre></div><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211116223404.png style=display:block;width:80% alt=NAME align=center></div><p>从这个图中，我们可以看到以下几个信息：</p><ul><li>server id 1，表示这个事务是在server_id=1的这个库上执行的。</li><li>每个event都有CRC32的值，这是因为我把参数binlog_checksum设置成了CRC32。</li><li>Table_map event跟在图5中看到的相同，显示了接下来要打开的表，map到数字226。现在我们这条SQL语句只操作了一张表，如果要操作多张表呢？每个表都有一个对应的Table_map event、都会map到一个单独的数字，用于区分对不同表的操作。</li><li>我们在mysqlbinlog的命令中，使用了-vv参数是为了把内容都解析出来，所以从结果里面可以看到各个字段的值（比如，@1=4、 @2=4这些值）。</li><li>binlog_row_image的默认配置是FULL，因此Delete_event里面，包含了删掉的行的所有字段的值。如果把binlog_row_image设置为MINIMAL，则只会记录必要的信息，在这个例子里，就是只会记录id=4这个信息。</li><li>最后的Xid event，用于表示事务被正确地提交了。</li></ul><p>你可以看到，当binlog_format使用row格式的时候，binlog里面记录了真实删除行的主键id，这样binlog传到备库去的时候，就肯定会删除id=4的行，不会有主备删除不同行的问题。</p><h2 id=为什么会有mixed格式的binlog>为什么会有mixed格式的binlog？</h2><p>基于上面的信息，我们来讨论一个问题：**为什么会有mixed这种binlog格式的存在场景？**推论过程是这样的：</p><ul><li>因为有些statement格式的binlog可能会导致主备不一致，所以要使用row格式。</li><li>但row格式的缺点是，很占空间。比如你用一个delete语句删掉10万行数据，用statement的话就是一个SQL语句被记录到binlog中，占用几十个字节的空间。但如果用row格式的binlog，就要把这10万条记录都写到binlog中。这样做，不仅会占用更大的空间，同时写binlog也要耗费IO资源，影响执行速度。</li><li>所以，MySQL就取了个折中方案，也就是有了mixed格式的binlog。mixed格式的意思是，MySQL自己会判断这条SQL语句是否可能引起主备不一致，如果有可能，就用row格式，否则就用statement格式。</li></ul><p>也就是说，mixed格式可以利用statment格式的优点，同时又避免了数据不一致的风险。</p><p>因此，如果你的线上MySQL设置的binlog格式是statement的话，那基本上就可以认为这是一个不合理的设置。你至少应该把binlog的格式设置为mixed。</p><p>比如我们这个例子，设置为mixed后，就会记录为row格式；而如果执行的语句去掉limit 1，就会记录为statement格式。</p><p>当然我要说的是，现在越来越多的场景要求把MySQL的binlog格式设置成row。这么做的理由有很多，我来给你举一个可以直接看出来的好处：<strong>恢复数据</strong>。</p><p>接下来，我们就分别从delete、insert和update这三种SQL语句的角度，来看看数据恢复的问题。</p><p>通过图6你可以看出来，即使我执行的是delete语句，row格式的binlog也会把被删掉的行的整行信息保存起来。所以，如果你在执行完一条delete语句以后，发现删错数据了，可以直接把binlog中记录的delete语句转成insert，把被错删的数据插入回去就可以恢复了。</p><p>如果你是执行错了insert语句呢？那就更直接了。row格式下，insert语句的binlog里会记录所有的字段信息，这些信息可以用来精确定位刚刚被插入的那一行。这时，你直接把insert语句转成delete语句，删除掉这被误插入的一行数据就可以了。</p><p>如果执行的是update语句的话，binlog里面会记录修改前整行的数据和修改后的整行数据。所以，如果你误执行了update语句的话，只需要把这个event前后的两行信息对调一下，再去数据库里面执行，就能恢复这个更新操作了。</p><p>其实，由delete、insert或者update语句导致的数据操作错误，需要恢复到操作之前状态的情况，也时有发生。MariaDB的<a href=https://mariadb.com/kb/en/library/flashback/>Flashback</a>工具就是基于上面介绍的原理来回滚数据的。</p><p>虽然mixed格式的binlog现在已经用得不多了，但这里我还是要再借用一下mixed格式来说明一个问题，来看一下这条SQL语句：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>mysql&gt; insert into t values(10,10, now());
</span></span></code></pre></div><p>如果我们把binlog格式设置为mixed，你觉得MySQL会把它记录为row格式还是statement格式呢？</p><p>先不要着急说结果，我们一起来看一下这条语句执行的效果。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211116223430.png style=display:block;width:80% alt=NAME align=center></div><p>可以看到，MySQL用的居然是statement格式。你一定会奇怪，如果这个binlog过了1分钟才传给备库的话，那主备的数据不就不一致了吗？</p><p>接下来，我们再用mysqlbinlog工具来看看：</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211116223440.png style=display:block;width:80% alt=NAME align=center></div><p>从图中的结果可以看到，原来binlog在记录event的时候，多记了一条命令：SET TIMESTAMP=1546103491。它用 SET TIMESTAMP命令约定了接下来的now()函数的返回时间。</p><p>因此，不论这个binlog是1分钟之后被备库执行，还是3天后用来恢复这个库的备份，这个insert语句插入的行，值都是固定的。也就是说，通过这条SET TIMESTAMP命令，MySQL就确保了主备数据的一致性。</p><p>我之前看过有人在重放binlog数据的时候，是这么做的：用mysqlbinlog解析出日志，然后把里面的statement语句直接拷贝出来执行。</p><p>你现在知道了，这个方法是有风险的。因为有些语句的执行结果是依赖于上下文命令的，直接执行的结果很可能是错误的。</p><p>所以，用binlog来恢复数据的标准做法是，用 mysqlbinlog工具解析出来，然后把解析结果整个发给MySQL执行。类似下面的命令：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>mysqlbinlog master.000001  --start-position=2738 --stop-position=2973 | mysql -h127.0.0.1 -P13000 -u$user -p$pwd;
</span></span></code></pre></div><p>这个命令的意思是，将 master.000001 文件里面从第2738字节到第2973字节中间这段内容解析出来，放到MySQL去执行。</p><h2 id=循环复制问题>循环复制问题</h2><p>通过上面对MySQL中binlog基本内容的理解，你现在可以知道，binlog的特性确保了在备库执行相同的binlog，可以得到与主库相同的状态。</p><p>因此，我们可以认为正常情况下主备的数据是一致的。也就是说，图1中A、B两个节点的内容是一致的。其实，图1中我画的是M-S结构，但实际生产上使用比较多的是双M结构，也就是图9所示的主备切换流程。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211116223500.png style=display:block;width:80% alt=NAME align=center></div><p>对比图9和图1，你可以发现，双M结构和M-S结构，其实区别只是多了一条线，即：节点A和B之间总是互为主备关系。这样在切换的时候就不用再修改主备关系。</p><p>但是，双M结构还有一个问题需要解决。</p><p>业务逻辑在节点A上更新了一条语句，然后再把生成的binlog 发给节点B，节点B执行完这条更新语句后也会生成binlog。（我建议你把参数log_slave_updates设置为on，表示备库执行relay log后生成binlog）。</p><p>那么，如果节点A同时是节点B的备库，相当于又把节点B新生成的binlog拿过来执行了一次，然后节点A和B间，会不断地循环执行这个更新语句，也就是循环复制了。这个要怎么解决呢？</p><p>从上面的图6中可以看到，MySQL在binlog中记录了这个命令第一次执行时所在实例的server id。因此，我们可以用下面的逻辑，来解决两个节点间的循环复制的问题：</p><ol><li>规定两个库的server id必须不同，如果相同，则它们之间不能设定为主备关系；</li><li>一个备库接到binlog并在重放的过程中，生成与原binlog的server id相同的新的binlog；</li><li>每个库在收到从自己的主库发过来的日志后，先判断server id，如果跟自己的相同，表示这个日志是自己生成的，就直接丢弃这个日志。</li></ol><p>按照这个逻辑，如果我们设置了双M结构，日志的执行流就会变成这样：</p><ol><li>从节点A更新的事务，binlog里面记的都是A的server id；</li><li>传到节点B执行一次以后，节点B生成的binlog 的server id也是A的server id；</li><li>再传回给节点A，A判断到这个server id与自己的相同，就不会再处理这个日志。所以，死循环在这里就断掉了。</li></ol></div><div class=td-content style=page-break-before:always><h1 id=pg-0675bad201397104cfbb2f53d0046fe9>5.25 - CH25-高可用</h1><p>在上一篇文章中，我和你介绍了binlog的基本内容，在一个主备关系中，每个备库接收主库的binlog并执行。</p><p>正常情况下，只要主库执行更新生成的所有binlog，都可以传到备库并被正确地执行，备库就能达到跟主库一致的状态，这就是最终一致性。</p><p>但是，MySQL要提供高可用能力，只有最终一致性是不够的。为什么这么说呢？今天我就着重和你分析一下。</p><p>这里，我再放一次上一篇文章中讲到的双M结构的主备切换流程图。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211116235051.png style=display:block;width:80% alt=NAME align=center></div><h2 id=主备延迟>主备延迟</h2><p>主备切换可能是一个主动运维动作，比如软件升级、主库所在机器按计划下线等，也可能是被动操作，比如主库所在机器掉电。</p><p>接下来，我们先一起看看主动切换的场景。</p><p>在介绍主动切换流程的详细步骤之前，我要先跟你说明一个概念，即“同步延迟”。与数据同步有关的时间点主要包括以下三个：</p><ol><li>主库A执行完成一个事务，写入binlog，我们把这个时刻记为T1;</li><li>之后传给备库B，我们把备库B接收完这个binlog的时刻记为T2;</li><li>备库B执行完成这个事务，我们把这个时刻记为T3。</li></ol><p>所谓主备延迟，就是同一个事务，在备库执行完成的时间和主库执行完成的时间之间的差值，也就是T3-T1。</p><p>你可以在备库上执行show slave status命令，它的返回结果里面会显示seconds_behind_master，用于表示当前备库延迟了多少秒。</p><p>seconds_behind_master的计算方法是这样的：</p><ol><li>每个事务的binlog 里面都有一个时间字段，用于记录主库上写入的时间；</li><li>备库取出当前正在执行的事务的时间字段的值，计算它与当前系统时间的差值，得到seconds_behind_master。</li></ol><p>可以看到，其实seconds_behind_master这个参数计算的就是T3-T1。所以，我们可以用seconds_behind_master来作为主备延迟的值，这个值的时间精度是秒。</p><p>你可能会问，如果主备库机器的系统时间设置不一致，会不会导致主备延迟的值不准？</p><p>其实不会的。因为，备库连接到主库的时候，会通过执行SELECT UNIX_TIMESTAMP()函数来获得当前主库的系统时间。如果这时候发现主库的系统时间与自己不一致，备库在执行seconds_behind_master计算的时候会自动扣掉这个差值。</p><p>需要说明的是，在网络正常的时候，日志从主库传给备库所需的时间是很短的，即T2-T1的值是非常小的。也就是说，网络正常情况下，主备延迟的主要来源是备库接收完binlog和执行完这个事务之间的时间差。</p><p>所以说，主备延迟最直接的表现是，备库消费中转日志（relay log）的速度，比主库生产binlog的速度要慢。接下来，我就和你一起分析下，这可能是由哪些原因导致的。</p><h2 id=延迟来源>延迟来源</h2><p><strong>首先，有些部署条件下，备库所在机器的性能要比主库所在的机器性能差。</strong></p><p>一般情况下，有人这么部署时的想法是，反正备库没有请求，所以可以用差一点儿的机器。或者，他们会把20个主库放在4台机器上，而把备库集中在一台机器上。</p><p>其实我们都知道，更新请求对IOPS的压力，在主库和备库上是无差别的。所以，做这种部署时，一般都会将备库设置为“非双1”的模式。</p><p>但实际上，更新过程中也会触发大量的读操作。所以，当备库主机上的多个备库都在争抢资源的时候，就可能会导致主备延迟了。</p><p>当然，这种部署现在比较少了。因为主备可能发生切换，备库随时可能变成主库，所以主备库选用相同规格的机器，并且做对称部署，是现在比较常见的情况。</p><p>追问1：但是，做了对称部署以后，还可能会有延迟。这是为什么呢？</p><p>这就是<strong>第二种常见的可能了，即备库的压力大</strong>。一般的想法是，主库既然提供了写能力，那么备库可以提供一些读能力。或者一些运营后台需要的分析语句，不能影响正常业务，所以只能在备库上跑。</p><p>我真就见过不少这样的情况。由于主库直接影响业务，大家使用起来会比较克制，反而忽视了备库的压力控制。结果就是，备库上的查询耗费了大量的CPU资源，影响了同步速度，造成主备延迟。</p><p>这种情况，我们一般可以这么处理：</p><ol><li>一主多从。除了备库外，可以多接几个从库，让这些从库来分担读的压力。</li><li>通过binlog输出到外部系统，比如Hadoop这类系统，让外部系统提供统计类查询的能力。</li></ol><p>其中，一主多从的方式大都会被采用。因为作为数据库系统，还必须保证有定期全量备份的能力。而从库，就很适合用来做备份。</p><blockquote><p>备注：这里需要说明一下，从库和备库在概念上其实差不多。在我们这个专栏里，为了方便描述，我把会在HA过程中被选成新主库的，称为备库，其他的称为从库。</p></blockquote><p>追问2：采用了一主多从，保证备库的压力不会超过主库，还有什么情况可能导致主备延迟吗？</p><p><strong>这就是第三种可能了，即大事务。</strong></p><p>大事务这种情况很好理解。因为主库上必须等事务执行完成才会写入binlog，再传给备库。所以，如果一个主库上的语句执行10分钟，那这个事务很可能就会导致从库延迟10分钟。</p><p>不知道你所在公司的DBA有没有跟你这么说过：不要<strong>一次性地用delete语句删除太多数据</strong>。其实，这就是一个典型的大事务场景。</p><p>比如，一些归档类的数据，平时没有注意删除历史数据，等到空间快满了，业务开发人员要一次性地删掉大量历史数据。同时，又因为要避免在高峰期操作会影响业务（至少有这个意识还是很不错的），所以会在晚上执行这些大量数据的删除操作。</p><p>结果，负责的DBA同学半夜就会收到延迟报警。然后，DBA团队就要求你后续再删除数据的时候，要控制每个事务删除的数据量，分成多次删除。</p><p>**另一种典型的大事务场景，就是大表DDL。**这个场景，我在前面的文章中介绍过。处理方案就是，计划内的DDL，建议使用gh-ost方案。</p><p>追问3：如果主库上也不做大事务了，还有什么原因会导致主备延迟吗？</p><p>造成主备延迟还有一个大方向的原因，就是<strong>备库的并行复制能力</strong>。这个话题，我会留在下一篇文章再和你详细介绍。</p><p>其实还是有不少其他情况会导致主备延迟，如果你还碰到过其他场景，欢迎你在评论区给我留言，我来和你一起分析、讨论。</p><p>由于主备延迟的存在，所以在主备切换的时候，就相应的有不同的策略。</p><h2 id=可靠性优先策略>可靠性优先策略</h2><p>在图1的双M结构下，从状态1到状态2切换的详细过程是这样的：</p><ol><li>判断备库B现在的seconds_behind_master，如果小于某个值（比如5秒）继续下一步，否则持续重试这一步；</li><li>把主库A改成只读状态，即把readonly设置为true；</li><li>判断备库B的seconds_behind_master的值，直到这个值变成0为止；</li><li>把备库B改成可读写状态，也就是把readonly 设置为false；</li><li>把业务请求切到备库B。</li></ol><p>这个切换流程，一般是由专门的HA系统来完成的，我们暂时称之为可靠性优先流程。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211116235135.png style=display:block;width:80% alt=NAME align=center></div><p>备注：图中的SBM，是seconds_behind_master参数的简写。</p><p>可以看到，这个切换流程中是有不可用时间的。因为在步骤2之后，主库A和备库B都处于readonly状态，也就是说这时系统处于不可写状态，直到步骤5完成后才能恢复。</p><p>在这个不可用状态中，比较耗费时间的是步骤3，可能需要耗费好几秒的时间。这也是为什么需要在步骤1先做判断，确保seconds_behind_master的值足够小。</p><p>试想如果一开始主备延迟就长达30分钟，而不先做判断直接切换的话，系统的不可用时间就会长达30分钟，这种情况一般业务都是不可接受的。</p><p>当然，系统的不可用时间，是由这个数据可靠性优先的策略决定的。你也可以选择可用性优先的策略，来把这个不可用时间几乎降为0。</p><h2 id=可用性优先策略>可用性优先策略</h2><p>如果我强行把步骤4、5调整到最开始执行，也就是说不等主备数据同步，直接把连接切到备库B，并且让备库B可以读写，那么系统几乎就没有不可用时间了。</p><p>我们把这个切换流程，暂时称作可用性优先流程。这个切换流程的代价，就是可能出现数据不一致的情况。</p><p>接下来，我就和你分享一个可用性优先流程产生数据不一致的例子。假设有一个表 t：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#000>mysql</span><span style=color:#ce5c00;font-weight:700>&gt;</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>CREATE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>TABLE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>t</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>(</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>id</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87>int</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>11</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>unsigned</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>NOT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>NULL</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>AUTO_INCREMENT</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#204a87;font-weight:700>c</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87>int</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>11</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>unsigned</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>DEFAULT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>NULL</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>PRIMARY</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>KEY</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>(</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>id</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>ENGINE</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#000>InnoDB</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>insert</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>into</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>t</span><span style=color:#000;font-weight:700>(</span><span style=color:#204a87;font-weight:700>c</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>values</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>),(</span><span style=color:#0000cf;font-weight:700>2</span><span style=color:#000;font-weight:700>),(</span><span style=color:#0000cf;font-weight:700>3</span><span style=color:#000;font-weight:700>);</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><p>这个表定义了一个自增主键id，初始化数据后，主库和备库上都是3行数据。接下来，业务人员要继续在表t上执行两条插入语句的命令，依次是：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>insert</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>into</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>t</span><span style=color:#000;font-weight:700>(</span><span style=color:#204a87;font-weight:700>c</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>values</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>4</span><span style=color:#000;font-weight:700>);</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>insert</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>into</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>t</span><span style=color:#000;font-weight:700>(</span><span style=color:#204a87;font-weight:700>c</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>values</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>5</span><span style=color:#000;font-weight:700>);</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><p>假设，现在主库上其他的数据表有大量的更新，导致主备延迟达到5秒。在插入一条c=4的语句后，发起了主备切换。</p><p>图3是<strong>可用性优先策略，且binlog_format=mixed</strong>时的切换流程和数据结果。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211116235156.png style=display:block;width:80% alt=NAME align=center></div><p>现在，我们一起分析下这个切换流程：</p><ol><li>步骤2中，主库A执行完insert语句，插入了一行数据（4,4），之后开始进行主备切换。</li><li>步骤3中，由于主备之间有5秒的延迟，所以备库B还没来得及应用“插入c=4”这个中转日志，就开始接收客户端“插入 c=5”的命令。</li><li>步骤4中，备库B插入了一行数据（4,5），并且把这个binlog发给主库A。</li><li>步骤5中，备库B执行“插入c=4”这个中转日志，插入了一行数据（5,4）。而直接在备库B执行的“插入c=5”这个语句，传到主库A，就插入了一行新数据（5,5）。</li></ol><p>最后的结果就是，主库A和备库B上出现了两行不一致的数据。可以看到，这个数据不一致，是由可用性优先流程导致的。</p><p>那么，如果我还是用<strong>可用性优先策略，但设置binlog_format=row</strong>，情况又会怎样呢？</p><p>因为row格式在记录binlog的时候，会记录新插入的行的所有字段值，所以最后只会有一行不一致。而且，两边的主备同步的应用线程会报错duplicate key error并停止。也就是说，这种情况下，备库B的(5,4)和主库A的(5,5)这两行数据，都不会被对方执行。</p><p>图4中我画出了详细过程，你可以自己再分析一下。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211116235208.png style=display:block;width:80% alt=NAME align=center></div><p>从上面的分析中，你可以看到一些结论：</p><ol><li>使用row格式的binlog时，数据不一致的问题更容易被发现。而使用mixed或者statement格式的binlog时，数据很可能悄悄地就不一致了。如果你过了很久才发现数据不一致的问题，很可能这时的数据不一致已经不可查，或者连带造成了更多的数据逻辑不一致。</li><li>主备切换的可用性优先策略会导致数据不一致。因此，大多数情况下，我都建议你使用可靠性优先策略。毕竟对数据服务来说的话，数据的可靠性一般还是要优于可用性的。</li></ol><p>但事无绝对，<strong>有没有哪种情况数据的可用性优先级更高呢？</strong></p><p>答案是，有的。</p><p>我曾经碰到过这样的一个场景：</p><ul><li>有一个库的作用是记录操作日志。这时候，如果数据不一致可以通过binlog来修补，而这个短暂的不一致也不会引发业务问题。</li><li>同时，业务系统依赖于这个日志写入逻辑，如果这个库不可写，会导致线上的业务操作无法执行。</li></ul><p>这时候，你可能就需要选择先强行切换，事后再补数据的策略。</p><p>当然，事后复盘的时候，我们想到了一个改进措施就是，让业务逻辑不要依赖于这类日志的写入。也就是说，日志写入这个逻辑模块应该可以降级，比如写到本地文件，或者写到另外一个临时库里面。</p><p>这样的话，这种场景就又可以使用可靠性优先策略了。</p><p>接下来我们再看看，<strong>按照可靠性优先的思路，异常切换会是什么效果？</strong></p><p>假设，主库A和备库B间的主备延迟是30分钟，这时候主库A掉电了，HA系统要切换B作为主库。我们在主动切换的时候，可以等到主备延迟小于5秒的时候再启动切换，但这时候已经别无选择了。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211116235222.png style=display:block;width:80% alt=NAME align=center></div><p>采用可靠性优先策略的话，你就必须得等到备库B的seconds_behind_master=0之后，才能切换。但现在的情况比刚刚更严重，并不是系统只读、不可写的问题了，而是系统处于完全不可用的状态。因为，主库A掉电后，我们的连接还没有切到备库B。</p><p>你可能会问，那能不能直接切换到备库B，但是保持B只读呢？</p><p>这样也不行。</p><p>因为，这段时间内，中转日志还没有应用完成，如果直接发起主备切换，客户端查询看不到之前执行完成的事务，会认为有“数据丢失”。</p><p>虽然随着中转日志的继续应用，这些数据会恢复回来，但是对于一些业务来说，查询到“暂时丢失数据的状态”也是不能被接受的。</p><p>聊到这里你就知道了，在满足数据可靠性的前提下，MySQL高可用系统的可用性，是依赖于主备延迟的。延迟的时间越小，在主库故障的时候，服务恢复需要的时间就越短，可用性就越高。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-5dfea19463cdc24ffa1cb4b681fba9a8>5.26 - CH26-备库延迟</h1><p>在上一篇文章中，我和你介绍了几种可能导致备库延迟的原因。你会发现，这些场景里，不论是偶发性的查询压力，还是备份，对备库延迟的影响一般是分钟级的，而且在备库恢复正常以后都能够追上来。</p><p>但是，如果备库执行日志的速度持续低于主库生成日志的速度，那这个延迟就有可能成了小时级别。而且对于一个压力持续比较高的主库来说，备库很可能永远都追不上主库的节奏。</p><p>这就涉及到今天我要给你介绍的话题：备库并行复制能力。</p><p>为了便于你理解，我们再一起看一下第24篇文章的主备流程图。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211116235537.png style=display:block;width:80% alt=NAME align=center></div><p>谈到主备的并行复制能力，我们要关注的是图中黑色的两个箭头。一个箭头代表了客户端写入主库，另一箭头代表的是备库上sql_thread执行中转日志（relay log）。如果用箭头的粗细来代表并行度的话，那么真实情况就如图1所示，第一个箭头要明显粗于第二个箭头。</p><p>在主库上，影响并发度的原因就是各种锁了。由于InnoDB引擎支持行锁，除了所有并发事务都在更新同一行（热点行）这种极端场景外，它对业务并发度的支持还是很友好的。所以，你在性能测试的时候会发现，并发压测线程32就比单线程时，总体吞吐量高。</p><p>而日志在备库上的执行，就是图中备库上sql_thread更新数据(DATA)的逻辑。如果是用单线程的话，就会导致备库应用日志不够快，造成主备延迟。</p><p>在官方的5.6版本之前，MySQL只支持单线程复制，由此在主库并发高、TPS高时就会出现严重的主备延迟问题。</p><p>从单线程复制到最新版本的多线程复制，中间的演化经历了好几个版本。接下来，我就跟你说说MySQL多线程复制的演进过程。</p><p>其实说到底，所有的多线程复制机制，都是要把图1中只有一个线程的sql_thread，拆成多个线程，也就是都符合下面的这个模型：</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211116235553.png style=display:block;width:80% alt=NAME align=center></div><p>图2中，coordinator就是原来的sql_thread, 不过现在它不再直接更新数据了，只负责读取中转日志和分发事务。真正更新日志的，变成了worker线程。而work线程的个数，就是由参数slave_parallel_workers决定的。根据我的经验，把这个值设置为8~16之间最好（32核物理机的情况），毕竟备库还有可能要提供读查询，不能把CPU都吃光了。</p><p>接下来，你需要先思考一个问题：事务能不能按照轮询的方式分发给各个worker，也就是第一个事务分给worker_1，第二个事务发给worker_2呢？</p><p>其实是不行的。因为，事务被分发给worker以后，不同的worker就独立执行了。但是，由于CPU的调度策略，很可能第二个事务最终比第一个事务先执行。而如果这时候刚好这两个事务更新的是同一行，也就意味着，同一行上的两个事务，在主库和备库上的执行顺序相反，会导致主备不一致的问题。</p><p>接下来，请你再设想一下另外一个问题：同一个事务的多个更新语句，能不能分给不同的worker来执行呢？</p><p>答案是，也不行。举个例子，一个事务更新了表t1和表t2中的各一行，如果这两条更新语句被分到不同worker的话，虽然最终的结果是主备一致的，但如果表t1执行完成的瞬间，备库上有一个查询，就会看到这个事务“更新了一半的结果”，破坏了事务逻辑的原子性。</p><p>所以，coordinator在分发的时候，需要满足以下这两个基本要求：</p><ol><li>不能造成更新覆盖。这就要求更新同一行的两个事务，必须被分发到同一个worker中。</li><li>同一个事务不能被拆开，必须放到同一个worker中。</li></ol><p>各个版本的多线程复制，都遵循了这两条基本原则。接下来，我们就看看各个版本的并行复制策略。</p><h2 id=mysql-55版本的并行复制策略>MySQL 5.5版本的并行复制策略</h2><p>官方MySQL 5.5版本是不支持并行复制的。但是，在2012年的时候，我自己服务的业务出现了严重的主备延迟，原因就是备库只有单线程复制。然后，我就先后写了两个版本的并行策略。</p><p>这里，我给你介绍一下这两个版本的并行策略，即按表分发策略和按行分发策略，以帮助你理解MySQL官方版本并行复制策略的迭代。</p><h3 id=按表分发策略>按表分发策略</h3><p>按表分发事务的基本思路是，如果两个事务更新不同的表，它们就可以并行。因为数据是存储在表里的，所以按表分发，可以保证两个worker不会更新同一行。</p><p>当然，如果有跨表的事务，还是要把两张表放在一起考虑的。如图3所示，就是按表分发的规则。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211116235614.png style=display:block;width:80% alt=NAME align=center></div><p>可以看到，每个worker线程对应一个hash表，用于保存当前正在这个worker的“执行队列”里的事务所涉及的表。hash表的key是“库名.表名”，value是一个数字，表示队列中有多少个事务修改这个表。</p><p>在有事务分配给worker时，事务里面涉及的表会被加到对应的hash表中。worker执行完成后，这个表会被从hash表中去掉。</p><p>图3中，hash_table_1表示，现在worker_1的“待执行事务队列”里，有4个事务涉及到db1.t1表，有1个事务涉及到db2.t2表；hash_table_2表示，现在worker_2中有一个事务会更新到表t3的数据。</p><p>假设在图中的情况下，coordinator从中转日志中读入一个新事务T，这个事务修改的行涉及到表t1和t3。</p><p>现在我们用事务T的分配流程，来看一下分配规则。</p><ol><li>由于事务T中涉及修改表t1，而worker_1队列中有事务在修改表t1，事务T和队列中的某个事务要修改同一个表的数据，这种情况我们说事务T和worker_1是冲突的。</li><li>按照这个逻辑，顺序判断事务T和每个worker队列的冲突关系，会发现事务T跟worker_2也冲突。</li><li>事务T跟多于一个worker冲突，coordinator线程就进入等待。</li><li>每个worker继续执行，同时修改hash_table。假设hash_table_2里面涉及到修改表t3的事务先执行完成，就会从hash_table_2中把db1.t3这一项去掉。</li><li>这样coordinator会发现跟事务T冲突的worker只有worker_1了，因此就把它分配给worker_1。</li><li>coordinator继续读下一个中转日志，继续分配事务。</li></ol><p>也就是说，每个事务在分发的时候，跟所有worker的冲突关系包括以下三种情况：</p><ol><li>如果跟所有worker都不冲突，coordinator线程就会把这个事务分配给最空闲的woker;</li><li>如果跟多于一个worker冲突，coordinator线程就进入等待状态，直到和这个事务存在冲突关系的worker只剩下1个；</li><li>如果只跟一个worker冲突，coordinator线程就会把这个事务分配给这个存在冲突关系的worker。</li></ol><p>这个按表分发的方案，在多个表负载均匀的场景里应用效果很好。但是，如果碰到热点表，比如所有的更新事务都会涉及到某一个表的时候，所有事务都会被分配到同一个worker中，就变成单线程复制了。</p><h3 id=按行分发策略>按行分发策略</h3><p>要解决热点表的并行复制问题，就需要一个按行并行复制的方案。按行复制的核心思路是：如果两个事务没有更新相同的行，它们在备库上可以并行执行。显然，这个模式要求binlog格式必须是row。</p><p>这时候，我们判断一个事务T和worker是否冲突，用的就规则就不是“修改同一个表”，而是“修改同一行”。</p><p>按行复制和按表复制的数据结构差不多，也是为每个worker，分配一个hash表。只是要实现按行分发，这时候的key，就必须是“库名+表名+唯一键的值”。</p><p>但是，这个“唯一键”只有主键id还是不够的，我们还需要考虑下面这种场景，表t1中除了主键，还有唯一索引a：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span><span style=color:#204a87;font-weight:700>CREATE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>TABLE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>t1</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>(</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>id</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>int</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>11</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>NOT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>NULL</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>a</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>int</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>11</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>DEFAULT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>NULL</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>b</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>int</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>11</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>DEFAULT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>NULL</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>PRIMARY</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>KEY</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>(</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>id</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000;font-weight:700>),</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>UNIQUE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>KEY</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>a</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>(</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>a</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>ENGINE</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#000>InnoDB</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>insert</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>into</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>t1</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>values</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>),(</span><span style=color:#0000cf;font-weight:700>2</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>2</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>2</span><span style=color:#000;font-weight:700>),(</span><span style=color:#0000cf;font-weight:700>3</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>3</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>3</span><span style=color:#000;font-weight:700>),(</span><span style=color:#0000cf;font-weight:700>4</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>4</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>4</span><span style=color:#000;font-weight:700>),(</span><span style=color:#0000cf;font-weight:700>5</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>5</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>5</span><span style=color:#000;font-weight:700>);</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><p>假设，接下来我们要在主库执行这两个事务：</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211116235629.png style=display:block;width:80% alt=NAME align=center></div><p>可以看到，这两个事务要更新的行的主键值不同，但是如果它们被分到不同的worker，就有可能session B的语句先执行。这时候id=1的行的a的值还是1，就会报唯一键冲突。</p><p>因此，基于行的策略，事务hash表中还需要考虑唯一键，即key应该是“库名+表名+索引a的名字+a的值”。</p><p>比如，在上面这个例子中，我要在表t1上执行update t1 set a=1 where id=2语句，在binlog里面记录了整行的数据修改前各个字段的值，和修改后各个字段的值。</p><p>因此，coordinator在解析这个语句的binlog的时候，这个事务的hash表就有三个项:</p><ol><li>key=hash_func(db1+t1+“PRIMARY”+2), value=2; 这里value=2是因为修改前后的行id值不变，出现了两次。</li><li>key=hash_func(db1+t1+“a”+2), value=1，表示会影响到这个表a=2的行。</li><li>key=hash_func(db1+t1+“a”+1), value=1，表示会影响到这个表a=1的行。</li></ol><p>可见，**相比于按表并行分发策略，按行并行策略在决定线程分发的时候，需要消耗更多的计算资源。**你可能也发现了，这两个方案其实都有一些约束条件：</p><ol><li>要能够从binlog里面解析出表名、主键值和唯一索引的值。也就是说，主库的binlog格式必须是row；</li><li>表必须有主键；</li><li>不能有外键。表上如果有外键，级联更新的行不会记录在binlog中，这样冲突检测就不准确。</li></ol><p>但，好在这三条约束规则，本来就是DBA之前要求业务开发人员必须遵守的线上使用规范，所以这两个并行复制策略在应用上也没有碰到什么麻烦。</p><p>对比按表分发和按行分发这两个方案的话，按行分发策略的并行度更高。不过，如果是要操作很多行的大事务的话，按行分发的策略有两个问题：</p><ol><li>耗费内存。比如一个语句要删除100万行数据，这时候hash表就要记录100万个项。</li><li>耗费CPU。解析binlog，然后计算hash值，对于大事务，这个成本还是很高的。</li></ol><p>所以，我在实现这个策略的时候会设置一个阈值，单个事务如果超过设置的行数阈值（比如，如果单个事务更新的行数超过10万行），就暂时退化为单线程模式，退化过程的逻辑大概是这样的：</p><ol><li>coordinator暂时先hold住这个事务；</li><li>等待所有worker都执行完成，变成空队列；</li><li>coordinator直接执行这个事务；</li><li>恢复并行模式。</li></ol><p>读到这里，你可能会感到奇怪，这两个策略又没有被合到官方，我为什么要介绍这么详细呢？其实，介绍这两个策略的目的是抛砖引玉，方便你理解后面要介绍的社区版本策略。</p><h2 id=mysql-56版本的并行复制策略>MySQL 5.6版本的并行复制策略</h2><p>官方MySQL5.6版本，支持了并行复制，只是支持的粒度是按库并行。理解了上面介绍的按表分发策略和按行分发策略，你就理解了，用于决定分发策略的hash表里，key就是数据库名。</p><p>这个策略的并行效果，取决于压力模型。如果在主库上有多个DB，并且各个DB的压力均衡，使用这个策略的效果会很好。</p><p>相比于按表和按行分发，这个策略有两个优势：</p><ol><li>构造hash值的时候很快，只需要库名；而且一个实例上DB数也不会很多，不会出现需要构造100万个项这种情况。</li><li>不要求binlog的格式。因为statement格式的binlog也可以很容易拿到库名。</li></ol><p>但是，如果你的主库上的表都放在同一个DB里面，这个策略就没有效果了；或者如果不同DB的热点不同，比如一个是业务逻辑库，一个是系统配置库，那也起不到并行的效果。</p><p>理论上你可以创建不同的DB，把相同热度的表均匀分到这些不同的DB中，强行使用这个策略。不过据我所知，由于需要特地移动数据，这个策略用得并不多。</p><h2 id=mariadb的并行复制策略>MariaDB的并行复制策略</h2><p>在第23篇文章中，我给你介绍了redo log组提交(group commit)优化， 而MariaDB的并行复制策略利用的就是这个特性：</p><ol><li>能够在同一组里提交的事务，一定不会修改同一行；</li><li>主库上可以并行执行的事务，备库上也一定是可以并行执行的。</li></ol><p>在实现上，MariaDB是这么做的：</p><ol><li>在一组里面一起提交的事务，有一个相同的commit_id，下一组就是commit_id+1；</li><li>commit_id直接写到binlog里面；</li><li>传到备库应用的时候，相同commit_id的事务分发到多个worker执行；</li><li>这一组全部执行完成后，coordinator再去取下一批。</li></ol><p>当时，这个策略出来的时候是相当惊艳的。因为，之前业界的思路都是在“分析binlog，并拆分到worker”上。而MariaDB的这个策略，目标是“模拟主库的并行模式”。</p><p>但是，这个策略有一个问题，它并没有实现“真正的模拟主库并发度”这个目标。在主库上，一组事务在commit的时候，下一组事务是同时处于“执行中”状态的。</p><p>如图5所示，假设了三组事务在主库的执行情况，你可以看到在trx1、trx2和trx3提交的时候，trx4、trx5和trx6是在执行的。这样，在第一组事务提交完成的时候，下一组事务很快就会进入commit状态。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211116235645.png style=display:block;width:80% alt=NAME align=center></div><p>而按照MariaDB的并行复制策略，备库上的执行效果如图6所示。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211116235655.png style=display:block;width:80% alt=NAME align=center></div><p>可以看到，在备库上执行的时候，要等第一组事务完全执行完成后，第二组事务才能开始执行，这样系统的吞吐量就不够。</p><p>另外，这个方案很容易被大事务拖后腿。假设trx2是一个超大事务，那么在备库应用的时候，trx1和trx3执行完成后，就只能等trx2完全执行完成，下一组才能开始执行。这段时间，只有一个worker线程在工作，是对资源的浪费。</p><p>不过即使如此，这个策略仍然是一个很漂亮的创新。因为，它对原系统的改造非常少，实现也很优雅。</p><h2 id=mysql-57的并行复制策略>MySQL 5.7的并行复制策略</h2><p>在MariaDB并行复制实现之后，官方的MySQL5.7版本也提供了类似的功能，由参数slave-parallel-type来控制并行复制策略：</p><ol><li>配置为DATABASE，表示使用MySQL 5.6版本的按库并行策略；</li><li>配置为 LOGICAL_CLOCK，表示的就是类似MariaDB的策略。不过，MySQL 5.7这个策略，针对并行度做了优化。这个优化的思路也很有趣儿。</li></ol><p>你可以先考虑这样一个问题：同时处于“执行状态”的所有事务，是不是可以并行？</p><p>答案是，不能。</p><p>因为，这里面可能有由于锁冲突而处于锁等待状态的事务。如果这些事务在备库上被分配到不同的worker，就会出现备库跟主库不一致的情况。</p><p>而上面提到的MariaDB这个策略的核心，是“所有处于commit”状态的事务可以并行。事务处于commit状态，表示已经通过了锁冲突的检验了。</p><p>这时候，你可以再回顾一下两阶段提交，我把前面第23篇文章中介绍过的两阶段提交过程图贴过来。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211116235709.png style=display:block;width:80% alt=NAME align=center></div><p>其实，不用等到commit阶段，只要能够到达redo log prepare阶段，就表示事务已经通过锁冲突的检验了。</p><p>因此，MySQL 5.7并行复制策略的思想是：</p><ol><li>同时处于prepare状态的事务，在备库执行时是可以并行的；</li><li>处于prepare状态的事务，与处于commit状态的事务之间，在备库执行时也是可以并行的。</li></ol><p>我在第23篇文章，讲binlog的组提交的时候，介绍过两个参数：</p><ol><li>binlog_group_commit_sync_delay参数，表示延迟多少微秒后才调用fsync;</li><li>binlog_group_commit_sync_no_delay_count参数，表示累积多少次以后才调用fsync。</li></ol><p>这两个参数是用于故意拉长binlog从write到fsync的时间，以此减少binlog的写盘次数。在MySQL 5.7的并行复制策略里，它们可以用来制造更多的“同时处于prepare阶段的事务”。这样就增加了备库复制的并行度。</p><p>也就是说，这两个参数，既可以“故意”让主库提交得慢些，又可以让备库执行得快些。在MySQL 5.7处理备库延迟的时候，可以考虑调整这两个参数值，来达到提升备库复制并发度的目的。</p><h2 id=mysql-5722的并行复制策略>MySQL 5.7.22的并行复制策略</h2><p>在2018年4月份发布的MySQL 5.7.22版本里，MySQL增加了一个新的并行复制策略，基于WRITESET的并行复制。</p><p>相应地，新增了一个参数binlog-transaction-dependency-tracking，用来控制是否启用这个新策略。这个参数的可选值有以下三种。</p><ol><li>COMMIT_ORDER，表示的就是前面介绍的，根据同时进入prepare和commit来判断是否可以并行的策略。</li><li>WRITESET，表示的是对于事务涉及更新的每一行，计算出这一行的hash值，组成集合writeset。如果两个事务没有操作相同的行，也就是说它们的writeset没有交集，就可以并行。</li><li>WRITESET_SESSION，是在WRITESET的基础上多了一个约束，即在主库上同一个线程先后执行的两个事务，在备库执行的时候，要保证相同的先后顺序。</li></ol><p>当然为了唯一标识，这个hash值是通过“库名+表名+索引名+值”计算出来的。如果一个表上除了有主键索引外，还有其他唯一索引，那么对于每个唯一索引，insert语句对应的writeset就要多增加一个hash值。</p><p>你可能看出来了，这跟我们前面介绍的基于MySQL 5.5版本的按行分发的策略是差不多的。不过，MySQL官方的这个实现还是有很大的优势：</p><ol><li>writeset是在主库生成后直接写入到binlog里面的，这样在备库执行的时候，不需要解析binlog内容（event里的行数据），节省了很多计算量；</li><li>不需要把整个事务的binlog都扫一遍才能决定分发到哪个worker，更省内存；</li><li>由于备库的分发策略不依赖于binlog内容，所以binlog是statement格式也是可以的。</li></ol><p>因此，MySQL 5.7.22的并行复制策略在通用性上还是有保证的。</p><p>当然，对于“表上没主键”和“外键约束”的场景，WRITESET策略也是没法并行的，也会暂时退化为单线程模型。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-53b4ceed281c41c2c9e040d31ccadf5e>5.27 - CH27-主库故障</h1><p>大多数的互联网应用场景都是读多写少，因此你负责的业务，在发展过程中很可能先会遇到读性能的问题。而在数据库层解决读性能问题，就要涉及到接下来两篇文章要讨论的架构：一主多从。</p><p>今天这篇文章，我们就先聊聊一主多从的切换正确性。然后，我们在下一篇文章中再聊聊解决一主多从的查询逻辑正确性的方法。</p><p>如图1所示，就是一个基本的一主多从结构。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211116235857.png style=display:block;width:80% alt=NAME align=center></div><p>图中，虚线箭头表示的是主备关系，也就是A和A’互为主备， 从库B、C、D指向的是主库A。一主多从的设置，一般用于读写分离，主库负责所有的写入和一部分读，其他的读请求则由从库分担。</p><p>今天我们要讨论的就是，在一主多从架构下，主库故障后的主备切换问题。</p><p>如图2所示，就是主库发生故障，主备切换后的结果。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211116235907.png style=display:block;width:80% alt=NAME align=center></div><p>相比于一主一备的切换流程，一主多从结构在切换完成后，A’会成为新的主库，从库B、C、D也要改接到A’。正是由于多了从库B、C、D重新指向的这个过程，所以主备切换的复杂性也相应增加了。</p><p>接下来，我们再一起看看一个切换系统会怎么完成一主多从的主备切换过程。</p><h2 id=基于位点的主备切换>基于位点的主备切换</h2><p>这里，我们需要先来回顾一个知识点。</p><p>当我们把节点B设置成节点A’的从库的时候，需要执行一条change master命令：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>CHANGE MASTER TO 
</span></span><span style=display:flex><span>MASTER_HOST=$host_name 
</span></span><span style=display:flex><span>MASTER_PORT=$port 
</span></span><span style=display:flex><span>MASTER_USER=$user_name 
</span></span><span style=display:flex><span>MASTER_PASSWORD=$password 
</span></span><span style=display:flex><span>MASTER_LOG_FILE=$master_log_name 
</span></span><span style=display:flex><span>MASTER_LOG_POS=$master_log_pos  
</span></span></code></pre></div><p>这条命令有这么6个参数：</p><ul><li>MASTER_HOST、MASTER_PORT、MASTER_USER和MASTER_PASSWORD四个参数，分别代表了主库A’的IP、端口、用户名和密码。</li><li>最后两个参数MASTER_LOG_FILE和MASTER_LOG_POS表示，要从主库的master_log_name文件的master_log_pos这个位置的日志继续同步。而这个位置就是我们所说的同步位点，也就是主库对应的文件名和日志偏移量。</li></ul><p>那么，这里就有一个问题了，节点B要设置成A’的从库，就要执行change master命令，就不可避免地要设置位点的这两个参数，但是这两个参数到底应该怎么设置呢？</p><p>原来节点B是A的从库，本地记录的也是A的位点。但是相同的日志，A的位点和A’的位点是不同的。因此，从库B要切换的时候，就需要先经过“找同步位点”这个逻辑。</p><p>这个位点很难精确取到，只能取一个大概位置。为什么这么说呢？</p><p>我来和你分析一下看看这个位点一般是怎么获取到的，你就清楚其中不精确的原因了。</p><p>考虑到切换过程中不能丢数据，所以我们找位点的时候，总是要找一个“稍微往前”的，然后再通过判断跳过那些在从库B上已经执行过的事务。</p><p>一种取同步位点的方法是这样的：</p><ol><li>等待新主库A’把中转日志（relay log）全部同步完成；</li><li>在A’上执行show master status命令，得到当前A’上最新的File 和 Position；</li><li>取原主库A故障的时刻T；</li><li>用mysqlbinlog工具解析A’的File，得到T时刻的位点。</li></ol><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>mysqlbinlog File --stop-datetime=T --start-datetime=T
</span></span></code></pre></div><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211116235922.png style=display:block;width:80% alt=NAME align=center></div><p>图中，end_log_pos后面的值“123”，表示的就是A’这个实例，在T时刻写入新的binlog的位置。然后，我们就可以把123这个值作为$master_log_pos ，用在节点B的change master命令里。</p><p>当然这个值并不精确。为什么呢？</p><p>你可以设想有这么一种情况，假设在T这个时刻，主库A已经执行完成了一个insert 语句插入了一行数据R，并且已经将binlog传给了A’和B，然后在传完的瞬间主库A的主机就掉电了。</p><p>那么，这时候系统的状态是这样的：</p><ol><li>在从库B上，由于同步了binlog， R这一行已经存在；</li><li>在新主库A’上， R这一行也已经存在，日志是写在123这个位置之后的；</li><li>我们在从库B上执行change master命令，指向A’的File文件的123位置，就会把插入R这一行数据的binlog又同步到从库B去执行。</li></ol><p>这时候，从库B的同步线程就会报告 Duplicate entry ‘id_of_R’ for key ‘PRIMARY’ 错误，提示出现了主键冲突，然后停止同步。</p><p>所以，<strong>通常情况下，我们在切换任务的时候，要先主动跳过这些错误，有两种常用的方法。</strong></p><p><strong>一种做法是</strong>，主动跳过一个事务。跳过命令的写法是：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>set global sql_slave_skip_counter=1;
</span></span><span style=display:flex><span>start slave;
</span></span></code></pre></div><p>因为切换过程中，可能会不止重复执行一个事务，所以我们需要在从库B刚开始接到新主库A’时，持续观察，每次碰到这些错误就停下来，执行一次跳过命令，直到不再出现停下来的情况，以此来跳过可能涉及的所有事务。</p><p>**另外一种方式是，**通过设置slave_skip_errors参数，直接设置跳过指定的错误。</p><p>在执行主备切换时，有这么两类错误，是经常会遇到的：</p><ul><li>1062错误是插入数据时唯一键冲突；</li><li>1032错误是删除数据时找不到行。</li></ul><p>因此，我们可以把slave_skip_errors 设置为 “1032,1062”，这样中间碰到这两个错误时就直接跳过。</p><p>这里需要注意的是，这种直接跳过指定错误的方法，针对的是主备切换时，由于找不到精确的同步位点，所以只能采用这种方法来创建从库和新主库的主备关系。</p><p>这个背景是，我们很清楚在主备切换过程中，直接跳过1032和1062这两类错误是无损的，所以才可以这么设置slave_skip_errors参数。等到主备间的同步关系建立完成，并稳定执行一段时间之后，我们还需要把这个参数设置为空，以免之后真的出现了主从数据不一致，也跳过了。</p><h2 id=gtid>GTID</h2><p>通过sql_slave_skip_counter跳过事务和通过slave_skip_errors忽略错误的方法，虽然都最终可以建立从库B和新主库A’的主备关系，但这两种操作都很复杂，而且容易出错。所以，MySQL 5.6版本引入了GTID，彻底解决了这个困难。</p><p>那么，GTID到底是什么意思，又是如何解决找同步位点这个问题呢？现在，我就和你简单介绍一下。</p><p>GTID的全称是Global Transaction Identifier，也就是全局事务ID，是一个事务在提交的时候生成的，是这个事务的唯一标识。它由两部分组成，格式是：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>GTID=server_uuid:gno
</span></span></code></pre></div><p>其中：</p><ul><li>server_uuid是一个实例第一次启动时自动生成的，是一个全局唯一的值；</li><li>gno是一个整数，初始值是1，每次提交事务的时候分配给这个事务，并加1。</li></ul><p>这里我需要和你说明一下，在MySQL的官方文档里，GTID格式是这么定义的：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>GTID=source_id:transaction_id
</span></span></code></pre></div><p>这里的source_id就是server_uuid；而后面的这个transaction_id，我觉得容易造成误导，所以我改成了gno。为什么说使用transaction_id容易造成误解呢？</p><p>因为，在MySQL里面我们说transaction_id就是指事务id，事务id是在事务执行过程中分配的，如果这个事务回滚了，事务id也会递增，而gno是在事务提交的时候才会分配。</p><p>从效果上看，GTID往往是连续的，因此我们用gno来表示更容易理解。</p><p>GTID模式的启动也很简单，我们只需要在启动一个MySQL实例的时候，加上参数gtid_mode=on和enforce_gtid_consistency=on就可以了。</p><p>在GTID模式下，每个事务都会跟一个GTID一一对应。这个GTID有两种生成方式，而使用哪种方式取决于session变量gtid_next的值。</p><ol><li>如果gtid_next=automatic，代表使用默认值。这时，MySQL就会把server_uuid:gno分配给这个事务。
a. 记录binlog的时候，先记录一行 SET @@SESSION.GTID_NEXT=‘server_uuid:gno’;
b. 把这个GTID加入本实例的GTID集合。</li><li>如果gtid_next是一个指定的GTID的值，比如通过set gtid_next=&lsquo;current_gtid’指定为current_gtid，那么就有两种可能：
a. 如果current_gtid已经存在于实例的GTID集合中，接下来执行的这个事务会直接被系统忽略；
b. 如果current_gtid没有存在于实例的GTID集合中，就将这个current_gtid分配给接下来要执行的事务，也就是说系统不需要给这个事务生成新的GTID，因此gno也不用加1。</li></ol><p>注意，一个current_gtid只能给一个事务使用。这个事务提交后，如果要执行下一个事务，就要执行set 命令，把gtid_next设置成另外一个gtid或者automatic。</p><p>这样，每个MySQL实例都维护了一个GTID集合，用来对应“这个实例执行过的所有事务”。</p><p>这样看上去不太容易理解，接下来我就用一个简单的例子，来和你说明GTID的基本用法。</p><p>我们在实例X中创建一个表t。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span><span style=color:#204a87;font-weight:700>CREATE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>TABLE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>t</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>(</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>id</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>int</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>11</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>NOT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>NULL</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>c</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>int</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>11</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>DEFAULT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>NULL</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>PRIMARY</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>KEY</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>(</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>id</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>ENGINE</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#000>InnoDB</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>insert</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>into</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>t</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>values</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>);</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211116235937.png style=display:block;width:80% alt=NAME align=center></div><p>可以看到，事务的BEGIN之前有一条SET @@SESSION.GTID_NEXT命令。这时，如果实例X有从库，那么将CREATE TABLE和insert语句的binlog同步过去执行的话，执行事务之前就会先执行这两个SET命令， 这样被加入从库的GTID集合的，就是图中的这两个GTID。</p><p>假设，现在这个实例X是另外一个实例Y的从库，并且此时在实例Y上执行了下面这条插入语句：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>insert into t values(1,1);
</span></span></code></pre></div><p>并且，这条语句在实例Y上的GTID是 “aaaaaaaa-cccc-dddd-eeee-ffffffffffff:10”。</p><p>那么，实例X作为Y的从库，就要同步这个事务过来执行，显然会出现主键冲突，导致实例X的同步线程停止。这时，我们应该怎么处理呢？</p><p>处理方法就是，你可以执行下面的这个语句序列：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>set gtid_next=&#39;aaaaaaaa-cccc-dddd-eeee-ffffffffffff:10&#39;;
</span></span><span style=display:flex><span>begin;
</span></span><span style=display:flex><span>commit;
</span></span><span style=display:flex><span>set gtid_next=automatic;
</span></span><span style=display:flex><span>start slave;
</span></span></code></pre></div><p>其中，前三条语句的作用，是通过提交一个空事务，把这个GTID加到实例X的GTID集合中。如图5所示，就是执行完这个空事务之后的show master status的结果。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211116235949.png style=display:block;width:80% alt=NAME align=center></div><p>可以看到实例X的Executed_Gtid_set里面，已经加入了这个GTID。</p><p>这样，我再执行start slave命令让同步线程执行起来的时候，虽然实例X上还是会继续执行实例Y传过来的事务，但是由于“aaaaaaaa-cccc-dddd-eeee-ffffffffffff:10”已经存在于实例X的GTID集合中了，所以实例X就会直接跳过这个事务，也就不会再出现主键冲突的错误。</p><p>在上面的这个语句序列中，start slave命令之前还有一句set gtid_next=automatic。这句话的作用是“恢复GTID的默认分配行为”，也就是说如果之后有新的事务再执行，就还是按照原来的分配方式，继续分配gno=3。</p><h1 id=基于gtid的主备切换>基于GTID的主备切换</h1><p>现在，我们已经理解GTID的概念，再一起来看看基于GTID的主备复制的用法。</p><p>在GTID模式下，备库B要设置为新主库A’的从库的语法如下：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>CHANGE MASTER TO 
</span></span><span style=display:flex><span>MASTER_HOST=$host_name 
</span></span><span style=display:flex><span>MASTER_PORT=$port 
</span></span><span style=display:flex><span>MASTER_USER=$user_name 
</span></span><span style=display:flex><span>MASTER_PASSWORD=$password 
</span></span><span style=display:flex><span>master_auto_position=1 
</span></span></code></pre></div><p>其中，master_auto_position=1就表示这个主备关系使用的是GTID协议。可以看到，前面让我们头疼不已的MASTER_LOG_FILE和MASTER_LOG_POS参数，已经不需要指定了。</p><p>我们把现在这个时刻，实例A’的GTID集合记为set_a，实例B的GTID集合记为set_b。接下来，我们就看看现在的主备切换逻辑。</p><p>我们在实例B上执行start slave命令，取binlog的逻辑是这样的：</p><ol><li>实例B指定主库A’，基于主备协议建立连接。</li><li>实例B把set_b发给主库A’。</li><li>实例A’算出set_a与set_b的差集，也就是所有存在于set_a，但是不存在于set_b的GITD的集合，判断A’本地是否包含了这个差集需要的所有binlog事务。
a. 如果不包含，表示A’已经把实例B需要的binlog给删掉了，直接返回错误；
b. 如果确认全部包含，A’从自己的binlog文件里面，找出第一个不在set_b的事务，发给B；</li><li>之后就从这个事务开始，往后读文件，按顺序取binlog发给B去执行。</li></ol><p>其实，这个逻辑里面包含了一个设计思想：在基于GTID的主备关系里，系统认为只要建立主备关系，就必须保证主库发给备库的日志是完整的。因此，如果实例B需要的日志已经不存在，A’就拒绝把日志发给B。</p><p>这跟基于位点的主备协议不同。基于位点的协议，是由备库决定的，备库指定哪个位点，主库就发哪个位点，不做日志的完整性判断。</p><p>基于上面的介绍，我们再来看看引入GTID后，一主多从的切换场景下，主备切换是如何实现的。</p><p>由于不需要找位点了，所以从库B、C、D只需要分别执行change master命令指向实例A’即可。</p><p>其实，严谨地说，主备切换不是不需要找位点了，而是找位点这个工作，在实例A’内部就已经自动完成了。但由于这个工作是自动的，所以对HA系统的开发人员来说，非常友好。</p><p>之后这个系统就由新主库A’写入，主库A’的自己生成的binlog中的GTID集合格式是：server_uuid_of_A’:1-M。</p><p>如果之前从库B的GTID集合格式是 server_uuid_of_A:1-N， 那么切换之后GTID集合的格式就变成了server_uuid_of_A:1-N, server_uuid_of_A’:1-M。</p><p>当然，主库A’之前也是A的备库，因此主库A’和从库B的GTID集合是一样的。这就达到了我们预期。</p><h2 id=gtid和在线ddl>GTID和在线DDL</h2><p>接下来，我再举个例子帮你理解GTID。</p><p>之前在第22篇文章中，我和你提到业务高峰期的慢查询性能问题时，分析到如果是由于索引缺失引起的性能问题，我们可以通过在线加索引来解决。但是，考虑到要避免新增索引对主库性能造成的影响，我们可以先在备库加索引，然后再切换。</p><p>当时我说，在双M结构下，备库执行的DDL语句也会传给主库，为了避免传回后对主库造成影响，要通过set sql_log_bin=off关掉binlog。</p><p>评论区有位同学提出了一个问题：这样操作的话，数据库里面是加了索引，但是binlog并没有记录下这一个更新，是不是会导致数据和日志不一致？</p><p>这个问题提得非常好。当时，我在留言的回复中就引用了GTID来说明。今天，我再和你展开说明一下。</p><p>假设，这两个互为主备关系的库还是实例X和实例Y，且当前主库是X，并且都打开了GTID模式。这时的主备切换流程可以变成下面这样：</p><ul><li>在实例X上执行stop slave。</li><li>在实例Y上执行DDL语句。注意，这里并不需要关闭binlog。</li><li>执行完成后，查出这个DDL语句对应的GTID，并记为 server_uuid_of_Y:gno。</li><li>到实例X上执行以下语句序列：</li></ul><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>set GTID_NEXT=&#34;server_uuid_of_Y:gno&#34;;
</span></span><span style=display:flex><span>begin;
</span></span><span style=display:flex><span>commit;
</span></span><span style=display:flex><span>set gtid_next=automatic;
</span></span><span style=display:flex><span>start slave;
</span></span></code></pre></div><p>这样做的目的在于，既可以让实例Y的更新有binlog记录，同时也可以确保不会在实例X上执行这条更新。</p><ul><li>接下来，执行完主备切换，然后照着上述流程再执行一遍即可。</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-7371b53aa14505a693659fe7b806bde8>5.28 - CH28-读写分离</h1><p>在上一篇文章中，我和你介绍了一主多从的结构以及切换流程。今天我们就继续聊聊一主多从架构的应用场景：读写分离，以及怎么处理主备延迟导致的读写分离问题。</p><p>我们在上一篇文章中提到的一主多从的结构，其实就是读写分离的基本结构了。这里，我再把这张图贴过来，方便你理解。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211117000107.png style=display:block;width:80% alt=NAME align=center></div><p>读写分离的主要目标就是分摊主库的压力。图1中的结构是客户端（client）主动做负载均衡，这种模式下一般会把数据库的连接信息放在客户端的连接层。也就是说，由客户端来选择后端数据库进行查询。</p><p>还有一种架构是，在MySQL和客户端之间有一个中间代理层proxy，客户端只连接proxy， 由proxy根据请求类型和上下文决定请求的分发路由。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211117000116.png style=display:block;width:80% alt=NAME align=center></div><p>接下来，我们就看一下客户端直连和带proxy的读写分离架构，各有哪些特点。</p><ol><li>客户端直连方案，因为少了一层proxy转发，所以查询性能稍微好一点儿，并且整体架构简单，排查问题更方便。但是这种方案，由于要了解后端部署细节，所以在出现主备切换、库迁移等操作的时候，客户端都会感知到，并且需要调整数据库连接信息。
你可能会觉得这样客户端也太麻烦了，信息大量冗余，架构很丑。其实也未必，一般采用这样的架构，一定会伴随一个负责管理后端的组件，比如Zookeeper，尽量让业务端只专注于业务逻辑开发。</li><li>带proxy的架构，对客户端比较友好。客户端不需要关注后端细节，连接维护、后端信息维护等工作，都是由proxy完成的。但这样的话，对后端维护团队的要求会更高。而且，proxy也需要有高可用架构。因此，带proxy架构的整体就相对比较复杂。</li></ol><p>理解了这两种方案的优劣，具体选择哪个方案就取决于数据库团队提供的能力了。但目前看，趋势是往带proxy的架构方向发展的。</p><p>但是，不论使用哪种架构，你都会碰到我们今天要讨论的问题：由于主从可能存在延迟，客户端执行完一个更新事务后马上发起查询，如果查询选择的是从库的话，就有可能读到刚刚的事务更新之前的状态。</p><p><strong>这种“在从库上会读到系统的一个过期状态”的现象，在这篇文章里，我们暂且称之为“过期读”。</strong></p><p>前面我们说过了几种可能导致主备延迟的原因，以及对应的优化策略，但是主从延迟还是不能100%避免的。</p><p>不论哪种结构，客户端都希望查询从库的数据结果，跟查主库的数据结果是一样的。</p><p>接下来，我们就来讨论怎么处理过期读问题。</p><p>这里，我先把文章中涉及到的处理过期读的方案汇总在这里，以帮助你更好地理解和掌握全文的知识脉络。这些方案包括：</p><ul><li>强制走主库方案；</li><li>sleep方案；</li><li>判断主备无延迟方案；</li><li>配合semi-sync方案；</li><li>等主库位点方案；</li><li>等GTID方案。</li></ul><h2 id=强制走主库方案>强制走主库方案</h2><p>强制走主库方案其实就是，将查询请求做分类。通常情况下，我们可以将查询请求分为这么两类：</p><ol><li>对于必须要拿到最新结果的请求，强制将其发到主库上。比如，在一个交易平台上，卖家发布商品以后，马上要返回主页面，看商品是否发布成功。那么，这个请求需要拿到最新的结果，就必须走主库。</li><li>对于可以读到旧数据的请求，才将其发到从库上。在这个交易平台上，买家来逛商铺页面，就算晚几秒看到最新发布的商品，也是可以接受的。那么，这类请求就可以走从库。</li></ol><p>你可能会说，这个方案是不是有点畏难和取巧的意思，但其实这个方案是用得最多的。</p><p>当然，这个方案最大的问题在于，有时候你会碰到“所有查询都不能是过期读”的需求，比如一些金融类的业务。这样的话，你就要放弃读写分离，所有读写压力都在主库，等同于放弃了扩展性。</p><p>因此接下来，我们来讨论的话题是：可以支持读写分离的场景下，有哪些解决过期读的方案，并分析各个方案的优缺点。</p><h2 id=sleep-方案>Sleep 方案</h2><p>主库更新后，读从库之前先sleep一下。具体的方案就是，类似于执行一条select sleep(1)命令。</p><p>这个方案的假设是，大多数情况下主备延迟在1秒之内，做一个sleep可以有很大概率拿到最新的数据。</p><p>这个方案给你的第一感觉，很可能是不靠谱儿，应该不会有人用吧？并且，你还可能会说，直接在发起查询时先执行一条sleep语句，用户体验很不友好啊。</p><p>但，这个思路确实可以在一定程度上解决问题。为了看起来更靠谱儿，我们可以换一种方式。</p><p>以卖家发布商品为例，商品发布后，用Ajax（Asynchronous JavaScript + XML，异步JavaScript和XML）直接把客户端输入的内容作为“新的商品”显示在页面上，而不是真正地去数据库做查询。</p><p>这样，卖家就可以通过这个显示，来确认产品已经发布成功了。等到卖家再刷新页面，去查看商品的时候，其实已经过了一段时间，也就达到了sleep的目的，进而也就解决了过期读的问题。</p><p>也就是说，这个sleep方案确实解决了类似场景下的过期读问题。但，从严格意义上来说，这个方案存在的问题就是不精确。这个不精确包含了两层意思：</p><ol><li>如果这个查询请求本来0.5秒就可以在从库上拿到正确结果，也会等1秒；</li><li>如果延迟超过1秒，还是会出现过期读。</li></ol><p>看到这里，你是不是有一种“你是不是在逗我”的感觉，这个改进方案虽然可以解决类似Ajax场景下的过期读问题，但还是怎么看都不靠谱儿。别着急，接下来我就和你介绍一些更准确的方案。</p><h2 id=判断主备无延迟方案>判断主备无延迟方案</h2><p>要确保备库无延迟，通常有三种做法。</p><p>通过前面的第25篇文章，我们知道show slave status结果里的seconds_behind_master参数的值，可以用来衡量主备延迟时间的长短。</p><p>所以**第一种确保主备无延迟的方法是，**每次从库执行查询请求前，先判断seconds_behind_master是否已经等于0。如果还不等于0 ，那就必须等到这个参数变为0才能执行查询请求。</p><p>seconds_behind_master的单位是秒，如果你觉得精度不够的话，还可以采用对比位点和GTID的方法来确保主备无延迟，也就是我们接下来要说的第二和第三种方法。</p><p>如图3所示，是一个show slave status结果的部分截图。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211117000132.png style=display:block;width:80% alt=NAME align=center></div><p>现在，我们就通过这个结果，来看看具体如何通过对比位点和GTID来确保主备无延迟。</p><p>**第二种方法，**对比位点确保主备无延迟：</p><ul><li>Master_Log_File和Read_Master_Log_Pos，表示的是读到的主库的最新位点；</li><li>Relay_Master_Log_File和Exec_Master_Log_Pos，表示的是备库执行的最新位点。</li></ul><p>如果Master_Log_File和Relay_Master_Log_File、Read_Master_Log_Pos和Exec_Master_Log_Pos这两组值完全相同，就表示接收到的日志已经同步完成。</p><p>**第三种方法，**对比GTID集合确保主备无延迟：</p><ul><li>Auto_Position=1 ，表示这对主备关系使用了GTID协议。</li><li>Retrieved_Gtid_Set，是备库收到的所有日志的GTID集合；</li><li>Executed_Gtid_Set，是备库所有已经执行完成的GTID集合。</li></ul><p>如果这两个集合相同，也表示备库接收到的日志都已经同步完成。</p><p>可见，对比位点和对比GTID这两种方法，都要比判断seconds_behind_master是否为0更准确。</p><p>在执行查询请求之前，先判断从库是否同步完成的方法，相比于sleep方案，准确度确实提升了不少，但还是没有达到“精确”的程度。为什么这么说呢？</p><p>我们现在一起来回顾下，一个事务的binlog在主备库之间的状态：</p><ol><li>主库执行完成，写入binlog，并反馈给客户端；</li><li>binlog被从主库发送给备库，备库收到；</li><li>在备库执行binlog完成。</li></ol><p>我们上面判断主备无延迟的逻辑，是“备库收到的日志都执行完成了”。但是，从binlog在主备之间状态的分析中，不难看出还有一部分日志，处于客户端已经收到提交确认，而备库还没收到日志的状态。</p><p>如图4所示就是这样的一个状态。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211117000209.png style=display:block;width:80% alt=NAME align=center></div><p>这时，主库上执行完成了三个事务trx1、trx2和trx3，其中：</p><ol><li>trx1和trx2已经传到从库，并且已经执行完成了；</li><li>trx3在主库执行完成，并且已经回复给客户端，但是还没有传到从库中。</li></ol><p>如果这时候你在从库B上执行查询请求，按照我们上面的逻辑，从库认为已经没有同步延迟，但还是查不到trx3的。严格地说，就是出现了过期读。</p><p>那么，这个问题有没有办法解决呢？</p><h2 id=配合semi-sync>配合semi-sync</h2><p>要解决这个问题，就要引入半同步复制，也就是semi-sync replication。</p><p>semi-sync做了这样的设计：</p><ol><li>事务提交的时候，主库把binlog发给从库；</li><li>从库收到binlog以后，发回给主库一个ack，表示收到了；</li><li>主库收到这个ack以后，才能给客户端返回“事务完成”的确认。</li></ol><p>也就是说，如果启用了semi-sync，就表示所有给客户端发送过确认的事务，都确保了备库已经收到了这个日志。</p><p>在第25篇文章的评论区，有同学问到：如果主库掉电的时候，有些binlog还来不及发给从库，会不会导致系统数据丢失？</p><p>答案是，如果使用的是普通的异步复制模式，就可能会丢失，但semi-sync就可以解决这个问题。</p><p>这样，semi-sync配合前面关于位点的判断，就能够确定在从库上执行的查询请求，可以避免过期读。</p><p>但是，semi-sync+位点判断的方案，只对一主一备的场景是成立的。在一主多从场景中，主库只要等到一个从库的ack，就开始给客户端返回确认。这时，在从库上执行查询请求，就有两种情况：</p><ol><li>如果查询是落在这个响应了ack的从库上，是能够确保读到最新数据；</li><li>但如果是查询落到其他从库上，它们可能还没有收到最新的日志，就会产生过期读的问题。</li></ol><p>其实，判断同步位点的方案还有另外一个潜在的问题，即：如果在业务更新的高峰期，主库的位点或者GTID集合更新很快，那么上面的两个位点等值判断就会一直不成立，很可能出现从库上迟迟无法响应查询请求的情况。</p><p>实际上，回到我们最初的业务逻辑里，当发起一个查询请求以后，我们要得到准确的结果，其实并不需要等到“主备完全同步”。</p><p>为什么这么说呢？我们来看一下这个时序图。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211117000221.png style=display:block;width:80% alt=NAME align=center></div><p>图5所示，就是等待位点方案的一个bad case。图中备库B下的虚线框，分别表示relaylog和binlog中的事务。可以看到，图5中从状态1 到状态4，一直处于延迟一个事务的状态。</p><p>备库B一直到状态4都和主库A存在延迟，如果用上面必须等到无延迟才能查询的方案，select语句直到状态4都不能被执行。</p><p>但是，其实客户端是在发完trx1更新后发起的select语句，我们只需要确保trx1已经执行完成就可以执行select语句了。也就是说，如果在状态3执行查询请求，得到的就是预期结果了。</p><p>到这里，我们小结一下，semi-sync配合判断主备无延迟的方案，存在两个问题：</p><ol><li>一主多从的时候，在某些从库执行查询请求会存在过期读的现象；</li><li>在持续延迟的情况下，可能出现过度等待的问题。</li></ol><p>接下来，我要和你介绍的等主库位点方案，就可以解决这两个问题。</p><h2 id=等主库位点方案>等主库位点方案</h2><p>要理解等主库位点方案，我需要先和你介绍一条命令：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>select master_pos_wait(file, pos[, timeout]);
</span></span></code></pre></div><p>这条命令的逻辑如下：</p><ol><li>它是在从库执行的；</li><li>参数file和pos指的是主库上的文件名和位置；</li><li>timeout可选，设置为正整数N表示这个函数最多等待N秒。</li></ol><p>这个命令正常返回的结果是一个正整数M，表示从命令开始执行，到应用完file和pos表示的binlog位置，执行了多少事务。</p><p>当然，除了正常返回一个正整数M外，这条命令还会返回一些其他结果，包括：</p><ol><li>如果执行期间，备库同步线程发生异常，则返回NULL；</li><li>如果等待超过N秒，就返回-1；</li><li>如果刚开始执行的时候，就发现已经执行过这个位置了，则返回0。</li></ol><p>对于图5中先执行trx1，再执行一个查询请求的逻辑，要保证能够查到正确的数据，我们可以使用这个逻辑：</p><ol><li>trx1事务更新完成后，马上执行show master status得到当前主库执行到的File和Position；</li><li>选定一个从库执行查询语句；</li><li>在从库上执行select master_pos_wait(File, Position, 1)；</li><li>如果返回值是>=0的正整数，则在这个从库执行查询语句；</li><li>否则，到主库执行查询语句。</li></ol><p>我把上面这个流程画出来。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211117000233.png style=display:block;width:80% alt=NAME align=center></div><p>这里我们假设，这条select查询最多在从库上等待1秒。那么，如果1秒内master_pos_wait返回一个大于等于0的整数，就确保了从库上执行的这个查询结果一定包含了trx1的数据。</p><p>步骤5到主库执行查询语句，是这类方案常用的退化机制。因为从库的延迟时间不可控，不能无限等待，所以如果等待超时，就应该放弃，然后到主库去查。</p><p>你可能会说，如果所有的从库都延迟超过1秒了，那查询压力不就都跑到主库上了吗？确实是这样。</p><p>但是，按照我们设定不允许过期读的要求，就只有两种选择，一种是超时放弃，一种是转到主库查询。具体怎么选择，就需要业务开发同学做好限流策略了。</p><h2 id=gtid方案>GTID方案</h2><p>如果你的数据库开启了GTID模式，对应的也有等待GTID的方案。</p><p>MySQL中同样提供了一个类似的命令：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span> select wait_for_executed_gtid_set(gtid_set, 1);
</span></span></code></pre></div><p>这条命令的逻辑是：</p><ol><li>等待，直到这个库执行的事务中包含传入的gtid_set，返回0；</li><li>超时返回1。</li></ol><p>在前面等位点的方案中，我们执行完事务后，还要主动去主库执行show master status。而MySQL 5.7.6版本开始，允许在执行完更新类事务后，把这个事务的GTID返回给客户端，这样等GTID的方案就可以减少一次查询。</p><p>这时，等GTID的执行流程就变成了：</p><ol><li>trx1事务更新完成后，从返回包直接获取这个事务的GTID，记为gtid1；</li><li>选定一个从库执行查询语句；</li><li>在从库上执行 select wait_for_executed_gtid_set(gtid1, 1)；</li><li>如果返回值是0，则在这个从库执行查询语句；</li><li>否则，到主库执行查询语句。</li></ol><p>跟等主库位点的方案一样，等待超时后是否直接到主库查询，需要业务开发同学来做限流考虑。</p><p>我把这个流程图画出来。</p><p>在上面的第一步中，trx1事务更新完成后，从返回包直接获取这个事务的GTID。问题是，怎么能够让MySQL在执行事务后，返回包中带上GTID呢？</p><p>你只需要将参数session_track_gtids设置为OWN_GTID，然后通过API接口mysql_session_track_get_first从返回包解析出GTID的值即可。</p><p>在专栏的第一篇文章中，我介绍mysql_reset_connection的时候，评论区有同学留言问这类接口应该怎么使用。</p><p>这里我再回答一下。其实，MySQL并没有提供这类接口的SQL用法，是提供给程序的API(<a href=https://dev.mysql.com/doc/refman/5.7/en/c-api-functions.html>https://dev.mysql.com/doc/refman/5.7/en/c-api-functions.html</a>)。</p><p>比如，为了让客户端在事务提交后，返回的GITD能够在客户端显示出来，我对MySQL客户端代码做了点修改，如下所示：</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211117000252.png style=display:block;width:80% alt=NAME align=center></div><p>这样，就可以看到语句执行完成，显示出GITD的值。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211117000302.png style=display:block;width:80% alt=NAME align=center></div><p>当然了，这只是一个例子。你要使用这个方案的时候，还是应该在你的客户端代码中调用mysql_session_track_get_first这个函数。</p><h2 id=总结>总结</h2><p>在今天这篇文章中，我跟你介绍了一主多从做读写分离时，可能碰到过期读的原因，以及几种应对的方案。</p><p>这几种方案中，有的方案看上去是做了妥协，有的方案看上去不那么靠谱儿，但都是有实际应用场景的，你需要根据业务需求选择。</p><p>即使是最后等待位点和等待GTID这两个方案，虽然看上去比较靠谱儿，但仍然存在需要权衡的情况。如果所有的从库都延迟，那么请求就会全部落到主库上，这时候会不会由于压力突然增大，把主库打挂了呢？</p><p>其实，在实际应用中，这几个方案是可以混合使用的。</p><p>比如，先在客户端对请求做分类，区分哪些请求可以接受过期读，而哪些请求完全不能接受过期读；然后，对于不能接受过期读的语句，再使用等GTID或等位点的方案。</p><p>但话说回来，过期读在本质上是由一写多读导致的。在实际应用中，可能会有别的不需要等待就可以水平扩展的数据库方案，但这往往是用牺牲写性能换来的，也就是需要在读性能和写性能中取权衡。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-ef5b50851aefc62365f4120a4c995d4f>5.29 - CH29-故障判断</h1><p>我在第25和27篇文章中，和你介绍了主备切换流程。通过这些内容的讲解，你应该已经很清楚了：在一主一备的双M架构里，主备切换只需要把客户端流量切到备库；而在一主多从架构里，主备切换除了要把客户端流量切到备库外，还需要把从库接到新主库上。</p><p>主备切换有两种场景，一种是主动切换，一种是被动切换。而其中被动切换，往往是因为主库出问题了，由HA系统发起的。</p><p>这也就引出了我们今天要讨论的问题：怎么判断一个主库出问题了？</p><p>你一定会说，这很简单啊，连上MySQL，执行个select 1就好了。但是select 1成功返回了，就表示主库没问题吗？</p><h2 id=select-1判断>select 1判断</h2><p>实际上，select 1成功返回，只能说明这个库的进程还在，并不能说明主库没问题。现在，我们来看一下这个场景。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>set</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>global</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>innodb_thread_concurrency</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#0000cf;font-weight:700>3</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>CREATE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>TABLE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>t</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>(</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>id</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87>int</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>11</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>NOT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>NULL</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#204a87;font-weight:700>c</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87>int</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>11</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>DEFAULT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>NULL</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>PRIMARY</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>KEY</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>(</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>id</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>ENGINE</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#000>InnoDB</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>insert</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>into</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>t</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>values</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211117000532.png style=display:block;width:80% alt=NAME align=center></div><p>我们设置innodb_thread_concurrency参数的目的是，控制InnoDB的并发线程上限。也就是说，一旦并发线程数达到这个值，InnoDB在接收到新请求的时候，就会进入等待状态，直到有线程退出。</p><p>这里，我把innodb_thread_concurrency设置成3，表示InnoDB只允许3个线程并行执行。而在我们的例子中，前三个session 中的sleep(100)，使得这三个语句都处于“执行”状态，以此来模拟大查询。</p><p>你看到了， session D里面，select 1是能执行成功的，但是查询表t的语句会被堵住。也就是说，如果这时候我们用select 1来检测实例是否正常的话，是检测不出问题的。</p><p>在InnoDB中，innodb_thread_concurrency这个参数的默认值是0，表示不限制并发线程数量。但是，不限制并发线程数肯定是不行的。因为，一个机器的CPU核数有限，线程全冲进来，上下文切换的成本就会太高。</p><p>所以，通常情况下，我们建议把innodb_thread_concurrency设置为64~128之间的值。这时，你一定会有疑问，并发线程上限数设置为128够干啥，线上的并发连接数动不动就上千了。</p><p>产生这个疑问的原因，是搞混了<strong>并发连接和并发查询。</strong></p><p>并发连接和并发查询，并不是同一个概念。你在show processlist的结果里，看到的几千个连接，指的就是并发连接。而“当前正在执行”的语句，才是我们所说的并发查询。</p><p>并发连接数达到几千个影响并不大，就是多占一些内存而已。我们应该关注的是并发查询，因为并发查询太高才是CPU杀手。这也是为什么我们需要设置innodb_thread_concurrency参数的原因。</p><p>然后，你可能还会想起我们在第7篇文章中讲到的热点更新和死锁检测的时候，如果把innodb_thread_concurrency设置为128的话，那么出现同一行热点更新的问题时，是不是很快就把128消耗完了，这样整个系统是不是就挂了呢？</p><p>实际上，<strong>在线程进入锁等待以后，并发线程的计数会减一</strong>，也就是说等行锁（也包括间隙锁）的线程是不算在128里面的。</p><p>MySQL这样设计是非常有意义的。因为，进入锁等待的线程已经不吃CPU了；更重要的是，必须这么设计，才能避免整个系统锁死。</p><p>为什么呢？假设处于锁等待的线程也占并发线程的计数，你可以设想一下这个场景：</p><ol><li>线程1执行begin; update t set c=c+1 where id=1, 启动了事务trx1， 然后保持这个状态。这时候，线程处于空闲状态，不算在并发线程里面。</li><li>线程2到线程129都执行 update t set c=c+1 where id=1; 由于等行锁，进入等待状态。这样就有128个线程处于等待状态；</li><li>如果处于锁等待状态的线程计数不减一，InnoDB就会认为线程数用满了，会阻止其他语句进入引擎执行，这样线程1不能提交事务。而另外的128个线程又处于锁等待状态，整个系统就堵住了。</li></ol><p>下图2显示的就是这个状态。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211117000547.png style=display:block;width:80% alt=NAME align=center></div><p>这时候InnoDB不能响应任何请求，整个系统被锁死。而且，由于所有线程都处于等待状态，此时占用的CPU却是0，而这明显不合理。所以，我们说InnoDB在设计时，遇到进程进入锁等待的情况时，将并发线程的计数减1的设计，是合理而且是必要的。</p><p>虽然说等锁的线程不算在并发线程计数里，但如果它在真正地执行查询，就比如我们上面例子中前三个事务中的select sleep(100) from t，还是要算进并发线程的计数的。</p><p>在这个例子中，同时在执行的语句超过了设置的innodb_thread_concurrency的值，这时候系统其实已经不行了，但是通过select 1来检测系统，会认为系统还是正常的。</p><p>因此，我们使用select 1的判断逻辑要修改一下。</p><h2 id=查表判断>查表判断</h2><p>为了能够检测InnoDB并发线程数过多导致的系统不可用情况，我们需要找一个访问InnoDB的场景。一般的做法是，在系统库（mysql库）里创建一个表，比如命名为health_check，里面只放一行数据，然后定期执行：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>mysql&gt; select * from mysql.health_check; 
</span></span></code></pre></div><p>使用这个方法，我们可以检测出由于并发线程过多导致的数据库不可用的情况。</p><p>但是，我们马上还会碰到下一个问题，即：空间满了以后，这种方法又会变得不好使。</p><p>我们知道，更新事务要写binlog，而一旦binlog所在磁盘的空间占用率达到100%，那么所有的更新语句和事务提交的commit语句就都会被堵住。但是，系统这时候还是可以正常读数据的。</p><p>因此，我们还是把这条监控语句再改进一下。接下来，我们就看看把查询语句改成更新语句后的效果。</p><h2 id=更新判断>更新判断</h2><p>既然要更新，就要放个有意义的字段，常见做法是放一个timestamp字段，用来表示最后一次执行检测的时间。这条更新语句类似于：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>mysql&gt; update mysql.health_check set t_modified=now();
</span></span></code></pre></div><p>节点可用性的检测都应该包含主库和备库。如果用更新来检测主库的话，那么备库也要进行更新检测。</p><p>但，备库的检测也是要写binlog的。由于我们一般会把数据库A和B的主备关系设计为双M结构，所以在备库B上执行的检测命令，也要发回给主库A。</p><p>但是，如果主库A和备库B都用相同的更新命令，就可能出现行冲突，也就是可能会导致主备同步停止。所以，现在看来mysql.health_check 这个表就不能只有一行数据了。</p><p>为了让主备之间的更新不产生冲突，我们可以在mysql.health_check表上存入多行数据，并用A、B的server_id做主键。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span><span style=color:#000>mysql</span><span style=color:#ce5c00;font-weight:700>&gt;</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>CREATE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>TABLE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>health_check</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>(</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>id</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>int</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>11</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>NOT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>NULL</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>t_modified</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>timestamp</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>NOT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>NULL</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>DEFAULT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>CURRENT_TIMESTAMP</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>PRIMARY</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>KEY</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>(</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>id</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>ENGINE</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#000>InnoDB</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#8f5902;font-style:italic>/* 检测命令 */</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>insert</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>into</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>mysql</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>health_check</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>id</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>t_modified</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>values</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>(</span><span style=color:#ce5c00;font-weight:700>@@</span><span style=color:#000>server_id</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>now</span><span style=color:#000;font-weight:700>())</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>on</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>duplicate</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>key</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>update</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>t_modified</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#000>now</span><span style=color:#000;font-weight:700>();</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><p>由于MySQL规定了主库和备库的server_id必须不同（否则创建主备关系的时候就会报错），这样就可以保证主、备库各自的检测命令不会发生冲突。</p><p>更新判断是一个相对比较常用的方案了，不过依然存在一些问题。其中，“判定慢”一直是让DBA头疼的问题。</p><p>你一定会疑惑，<strong>更新语句，如果失败或者超时，就可以发起主备切换了，为什么还会有判定慢的问题呢？</strong></p><p>其实，这里涉及到的是服务器IO资源分配的问题。</p><p>首先，所有的检测逻辑都需要一个超时时间N。执行一条update语句，超过N秒后还不返回，就认为系统不可用。</p><p>你可以设想一个日志盘的IO利用率已经是100%的场景。这时候，整个系统响应非常慢，已经需要做主备切换了。</p><p>但是你要知道，IO利用率100%表示系统的IO是在工作的，每个请求都有机会获得IO资源，执行自己的任务。而我们的检测使用的update命令，需要的资源很少，所以可能在拿到IO资源的时候就可以提交成功，并且在超时时间N秒未到达之前就返回给了检测系统。</p><p>检测系统一看，update命令没有超时，于是就得到了“系统正常”的结论。</p><p>也就是说，这时候在业务系统上正常的SQL语句已经执行得很慢了，但是DBA上去一看，HA系统还在正常工作，并且认为主库现在处于可用状态。</p><p>之所以会出现这个现象，根本原因是我们上面说的所有方法，都是基于外部检测的。外部检测天然有一个问题，就是随机性。</p><p>因为，外部检测都需要定时轮询，所以系统可能已经出问题了，但是却需要等到下一个检测发起执行语句的时候，我们才有可能发现问题。而且，如果你的运气不够好的话，可能第一次轮询还不能发现，这就会导致切换慢的问题。</p><p>所以，接下来我要再和你介绍一种在MySQL内部发现数据库问题的方法。</p><h2 id=内部统计>内部统计</h2><p>针对磁盘利用率这个问题，如果MySQL可以告诉我们，内部每一次IO请求的时间，那我们判断数据库是否出问题的方法就可靠得多了。</p><p>其实，MySQL 5.6版本以后提供的performance_schema库，就在file_summary_by_event_name表里统计了每次IO请求的时间。</p><p>file_summary_by_event_name表里有很多行数据，我们先来看看event_name=&lsquo;wait/io/file/innodb/innodb_log_file’这一行。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211117000604.png style=display:block;width:80% alt=NAME align=center></div><p>图中这一行表示统计的是redo log的写入时间，第一列EVENT_NAME 表示统计的类型。</p><p>接下来的三组数据，显示的是redo log操作的时间统计。</p><p>第一组五列，是所有IO类型的统计。其中，COUNT_STAR是所有IO的总次数，接下来四列是具体的统计项， 单位是皮秒；前缀SUM、MIN、AVG、MAX，顾名思义指的就是总和、最小值、平均值和最大值。</p><p>第二组六列，是读操作的统计。最后一列SUM_NUMBER_OF_BYTES_READ统计的是，总共从redo log里读了多少个字节。</p><p>第三组六列，统计的是写操作。</p><p>最后的第四组数据，是对其他类型数据的统计。在redo log里，你可以认为它们就是对fsync的统计。</p><p>在performance_schema库的file_summary_by_event_name表里，binlog对应的是event_name = &ldquo;wait/io/file/sql/binlog"这一行。各个字段的统计逻辑，与redo log的各个字段完全相同。这里，我就不再赘述了。</p><p>因为我们每一次操作数据库，performance_schema都需要额外地统计这些信息，所以我们打开这个统计功能是有性能损耗的。</p><p>我的测试结果是，如果打开所有的performance_schema项，性能大概会下降10%左右。所以，我建议你只打开自己需要的项进行统计。你可以通过下面的方法打开或者关闭某个具体项的统计。</p><p>如果要打开redo log的时间监控，你可以执行这个语句：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>mysql&gt; update setup_instruments set ENABLED=&#39;YES&#39;, Timed=&#39;YES&#39; where name like &#39;%wait/io/file/innodb/innodb_log_file%&#39;;
</span></span></code></pre></div><p>假设，现在你已经开启了redo log和binlog这两个统计信息，那要怎么把这个信息用在实例状态诊断上呢？</p><p>很简单，你可以通过MAX_TIMER的值来判断数据库是否出问题了。比如，你可以设定阈值，单次IO请求时间超过200毫秒属于异常，然后使用类似下面这条语句作为检测逻辑。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>mysql&gt; select event_name,MAX_TIMER_WAIT  FROM performance_schema.file_summary_by_event_name where event_name in (&#39;wait/io/file/innodb/innodb_log_file&#39;,&#39;wait/io/file/sql/binlog&#39;) and MAX_TIMER_WAIT&gt;200*1000000000;
</span></span></code></pre></div><p>发现异常后，取到你需要的信息，再通过下面这条语句：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>mysql&gt; truncate table performance_schema.file_summary_by_event_name;
</span></span></code></pre></div><p>把之前的统计信息清空。这样如果后面的监控中，再次出现这个异常，就可以加入监控累积值了。</p><h2 id=小结>小结</h2><p>今天，我和你介绍了检测一个MySQL实例健康状态的几种方法，以及各种方法存在的问题和演进的逻辑。</p><p>你看完后可能会觉得，select 1这样的方法是不是已经被淘汰了呢，但实际上使用非常广泛的MHA（Master High Availability），默认使用的就是这个方法。</p><p>MHA中的另一个可选方法是只做连接，就是 “如果连接成功就认为主库没问题”。不过据我所知，选择这个方法的很少。</p><p>其实，每个改进的方案，都会增加额外损耗，并不能用“对错”做直接判断，需要你根据业务实际情况去做权衡。</p><p>我个人比较倾向的方案，是优先考虑update系统表，然后再配合增加检测performance_schema的信息。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-3cf5d6f4b487f2512a1f937d50db6efb>5.30 - CH30-动态观察锁</h1><p>在第20 和 21篇文章中，我和你介绍了InnoDB的间隙锁、next-key lock，以及加锁规则。在这两篇文章的评论区，出现了很多高质量的留言。我觉得通过分析这些问题，可以帮助你加深对加锁规则的理解。</p><p>所以，我就从中挑选了几个有代表性的问题，构成了今天这篇答疑文章的主题，即：用动态的观点看加锁。</p><p><strong>为了方便你理解，我们再一起复习一下加锁规则。这个规则中，包含了两个“原则”、两个“优化”和一个“bug”：</strong></p><ul><li>原则1：加锁的基本单位是next-key lock。希望你还记得，next-key lock是前开后闭区间。</li><li>原则2：查找过程中访问到的对象才会加锁。</li><li>优化1：索引上的等值查询，给唯一索引加锁的时候，next-key lock退化为行锁。</li><li>优化2：索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候，next-key lock退化为间隙锁。</li><li>一个bug：唯一索引上的范围查询会访问到不满足条件的第一个值为止。</li></ul><p>接下来，我们的讨论还是基于下面这个表t：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>CREATE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>TABLE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>t</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>(</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>id</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87>int</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>11</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>NOT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>NULL</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#204a87;font-weight:700>c</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87>int</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>11</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>DEFAULT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>NULL</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>d</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87>int</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>11</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>DEFAULT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>NULL</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>PRIMARY</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>KEY</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>(</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>id</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000;font-weight:700>),</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>KEY</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#204a87;font-weight:700>c</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>(</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#204a87;font-weight:700>c</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>ENGINE</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#000>InnoDB</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>insert</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>into</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>t</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>values</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>0</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>0</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>0</span><span style=color:#000;font-weight:700>),(</span><span style=color:#0000cf;font-weight:700>5</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>5</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>5</span><span style=color:#000;font-weight:700>),</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>10</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>10</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>10</span><span style=color:#000;font-weight:700>),(</span><span style=color:#0000cf;font-weight:700>15</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>15</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>15</span><span style=color:#000;font-weight:700>),(</span><span style=color:#0000cf;font-weight:700>20</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>20</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>20</span><span style=color:#000;font-weight:700>),(</span><span style=color:#0000cf;font-weight:700>25</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>25</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>25</span><span style=color:#000;font-weight:700>);</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><h2 id=不等号条件里的等值查询>不等号条件里的等值查询</h2><p>有同学对“等值查询”提出了疑问：等值查询和“遍历”有什么区别？为什么我们文章的例子里面，where条件是不等号，这个过程里也有等值查询？</p><p>我们一起来看下这个例子，分析一下这条查询语句的加锁范围：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>begin</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>select</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>*</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>from</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>t</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>where</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>id</span><span style=color:#ce5c00;font-weight:700>&gt;</span><span style=color:#0000cf;font-weight:700>9</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>and</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>id</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>12</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>order</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>by</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>id</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>desc</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>for</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>update</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><p>利用上面的加锁规则，我们知道这个语句的加锁范围是主键索引上的 (0,5]、(5,10]和(10, 15)。也就是说，id=15这一行，并没有被加上行锁。为什么呢？</p><p>我们说加锁单位是next-key lock，都是前开后闭区间，但是这里用到了优化2，即索引上的等值查询，向右遍历的时候id=15不满足条件，所以next-key lock退化为了间隙锁 (10, 15)。</p><p>但是，我们的查询语句中where条件是大于号和小于号，这里的“等值查询”又是从哪里来的呢？</p><p>要知道，加锁动作是发生在语句执行过程中的，所以你在分析加锁行为的时候，要从索引上的数据结构开始。这里，我再把这个过程拆解一下。</p><p>如图1所示，是这个表的索引id的示意图。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211117000743.png style=display:block;width:80% alt=NAME align=center></div><ol><li>首先这个查询语句的语义是order by id desc，要拿到满足条件的所有行，优化器必须先找到“第一个id&lt;12的值”。</li><li>这个过程是通过索引树的搜索过程得到的，在引擎内部，其实是要找到id=12的这个值，只是最终没找到，但找到了(10,15)这个间隙。</li><li>然后向左遍历，在遍历过程中，就不是等值查询了，会扫描到id=5这一行，所以会加一个next-key lock (0,5]。</li></ol><p>也就是说，在执行过程中，通过树搜索的方式定位记录的时候，用的是“等值查询”的方法。</p><h2 id=等值查询的过程>等值查询的过程</h2><p>与上面这个例子对应的，是@发条橙子同学提出的问题：下面这个语句的加锁范围是什么？</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>begin</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>select</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>id</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>from</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>t</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>where</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>c</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>in</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>5</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>20</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>10</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>lock</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>in</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>share</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>mode</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><p>这条查询语句里用的是in，我们先来看这条语句的explain结果。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211117000756.png style=display:block;width:80% alt=NAME align=center></div><p>可以看到，这条in语句使用了索引c并且rows=3，说明这三个值都是通过B+树搜索定位的。</p><p>在查找c=5的时候，先锁住了(0,5]。但是因为c不是唯一索引，为了确认还有没有别的记录c=5，就要向右遍历，找到c=10才确认没有了，这个过程满足优化2，所以加了间隙锁(5,10)。</p><p>同样的，执行c=10这个逻辑的时候，加锁的范围是(5,10] 和 (10,15)；执行c=20这个逻辑的时候，加锁的范围是(15,20] 和 (20,25)。</p><p>通过这个分析，我们可以知道，这条语句在索引c上加的三个记录锁的顺序是：先加c=5的记录锁，再加c=10的记录锁，最后加c=20的记录锁。</p><p>你可能会说，这个加锁范围，不就是从(5,25)中去掉c=15的行锁吗？为什么这么麻烦地分段说呢？</p><p>因为我要跟你强调这个过程：这些锁是“在执行过程中一个一个加的”，而不是一次性加上去的。</p><p>理解了这个加锁过程之后，我们就可以来分析下面例子中的死锁问题了。</p><p>如果同时有另外一个语句，是这么写的：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>select</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>id</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>from</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>t</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>where</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>c</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>in</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>5</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>20</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>10</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>order</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>by</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>c</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>desc</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>for</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>update</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><p>此时的加锁范围，又是什么呢？</p><p>我们现在都知道间隙锁是不互锁的，但是这两条语句都会在索引c上的c=5、10、20这三行记录上加记录锁。</p><p>这里你需要注意一下，由于语句里面是order by c desc， 这三个记录锁的加锁顺序，是先锁c=20，然后c=10，最后是c=5。</p><p>也就是说，这两条语句要加锁相同的资源，但是加锁顺序相反。当这两条语句并发执行的时候，就可能出现死锁。</p><p>关于死锁的信息，MySQL只保留了最后一个死锁的现场，但这个现场还是不完备的。</p><p>有同学在评论区留言到，希望我能展开一下怎么看死锁。现在，我就来简单分析一下上面这个例子的死锁现场。</p><h2 id=怎么看死锁>怎么看死锁？</h2><p>图3是在出现死锁后，执行show engine innodb status命令得到的部分输出。这个命令会输出很多信息，有一节LATESTDETECTED DEADLOCK，就是记录的最后一次死锁信息。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211117000809.png style=display:block;width:80% alt=NAME align=center></div><p>我们来看看这图中的几个关键信息。</p><ol><li>这个结果分成三部分：<ul><li>(1) TRANSACTION，是第一个事务的信息；</li><li>(2) TRANSACTION，是第二个事务的信息；</li><li>WE ROLL BACK TRANSACTION (1)，是最终的处理结果，表示回滚了第一个事务。</li></ul></li><li>第一个事务的信息中：<ul><li>WAITING FOR THIS LOCK TO BE GRANTED，表示的是这个事务在等待的锁信息；</li><li>index c of table <code>test</code>.<code>t</code>，说明在等的是表t的索引c上面的锁；</li><li>lock mode S waiting 表示这个语句要自己加一个读锁，当前的状态是等待中；</li><li>Record lock说明这是一个记录锁；</li><li>n_fields 2表示这个记录是两列，也就是字段c和主键字段id；</li><li>0: len 4; hex 0000000a; asc ;;是第一个字段，也就是c。值是十六进制a，也就是10；</li><li>1: len 4; hex 0000000a; asc ;;是第二个字段，也就是主键id，值也是10；</li><li>这两行里面的asc表示的是，接下来要打印出值里面的“可打印字符”，但10不是可打印字符，因此就显示空格。</li><li>第一个事务信息就只显示出了等锁的状态，在等待(c=10,id=10)这一行的锁。</li><li>当然你是知道的，既然出现死锁了，就表示这个事务也占有别的锁，但是没有显示出来。别着急，我们从第二个事务的信息中推导出来。</li></ul></li><li>第二个事务显示的信息要多一些：<ul><li>“ HOLDS THE LOCK(S)”用来显示这个事务持有哪些锁；</li><li>index c of table <code>test</code>.<code>t</code> 表示锁是在表t的索引c上；</li><li>hex 0000000a和hex 00000014表示这个事务持有c=10和c=20这两个记录锁；</li><li>WAITING FOR THIS LOCK TO BE GRANTED，表示在等(c=5,id=5)这个记录锁。</li></ul></li></ol><p>从上面这些信息中，我们就知道：</p><ol><li>“lock in share mode”的这条语句，持有c=5的记录锁，在等c=10的锁；</li><li>“for update”这个语句，持有c=20和c=10的记录锁，在等c=5的记录锁。</li></ol><p>因此导致了死锁。这里，我们可以得到两个结论：</p><ol><li>由于锁是一个个加的，要避免死锁，对同一组资源，要按照尽量相同的顺序访问；</li><li>在发生死锁的时刻，for update 这条语句占有的资源更多，回滚成本更大，所以InnoDB选择了回滚成本更小的lock in share mode语句，来回滚。</li></ol><h2 id=怎么看锁等待>怎么看锁等待？</h2><p>看完死锁，我们再来看一个锁等待的例子。</p><p>在第21篇文章的评论区，@Geek_9ca34e 同学做了一个有趣验证，我把复现步骤列出来：</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211117000822.png style=display:block;width:80% alt=NAME align=center></div><p>可以看到，由于session A并没有锁住c=10这个记录，所以session B删除id=10这一行是可以的。但是之后，session B再想insert id=10这一行回去就不行了。</p><p>现在我们一起看一下此时show engine innodb status的结果，看看能不能给我们一些提示。锁信息是在这个命令输出结果的TRANSACTIONS这一节。你可以在文稿中看到这张图片</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211117000834.png style=display:block;width:80% alt=NAME align=center></div><p>我们来看几个关键信息。</p><ol><li>index PRIMARY of table <code>test</code>.<code>t</code> ，表示这个语句被锁住是因为表t主键上的某个锁。</li><li>lock_mode X locks gap before rec insert intention waiting 这里有几个信息：<ul><li>insert intention表示当前线程准备插入一个记录，这是一个插入意向锁。为了便于理解，你可以认为它就是这个插入动作本身。</li><li>gap before rec 表示这是一个间隙锁，而不是记录锁。</li></ul></li><li>那么这个gap是在哪个记录之前的呢？接下来的0~4这5行的内容就是这个记录的信息。</li><li>n_fields 5也表示了，这一个记录有5列：<ul><li>0: len 4; hex 0000000f; asc ;;第一列是主键id字段，十六进制f就是id=15。所以，这时我们就知道了，这个间隙就是id=15之前的，因为id=10已经不存在了，它表示的就是(5,15)。</li><li>1: len 6; hex 000000000513; asc ;;第二列是长度为6字节的事务id，表示最后修改这一行的是trx id为1299的事务。</li><li>2: len 7; hex b0000001250134; asc % 4;; 第三列长度为7字节的回滚段信息。可以看到，这里的acs后面有显示内容(%和4)，这是因为刚好这个字节是可打印字符。</li><li>后面两列是c和d的值，都是15。</li></ul></li></ol><p>因此，我们就知道了，由于delete操作把id=10这一行删掉了，原来的两个间隙(5,10)、(10,15）变成了一个(5,15)。</p><p>说到这里，你可以联合起来再思考一下这两个现象之间的关联：</p><ol><li>session A执行完select语句后，什么都没做，但它加锁的范围突然“变大”了；</li><li>第21篇文章的课后思考题，当我们执行select * from t where c>=15 and c&lt;=20 order by c desc lock in share mode; 向左扫描到c=10的时候，要把(5, 10]锁起来。</li></ol><p>也就是说，所谓“间隙”，其实根本就是由“这个间隙右边的那个记录”定义的。</p><h2 id=update的例子>update的例子</h2><p>看过了insert和delete的加锁例子，我们再来看一个update语句的案例。在留言区中@信信 同学做了这个试验：</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211117000846.png style=display:block;width:80% alt=NAME align=center></div><p>你可以自己分析一下，session A的加锁范围是索引c上的 (5,10]、(10,15]、(15,20]、(20,25]和(25,suprenum]。</p><p>之后session B的第一个update语句，要把c=5改成c=1，你可以理解为两步：</p><ol><li>插入(c=1, id=5)这个记录；</li><li>删除(c=5, id=5)这个记录。</li></ol><p>按照我们上一节说的，索引c上(5,10)间隙是由这个间隙右边的记录，也就是c=10定义的。所以通过这个操作，session A的加锁范围变成了图7所示的样子：</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211117000858.png style=display:block;width:80% alt=NAME align=center></div><p>好，接下来session B要执行 update t set c = 5 where c = 1这个语句了，一样地可以拆成两步：</p><ol><li>插入(c=5, id=5)这个记录；</li><li>删除(c=1, id=5)这个记录。</li></ol><p>第一步试图在已经加了间隙锁的(1,10)中插入数据，所以就被堵住了。</p><h2 id=小结>小结</h2><p>今天这篇文章，我用前面20 和 21文章评论区的几个问题，再次跟你复习了加锁规则。并且，我和你重点说明了，分析加锁范围时，一定要配合语句执行逻辑来进行。</p><p>在我看来，每个想认真了解MySQL原理的同学，应该都要能够做到：通过explain的结果，就能够脑补出一个SQL语句的执行流程。达到这样的程度，才算是对索引组织表、索引、锁的概念有了比较清晰的认识。你同样也可以用这个方法，来验证自己对这些知识点的掌握程度。</p><p>在分析这些加锁规则的过程中，我也顺便跟你介绍了怎么看show engine innodb status输出结果中的事务信息和死锁信息，希望这些内容对你以后分析现场能有所帮助。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-105696c87ee0cea84747208605caecd0>5.31 - CH31-误删恢复</h1><p>在前面几篇文章中，我们介绍了MySQL的高可用架构。当然，传统的高可用架构是不能预防误删数据的，因为主库的一个drop table命令，会通过binlog传给所有从库和级联从库，进而导致整个集群的实例都会执行这个命令。</p><p>虽然我们之前遇到的大多数的数据被删，都是运维同学或者DBA背锅的。但实际上，只要有数据操作权限的同学，都有可能踩到误删数据这条线。</p><p>今天我们就来聊聊误删数据前后，我们可以做些什么，减少误删数据的风险，和由误删数据带来的损失。</p><p>为了找到解决误删数据的更高效的方法，我们需要先对和MySQL相关的误删数据，做下分类：</p><ol><li>使用delete语句误删数据行；</li><li>使用drop table或者truncate table语句误删数据表；</li><li>使用drop database语句误删数据库；</li><li>使用rm命令误删整个MySQL实例。</li></ol><h2 id=误删行>误删行</h2><p>在第24篇文章中，我们提到如果是使用delete语句误删了数据行，可以用Flashback工具通过闪回把数据恢复回来。</p><p>Flashback恢复数据的原理，是修改binlog的内容，拿回原库重放。而能够使用这个方案的前提是，需要确保binlog_format=row 和 binlog_row_image=FULL。</p><p>具体恢复数据时，对单个事务做如下处理：</p><ol><li>对于insert语句，对应的binlog event类型是Write_rows event，把它改成Delete_rows event即可；</li><li>同理，对于delete语句，也是将Delete_rows event改为Write_rows event；</li><li>而如果是Update_rows的话，binlog里面记录了数据行修改前和修改后的值，对调这两行的位置即可。</li></ol><p>如果误操作不是一个，而是多个，会怎么样呢？比如下面三个事务：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#000;font-weight:700>(</span><span style=color:#000>A</span><span style=color:#000;font-weight:700>)</span><span style=color:#204a87;font-weight:700>delete</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>...</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#000;font-weight:700>(</span><span style=color:#000>B</span><span style=color:#000;font-weight:700>)</span><span style=color:#204a87;font-weight:700>insert</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>...</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#000;font-weight:700>(</span><span style=color:#204a87;font-weight:700>C</span><span style=color:#000;font-weight:700>)</span><span style=color:#204a87;font-weight:700>update</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>...</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><p>现在要把数据库恢复回这三个事务操作之前的状态，用Flashback工具解析binlog后，写回主库的命令是：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#000;font-weight:700>(</span><span style=color:#000>reverse</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>C</span><span style=color:#000;font-weight:700>)</span><span style=color:#204a87;font-weight:700>update</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>...</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#000;font-weight:700>(</span><span style=color:#000>reverse</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>B</span><span style=color:#000;font-weight:700>)</span><span style=color:#204a87;font-weight:700>delete</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>...</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#000;font-weight:700>(</span><span style=color:#000>reverse</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>A</span><span style=color:#000;font-weight:700>)</span><span style=color:#204a87;font-weight:700>insert</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>...</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><p>也就是说，如果误删数据涉及到了多个事务的话，需要将事务的顺序调过来再执行。</p><p><strong>需要说明的是，我不建议你直接在主库上执行这些操作。</strong></p><p>恢复数据比较安全的做法，是恢复出一个备份，或者找一个从库作为临时库，在这个临时库上执行这些操作，然后再将确认过的临时库的数据，恢复回主库。</p><p>为什么要这么做呢？</p><p>这是因为，一个在执行线上逻辑的主库，数据状态的变更往往是有关联的。可能由于发现数据问题的时间晚了一点儿，就导致已经在之前误操作的基础上，业务代码逻辑又继续修改了其他数据。所以，如果这时候单独恢复这几行数据，而又未经确认的话，就可能会出现对数据的二次破坏。</p><p>当然，<strong>我们不止要说误删数据的事后处理办法，更重要是要做到事前预防</strong>。我有以下两个建议：</p><ol><li>把sql_safe_updates参数设置为on。这样一来，如果我们忘记在delete或者update语句中写where条件，或者where条件里面没有包含索引字段的话，这条语句的执行就会报错。</li><li>代码上线前，必须经过SQL审计。</li></ol><p>你可能会说，设置了sql_safe_updates=on，如果我真的要把一个小表的数据全部删掉，应该怎么办呢？</p><p>如果你确定这个删除操作没问题的话，可以在delete语句中加上where条件，比如where id>=0。</p><p>但是，delete全表是很慢的，需要生成回滚日志、写redo、写binlog。所以，从性能角度考虑，你应该优先考虑使用truncate table或者drop table命令。</p><p>使用delete命令删除的数据，你还可以用Flashback来恢复。而使用truncate /drop table和drop database命令删除的数据，就没办法通过Flashback来恢复了。为什么呢？</p><p>这是因为，即使我们配置了binlog_format=row，执行这三个命令时，记录的binlog还是statement格式。binlog里面就只有一个truncate/drop 语句，这些信息是恢复不出数据的。</p><p>那么，如果我们真的是使用这几条命令误删数据了，又该怎么办呢？</p><h2 id=误删库表>误删库/表</h2><p>这种情况下，要想恢复数据，就需要使用全量备份，加增量日志的方式了。这个方案要求线上有定期的全量备份，并且实时备份binlog。</p><p>在这两个条件都具备的情况下，假如有人中午12点误删了一个库，恢复数据的流程如下：</p><ol><li>取最近一次全量备份，假设这个库是一天一备，上次备份是当天0点；</li><li>用备份恢复出一个临时库；</li><li>从日志备份里面，取出凌晨0点之后的日志；</li><li>把这些日志，除了误删除数据的语句外，全部应用到临时库。</li></ol><p>这个流程的示意图如下所示：</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211117220201.png style=display:block;width:80% alt=NAME align=center></div><p>关于这个过程，我需要和你说明如下几点：</p><ol><li>为了加速数据恢复，如果这个临时库上有多个数据库，你可以在使用mysqlbinlog命令时，加上一个–database参数，用来指定误删表所在的库。这样，就避免了在恢复数据时还要应用其他库日志的情况。</li><li>在应用日志的时候，需要跳过12点误操作的那个语句的binlog：<ul><li>如果原实例没有使用GTID模式，只能在应用到包含12点的binlog文件的时候，先用–stop-position参数执行到误操作之前的日志，然后再用–start-position从误操作之后的日志继续执行；</li><li>如果实例使用了GTID模式，就方便多了。假设误操作命令的GTID是gtid1，那么只需要执行set gtid_next=gtid1;begin;commit; 先把这个GTID加到临时实例的GTID集合，之后按顺序执行binlog的时候，就会自动跳过误操作的语句。</li></ul></li></ol><p>不过，即使这样，使用mysqlbinlog方法恢复数据还是不够快，主要原因有两个：</p><ol><li>如果是误删表，最好就是只恢复出这张表，也就是只重放这张表的操作，但是mysqlbinlog工具并不能指定只解析一个表的日志；</li><li>用mysqlbinlog解析出日志应用，应用日志的过程就只能是单线程。我们在第26篇文章中介绍的那些并行复制的方法，在这里都用不上。</li></ol><p>**一种加速的方法是，**在用备份恢复出临时实例之后，将这个临时实例设置成线上备库的从库，这样：</p><ol><li>在start slave之前，先通过执行﻿
﻿change replication filter replicate_do_table = (tbl_name) 命令，就可以让临时库只同步误操作的表；</li><li>这样做也可以用上并行复制技术，来加速整个数据恢复过程。</li></ol><p>这个过程的示意图如下所示。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211117220214.png style=display:block;width:80% alt=NAME align=center></div><p>可以看到，图中binlog备份系统到线上备库有一条虚线，是指如果由于时间太久，备库上已经删除了临时实例需要的binlog的话，我们可以从binlog备份系统中找到需要的binlog，再放回备库中。</p><p>假设，我们发现当前临时实例需要的binlog是从master.000005开始的，但是在备库上执行show binlogs 显示的最小的binlog文件是master.000007，意味着少了两个binlog文件。这时，我们就需要去binlog备份系统中找到这两个文件。</p><p>把之前删掉的binlog放回备库的操作步骤，是这样的：</p><ol><li>从备份系统下载master.000005和master.000006这两个文件，放到备库的日志目录下；</li><li>打开日志目录下的master.index文件，在文件开头加入两行，内容分别是 “./master.000005”和“./master.000006”;</li><li>重启备库，目的是要让备库重新识别这两个日志文件；</li><li>现在这个备库上就有了临时库需要的所有binlog了，建立主备关系，就可以正常同步了。</li></ol><p>不论是把mysqlbinlog工具解析出的binlog文件应用到临时库，还是把临时库接到备库上，这两个方案的共同点是：误删库或者表后，恢复数据的思路主要就是通过备份，再加上应用binlog的方式。</p><p>也就是说，这两个方案都要求备份系统定期备份全量日志，而且需要确保binlog在被从本地删除之前已经做了备份。</p><p>但是，一个系统不可能备份无限的日志，你还需要根据成本和磁盘空间资源，设定一个日志保留的天数。如果你的DBA团队告诉你，可以保证把某个实例恢复到半个月内的任意时间点，这就表示备份系统保留的日志时间就至少是半个月。</p><p>另外，我建议你不论使用上述哪种方式，都要把这个数据恢复功能做成自动化工具，并且经常拿出来演练。为什么这么说呢？</p><p>这里的原因，主要包括两个方面：</p><ol><li>虽然“发生这种事，大家都不想的”，但是万一出现了误删事件，能够快速恢复数据，将损失降到最小，也应该不用跑路了。</li><li>而如果临时再手忙脚乱地手动操作，最后又误操作了，对业务造成了二次伤害，那就说不过去了。</li></ol><h2 id=延迟复制备库>延迟复制备库</h2><p>虽然我们可以通过利用并行复制来加速恢复数据的过程，但是这个方案仍然存在“恢复时间不可控”的问题。</p><p>如果一个库的备份特别大，或者误操作的时间距离上一个全量备份的时间较长，比如一周一备的实例，在备份之后的第6天发生误操作，那就需要恢复6天的日志，这个恢复时间可能是要按天来计算的。</p><p>那么，我们有什么方法可以缩短恢复数据需要的时间呢？</p><p>如果有非常核心的业务，不允许太长的恢复时间，我们可以考虑**搭建延迟复制的备库。**这个功能是MySQL 5.6版本引入的。</p><p>一般的主备复制结构存在的问题是，如果主库上有个表被误删了，这个命令很快也会被发给所有从库，进而导致所有从库的数据表也都一起被误删了。</p><p>延迟复制的备库是一种特殊的备库，通过 CHANGE MASTER TO MASTER_DELAY = N命令，可以指定这个备库持续保持跟主库有N秒的延迟。</p><p>比如你把N设置为3600，这就代表了如果主库上有数据被误删了，并且在1小时内发现了这个误操作命令，这个命令就还没有在这个延迟复制的备库执行。这时候到这个备库上执行stop slave，再通过之前介绍的方法，跳过误操作命令，就可以恢复出需要的数据。</p><p>这样的话，你就随时可以得到一个，只需要最多再追1小时，就可以恢复出数据的临时实例，也就缩短了整个数据恢复需要的时间。</p><h2 id=预防误删库表的方法>预防误删库/表的方法</h2><p>虽然常在河边走，很难不湿鞋，但终究还是可以找到一些方法来避免的。所以这里，我也会给你一些减少误删操作风险的建议。</p><p>第一条建议是，账号分离。这样做的目的是，避免写错命令。比如：</p><ul><li>我们只给业务开发同学DML权限，而不给truncate/drop权限。而如果业务开发人员有DDL需求的话，也可以通过开发管理系统得到支持。</li><li>即使是DBA团队成员，日常也都规定只使用只读账号，必要的时候才使用有更新权限的账号。</li></ul><p>第二条建议是，制定操作规范。这样做的目的，是避免写错要删除的表名。比如：</p><ul><li>在删除数据表之前，必须先对表做改名操作。然后，观察一段时间，确保对业务无影响以后再删除这张表。</li><li>改表名的时候，要求给表名加固定的后缀（比如加_to_be_deleted)，然后删除表的动作必须通过管理系统执行。并且，管理系删除表的时候，只能删除固定后缀的表。</li></ul><h2 id=rm删除数据>rm删除数据</h2><p>其实，对于一个有高可用机制的MySQL集群来说，最不怕的就是rm删除数据了。只要不是恶意地把整个集群删除，而只是删掉了其中某一个节点的数据的话，HA系统就会开始工作，选出一个新的主库，从而保证整个集群的正常工作。</p><p>这时，你要做的就是在这个节点上把数据恢复回来，再接入整个集群。</p><p>当然了，现在不止是DBA有自动化系统，SA（系统管理员）也有自动化系统，所以也许一个批量下线机器的操作，会让你整个MySQL集群的所有节点都全军覆没。</p><p>应对这种情况，我的建议只能是说尽量把你的备份跨机房，或者最好是跨城市保存。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-96bf2c9b77e9408d0238c4a9ae5d4cda>5.32 - CH32-KILL 语句</h1><p>在MySQL中有两个kill命令：一个是kill query +线程id，表示终止这个线程中正在执行的语句；一个是kill connection +线程id，这里connection可缺省，表示断开这个线程的连接，当然如果这个线程有语句正在执行，也是要先停止正在执行的语句的。</p><p>不知道你在使用MySQL的时候，有没有遇到过这样的现象：使用了kill命令，却没能断开这个连接。再执行show processlist命令，看到这条语句的Command列显示的是Killed。</p><p>你一定会奇怪，显示为Killed是什么意思，不是应该直接在show processlist的结果里看不到这个线程了吗？</p><p>今天，我们就来讨论一下这个问题。</p><p>其实大多数情况下，kill query/connection命令是有效的。比如，执行一个查询的过程中，发现执行时间太久，要放弃继续查询，这时我们就可以用kill query命令，终止这条查询语句。</p><p>还有一种情况是，语句处于锁等待的时候，直接使用kill命令也是有效的。我们一起来看下这个例子：</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211117220342.png style=display:block;width:80% alt=NAME align=center></div><p>可以看到，session C 执行kill query以后，session B几乎同时就提示了语句被中断。这，就是我们预期的结果。</p><h2 id=收到kill以后线程做什么>收到kill以后，线程做什么？</h2><p>但是，这里你要停下来想一下：session B是直接终止掉线程，什么都不管就直接退出吗？显然，这是不行的。</p><p>我在第6篇文章中讲过，当对一个表做增删改查操作时，会在表上加MDL读锁。所以，session B虽然处于blocked状态，但还是拿着一个MDL读锁的。如果线程被kill的时候，就直接终止，那之后这个MDL读锁就没机会被释放了。</p><p>这样看来，kill并不是马上停止的意思，而是告诉执行线程说，这条语句已经不需要继续执行了，可以开始“执行停止的逻辑了”。</p><blockquote><p>其实，这跟Linux的kill命令类似，kill -N pid并不是让进程直接停止，而是给进程发一个信号，然后进程处理这个信号，进入终止逻辑。只是对于MySQL的kill命令来说，不需要传信号量参数，就只有“停止”这个命令。</p></blockquote><p><strong>实现上，当用户执行kill query thread_id_B时，MySQL里处理kill命令的线程做了两件事：</strong></p><ol><li>把session B的运行状态改成THD::KILL_QUERY(将变量killed赋值为THD::KILL_QUERY)；</li><li>给session B的执行线程发一个信号。</li></ol><p>为什么要发信号呢？</p><p>因为像图1的我们例子里面，session B处于锁等待状态，如果只是把session B的线程状态设置THD::KILL_QUERY，线程B并不知道这个状态变化，还是会继续等待。发一个信号的目的，就是让session B退出等待，来处理这个THD::KILL_QUERY状态。</p><p>上面的分析中，隐含了这么三层意思：</p><ol><li>一个语句执行过程中有多处“埋点”，在这些“埋点”的地方判断线程状态，如果发现线程状态是THD::KILL_QUERY，才开始进入语句终止逻辑；</li><li>如果处于等待状态，必须是一个可以被唤醒的等待，否则根本不会执行到“埋点”处；</li><li>语句从开始进入终止逻辑，到终止逻辑完全完成，是有一个过程的。</li></ol><p>到这里你就知道了，原来不是“说停就停的”。</p><p>接下来，我们<strong>再看一个kill不掉的例子</strong>，也就是我们在前面第29篇文章中提到的 innodb_thread_concurrency 不够用的例子。</p><p>首先，执行set global innodb_thread_concurrency=2，将InnoDB的并发线程上限数设置为2；然后，执行下面的序列：</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211117220414.png style=display:block;width:80% alt=NAME align=center></div><p>可以看到：</p><ol><li>sesssion C执行的时候被堵住了；</li><li>但是session D执行的kill query C命令却没什么效果，</li><li>直到session E执行了kill connection命令，才断开了session C的连接，提示“Lost connection to MySQL server during query”，</li><li>但是这时候，如果在session E中执行show processlist，你就能看到下面这个图。</li></ol><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211117220426.png style=display:block;width:80% alt=NAME align=center></div><p>这时候，id=12这个线程的Commnad列显示的是Killed。也就是说，客户端虽然断开了连接，但实际上服务端上这条语句还在执行过程中。</p><p><strong>为什么在执行kill query命令时，这条语句不像第一个例子的update语句一样退出呢？</strong></p><p>在实现上，等行锁时，使用的是pthread_cond_timedwait函数，这个等待状态可以被唤醒。但是，在这个例子里，12号线程的等待逻辑是这样的：每10毫秒判断一下是否可以进入InnoDB执行，如果不行，就调用nanosleep函数进入sleep状态。</p><p>也就是说，虽然12号线程的状态已经被设置成了KILL_QUERY，但是在这个等待进入InnoDB的循环过程中，并没有去判断线程的状态，因此根本不会进入终止逻辑阶段。</p><p>而当session E执行kill connection 命令时，是这么做的，</p><ol><li>把12号线程状态设置为KILL_CONNECTION；</li><li>关掉12号线程的网络连接。因为有这个操作，所以你会看到，这时候session C收到了断开连接的提示。</li></ol><p>那为什么执行show processlist的时候，会看到Command列显示为killed呢？其实，这就是因为在执行show processlist的时候，有一个特别的逻辑：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>如果一个线程的状态是KILL_CONNECTION，就把Command列显示成Killed。
</span></span></code></pre></div><p>所以其实，即使是客户端退出了，这个线程的状态仍然是在等待中。那这个线程什么时候会退出呢？</p><p>答案是，只有等到满足进入InnoDB的条件后，session C的查询语句继续执行，然后才有可能判断到线程状态已经变成了KILL_QUERY或者KILL_CONNECTION，再进入终止逻辑阶段。</p><p>到这里，我们来小结一下。</p><p>**这个例子是kill无效的第一类情况，即：线程没有执行到判断线程状态的逻辑。**跟这种情况相同的，还有由于IO压力过大，读写IO的函数一直无法返回，导致不能及时判断线程的状态。</p><p>**另一类情况是，终止逻辑耗时较长。**这时候，从show processlist结果上看也是Command=Killed，需要等到终止逻辑完成，语句才算真正完成。这类情况，比较常见的场景有以下几种：</p><ol><li>超大事务执行期间被kill。这时候，回滚操作需要对事务执行期间生成的所有新数据版本做回收操作，耗时很长。</li><li>大查询回滚。如果查询过程中生成了比较大的临时文件，加上此时文件系统压力大，删除临时文件可能需要等待IO资源，导致耗时较长。</li><li>DDL命令执行到最后阶段，如果被kill，需要删除中间过程的临时文件，也可能受IO资源影响耗时较久。</li></ol><p>之前有人问过我，如果直接在客户端通过Ctrl+C命令，是不是就可以直接终止线程呢？</p><p>答案是，不可以。</p><p>这里有一个误解，其实在客户端的操作只能操作到客户端的线程，客户端和服务端只能通过网络交互，是不可能直接操作服务端线程的。</p><p>而由于MySQL是停等协议，所以这个线程执行的语句还没有返回的时候，再往这个连接里面继续发命令也是没有用的。实际上，执行Ctrl+C的时候，是MySQL客户端另外启动一个连接，然后发送一个kill query 命令。</p><p>所以，你可别以为在客户端执行完Ctrl+C就万事大吉了。因为，要kill掉一个线程，还涉及到后端的很多操作。</p><h2 id=另外两个关于客户端的误解>另外两个关于客户端的误解</h2><p>在实际使用中，我也经常会碰到一些同学对客户端的使用有误解。接下来，我们就来看看两个最常见的误解。</p><p><strong>第一个误解是：如果库里面的表特别多，连接就会很慢。</strong></p><p>有些线上的库，会包含很多表（我见过最多的一个库里有6万个表）。这时候，你就会发现，每次用客户端连接都会卡在下面这个界面上。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211117220445.png style=display:block;width:80% alt=NAME align=center></div><p>而如果db1这个库里表很少的话，连接起来就会很快，可以很快进入输入命令的状态。因此，有同学会认为是表的数目影响了连接性能。</p><p>从第一篇文章你就知道，每个客户端在和服务端建立连接的时候，需要做的事情就是TCP握手、用户校验、获取权限。但这几个操作，显然跟库里面表的个数无关。</p><p>但实际上，正如图中的文字提示所说的，当使用默认参数连接的时候，MySQL客户端会提供一个本地库名和表名补全的功能。为了实现这个功能，客户端在连接成功后，需要多做一些操作：</p><ol><li>执行show databases；</li><li>切到db1库，执行show tables；</li><li>把这两个命令的结果用于构建一个本地的哈希表。</li></ol><p>在这些操作中，最花时间的就是第三步在本地构建哈希表的操作。所以，当一个库中的表个数非常多的时候，这一步就会花比较长的时间。</p><p>也就是说，<strong>我们感知到的连接过程慢，其实并不是连接慢，也不是服务端慢，而是客户端慢。</strong></p><p>图中的提示也说了，如果在连接命令中加上-A，就可以关掉这个自动补全的功能，然后客户端就可以快速返回了。</p><p>这里自动补全的效果就是，你在输入库名或者表名的时候，输入前缀，可以使用Tab键自动补全表名或者显示提示。</p><p>实际使用中，如果你自动补全功能用得并不多，我建议你每次使用的时候都默认加-A。</p><p>其实提示里面没有说，除了加-A以外，加–quick(或者简写为-q)参数，也可以跳过这个阶段。但是，这个**–quick是一个更容易引起误会的参数，也是关于客户端常见的一个误解。**</p><p>你看到这个参数，是不是觉得这应该是一个让服务端加速的参数？但实际上恰恰相反，设置了这个参数可能会降低服务端的性能。为什么这么说呢？</p><p>MySQL客户端发送请求后，接收服务端返回结果的方式有两种：</p><ol><li>一种是本地缓存，也就是在本地开一片内存，先把结果存起来。如果你用API开发，对应的就是mysql_store_result 方法。</li><li>另一种是不缓存，读一个处理一个。如果你用API开发，对应的就是mysql_use_result方法。</li></ol><p>MySQL客户端默认采用第一种方式，而如果加上–quick参数，就会使用第二种不缓存的方式。</p><p>采用不缓存的方式时，如果本地处理得慢，就会导致服务端发送结果被阻塞，因此会让服务端变慢。关于服务端的具体行为，我会在下一篇文章再和你展开说明。</p><p>那你会说，既然这样，为什么要给这个参数取名叫作quick呢？这是因为使用这个参数可以达到以下三点效果：</p><ul><li>第一点，就是前面提到的，跳过表名自动补全功能。</li><li>第二点，mysql_store_result需要申请本地内存来缓存查询结果，如果查询结果太大，会耗费较多的本地内存，可能会影响客户端本地机器的性能；</li><li>第三点，是不会把执行命令记录到本地的命令历史文件。</li></ul><p>所以你看到了，–quick参数的意思，是让客户端变得更快。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-029fcd79263b8e63f77ed4e182b0a61e>5.33 - CH33-内存占用</h1><p>我经常会被问到这样一个问题：我的主机内存只有100G，现在要对一个200G的大表做全表扫描，会不会把数据库主机的内存用光了？</p><p>这个问题确实值得担心，被系统OOM（out of memory）可不是闹着玩的。但是，反过来想想，逻辑备份的时候，可不就是做整库扫描吗？如果这样就会把内存吃光，逻辑备份不是早就挂了？</p><p>所以说，对大表做全表扫描，看来应该是没问题的。但是，这个流程到底是怎么样的呢？</p><h2 id=全表扫描对server层的影响>全表扫描对server层的影响</h2><p>假设，我们现在要对一个200G的InnoDB表db1. t，执行一个全表扫描。当然，你要把扫描结果保存在客户端，会使用类似这样的命令：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#000>mysql</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>-</span><span style=color:#000>h$host</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>-</span><span style=color:#000>P$port</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>-</span><span style=color:#000>u$user</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>-</span><span style=color:#000>p$pwd</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>-</span><span style=color:#000>e</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#4e9a06>&#34;select * from db1.t&#34;</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>&gt;</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#a40000>$</span><span style=color:#000>target_file</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><p>你已经知道了，InnoDB的数据是保存在主键索引上的，所以全表扫描实际上是直接扫描表t的主键索引。这条查询语句由于没有其他的判断条件，所以查到的每一行都可以直接放到结果集里面，然后返回给客户端。</p><p>那么，这个“结果集”存在哪里呢？</p><p>实际上，服务端并不需要保存一个完整的结果集。取数据和发数据的流程是这样的：</p><ol><li>获取一行，写到net_buffer中。这块内存的大小是由参数net_buffer_length定义的，默认是16k。</li><li>重复获取行，直到net_buffer写满，调用网络接口发出去。</li><li>如果发送成功，就清空net_buffer，然后继续取下一行，并写入net_buffer。</li><li>如果发送函数返回EAGAIN或WSAEWOULDBLOCK，就表示本地网络栈（socket send buffer）写满了，进入等待。直到网络栈重新可写，再继续发送。</li></ol><p>这个过程对应的流程图如下所示。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211117220636.png style=display:block;width:80% alt=NAME align=center></div><p>从这个流程中，你可以看到：</p><ol><li>一个查询在发送过程中，占用的MySQL内部的内存最大就是net_buffer_length这么大，并不会达到200G；</li><li>socket send buffer 也不可能达到200G（默认定义/proc/sys/net/core/wmem_default），如果socket send buffer被写满，就会暂停读数据的流程。</li></ol><p>也就是说，<strong>MySQL是“边读边发的”</strong>，这个概念很重要。这就意味着，如果客户端接收得慢，会导致MySQL服务端由于结果发不出去，这个事务的执行时间变长。</p><p>比如下面这个状态，就是我故意让客户端不去读socket receive buffer中的内容，然后在服务端show processlist看到的结果。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211117220650.png style=display:block;width:80% alt=NAME align=center></div><p>如果你看到State的值一直处于**“Sending to client”**，就表示服务器端的网络栈写满了。</p><p>我在上一篇文章中曾提到，如果客户端使用–quick参数，会使用mysql_use_result方法。这个方法是读一行处理一行。你可以想象一下，假设有一个业务的逻辑比较复杂，每读一行数据以后要处理的逻辑如果很慢，就会导致客户端要过很久才会去取下一行数据，可能就会出现如图2所示的这种情况。</p><p>因此，<strong>对于正常的线上业务来说，如果一个查询的返回结果不会很多的话，我都建议你使用mysql_store_result这个接口，直接把查询结果保存到本地内存。</strong></p><p>当然前提是查询返回结果不多。在第30篇文章评论区，有同学说到自己因为执行了一个大查询导致客户端占用内存近20G，这种情况下就需要改用mysql_use_result接口了。</p><p>另一方面，如果你在自己负责维护的MySQL里看到很多个线程都处于“Sending to client”这个状态，就意味着你要让业务开发同学优化查询结果，并评估这么多的返回结果是否合理。</p><p>而如果要快速减少处于这个状态的线程的话，将net_buffer_length参数设置为一个更大的值是一个可选方案。</p><p>与“Sending to client”长相很类似的一个状态是**“Sending data”**，这是一个经常被误会的问题。有同学问我说，在自己维护的实例上看到很多查询语句的状态是“Sending data”，但查看网络也没什么问题啊，为什么Sending data要这么久？</p><p>实际上，一个查询语句的状态变化是这样的（注意：这里，我略去了其他无关的状态）：</p><ul><li>MySQL查询语句进入执行阶段后，首先把状态设置成“Sending data”；</li><li>然后，发送执行结果的列相关的信息（meta data) 给客户端；</li><li>再继续执行语句的流程；</li><li>执行完成后，把状态设置成空字符串。</li></ul><p>也就是说，“Sending data”并不一定是指“正在发送数据”，而可能是处于执行器过程中的任意阶段。比如，你可以构造一个锁等待的场景，就能看到Sending data状态。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211117220714.png style=display:block;width:80% alt=NAME align=center></div><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211117220721.png style=display:block;width:80% alt=NAME align=center></div><p>可以看到，session B明显是在等锁，状态显示为Sending data。</p><p>也就是说，仅当一个线程处于“等待客户端接收结果”的状态，才会显示"Sending to client"；而如果显示成“Sending data”，它的意思只是“正在执行”。</p><p>现在你知道了，查询的结果是分段发给客户端的，因此扫描全表，查询返回大量的数据，并不会把内存打爆。</p><p>在server层的处理逻辑我们都清楚了，在InnoDB引擎里面又是怎么处理的呢？ 扫描全表会不会对引擎系统造成影响呢？</p><h2 id=全表扫描对innodb的影响>全表扫描对InnoDB的影响</h2><p>在第 2 和第 15 篇文章中，我介绍WAL机制的时候，和你分析了InnoDB内存的一个作用，是保存更新的结果，再配合redo log，就避免了随机写盘。</p><p>内存的数据页是在Buffer Pool (BP)中管理的，在WAL里Buffer Pool 起到了加速更新的作用。而实际上，Buffer Pool 还有一个更重要的作用，就是加速查询。</p><p>在第2篇文章的评论区有同学问道，由于有WAL机制，当事务提交的时候，磁盘上的数据页是旧的，那如果这时候马上有一个查询要来读这个数据页，是不是要马上把redo log应用到数据页呢？</p><p>答案是不需要。因为这时候内存数据页的结果是最新的，直接读内存页就可以了。你看，这时候查询根本不需要读磁盘，直接从内存拿结果，速度是很快的。所以说，Buffer Pool还有加速查询的作用。</p><p>而Buffer Pool对查询的加速效果，依赖于一个重要的指标，即：<strong>内存命中率</strong>。</p><p>你可以在show engine innodb status结果中，查看一个系统当前的BP命中率。一般情况下，一个稳定服务的线上系统，要保证响应时间符合要求的话，内存命中率要在99%以上。</p><p>执行show engine innodb status ，可以看到“Buffer pool hit rate”字样，显示的就是当前的命中率。比如图5这个命中率，就是99.0%。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211117220748.png style=display:block;width:80% alt=NAME align=center></div><p>如果所有查询需要的数据页都能够直接从内存得到，那是最好的，对应的命中率就是100%。但，这在实际生产上是很难做到的。</p><p>InnoDB Buffer Pool的大小是由参数 innodb_buffer_pool_size确定的，一般建议设置成可用物理内存的60%~80%。</p><p>在大约十年前，单机的数据量是上百个G，而物理内存是几个G；现在虽然很多服务器都能有128G甚至更高的内存，但是单机的数据量却达到了T级别。</p><p>所以，innodb_buffer_pool_size小于磁盘的数据量是很常见的。如果一个 Buffer Pool满了，而又要从磁盘读入一个数据页，那肯定是要淘汰一个旧数据页的。</p><p>InnoDB内存管理用的是最近最少使用 (Least Recently Used, LRU)算法，这个算法的核心就是淘汰最久未使用的数据。</p><p>下图是一个LRU算法的基本模型。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211117220759.png style=display:block;width:80% alt=NAME align=center></div><p>InnoDB管理Buffer Pool的LRU算法，是用链表来实现的。</p><ol><li>在图6的状态1里，链表头部是P1，表示P1是最近刚刚被访问过的数据页；假设内存里只能放下这么多数据页；</li><li>这时候有一个读请求访问P3，因此变成状态2，P3被移到最前面；</li><li>状态3表示，这次访问的数据页是不存在于链表中的，所以需要在Buffer Pool中新申请一个数据页Px，加到链表头部。但是由于内存已经满了，不能申请新的内存。于是，会清空链表末尾Pm这个数据页的内存，存入Px的内容，然后放到链表头部。</li><li>从效果上看，就是最久没有被访问的数据页Pm，被淘汰了。</li></ol><p>这个算法乍一看上去没什么问题，但是如果考虑到要做一个全表扫描，会不会有问题呢？</p><p>假设按照这个算法，我们要扫描一个200G的表，而这个表是一个历史数据表，平时没有业务访问它。</p><p>那么，按照这个算法扫描的话，就会把当前的Buffer Pool里的数据全部淘汰掉，存入扫描过程中访问到的数据页的内容。也就是说Buffer Pool里面主要放的是这个历史数据表的数据。</p><p>对于一个正在做业务服务的库，这可不妙。你会看到，Buffer Pool的内存命中率急剧下降，磁盘压力增加，SQL语句响应变慢。</p><p>所以，InnoDB不能直接使用这个LRU算法。实际上，InnoDB对LRU算法做了改进。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211117220816.png style=display:block;width:80% alt=NAME align=center></div><p>在InnoDB实现上，按照5:3的比例把整个LRU链表分成了young区域和old区域。图中LRU_old指向的就是old区域的第一个位置，是整个链表的5/8处。也就是说，靠近链表头部的5/8是young区域，靠近链表尾部的3/8是old区域。</p><p>改进后的LRU算法执行流程变成了下面这样。</p><ol><li>图7中状态1，要访问数据页P3，由于P3在young区域，因此和优化前的LRU算法一样，将其移到链表头部，变成状态2。</li><li>之后要访问一个新的不存在于当前链表的数据页，这时候依然是淘汰掉数据页Pm，但是新插入的数据页Px，是放在LRU_old处。</li><li>处于old区域的数据页，每次被访问的时候都要做下面这个判断：<ul><li>若这个数据页在LRU链表中存在的时间超过了1秒，就把它移动到链表头部；</li><li>如果这个数据页在LRU链表中存在的时间短于1秒，位置保持不变。1秒这个时间，是由参数innodb_old_blocks_time控制的。其默认值是1000，单位毫秒。</li></ul></li></ol><p>这个策略，就是为了处理类似全表扫描的操作量身定制的。还是以刚刚的扫描200G的历史数据表为例，我们看看改进后的LRU算法的操作逻辑：</p><ol><li>扫描过程中，需要新插入的数据页，都被放到old区域;</li><li>一个数据页里面有多条记录，这个数据页会被多次访问到，但由于是顺序扫描，这个数据页第一次被访问和最后一次被访问的时间间隔不会超过1秒，因此还是会被保留在old区域；</li><li>再继续扫描后续的数据，之前的这个数据页之后也不会再被访问到，于是始终没有机会移到链表头部（也就是young区域），很快就会被淘汰出去。</li></ol><p>可以看到，这个策略最大的收益，就是在扫描这个大表的过程中，虽然也用到了Buffer Pool，但是对young区域完全没有影响，从而保证了Buffer Pool响应正常业务的查询命中率。</p><h2 id=总结>总结</h2><p>今天，我用“大查询会不会把内存用光”这个问题，和你介绍了MySQL的查询结果，发送给客户端的过程。</p><p>由于MySQL采用的是边算边发的逻辑，因此对于数据量很大的查询结果来说，不会在server端保存完整的结果集。所以，如果客户端读结果不及时，会堵住MySQL的查询过程，但是不会把内存打爆。</p><p>而对于InnoDB引擎内部，由于有淘汰策略，大查询也不会导致内存暴涨。并且，由于InnoDB对LRU算法做了改进，冷数据的全表扫描，对Buffer Pool的影响也能做到可控。</p><p>当然，我们前面文章有说过，全表扫描还是比较耗费IO资源的，所以业务高峰期还是不能直接在线上主库执行全表扫描的。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-ae53ce85470f1a5d487b0943e0f46675>5.34 - CH34-JOIN 应用</h1><p>在实际生产中，关于join语句使用的问题，一般会集中在以下两类：</p><ol><li>我们DBA不让使用join，使用join有什么问题呢？</li><li>如果有两个大小不同的表做join，应该用哪个表做驱动表呢？</li></ol><p>今天这篇文章，我就先跟你说说join语句到底是怎么执行的，然后再来回答这两个问题。</p><p>为了便于量化分析，我还是创建两个表t1和t2来和你说明。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>CREATE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>TABLE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>t2</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>(</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>id</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87>int</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>11</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>NOT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>NULL</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>a</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87>int</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>11</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>DEFAULT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>NULL</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>b</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87>int</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>11</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>DEFAULT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>NULL</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>PRIMARY</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>KEY</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>(</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>id</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000;font-weight:700>),</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>KEY</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>a</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>(</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>a</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>ENGINE</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#000>InnoDB</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>drop</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>procedure</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>idata</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>delimiter</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>;;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>create</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>procedure</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>idata</span><span style=color:#000;font-weight:700>()</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>begin</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>declare</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>i</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87>int</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>set</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>i</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#000>while</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>i</span><span style=color:#ce5c00;font-weight:700>&lt;=</span><span style=color:#0000cf;font-weight:700>1000</span><span style=color:#000;font-weight:700>)</span><span style=color:#204a87;font-weight:700>do</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>    </span><span style=color:#204a87;font-weight:700>insert</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>into</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>t2</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>values</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>i</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>i</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>i</span><span style=color:#000;font-weight:700>);</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>    </span><span style=color:#204a87;font-weight:700>set</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>i</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#000>i</span><span style=color:#ce5c00;font-weight:700>+</span><span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>end</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>while</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>end</span><span style=color:#000;font-weight:700>;;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>delimiter</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>call</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>idata</span><span style=color:#000;font-weight:700>();</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>create</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>table</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>t1</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>like</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>t2</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>insert</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>into</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>t1</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>(</span><span style=color:#204a87;font-weight:700>select</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>*</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>from</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>t2</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>where</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>id</span><span style=color:#ce5c00;font-weight:700>&lt;=</span><span style=color:#0000cf;font-weight:700>100</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><p>可以看到，这两个表都有一个主键索引id和一个索引a，字段b上无索引。存储过程idata()往表t2里插入了1000行数据，在表t1里插入的是100行数据。</p><h2 id=index-nested-loop-join>Index Nested-Loop Join</h2><p>我们来看一下这个语句：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>select</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>*</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>from</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>t1</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>straight_join</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>t2</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>on</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>(</span><span style=color:#000>t1</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>a</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#000>t2</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>a</span><span style=color:#000;font-weight:700>);</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><p>如果直接使用join语句，MySQL优化器可能会选择表t1或t2作为驱动表，这样会影响我们分析SQL语句的执行过程。所以，为了便于分析执行过程中的性能问题，我改用straight_join让MySQL使用固定的连接方式执行查询，这样优化器只会按照我们指定的方式去join。在这个语句里，t1 是驱动表，t2是被驱动表。</p><p>现在，我们来看一下这条语句的explain结果。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211117220921.png style=display:block;width:80% alt=NAME align=center></div><p>可以看到，在这条语句里，被驱动表t2的字段a上有索引，join过程用上了这个索引，因此这个语句的执行流程是这样的：</p><ol><li>从表t1中读入一行数据 R；</li><li>从数据行R中，取出a字段到表t2里去查找；</li><li>取出表t2中满足条件的行，跟R组成一行，作为结果集的一部分；</li><li>重复执行步骤1到3，直到表t1的末尾循环结束。</li></ol><p>这个过程是先遍历表t1，然后根据从表t1中取出的每行数据中的a值，去表t2中查找满足条件的记录。在形式上，这个过程就跟我们写程序时的嵌套查询类似，并且可以用上被驱动表的索引，所以我们称之为“Index Nested-Loop Join”，简称NLJ。</p><p>它对应的流程图如下所示：</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211117220932.png style=display:block;width:80% alt=NAME align=center></div><p>在这个流程里：</p><ol><li>对驱动表t1做了全表扫描，这个过程需要扫描100行；</li><li>而对于每一行R，根据a字段去表t2查找，走的是树搜索过程。由于我们构造的数据都是一一对应的，因此每次的搜索过程都只扫描一行，也是总共扫描100行；</li><li>所以，整个执行流程，总扫描行数是200。</li></ol><p>现在我们知道了这个过程，再试着回答一下文章开头的两个问题。</p><p>先看第一个问题：<strong>能不能使用join?</strong></p><p>假设不使用join，那我们就只能用单表查询。我们看看上面这条语句的需求，用单表查询怎么实现。</p><ol><li>执行<code>select * from t1</code>，查出表t1的所有数据，这里有100行；</li><li>循环遍历这100行数据：<ul><li>从每一行R取出字段a的值$R.a；</li><li>执行<code>select * from t2 where a=$R.a</code>；</li><li>把返回的结果和R构成结果集的一行。</li></ul></li></ol><p>可以看到，在这个查询过程，也是扫描了200行，但是总共执行了101条语句，比直接join多了100次交互。除此之外，客户端还要自己拼接SQL语句和结果。</p><p>显然，这么做还不如直接join好。</p><p>我们再来看看第二个问题：<strong>怎么选择驱动表？</strong></p><p>在这个join语句执行过程中，驱动表是走全表扫描，而被驱动表是走树搜索。</p><p>假设被驱动表的行数是M。每次在被驱动表查一行数据，要先搜索索引a，再搜索主键索引。每次搜索一棵树近似复杂度是以2为底的M的对数，记为log2M，所以在被驱动表上查一行的时间复杂度是 2*log2M。</p><p>假设驱动表的行数是N，执行过程就要扫描驱动表N行，然后对于每一行，到被驱动表上匹配一次。</p><p>因此整个执行过程，近似复杂度是 N + N<em>2</em>log2M。</p><p>显然，N对扫描行数的影响更大，因此应该让小表来做驱动表。</p><blockquote><p>如果你没觉得这个影响有那么“显然”， 可以这么理解：N扩大1000倍的话，扫描行数就会扩大1000倍；而M扩大1000倍，扫描行数扩大不到10倍。</p></blockquote><p>到这里小结一下，通过上面的分析我们得到了两个结论：</p><ol><li>使用join语句，性能比强行拆成多个单表执行SQL语句的性能要好；</li><li>如果使用join语句的话，需要让小表做驱动表。</li></ol><p>但是，你需要注意，这个结论的前提是“可以使用被驱动表的索引”。</p><p>接下来，我们再看看被驱动表用不上索引的情况。</p><h2 id=simple-nested-loop-join>Simple Nested-Loop Join</h2><p>现在，我们把SQL语句改成这样：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>select</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>*</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>from</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>t1</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>straight_join</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>t2</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>on</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>(</span><span style=color:#000>t1</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>a</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#000>t2</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>b</span><span style=color:#000;font-weight:700>);</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><p>由于表t2的字段b上没有索引，因此再用图2的执行流程时，每次到t2去匹配的时候，就要做一次全表扫描。</p><p>你可以先设想一下这个问题，继续使用图2的算法，是不是可以得到正确的结果呢？如果只看结果的话，这个算法是正确的，而且这个算法也有一个名字，叫做“Simple Nested-Loop Join”。</p><p>但是，这样算来，这个SQL请求就要扫描表t2多达100次，总共扫描100*1000=10万行。</p><p>这还只是两个小表，如果t1和t2都是10万行的表（当然了，这也还是属于小表的范围），就要扫描100亿行，这个算法看上去太“笨重”了。</p><p>当然，MySQL也没有使用这个Simple Nested-Loop Join算法，而是使用了另一个叫作“Block Nested-Loop Join”的算法，简称BNL。</p><h2 id=block-nested-loop-join>Block Nested-Loop Join</h2><p>这时候，被驱动表上没有可用的索引，算法的流程是这样的：</p><ol><li>把表t1的数据读入线程内存join_buffer中，由于我们这个语句中写的是select *，因此是把整个表t1放入了内存；</li><li>扫描表t2，把表t2中的每一行取出来，跟join_buffer中的数据做对比，满足join条件的，作为结果集的一部分返回。</li></ol><p>这个过程的流程图如下：</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211117220958.png style=display:block;width:80% alt=NAME align=center></div><p>对应地，这条SQL语句的explain结果如下所示：</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211117221009.png style=display:block;width:80% alt=NAME align=center></div><p>可以看到，在这个过程中，对表t1和t2都做了一次全表扫描，因此总的扫描行数是1100。由于join_buffer是以无序数组的方式组织的，因此对表t2中的每一行，都要做100次判断，总共需要在内存中做的判断次数是：100*1000=10万次。</p><p>前面我们说过，如果使用Simple Nested-Loop Join算法进行查询，扫描行数也是10万行。因此，从时间复杂度上来说，这两个算法是一样的。但是，Block Nested-Loop Join算法的这10万次判断是内存操作，速度上会快很多，性能也更好。</p><p>接下来，我们来看一下，在这种情况下，应该选择哪个表做驱动表。</p><p>假设小表的行数是N，大表的行数是M，那么在这个算法里：</p><ol><li>两个表都做一次全表扫描，所以总的扫描行数是M+N；</li><li>内存中的判断次数是M*N。</li></ol><p>可以看到，调换这两个算式中的M和N没差别，因此这时候选择大表还是小表做驱动表，执行耗时是一样的。</p><p>然后，你可能马上就会问了，这个例子里表t1才100行，要是表t1是一个大表，join_buffer放不下怎么办呢？</p><p>join_buffer的大小是由参数join_buffer_size设定的，默认值是256k。**如果放不下表t1的所有数据话，策略很简单，就是分段放。**我把join_buffer_size改成1200，再执行：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>select</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>*</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>from</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>t1</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>straight_join</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>t2</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>on</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>(</span><span style=color:#000>t1</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>a</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#000>t2</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>b</span><span style=color:#000;font-weight:700>);</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><p>执行过程就变成了：</p><ol><li>扫描表t1，顺序读取数据行放入join_buffer中，放完第88行join_buffer满了，继续第2步；</li><li>扫描表t2，把t2中的每一行取出来，跟join_buffer中的数据做对比，满足join条件的，作为结果集的一部分返回；</li><li>清空join_buffer；</li><li>继续扫描表t1，顺序读取最后的12行数据放入join_buffer中，继续执行第2步。</li></ol><p>执行流程图也就变成这样：</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211117221022.png style=display:block;width:80% alt=NAME align=center></div><p>图中的步骤4和5，表示清空join_buffer再复用。</p><p>这个流程才体现出了这个算法名字中“Block”的由来，表示“分块去join”。</p><p>可以看到，这时候由于表t1被分成了两次放入join_buffer中，导致表t2会被扫描两次。虽然分成两次放入join_buffer，但是判断等值条件的次数还是不变的，依然是(88+12)*1000=10万次。</p><p>我们再来看下，在这种情况下驱动表的选择问题。</p><p>假设，驱动表的数据行数是N，需要分K段才能完成算法流程，被驱动表的数据行数是M。</p><p>注意，这里的K不是常数，N越大K就会越大，因此把K表示为λ*N，显然λ的取值范围是(0,1)。</p><p>所以，在这个算法的执行过程中：</p><ol><li>扫描行数是 N+λ<em>N</em>M；</li><li>内存判断 N*M次。</li></ol><p>显然，内存判断次数是不受选择哪个表作为驱动表影响的。而考虑到扫描行数，在M和N大小确定的情况下，N小一些，整个算式的结果会更小。</p><p>所以结论是，应该让小表当驱动表。</p><p>当然，你会发现，在N+λ<em>N</em>M这个式子里，λ才是影响扫描行数的关键因素，这个值越小越好。</p><p>刚刚我们说了N越大，分段数K越大。那么，N固定的时候，什么参数会影响K的大小呢？（也就是λ的大小）答案是join_buffer_size。join_buffer_size越大，一次可以放入的行越多，分成的段数也就越少，对被驱动表的全表扫描次数就越少。</p><p>这就是为什么，你可能会看到一些建议告诉你，如果你的join语句很慢，就把join_buffer_size改大。</p><p>理解了MySQL执行join的两种算法，现在我们再来试着<strong>回答文章开头的两个问题</strong>。</p><p>第一个问题：能不能使用join语句？</p><ol><li>如果可以使用Index Nested-Loop Join算法，也就是说可以用上被驱动表上的索引，其实是没问题的；</li><li>如果使用Block Nested-Loop Join算法，扫描行数就会过多。尤其是在大表上的join操作，这样可能要扫描被驱动表很多次，会占用大量的系统资源。所以这种join尽量不要用。</li></ol><p>所以你在判断要不要使用join语句时，就是看explain结果里面，Extra字段里面有没有出现“Block Nested Loop”字样。</p><p>第二个问题是：如果要使用join，应该选择大表做驱动表还是选择小表做驱动表？</p><ol><li>如果是Index Nested-Loop Join算法，应该选择小表做驱动表；</li><li>如果是Block Nested-Loop Join算法：<ul><li>在join_buffer_size足够大的时候，是一样的；</li><li>在join_buffer_size不够大的时候（这种情况更常见），应该选择小表做驱动表。</li></ul></li></ol><p>所以，这个问题的结论就是，总是应该使用小表做驱动表。</p><p>当然了，这里我需要说明下，<strong>什么叫作“小表”</strong>。</p><p>我们前面的例子是没有加条件的。如果我在语句的where条件加上 t2.id&lt;=50这个限定条件，再来看下这两条语句：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>select</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>*</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>from</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>t1</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>straight_join</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>t2</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>on</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>(</span><span style=color:#000>t1</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>b</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#000>t2</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>b</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>where</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>t2</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>id</span><span style=color:#ce5c00;font-weight:700>&lt;=</span><span style=color:#0000cf;font-weight:700>50</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>select</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>*</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>from</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>t2</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>straight_join</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>t1</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>on</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>(</span><span style=color:#000>t1</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>b</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#000>t2</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>b</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>where</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>t2</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>id</span><span style=color:#ce5c00;font-weight:700>&lt;=</span><span style=color:#0000cf;font-weight:700>50</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><p>注意，为了让两条语句的被驱动表都用不上索引，所以join字段都使用了没有索引的字段b。</p><p>但如果是用第二个语句的话，join_buffer只需要放入t2的前50行，显然是更好的。所以这里，“t2的前50行”是那个相对小的表，也就是“小表”。</p><p>我们再来看另外一组例子：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>select</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>t1</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>b</span><span style=color:#000;font-weight:700>,</span><span style=color:#000>t2</span><span style=color:#000;font-weight:700>.</span><span style=color:#ce5c00;font-weight:700>*</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>from</span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#000>t1</span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#000>straight_join</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>t2</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>on</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>(</span><span style=color:#000>t1</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>b</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#000>t2</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>b</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>where</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>t2</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>id</span><span style=color:#ce5c00;font-weight:700>&lt;=</span><span style=color:#0000cf;font-weight:700>100</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>select</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>t1</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>b</span><span style=color:#000;font-weight:700>,</span><span style=color:#000>t2</span><span style=color:#000;font-weight:700>.</span><span style=color:#ce5c00;font-weight:700>*</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>from</span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#000>t2</span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#000>straight_join</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>t1</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>on</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>(</span><span style=color:#000>t1</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>b</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#000>t2</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>b</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>where</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>t2</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>id</span><span style=color:#ce5c00;font-weight:700>&lt;=</span><span style=color:#0000cf;font-weight:700>100</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><p>这个例子里，表t1 和 t2都是只有100行参加join。但是，这两条语句每次查询放入join_buffer中的数据是不一样的：</p><ul><li>表t1只查字段b，因此如果把t1放到join_buffer中，则join_buffer中只需要放入b的值；</li><li>表t2需要查所有的字段，因此如果把表t2放到join_buffer中的话，就需要放入三个字段id、a和b。</li></ul><p>这里，我们应该选择表t1作为驱动表。也就是说在这个例子里，“只需要一列参与join的表t1”是那个相对小的表。</p><p>所以，更准确地说，<strong>在决定哪个表做驱动表的时候，应该是两个表按照各自的条件过滤，过滤完成之后，计算参与join的各个字段的总数据量，数据量小的那个表，就是“小表”，应该作为驱动表。</strong></p><h2 id=小结>小结</h2><p>今天，我和你介绍了MySQL执行join语句的两种可能算法，这两种算法是由能否使用被驱动表的索引决定的。而能否用上被驱动表的索引，对join语句的性能影响很大。</p><p>通过对Index Nested-Loop Join和Block Nested-Loop Join两个算法执行过程的分析，我们也得到了文章开头两个问题的答案：</p><ol><li>如果可以使用被驱动表的索引，join语句还是有其优势的；</li><li>不能使用被驱动表的索引，只能使用Block Nested-Loop Join算法，这样的语句就尽量不要使用；</li><li>在使用join的时候，应该让小表做驱动表。</li></ol></div><div class=td-content style=page-break-before:always><h1 id=pg-3259143b4213c83ebd11172671a116d6>5.35 - CH35-JOIN 优化</h1><p>在上一篇文章中，我和你介绍了join语句的两种算法，分别是Index Nested-Loop Join(NLJ)和Block Nested-Loop Join(BNL)。</p><p>我们发现在使用NLJ算法的时候，其实效果还是不错的，比通过应用层拆分成多个语句然后再拼接查询结果更方便，而且性能也不会差。</p><p>但是，BNL算法在大表join的时候性能就差多了，比较次数等于两个表参与join的行数的乘积，很消耗CPU资源。</p><p>当然了，这两个算法都还有继续优化的空间，我们今天就来聊聊这个话题。</p><p>为了便于分析，我还是创建两个表t1、t2来和你展开今天的问题。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>create</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>table</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>t1</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>id</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87>int</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>primary</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>key</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>a</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87>int</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>b</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87>int</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>index</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>a</span><span style=color:#000;font-weight:700>));</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>create</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>table</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>t2</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>like</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>t1</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>drop</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>procedure</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>idata</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>delimiter</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>;;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>create</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>procedure</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>idata</span><span style=color:#000;font-weight:700>()</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>begin</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>declare</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>i</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87>int</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>set</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>i</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#000>while</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>i</span><span style=color:#ce5c00;font-weight:700>&lt;=</span><span style=color:#0000cf;font-weight:700>1000</span><span style=color:#000;font-weight:700>)</span><span style=color:#204a87;font-weight:700>do</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>    </span><span style=color:#204a87;font-weight:700>insert</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>into</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>t1</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>values</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>i</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#0000cf;font-weight:700>1001</span><span style=color:#ce5c00;font-weight:700>-</span><span style=color:#000>i</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>i</span><span style=color:#000;font-weight:700>);</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>    </span><span style=color:#204a87;font-weight:700>set</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>i</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#000>i</span><span style=color:#ce5c00;font-weight:700>+</span><span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>end</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>while</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>set</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>i</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#000>while</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>i</span><span style=color:#ce5c00;font-weight:700>&lt;=</span><span style=color:#0000cf;font-weight:700>1000000</span><span style=color:#000;font-weight:700>)</span><span style=color:#204a87;font-weight:700>do</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>    </span><span style=color:#204a87;font-weight:700>insert</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>into</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>t2</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>values</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>i</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>i</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>i</span><span style=color:#000;font-weight:700>);</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>    </span><span style=color:#204a87;font-weight:700>set</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>i</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#000>i</span><span style=color:#ce5c00;font-weight:700>+</span><span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>end</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>while</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>end</span><span style=color:#000;font-weight:700>;;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>delimiter</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>call</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>idata</span><span style=color:#000;font-weight:700>();</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><p>为了便于后面量化说明，我在表t1里，插入了1000行数据，每一行的a=1001-id的值。也就是说，表t1中字段a是逆序的。同时，我在表t2中插入了100万行数据。</p><h2 id=multi-range-read优化>Multi-Range Read优化</h2><p>在介绍join语句的优化方案之前，我需要先和你介绍一个知识点，即：Multi-Range Read优化(MRR)。这个优化的主要目的是尽量使用顺序读盘。</p><p>在第4篇文章中，我和你介绍InnoDB的索引结构时，提到了“回表”的概念。我们先来回顾一下这个概念。回表是指，InnoDB在普通索引a上查到主键id的值后，再根据一个个主键id的值到主键索引上去查整行数据的过程。</p><p>然后，有同学在留言区问到，回表过程是一行行地查数据，还是批量地查数据？</p><p>我们先来看看这个问题。假设，我执行这个语句：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>select</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>*</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>from</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>t1</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>where</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>a</span><span style=color:#ce5c00;font-weight:700>&gt;=</span><span style=color:#0000cf;font-weight:700>1</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>and</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>a</span><span style=color:#ce5c00;font-weight:700>&lt;=</span><span style=color:#0000cf;font-weight:700>100</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><p>主键索引是一棵B+树，在这棵树上，每次只能根据一个主键id查到一行数据。因此，回表肯定是一行行搜索主键索引的，基本流程如图1所示。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211117221202.png style=display:block;width:80% alt=NAME align=center></div><p>如果随着a的值递增顺序查询的话，id的值就变成随机的，那么就会出现随机访问，性能相对较差。虽然“按行查”这个机制不能改，但是调整查询的顺序，还是能够加速的。</p><p><strong>因为大多数的数据都是按照主键递增顺序插入得到的，所以我们可以认为，如果按照主键的递增顺序查询的话，对磁盘的读比较接近顺序读，能够提升读性能。</strong></p><p>这，就是MRR优化的设计思路。此时，语句的执行流程变成了这样：</p><ol><li>根据索引a，定位到满足条件的记录，将id值放入read_rnd_buffer中;</li><li>将read_rnd_buffer中的id进行递增排序；</li><li>排序后的id数组，依次到主键id索引中查记录，并作为结果返回。</li></ol><p>这里，read_rnd_buffer的大小是由read_rnd_buffer_size参数控制的。如果步骤1中，read_rnd_buffer放满了，就会先执行完步骤2和3，然后清空read_rnd_buffer。之后继续找索引a的下个记录，并继续循环。</p><p>另外需要说明的是，如果你想要稳定地使用MRR优化的话，需要设置<code>set optimizer_switch="mrr_cost_based=off"</code>。（官方文档的说法，是现在的优化器策略，判断消耗的时候，会更倾向于不使用MRR，把mrr_cost_based设置为off，就是固定使用MRR了。）</p><p>下面两幅图就是使用了MRR优化后的执行流程和explain结果。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211117221221.png style=display:block;width:80% alt=NAME align=center></div><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211117221229.png style=display:block;width:80% alt=NAME align=center></div><p>从图3的explain结果中，我们可以看到Extra字段多了Using MRR，表示的是用上了MRR优化。而且，由于我们在read_rnd_buffer中按照id做了排序，所以最后得到的结果集也是按照主键id递增顺序的，也就是与图1结果集中行的顺序相反。</p><p>到这里，我们小结一下。</p><p><strong>MRR能够提升性能的核心</strong>在于，这条查询语句在索引a上做的是一个范围查询（也就是说，这是一个多值查询），可以得到足够多的主键id。这样通过排序以后，再去主键索引查数据，才能体现出“顺序性”的优势。</p><h2 id=batched-key-access>Batched Key Access</h2><p>理解了MRR性能提升的原理，我们就能理解MySQL在5.6版本后开始引入的Batched Key Acess(BKA)算法了。这个BKA算法，其实就是对NLJ算法的优化。</p><p>我们再来看看上一篇文章中用到的NLJ算法的流程图：</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211117221251.png style=display:block;width:80% alt=NAME align=center></div><p>NLJ算法执行的逻辑是：从驱动表t1，一行行地取出a的值，再到被驱动表t2去做join。也就是说，对于表t2来说，每次都是匹配一个值。这时，MRR的优势就用不上了。</p><p>那怎么才能一次性地多传些值给表t2呢？方法就是，从表t1里一次性地多拿些行出来，一起传给表t2。</p><p>既然如此，我们就把表t1的数据取出来一部分，先放到一个临时内存。这个临时内存不是别人，就是join_buffer。</p><p>通过上一篇文章，我们知道join_buffer 在BNL算法里的作用，是暂存驱动表的数据。但是在NLJ算法里并没有用。那么，我们刚好就可以复用join_buffer到BKA算法中。</p><p>如图5所示，是上面的NLJ算法优化后的BKA算法的流程。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211117221305.png style=display:block;width:80% alt=NAME align=center></div><p>图中，我在join_buffer中放入的数据是P1~P100，表示的是只会取查询需要的字段。当然，如果join buffer放不下P1~P100的所有数据，就会把这100行数据分成多段执行上图的流程。</p><p>那么，这个BKA算法到底要怎么启用呢？</p><p>如果要使用BKA优化算法的话，你需要在执行SQL语句之前，先设置</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>set</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>optimizer_switch</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#4e9a06>&#39;mrr=on,mrr_cost_based=off,batched_key_access=on&#39;</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><p>其中，前两个参数的作用是要启用MRR。这么做的原因是，BKA算法的优化要依赖于MRR。</p><h1 id=bnl算法的性能问题>BNL算法的性能问题</h1><p>说完了NLJ算法的优化，我们再来看BNL算法的优化。</p><p>我在上一篇文章末尾，给你留下的思考题是，使用Block Nested-Loop Join(BNL)算法时，可能会对被驱动表做多次扫描。如果这个被驱动表是一个大的冷数据表，除了会导致IO压力大以外，还会对系统有什么影响呢？</p><p>在第33篇文章中，我们说到InnoDB的LRU算法的时候提到，由于InnoDB对Bufffer Pool的LRU算法做了优化，即：第一次从磁盘读入内存的数据页，会先放在old区域。如果1秒之后这个数据页不再被访问了，就不会被移动到LRU链表头部，这样对Buffer Pool的命中率影响就不大。</p><p>但是，如果一个使用BNL算法的join语句，多次扫描一个冷表，而且这个语句执行时间超过1秒，就会在再次扫描冷表的时候，把冷表的数据页移到LRU链表头部。</p><p>这种情况对应的，是冷表的数据量小于整个Buffer Pool的3/8，能够完全放入old区域的情况。</p><p>如果这个冷表很大，就会出现另外一种情况：业务正常访问的数据页，没有机会进入young区域。</p><p>由于优化机制的存在，一个正常访问的数据页，要进入young区域，需要隔1秒后再次被访问到。但是，由于我们的join语句在循环读磁盘和淘汰内存页，进入old区域的数据页，很可能在1秒之内就被淘汰了。这样，就会导致这个MySQL实例的Buffer Pool在这段时间内，young区域的数据页没有被合理地淘汰。</p><p>也就是说，这两种情况都会影响Buffer Pool的正常运作。</p><p><strong>大表join操作虽然对IO有影响，但是在语句执行结束后，对IO的影响也就结束了。但是，对Buffer Pool的影响就是持续性的，需要依靠后续的查询请求慢慢恢复内存命中率。</strong></p><p>为了减少这种影响，你可以考虑增大join_buffer_size的值，减少对被驱动表的扫描次数。</p><p>也就是说，BNL算法对系统的影响主要包括三个方面：</p><ol><li>可能会多次扫描被驱动表，占用磁盘IO资源；</li><li>判断join条件需要执行M*N次对比（M、N分别是两张表的行数），如果是大表就会占用非常多的CPU资源；</li><li>可能会导致Buffer Pool的热数据被淘汰，影响内存命中率。</li></ol><p>我们执行语句之前，需要通过理论分析和查看explain结果的方式，确认是否要使用BNL算法。如果确认优化器会使用BNL算法，就需要做优化。优化的常见做法是，给被驱动表的join字段加上索引，把BNL算法转成BKA算法。</p><p>接下来，我们就具体看看，这个优化怎么做？</p><h2 id=bnl转bka>BNL转BKA</h2><p>一些情况下，我们可以直接在被驱动表上建索引，这时就可以直接转成BKA算法了。</p><p>但是，有时候你确实会碰到一些不适合在被驱动表上建索引的情况。比如下面这个语句：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>select</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>*</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>from</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>t1</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>join</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>t2</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>on</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>(</span><span style=color:#000>t1</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>b</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#000>t2</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>b</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>where</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>t2</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>b</span><span style=color:#ce5c00;font-weight:700>&gt;=</span><span style=color:#0000cf;font-weight:700>1</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>and</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>t2</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>b</span><span style=color:#ce5c00;font-weight:700>&lt;=</span><span style=color:#0000cf;font-weight:700>2000</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><p>我们在文章开始的时候，在表t2中插入了100万行数据，但是经过where条件过滤后，需要参与join的只有2000行数据。如果这条语句同时是一个低频的SQL语句，那么再为这个语句在表t2的字段b上创建一个索引就很浪费了。</p><p>但是，如果使用BNL算法来join的话，这个语句的执行流程是这样的：</p><ol><li>把表t1的所有字段取出来，存入join_buffer中。这个表只有1000行，join_buffer_size默认值是256k，可以完全存入。</li><li>扫描表t2，取出每一行数据跟join_buffer中的数据进行对比，<ul><li>如果不满足t1.b=t2.b，则跳过；</li><li>如果满足t1.b=t2.b, 再判断其他条件，也就是是否满足t2.b处于[1,2000]的条件，如果是，就作为结果集的一部分返回，否则跳过。</li></ul></li></ol><p>我在上一篇文章中说过，对于表t2的每一行，判断join是否满足的时候，都需要遍历join_buffer中的所有行。因此判断等值条件的次数是1000*100万=10亿次，这个判断的工作量很大。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211117221332.png style=display:block;width:80% alt=NAME align=center></div><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211117221348.png style=display:block;width:80% alt=NAME align=center></div><p>可以看到，explain结果里Extra字段显示使用了BNL算法。在我的测试环境里，这条语句需要执行1分11秒。</p><p>在表t2的字段b上创建索引会浪费资源，但是不创建索引的话这个语句的等值条件要判断10亿次，想想也是浪费。那么，有没有两全其美的办法呢？</p><p>这时候，我们可以考虑使用临时表。使用临时表的大致思路是：</p><ol><li>把表t2中满足条件的数据放在临时表tmp_t中；</li><li>为了让join使用BKA算法，给临时表tmp_t的字段b加上索引；</li><li>让表t1和tmp_t做join操作。</li></ol><p>此时，对应的SQL语句的写法如下：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>create</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>temporary</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>table</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>temp_t</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>id</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87>int</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>primary</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>key</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>a</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87>int</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>b</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87>int</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>index</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>b</span><span style=color:#000;font-weight:700>))</span><span style=color:#000>engine</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#000>innodb</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>insert</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>into</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>temp_t</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>select</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>*</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>from</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>t2</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>where</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>b</span><span style=color:#ce5c00;font-weight:700>&gt;=</span><span style=color:#0000cf;font-weight:700>1</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>and</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>b</span><span style=color:#ce5c00;font-weight:700>&lt;=</span><span style=color:#0000cf;font-weight:700>2000</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>select</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>*</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>from</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>t1</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>join</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>temp_t</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>on</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>(</span><span style=color:#000>t1</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>b</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#000>temp_t</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>b</span><span style=color:#000;font-weight:700>);</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><p>图8就是这个语句序列的执行效果。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211117221359.png style=display:block;width:80% alt=NAME align=center></div><p>可以看到，整个过程3个语句执行时间的总和还不到1秒，相比于前面的1分11秒，性能得到了大幅提升。接下来，我们一起看一下这个过程的消耗：</p><ol><li>执行insert语句构造temp_t表并插入数据的过程中，对表t2做了全表扫描，这里扫描行数是100万。</li><li>之后的join语句，扫描表t1，这里的扫描行数是1000；join比较过程中，做了1000次带索引的查询。相比于优化前的join语句需要做10亿次条件判断来说，这个优化效果还是很明显的。</li></ol><p>总体来看，不论是在原表上加索引，还是用有索引的临时表，我们的思路都是让join语句能够用上被驱动表上的索引，来触发BKA算法，提升查询性能。</p><h2 id=扩展-hash-join>扩展-hash join</h2><p>看到这里你可能发现了，其实上面计算10亿次那个操作，看上去有点儿傻。如果join_buffer里面维护的不是一个无序数组，而是一个哈希表的话，那么就不是10亿次判断，而是100万次hash查找。这样的话，整条语句的执行速度就快多了吧？</p><p>确实如此。</p><p>这，也正是MySQL的优化器和执行器一直被诟病的一个原因：不支持哈希join。并且，MySQL官方的roadmap，也是迟迟没有把这个优化排上议程。</p><p>实际上，这个优化思路，我们可以自己实现在业务端。实现流程大致如下：</p><ol><li><code>select * from t1;</code>取得表t1的全部1000行数据，在业务端存入一个hash结构，比如C++里的set、PHP的dict这样的数据结构。</li><li><code>select * from t2 where b>=1 and b&lt;=2000;</code> 获取表t2中满足条件的2000行数据。</li><li>把这2000行数据，一行一行地取到业务端，到hash结构的数据表中寻找匹配的数据。满足匹配的条件的这行数据，就作为结果集的一行。</li></ol><p>理论上，这个过程会比临时表方案的执行速度还要快一些。如果你感兴趣的话，可以自己验证一下。</p><h2 id=小结>小结</h2><p>今天，我和你分享了Index Nested-Loop Join（NLJ）和Block Nested-Loop Join（BNL）的优化方法。</p><p>在这些优化方法中：</p><ol><li>BKA优化是MySQL已经内置支持的，建议你默认使用；</li><li>BNL算法效率低，建议你都尽量转成BKA算法。优化的方向就是给被驱动表的关联字段加上索引；</li><li>基于临时表的改进方案，对于能够提前过滤出小数据的join语句来说，效果还是很好的；</li><li>MySQL目前的版本还不支持hash join，但你可以配合应用端自己模拟出来，理论上效果要好于临时表的方案。</li></ol></div><div class=td-content style=page-break-before:always><h1 id=pg-70bbd7d7aa199195163b3e70c1cbb13c>5.36 - CH36-临时表重名</h1><p>在上一篇文章中，我们在优化join查询的时候使用到了临时表。当时，我们是这么用的：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>create</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>temporary</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>table</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>temp_t</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>like</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>t1</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>alter</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>table</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>temp_t</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>add</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>index</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>b</span><span style=color:#000;font-weight:700>);</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>insert</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>into</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>temp_t</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>select</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>*</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>from</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>t2</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>where</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>b</span><span style=color:#ce5c00;font-weight:700>&gt;=</span><span style=color:#0000cf;font-weight:700>1</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>and</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>b</span><span style=color:#ce5c00;font-weight:700>&lt;=</span><span style=color:#0000cf;font-weight:700>2000</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>select</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>*</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>from</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>t1</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>join</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>temp_t</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>on</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>(</span><span style=color:#000>t1</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>b</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#000>temp_t</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>b</span><span style=color:#000;font-weight:700>);</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><p>你可能会有疑问，为什么要用临时表呢？直接用普通表是不是也可以呢？</p><p>今天我们就从这个问题说起：临时表有哪些特征，为什么它适合这个场景？</p><p>这里，我需要先帮你厘清一个容易误解的问题：有的人可能会认为，临时表就是内存表。但是，这两个概念可是完全不同的。</p><ul><li>内存表，指的是使用Memory引擎的表，建表语法是create table … engine=memory。这种表的数据都保存在内存里，系统重启的时候会被清空，但是表结构还在。除了这两个特性看上去比较“奇怪”外，从其他的特征上看，它就是一个正常的表。</li><li>而临时表，可以使用各种引擎类型 。如果是使用InnoDB引擎或者MyISAM引擎的临时表，写数据的时候是写到磁盘上的。当然，临时表也可以使用Memory引擎。</li></ul><p>弄清楚了内存表和临时表的区别以后，我们再来看看临时表有哪些特征。</p><h2 id=临时表的特性>临时表的特性</h2><p>为了便于理解，我们来看下下面这个操作序列：</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211117221510.png style=display:block;width:80% alt=NAME align=center></div><p>可以看到，临时表在使用上有以下几个特点：</p><ol><li>建表语法是create temporary table …。</li><li>一个临时表只能被创建它的session访问，对其他线程不可见。所以，图中session A创建的临时表t，对于session B就是不可见的。</li><li>临时表可以与普通表同名。</li><li>session A内有同名的临时表和普通表的时候，show create语句，以及增删改查语句访问的是临时表。</li><li>show tables命令不显示临时表。</li></ol><p>由于临时表只能被创建它的session访问，所以在这个session结束的时候，会自动删除临时表。也正是由于这个特性，<strong>临时表就特别适合我们文章开头的join优化这种场景</strong>。为什么呢？</p><p>原因主要包括以下两个方面：</p><ol><li>不同session的临时表是可以重名的，如果有多个session同时执行join优化，不需要担心表名重复导致建表失败的问题。</li><li>不需要担心数据删除问题。如果使用普通表，在流程执行过程中客户端发生了异常断开，或者数据库发生异常重启，还需要专门来清理中间过程中生成的数据表。而临时表由于会自动回收，所以不需要这个额外的操作。</li></ol><h2 id=临时表的应用>临时表的应用</h2><p>由于不用担心线程之间的重名冲突，临时表经常会被用在复杂查询的优化过程中。其中，分库分表系统的跨库查询就是一个典型的使用场景。</p><p>一般分库分表的场景，就是要把一个逻辑上的大表分散到不同的数据库实例上。比如。将一个大表ht，按照字段f，拆分成1024个分表，然后分布到32个数据库实例上。如下图所示：</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211117221524.png style=display:block;width:80% alt=NAME align=center></div><p>一般情况下，这种分库分表系统都有一个中间层proxy。不过，也有一些方案会让客户端直接连接数据库，也就是没有proxy这一层。</p><p>在这个架构中，分区key的选择是以“减少跨库和跨表查询”为依据的。如果大部分的语句都会包含f的等值条件，那么就要用f做分区键。这样，在proxy这一层解析完SQL语句以后，就能确定将这条语句路由到哪个分表做查询。</p><p>比如下面这条语句：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>select</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>v</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>from</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>ht</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>where</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>f</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#000>N</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><p>这时，我们就可以通过分表规则（比如，N%1024)来确认需要的数据被放在了哪个分表上。这种语句只需要访问一个分表，是分库分表方案最欢迎的语句形式了。</p><p>但是，如果这个表上还有另外一个索引k，并且查询语句是这样的：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>select</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>v</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>from</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>ht</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>where</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>k</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>&gt;=</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>M</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>order</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>by</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>t_modified</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>desc</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>limit</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#0000cf;font-weight:700>100</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><p>这时候，由于查询条件里面没有用到分区字段f，只能到所有的分区中去查找满足条件的所有行，然后统一做order by 的操作。这种情况下，有两种比较常用的思路。</p><p>**第一种思路是，**在proxy层的进程代码中实现排序。</p><p>这种方式的优势是处理速度快，拿到分库的数据以后，直接在内存中参与计算。不过，这个方案的缺点也比较明显：</p><ol><li>需要的开发工作量比较大。我们举例的这条语句还算是比较简单的，如果涉及到复杂的操作，比如group by，甚至join这样的操作，对中间层的开发能力要求比较高；</li><li>对proxy端的压力比较大，尤其是很容易出现内存不够用和CPU瓶颈的问题。</li></ol><p>**另一种思路就是，**把各个分库拿到的数据，汇总到一个MySQL实例的一个表中，然后在这个汇总实例上做逻辑操作。</p><p>比如上面这条语句，执行流程可以类似这样：</p><ul><li>在汇总库上创建一个临时表temp_ht，表里包含三个字段v、k、t_modified；</li><li>在各个分库上执行</li></ul><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>select</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>v</span><span style=color:#000;font-weight:700>,</span><span style=color:#000>k</span><span style=color:#000;font-weight:700>,</span><span style=color:#000>t_modified</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>from</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>ht_x</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>where</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>k</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>&gt;=</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>M</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>order</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>by</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>t_modified</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>desc</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>limit</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#0000cf;font-weight:700>100</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><ul><li>把分库执行的结果插入到temp_ht表中；</li><li>执行</li></ul><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>select</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>v</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>from</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>temp_ht</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>order</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>by</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>t_modified</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>desc</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>limit</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#0000cf;font-weight:700>100</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline> 
</span></span></span></code></pre></div><p>得到结果。</p><p>这个过程对应的流程图如下所示：</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211117221549.png style=display:block;width:80% alt=NAME align=center></div><p>**在实践中，我们往往会发现每个分库的计算量都不饱和，所以会直接把临时表temp_ht放到32个分库中的某一个上。**这时的查询逻辑与图3类似，你可以自己再思考一下具体的流程。</p><h2 id=为什么临时表可以重名>为什么临时表可以重名？</h2><p>你可能会问，不同线程可以创建同名的临时表，这是怎么做到的呢？</p><p>接下来，我们就看一下这个问题。</p><p>我们在执行</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>create</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>temporary</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>table</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>temp_t</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>id</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87>int</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>primary</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>key</span><span style=color:#000;font-weight:700>)</span><span style=color:#000>engine</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#000>innodb</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><p>这个语句的时候，MySQL要给这个InnoDB表创建一个frm文件保存表结构定义，还要有地方保存表数据。</p><p><strong>这个frm文件放在临时文件目录下，文件名的后缀是.frm，前缀是“#sql{进程id}_{线程id}_序列号”</strong>。你可以使用select @@tmpdir命令，来显示实例的临时文件目录。</p><p>而关于表中数据的存放方式，在不同的MySQL版本中有着不同的处理方式：</p><ul><li>在5.6以及之前的版本里，MySQL会在临时文件目录下创建一个相同前缀、以.ibd为后缀的文件，用来存放数据文件；</li><li>而从 5.7版本开始，MySQL引入了一个临时文件表空间，专门用来存放临时文件的数据。因此，我们就不需要再创建ibd文件了。</li></ul><p>从文件名的前缀规则，我们可以看到，其实创建一个叫作t1的InnoDB临时表，MySQL在存储上认为我们创建的表名跟普通表t1是不同的，因此同一个库下面已经有普通表t1的情况下，还是可以再创建一个临时表t1的。</p><p>为了便于后面讨论，我先来举一个例子。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211117221601.png style=display:block;width:80% alt=NAME align=center></div><p>这个进程的进程号是1234，session A的线程id是4，session B的线程id是5。所以你看到了，session A和session B创建的临时表，在磁盘上的文件不会重名。</p><p>MySQL维护数据表，除了物理上要有文件外，内存里面也有一套机制区别不同的表，每个表都对应一个table_def_key。</p><ul><li>一个普通表的table_def_key的值是由“库名+表名”得到的，所以如果你要在同一个库下创建两个同名的普通表，创建第二个表的过程中就会发现table_def_key已经存在了。</li><li>而对于临时表，table_def_key在“库名+表名”基础上，又加入了“server_id+thread_id”。</li></ul><p>也就是说，session A和sessionB创建的两个临时表t1，它们的table_def_key不同，磁盘文件名也不同，因此可以并存。</p><p>在实现上，每个线程都维护了自己的临时表链表。这样每次session内操作表的时候，先遍历链表，检查是否有这个名字的临时表，如果有就优先操作临时表，如果没有再操作普通表；在session结束的时候，对链表里的每个临时表，执行 “DROP TEMPORARY TABLE +表名”操作。</p><p>这时候你会发现，binlog中也记录了DROP TEMPORARY TABLE这条命令。你一定会觉得奇怪，临时表只在线程内自己可以访问，为什么需要写到binlog里面？</p><p>这，就需要说到主备复制了。</p><h2 id=临时表和主备复制>临时表和主备复制</h2><p>既然写binlog，就意味着备库需要。</p><p>你可以设想一下，在主库上执行下面这个语句序列：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>create</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>table</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>t_normal</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>id</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87>int</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>primary</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>key</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>c</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87>int</span><span style=color:#000;font-weight:700>)</span><span style=color:#000>engine</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#000>innodb</span><span style=color:#000;font-weight:700>;</span><span style=color:#8f5902;font-style:italic>/*Q1*/</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>create</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>temporary</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>table</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>temp_t</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>like</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>t_normal</span><span style=color:#000;font-weight:700>;</span><span style=color:#8f5902;font-style:italic>/*Q2*/</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>insert</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>into</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>temp_t</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>values</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>);</span><span style=color:#8f5902;font-style:italic>/*Q3*/</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>insert</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>into</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>t_normal</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>select</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>*</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>from</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>temp_t</span><span style=color:#000;font-weight:700>;</span><span style=color:#8f5902;font-style:italic>/*Q4*/</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><p>如果关于临时表的操作都不记录，那么在备库就只有create table t_normal表和insert into t_normal select * from temp_t这两个语句的binlog日志，备库在执行到insert into t_normal的时候，就会报错“表temp_t不存在”。</p><p>你可能会说，如果把binlog设置为row格式就好了吧？因为binlog是row格式时，在记录insert into t_normal的binlog时，记录的是这个操作的数据，即：write_row event里面记录的逻辑是“插入一行数据（1,1)”。</p><p>确实是这样。如果当前的binlog_format=row，那么跟临时表有关的语句，就不会记录到binlog里。也就是说，只在binlog_format=statment/mixed 的时候，binlog中才会记录临时表的操作。</p><p>这种情况下，创建临时表的语句会传到备库执行，因此备库的同步线程就会创建这个临时表。主库在线程退出的时候，会自动删除临时表，但是备库同步线程是持续在运行的。所以，这时候我们就需要在主库上再写一个DROP TEMPORARY TABLE传给备库执行。</p><p>**之前有人问过我一个有趣的问题：**MySQL在记录binlog的时候，不论是create table还是alter table语句，都是原样记录，甚至于连空格都不变。但是如果执行drop table t_normal，系统记录binlog就会写成：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>DROP</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>TABLE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>t_normal</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#8f5902;font-style:italic>/* generated by server */</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><p>也就是改成了标准的格式。为什么要这么做呢 ？</p><p>现在你知道原因了，那就是：drop table命令是可以一次删除多个表的。比如，在上面的例子中，设置binlog_format=row，如果主库上执行 &ldquo;drop table t_normal, temp_t"这个命令，那么binlog中就只能记录：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>DROP</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>TABLE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>t_normal</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#8f5902;font-style:italic>/* generated by server */</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><p>因为备库上并没有表temp_t，将这个命令重写后再传到备库执行，才不会导致备库同步线程停止。</p><p>所以，drop table命令记录binlog的时候，就必须对语句做改写。“/* generated by server */”说明了这是一个被服务端改写过的命令。</p><p>说到主备复制，<strong>还有另外一个问题需要解决</strong>：主库上不同的线程创建同名的临时表是没关系的，但是传到备库执行是怎么处理的呢？</p><p>现在，我给你举个例子，下面的序列中实例S是M的备库。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211117221621.png style=display:block;width:80% alt=NAME align=center></div><p>主库M上的两个session创建了同名的临时表t1，这两个create temporary table t1 语句都会被传到备库S上。</p><p>但是，备库的应用日志线程是共用的，也就是说要在应用线程里面先后执行这个create 语句两次。（即使开了多线程复制，也可能被分配到从库的同一个worker中执行）。那么，这会不会导致同步线程报错 ？</p><p>显然是不会的，否则临时表就是一个bug了。也就是说，备库线程在执行的时候，要把这两个t1表当做两个不同的临时表来处理。这，又是怎么实现的呢？</p><p>MySQL在记录binlog的时候，会把主库执行这个语句的线程id写到binlog中。这样，在备库的应用线程就能够知道执行每个语句的主库线程id，并利用这个线程id来构造临时表的table_def_key：</p><ol><li>session A的临时表t1，在备库的table_def_key就是：库名+t1+“M的serverid”+“session A的thread_id”;</li><li>session B的临时表t1，在备库的table_def_key就是 ：库名+t1+“M的serverid”+“session B的thread_id”。</li></ol><p>由于table_def_key不同，所以这两个表在备库的应用线程里面是不会冲突的。</p><h2 id=小结>小结</h2><p>今天这篇文章，我和你介绍了临时表的用法和特性。</p><p>在实际应用中，临时表一般用于处理比较复杂的计算逻辑。由于临时表是每个线程自己可见的，所以不需要考虑多个线程执行同一个处理逻辑时，临时表的重名问题。在线程退出的时候，临时表也能自动删除，省去了收尾和异常处理的工作。</p><p>在binlog_format=&lsquo;row’的时候，临时表的操作不记录到binlog中，也省去了不少麻烦，这也可以成为你选择binlog_format时的一个考虑因素。</p><p>需要注意的是，我们上面说到的这种临时表，是用户自己创建的 ，也可以称为用户临时表。与它相对应的，就是内部临时表，在第17篇文章中我已经和你介绍过。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-a61074124cee621204f12f3145ff7887>5.37 - CH37-内部临时表</h1><p>在第16和第34篇文章中，我分别和你介绍了sort buffer、内存临时表和join buffer。这三个数据结构都是用来存放语句执行过程中的中间数据，以辅助SQL语句的执行的。其中，我们在排序的时候用到了sort buffer，在使用join语句的时候用到了join buffer。</p><p>然后，你可能会有这样的疑问，MySQL什么时候会使用内部临时表呢？</p><p>今天这篇文章，我就先给你举两个需要用到内部临时表的例子，来看看内部临时表是怎么工作的。然后，我们再来分析，什么情况下会使用内部临时表。</p><h2 id=union-执行流程>union 执行流程</h2><p>为了便于量化分析，我用下面的表t1来举例。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>create</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>table</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>t1</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>id</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87>int</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>primary</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>key</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>a</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87>int</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>b</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87>int</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>index</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>a</span><span style=color:#000;font-weight:700>));</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>delimiter</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>;;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>create</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>procedure</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>idata</span><span style=color:#000;font-weight:700>()</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>begin</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>declare</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>i</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87>int</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>set</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>i</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#000>while</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>i</span><span style=color:#ce5c00;font-weight:700>&lt;=</span><span style=color:#0000cf;font-weight:700>1000</span><span style=color:#000;font-weight:700>)</span><span style=color:#204a87;font-weight:700>do</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>insert</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>into</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>t1</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>values</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>i</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>i</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>i</span><span style=color:#000;font-weight:700>);</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>set</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>i</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#000>i</span><span style=color:#ce5c00;font-weight:700>+</span><span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>end</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>while</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>end</span><span style=color:#000;font-weight:700>;;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>delimiter</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>call</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>idata</span><span style=color:#000;font-weight:700>();</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><p>然后，我们执行下面这条语句：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#000;font-weight:700>(</span><span style=color:#204a87;font-weight:700>select</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#0000cf;font-weight:700>1000</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>as</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>f</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>union</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>(</span><span style=color:#204a87;font-weight:700>select</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>id</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>from</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>t1</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>order</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>by</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>id</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>desc</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>limit</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#0000cf;font-weight:700>2</span><span style=color:#000;font-weight:700>);</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><p>这条语句用到了union，它的语义是，取这两个子查询结果的并集。并集的意思就是这两个集合加起来，重复的行只保留一行。</p><p>下图是这个语句的explain结果。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211117221732.png style=display:block;width:80% alt=NAME align=center></div><p>可以看到：</p><ul><li>第二行的key=PRIMARY，说明第二个子句用到了索引id。</li><li>第三行的Extra字段，表示在对子查询的结果集做union的时候，使用了临时表(Using temporary)。</li></ul><p>这个语句的执行流程是这样的：</p><ol><li><p>创建一个内存临时表，这个临时表只有一个整型字段f，并且f是主键字段。</p></li><li><p>执行第一个子查询，得到1000这个值，并存入临时表中。</p></li><li><p>执行第二个子查询：</p><ol><li>拿到第一行id=1000，试图插入临时表中。但由于1000这个值已经存在于临时表了，违反了唯一性约束，所以插入失败，然后继续执行；</li><li>取到第二行id=999，插入临时表成功。</li></ol></li><li><p>从临时表中按行取出数据，返回结果，并删除临时表，结果中包含两行数据分别是1000和999。</p></li></ol><p>这个过程的流程图如下所示：</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211117221745.png style=display:block;width:80% alt=NAME align=center></div><p>可以看到，这里的内存临时表起到了暂存数据的作用，而且计算过程还用上了临时表主键id的唯一性约束，实现了union的语义。</p><p>顺便提一下，如果把上面这个语句中的union改成union all的话，就没有了“去重”的语义。这样执行的时候，就依次执行子查询，得到的结果直接作为结果集的一部分，发给客户端。因此也就不需要临时表了。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211117221801.png style=display:block;width:80% alt=NAME align=center></div><p>可以看到，第二行的Extra字段显示的是Using index，表示只使用了覆盖索引，没有用临时表了。</p><h2 id=group-by-执行流程>group by 执行流程</h2><p>另外一个常见的使用临时表的例子是group by，我们来看一下这个语句：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>select</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>id</span><span style=color:#ce5c00;font-weight:700>%</span><span style=color:#0000cf;font-weight:700>10</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>as</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>m</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>count</span><span style=color:#000;font-weight:700>(</span><span style=color:#ce5c00;font-weight:700>*</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>as</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>c</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>from</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>t1</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>group</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>by</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>m</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><p>这个语句的逻辑是把表t1里的数据，按照 id%10 进行分组统计，并按照m的结果排序后输出。它的explain结果如下：</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211117221814.png style=display:block;width:80% alt=NAME align=center></div><p>在Extra字段里面，我们可以看到三个信息：</p><ul><li>Using index，表示这个语句使用了覆盖索引，选择了索引a，不需要回表；</li><li>Using temporary，表示使用了临时表；</li><li>Using filesort，表示需要排序。</li></ul><p>这个语句的执行流程是这样的：</p><ol><li><p>创建内存临时表，表里有两个字段m和c，主键是m；</p></li><li><p>扫描表t1的索引a，依次取出叶子节点上的id值，计算id%10的结果，记为x；</p><ol><li>如果临时表中没有主键为x的行，就插入一个记录(x,1);</li><li>如果表中有主键为x的行，就将x这一行的c值加1；</li></ol></li><li><p>遍历完成后，再根据字段m做排序，得到结果集返回给客户端。</p></li></ol><p>这个流程的执行图如下：</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211117221828.png style=display:block;width:80% alt=NAME align=center></div><p>图中最后一步，对内存临时表的排序，在第17篇文章中已经有过介绍，我把图贴过来，方便你回顾。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211117221840.png style=display:block;width:80% alt=NAME align=center></div><p>其中，临时表的排序过程就是图6中虚线框内的过程。</p><p>接下来，我们再看一下这条语句的执行结果：</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211117221852.png style=display:block;width:80% alt=NAME align=center></div><p>如果你的需求并不需要对结果进行排序，那你可以在SQL语句末尾增加order by null，也就是改成：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>select</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>id</span><span style=color:#ce5c00;font-weight:700>%</span><span style=color:#0000cf;font-weight:700>10</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>as</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>m</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>count</span><span style=color:#000;font-weight:700>(</span><span style=color:#ce5c00;font-weight:700>*</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>as</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>c</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>from</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>t1</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>group</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>by</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>m</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>order</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>by</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>null</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><p>这样就跳过了最后排序的阶段，直接从临时表中取数据返回。返回的结果如图8所示。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211117221902.png style=display:block;width:80% alt=NAME align=center></div><p>由于表t1中的id值是从1开始的，因此返回的结果集中第一行是id=1；扫描到id=10的时候才插入m=0这一行，因此结果集里最后一行才是m=0。</p><p>这个例子里由于临时表只有10行，内存可以放得下，因此全程只使用了内存临时表。但是，内存临时表的大小是有限制的，参数tmp_table_size就是控制这个内存大小的，默认是16M。</p><p>如果我执行下面这个语句序列：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>set</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>tmp_table_size</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#0000cf;font-weight:700>1024</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>select</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>id</span><span style=color:#ce5c00;font-weight:700>%</span><span style=color:#0000cf;font-weight:700>100</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>as</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>m</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>count</span><span style=color:#000;font-weight:700>(</span><span style=color:#ce5c00;font-weight:700>*</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>as</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>c</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>from</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>t1</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>group</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>by</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>m</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>order</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>by</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>null</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>limit</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#0000cf;font-weight:700>10</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><p>把内存临时表的大小限制为最大1024字节，并把语句改成id % 100，这样返回结果里有100行数据。但是，这时的内存临时表大小不够存下这100行数据，也就是说，执行过程中会发现内存临时表大小到达了上限（1024字节）。</p><p>那么，这时候就会把内存临时表转成磁盘临时表，磁盘临时表默认使用的引擎是InnoDB。 这时，返回的结果如图9所示。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211117221915.png style=display:block;width:80% alt=NAME align=center></div><p>如果这个表t1的数据量很大，很可能这个查询需要的磁盘临时表就会占用大量的磁盘空间。</p><h2 id=group-by-优化方法---索引>group by 优化方法 &ndash;索引</h2><p>可以看到，不论是使用内存临时表还是磁盘临时表，group by逻辑都需要构造一个带唯一索引的表，执行代价都是比较高的。如果表的数据量比较大，上面这个group by语句执行起来就会很慢，我们有什么优化的方法呢？</p><p>要解决group by语句的优化问题，你可以先想一下这个问题：执行group by语句为什么需要临时表？</p><p>group by的语义逻辑，是统计不同的值出现的个数。但是，由于每一行的id%100的结果是无序的，所以我们就需要有一个临时表，来记录并统计结果。</p><p>那么，如果扫描过程中可以保证出现的数据是有序的，是不是就简单了呢？</p><p>假设，现在有一个类似图10的这么一个数据结构，我们来看看group by可以怎么做。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211117221930.png style=display:block;width:80% alt=NAME align=center></div><p>可以看到，如果可以确保输入的数据是有序的，那么计算group by的时候，就只需要从左到右，顺序扫描，依次累加。也就是下面这个过程：</p><ul><li>当碰到第一个1的时候，已经知道累积了X个0，结果集里的第一行就是(0,X);</li><li>当碰到第一个2的时候，已经知道累积了Y个1，结果集里的第二行就是(1,Y);</li></ul><p>按照这个逻辑执行的话，扫描到整个输入的数据结束，就可以拿到group by的结果，不需要临时表，也不需要再额外排序。</p><p>你一定想到了，InnoDB的索引，就可以满足这个输入有序的条件。</p><p>在MySQL 5.7版本支持了generated column机制，用来实现列数据的关联更新。你可以用下面的方法创建一个列z，然后在z列上创建一个索引（如果是MySQL 5.6及之前的版本，你也可以创建普通列和索引，来解决这个问题）。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>alter</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>table</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>t1</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>add</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>column</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>z</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87>int</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>generated</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>always</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>as</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>id</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>%</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#0000cf;font-weight:700>100</span><span style=color:#000;font-weight:700>),</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>add</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>index</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>z</span><span style=color:#000;font-weight:700>);</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><p>这样，索引z上的数据就是类似图10这样有序的了。上面的group by语句就可以改成：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>select</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>z</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>count</span><span style=color:#000;font-weight:700>(</span><span style=color:#ce5c00;font-weight:700>*</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>as</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>c</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>from</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>t1</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>group</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>by</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>z</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><p>优化后的group by语句的explain结果，如下图所示：</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211117221943.png style=display:block;width:80% alt=NAME align=center></div><p>从Extra字段可以看到，这个语句的执行不再需要临时表，也不需要排序了。</p><h2 id=group-by优化方法---直接排序>group by优化方法 &ndash;直接排序</h2><p>所以，如果可以通过加索引来完成group by逻辑就再好不过了。但是，如果碰上不适合创建索引的场景，我们还是要老老实实做排序的。那么，这时候的group by要怎么优化呢？</p><p>如果我们明明知道，一个group by语句中需要放到临时表上的数据量特别大，却还是要按照“先放到内存临时表，插入一部分数据后，发现内存临时表不够用了再转成磁盘临时表”，看上去就有点儿傻。</p><p>那么，我们就会想了，MySQL有没有让我们直接走磁盘临时表的方法呢？</p><p>答案是，有的。</p><p>在group by语句中加入SQL_BIG_RESULT这个提示（hint），就可以告诉优化器：这个语句涉及的数据量很大，请直接用磁盘临时表。</p><p>MySQL的优化器一看，磁盘临时表是B+树存储，存储效率不如数组来得高。所以，既然你告诉我数据量很大，那从磁盘空间考虑，还是直接用数组来存吧。</p><p>因此，下面这个语句</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>select</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>SQL_BIG_RESULT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>id</span><span style=color:#ce5c00;font-weight:700>%</span><span style=color:#0000cf;font-weight:700>100</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>as</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>m</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>count</span><span style=color:#000;font-weight:700>(</span><span style=color:#ce5c00;font-weight:700>*</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>as</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>c</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>from</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>t1</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>group</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>by</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>m</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><p>的执行流程就是这样的：</p><ol><li>初始化sort_buffer，确定放入一个整型字段，记为m；</li><li>扫描表t1的索引a，依次取出里面的id值, 将 id%100的值存入sort_buffer中；</li><li>扫描完成后，对sort_buffer的字段m做排序（如果sort_buffer内存不够用，就会利用磁盘临时文件辅助排序）；</li><li>排序完成后，就得到了一个有序数组。</li></ol><p>根据有序数组，得到数组里面的不同值，以及每个值的出现次数。这一步的逻辑，你已经从前面的图10中了解过了。</p><p>下面两张图分别是执行流程图和执行explain命令得到的结果。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211117221958.png style=display:block;width:80% alt=NAME align=center></div><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211117222007.png style=display:block;width:80% alt=NAME align=center></div><p>从Extra字段可以看到，这个语句的执行没有再使用临时表，而是直接用了排序算法。</p><p>基于上面的union、union all和group by语句的执行过程的分析，我们来回答文章开头的问题：MySQL什么时候会使用内部临时表？</p><ol><li>如果语句执行过程可以一边读数据，一边直接得到结果，是不需要额外内存的，否则就需要额外的内存，来保存中间结果；</li><li>join_buffer是无序数组，sort_buffer是有序数组，临时表是二维表结构；</li><li>如果执行逻辑需要用到二维表特性，就会优先考虑使用临时表。比如我们的例子中，union需要用到唯一索引约束， group by还需要用到另外一个字段来存累积计数。</li></ol><h2 id=小结>小结</h2><p>通过今天这篇文章，我重点和你讲了group by的几种实现算法，从中可以总结一些使用的指导原则：</p><p>如果对group by语句的结果没有排序要求，要在语句后面加 order by null；</p><p>尽量让group by过程用上表的索引，确认方法是explain结果里没有Using temporary 和 Using filesort；</p><p>如果group by需要统计的数据量不大，尽量只使用内存临时表；也可以通过适当调大tmp_table_size参数，来避免用到磁盘临时表；</p><p>如果数据量实在太大，使用SQL_BIG_RESULT这个提示，来告诉优化器直接使用排序算法得到group by的结果。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-9bdb84907c295c993aefeec8cdf5f549>5.38 - CH38-Memory 引擎</h1><p>我在上一篇文章末尾留给你的问题是：两个group by 语句都用了order by null，为什么使用内存临时表得到的语句结果里，0这个值在最后一行；而使用磁盘临时表得到的结果里，0这个值在第一行？</p><p>今天我们就来看看，出现这个问题的原因吧。</p><h2 id=内存表的数据组织结构>内存表的数据组织结构</h2><p>为了便于分析，我来把这个问题简化一下，假设有以下的两张表t1 和 t2，其中表t1使用Memory 引擎， 表t2使用InnoDB引擎。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>create</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>table</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>t1</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>id</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87>int</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>primary</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>key</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>c</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87>int</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>engine</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#000>Memory</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>create</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>table</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>t2</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>id</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87>int</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>primary</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>key</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>c</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87>int</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>engine</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#000>innodb</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>insert</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>into</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>t1</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>values</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>),(</span><span style=color:#0000cf;font-weight:700>2</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>2</span><span style=color:#000;font-weight:700>),(</span><span style=color:#0000cf;font-weight:700>3</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>3</span><span style=color:#000;font-weight:700>),(</span><span style=color:#0000cf;font-weight:700>4</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>4</span><span style=color:#000;font-weight:700>),(</span><span style=color:#0000cf;font-weight:700>5</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>5</span><span style=color:#000;font-weight:700>),(</span><span style=color:#0000cf;font-weight:700>6</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>6</span><span style=color:#000;font-weight:700>),(</span><span style=color:#0000cf;font-weight:700>7</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>7</span><span style=color:#000;font-weight:700>),(</span><span style=color:#0000cf;font-weight:700>8</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>8</span><span style=color:#000;font-weight:700>),(</span><span style=color:#0000cf;font-weight:700>9</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>9</span><span style=color:#000;font-weight:700>),(</span><span style=color:#0000cf;font-weight:700>0</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>0</span><span style=color:#000;font-weight:700>);</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>insert</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>into</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>t2</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>values</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>),(</span><span style=color:#0000cf;font-weight:700>2</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>2</span><span style=color:#000;font-weight:700>),(</span><span style=color:#0000cf;font-weight:700>3</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>3</span><span style=color:#000;font-weight:700>),(</span><span style=color:#0000cf;font-weight:700>4</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>4</span><span style=color:#000;font-weight:700>),(</span><span style=color:#0000cf;font-weight:700>5</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>5</span><span style=color:#000;font-weight:700>),(</span><span style=color:#0000cf;font-weight:700>6</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>6</span><span style=color:#000;font-weight:700>),(</span><span style=color:#0000cf;font-weight:700>7</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>7</span><span style=color:#000;font-weight:700>),(</span><span style=color:#0000cf;font-weight:700>8</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>8</span><span style=color:#000;font-weight:700>),(</span><span style=color:#0000cf;font-weight:700>9</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>9</span><span style=color:#000;font-weight:700>),(</span><span style=color:#0000cf;font-weight:700>0</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>0</span><span style=color:#000;font-weight:700>);</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><p>然后，我分别执行select * from t1和select * from t2。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211117222632.png style=display:block;width:80% alt=NAME align=center></div><p>可以看到，内存表t1的返回结果里面0在最后一行，而InnoDB表t2的返回结果里0在第一行。</p><p>出现这个区别的原因，要从这两个引擎的主键索引的组织方式说起。</p><p>表t2用的是InnoDB引擎，它的主键索引id的组织方式，你已经很熟悉了：InnoDB表的数据就放在主键索引树上，主键索引是B+树。所以表t2的数据组织方式如下图所示：</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211117222642.png style=display:block;width:80% alt=NAME align=center></div><p>主键索引上的值是有序存储的。在执行select *的时候，就会按照叶子节点从左到右扫描，所以得到的结果里，0就出现在第一行。</p><p>与InnoDB引擎不同，Memory引擎的数据和索引是分开的。我们来看一下表t1中的数据内容。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211117222654.png style=display:block;width:80% alt=NAME align=center></div><p>可以看到，内存表的数据部分以数组的方式单独存放，而主键id索引里，存的是每个数据的位置。主键id是hash索引，可以看到索引上的key并不是有序的。</p><p>在内存表t1中，当我执行select *的时候，走的是全表扫描，也就是顺序扫描这个数组。因此，0就是最后一个被读到，并放入结果集的数据。</p><p>可见，InnoDB和Memory引擎的数据组织方式是不同的：</p><ul><li>InnoDB引擎把数据放在主键索引上，其他索引上保存的是主键id。这种方式，我们称之为<strong>索引组织表</strong>（Index Organizied Table）。</li><li>而Memory引擎采用的是把数据单独存放，索引上保存数据位置的数据组织形式，我们称之为<strong>堆组织表</strong>（Heap Organizied Table）。</li></ul><p>从中我们可以看出，这两个引擎的一些典型不同：</p><ol><li>InnoDB表的数据总是有序存放的，而内存表的数据就是按照写入顺序存放的；</li><li>当数据文件有空洞的时候，InnoDB表在插入新数据的时候，为了保证数据有序性，只能在固定的位置写入新值，而内存表找到空位就可以插入新值；</li><li>数据位置发生变化的时候，InnoDB表只需要修改主键索引，而内存表需要修改所有索引；</li><li>InnoDB表用主键索引查询时需要走一次索引查找，用普通索引查询的时候，需要走两次索引查找。而内存表没有这个区别，所有索引的“地位”都是相同的。</li><li>InnoDB支持变长数据类型，不同记录的长度可能不同；内存表不支持Blob 和 Text字段，并且即使定义了varchar(N)，实际也当作char(N)，也就是固定长度字符串来存储，因此内存表的每行数据长度相同。</li></ol><p>由于内存表的这些特性，每个数据行被删除以后，空出的这个位置都可以被接下来要插入的数据复用。比如，如果要在表t1中执行：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>delete</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>from</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>t1</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>where</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>id</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#0000cf;font-weight:700>5</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>insert</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>into</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>t1</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>values</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>10</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>10</span><span style=color:#000;font-weight:700>);</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>select</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>*</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>from</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>t1</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><p>就会看到返回结果里，id=10这一行出现在id=4之后，也就是原来id=5这行数据的位置。</p><p>需要指出的是，表t1的这个主键索引是哈希索引，因此如果执行范围查询，比如</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>select</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>*</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>from</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>t1</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>where</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>id</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>5</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><p>是用不上主键索引的，需要走全表扫描。你可以借此再回顾下第4篇文章的内容。那如果要让内存表支持范围扫描，应该怎么办呢 ？</p><h2 id=hash索引和b-tree索引>hash索引和B-Tree索引</h2><p>实际上，内存表也是支B-Tree索引的。在id列上创建一个B-Tree索引，SQL语句可以这么写：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>alter</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>table</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>t1</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>add</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>index</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>a_btree_index</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>using</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>btree</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>(</span><span style=color:#000>id</span><span style=color:#000;font-weight:700>);</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><p>这时，表t1的数据组织形式就变成了这样：</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211117222736.png style=display:block;width:80% alt=NAME align=center></div><p>新增的这个B-Tree索引你看着就眼熟了，这跟InnoDB的b+树索引组织形式类似。</p><p>作为对比，你可以看一下这下面这两个语句的输出：</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211117222752.png style=display:block;width:80% alt=NAME align=center></div><p>可以看到，执行select * from t1 where id&lt;5的时候，优化器会选择B-Tree索引，所以返回结果是0到4。 使用force index强行使用主键id这个索引，id=0这一行就在结果集的最末尾了。</p><p>其实，一般在我们的印象中，内存表的优势是速度快，其中的一个原因就是Memory引擎支持hash索引。当然，更重要的原因是，内存表的所有数据都保存在内存，而内存的读写速度总是比磁盘快。</p><p>但是，接下来我要跟你说明，为什么我不建议你在生产环境上使用内存表。这里的原因主要包括两个方面：</p><ol><li>锁粒度问题；</li><li>数据持久化问题。</li></ol><h2 id=内存表的锁>内存表的锁</h2><p>我们先来说说内存表的锁粒度问题。</p><p>内存表不支持行锁，只支持表锁。因此，一张表只要有更新，就会堵住其他所有在这个表上的读写操作。</p><p>需要注意的是，这里的表锁跟之前我们介绍过的MDL锁不同，但都是表级的锁。接下来，我通过下面这个场景，跟你模拟一下内存表的表级锁。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211117222807.png style=display:block;width:80% alt=NAME align=center></div><p>在这个执行序列里，session A的update语句要执行50秒，在这个语句执行期间session B的查询会进入锁等待状态。session C的show processlist 结果输出如下：</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211117222818.png style=display:block;width:80% alt=NAME align=center></div><p>跟行锁比起来，表锁对并发访问的支持不够好。所以，内存表的锁粒度问题，决定了它在处理并发事务的时候，性能也不会太好。</p><h2 id=数据持久性问题>数据持久性问题</h2><p>接下来，我们再看看数据持久性的问题。</p><p>数据放在内存中，是内存表的优势，但也是一个劣势。因为，数据库重启的时候，所有的内存表都会被清空。</p><p>你可能会说，如果数据库异常重启，内存表被清空也就清空了，不会有什么问题啊。但是，在高可用架构下，内存表的这个特点简直可以当做bug来看待了。为什么这么说呢？</p><p><strong>我们先看看M-S架构下，使用内存表存在的问题。</strong></p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211117222832.png style=display:block;width:80% alt=NAME align=center></div><p>我们来看一下下面这个时序：</p><ol><li>业务正常访问主库；</li><li>备库硬件升级，备库重启，内存表t1内容被清空；</li><li>备库重启后，客户端发送一条update语句，修改表t1的数据行，这时备库应用线程就会报错“找不到要更新的行”。</li></ol><p>这样就会导致主备同步停止。当然，如果这时候发生主备切换的话，客户端会看到，表t1的数据“丢失”了。</p><p>在图8中这种有proxy的架构里，大家默认主备切换的逻辑是由数据库系统自己维护的。这样对客户端来说，就是“网络断开，重连之后，发现内存表数据丢失了”。</p><p>你可能说这还好啊，毕竟主备发生切换，连接会断开，业务端能够感知到异常。</p><p>但是，接下来内存表的这个特性就会让使用现象显得更“诡异”了。由于MySQL知道重启之后，内存表的数据会丢失。所以，担心主库重启之后，出现主备不一致，MySQL在实现上做了这样一件事儿：在数据库重启之后，往binlog里面写入一行DELETE FROM t1。</p><p><strong>如果你使用是如图9所示的双M结构的话：</strong></p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211117222847.png style=display:block;width:80% alt=NAME align=center></div><p>在备库重启的时候，备库binlog里的delete语句就会传到主库，然后把主库内存表的内容删除。这样你在使用的时候就会发现，主库的内存表数据突然被清空了。</p><p>基于上面的分析，你可以看到，内存表并不适合在生产环境上作为普通数据表使用。</p><p>有同学会说，但是内存表执行速度快呀。这个问题，其实你可以这么分析：</p><ol><li>如果你的表更新量大，那么并发度是一个很重要的参考指标，InnoDB支持行锁，并发度比内存表好；</li><li>能放到内存表的数据量都不大。如果你考虑的是读的性能，一个读QPS很高并且数据量不大的表，即使是使用InnoDB，数据也是都会缓存在InnoDB Buffer Pool里的。因此，使用InnoDB表的读性能也不会差。</li></ol><p>所以，**我建议你把普通内存表都用InnoDB表来代替。**但是，有一个场景却是例外的。</p><p>这个场景就是，我们在第35和36篇说到的用户临时表。在数据量可控，不会耗费过多内存的情况下，你可以考虑使用内存表。</p><p>内存临时表刚好可以无视内存表的两个不足，主要是下面的三个原因：</p><ol><li>临时表不会被其他线程访问，没有并发性的问题；</li><li>临时表重启后也是需要删除的，清空数据这个问题不存在；</li><li>备库的临时表也不会影响主库的用户线程。</li></ol><p>现在，我们回过头再看一下第35篇join语句优化的例子，当时我建议的是创建一个InnoDB临时表，使用的语句序列是：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>create</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>temporary</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>table</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>temp_t</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>id</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87>int</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>primary</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>key</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>a</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87>int</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>b</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87>int</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>index</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>b</span><span style=color:#000;font-weight:700>))</span><span style=color:#000>engine</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#000>innodb</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>insert</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>into</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>temp_t</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>select</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>*</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>from</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>t2</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>where</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>b</span><span style=color:#ce5c00;font-weight:700>&gt;=</span><span style=color:#0000cf;font-weight:700>1</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>and</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>b</span><span style=color:#ce5c00;font-weight:700>&lt;=</span><span style=color:#0000cf;font-weight:700>2000</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>select</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>*</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>from</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>t1</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>join</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>temp_t</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>on</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>(</span><span style=color:#000>t1</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>b</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#000>temp_t</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>b</span><span style=color:#000;font-weight:700>);</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><p>了解了内存表的特性，你就知道了， 其实这里使用内存临时表的效果更好，原因有三个：</p><ol><li>相比于InnoDB表，使用内存表不需要写磁盘，往表temp_t的写数据的速度更快；</li><li>索引b使用hash索引，查找的速度比B-Tree索引快；</li><li>临时表数据只有2000行，占用的内存有限。</li></ol><p>因此，你可以对第35篇文章的语句序列做一个改写，将临时表t1改成内存临时表，并且在字段b上创建一个hash索引。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>create</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>temporary</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>table</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>temp_t</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>id</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87>int</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>primary</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>key</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>a</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87>int</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>b</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87>int</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>index</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>(</span><span style=color:#000>b</span><span style=color:#000;font-weight:700>))</span><span style=color:#000>engine</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#000>memory</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>insert</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>into</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>temp_t</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>select</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>*</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>from</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>t2</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>where</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>b</span><span style=color:#ce5c00;font-weight:700>&gt;=</span><span style=color:#0000cf;font-weight:700>1</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>and</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>b</span><span style=color:#ce5c00;font-weight:700>&lt;=</span><span style=color:#0000cf;font-weight:700>2000</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>select</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>*</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>from</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>t1</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>join</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>temp_t</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>on</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>(</span><span style=color:#000>t1</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>b</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#000>temp_t</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>b</span><span style=color:#000;font-weight:700>);</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211117222907.png style=display:block;width:80% alt=NAME align=center></div><p>可以看到，不论是导入数据的时间，还是执行join的时间，使用内存临时表的速度都比使用InnoDB临时表要更快一些。</p><h2 id=小结>小结</h2><p>今天这篇文章，我从“要不要使用内存表”这个问题展开，和你介绍了Memory引擎的几个特性。</p><p>可以看到，由于重启会丢数据，如果一个备库重启，会导致主备同步线程停止；如果主库跟这个备库是双M架构，还可能导致主库的内存表数据被删掉。</p><p>因此，在生产上，我不建议你使用普通内存表。</p><p>如果你是DBA，可以在建表的审核系统中增加这类规则，要求业务改用InnoDB表。我们在文中也分析了，其实InnoDB表性能还不错，而且数据安全也有保障。而内存表由于不支持行锁，更新语句会阻塞查询，性能也未必就如想象中那么好。</p><p>基于内存表的特性，我们还分析了它的一个适用场景，就是内存临时表。内存表支持hash索引，这个特性利用起来，对复杂查询的加速效果还是很不错的。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-cf1ea9bcb1f19bd706aa66a3e390e045>5.39 - CH39-自增主键连续性</h1><p>在第4篇文章中，我们提到过自增主键，由于自增主键可以让主键索引尽量地保持递增顺序插入，避免了页分裂，因此索引更紧凑。</p><p>之前我见过有的业务设计依赖于自增主键的连续性，也就是说，这个设计假设自增主键是连续的。但实际上，这样的假设是错的，因为自增主键不能保证连续递增。</p><p>今天这篇文章，我们就来说说这个问题，看看什么情况下自增主键会出现 “空洞”？</p><p>为了便于说明，我们创建一个表t，其中id是自增主键字段、c是唯一索引。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>CREATE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>TABLE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>t</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>(</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>id</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87>int</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>11</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>NOT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>NULL</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>AUTO_INCREMENT</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#204a87;font-weight:700>c</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87>int</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>11</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>DEFAULT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>NULL</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>d</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87>int</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>11</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>DEFAULT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>NULL</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>PRIMARY</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>KEY</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>(</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>id</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000;font-weight:700>),</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>UNIQUE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>KEY</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#204a87;font-weight:700>c</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>(</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#204a87;font-weight:700>c</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>ENGINE</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#000>InnoDB</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><h2 id=自增值保存在哪儿>自增值保存在哪儿？</h2><p>在这个空表t里面执行insert into t values(null, 1, 1);插入一行数据，再执行show create table命令，就可以看到如下图所示的结果：</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/cb2637cada0201b18650f56875e94fff.png style=display:block;width:80% alt=NAME align=center></div><p>可以看到，表定义里面出现了一个AUTO_INCREMENT=2，表示下一次插入数据时，如果需要自动生成自增值，会生成id=2。</p><p>其实，这个输出结果容易引起这样的误解：自增值是保存在表结构定义里的。实际上，<strong>表的结构定义存放在后缀名为.frm的文件中，但是并不会保存自增值。</strong></p><p>不同的引擎对于自增值的保存策略不同。</p><ul><li>MyISAM引擎的自增值保存在数据文件中。</li><li>InnoDB引擎的自增值，其实是保存在了内存里，并且到了MySQL 8.0版本后，才有了“自增值持久化”的能力，也就是才实现了“如果发生重启，表的自增值可以恢复为MySQL重启前的值”，具体情况是：<ul><li>在MySQL 5.7及之前的版本，自增值保存在内存里，并没有持久化。每次重启后，第一次打开表的时候，都会去找自增值的最大值max(id)，然后将max(id)+1作为这个表当前的自增值。﻿
举例来说，如果一个表当前数据行里最大的id是10，AUTO_INCREMENT=11。这时候，我们删除id=10的行，AUTO_INCREMENT还是11。但如果马上重启实例，重启后这个表的AUTO_INCREMENT就会变成10。﻿
也就是说，MySQL重启可能会修改一个表的AUTO_INCREMENT的值。</li><li>在MySQL 8.0版本，将自增值的变更记录在了redo log中，重启的时候依靠redo log恢复重启之前的值。</li></ul></li></ul><p>理解了MySQL对自增值的保存策略以后，我们再看看自增值修改机制。</p><h2 id=自增值修改机制>自增值修改机制</h2><p>在MySQL里面，如果字段id被定义为AUTO_INCREMENT，在插入一行数据的时候，自增值的行为如下：</p><ol><li>如果插入数据时id字段指定为0、null 或未指定值，那么就把这个表当前的 AUTO_INCREMENT值填到自增字段；</li><li>如果插入数据时id字段指定了具体的值，就直接使用语句里指定的值。</li></ol><p>根据要插入的值和当前自增值的大小关系，自增值的变更结果也会有所不同。假设，某次要插入的值是X，当前的自增值是Y。</p><ol><li>如果X&lt;Y，那么这个表的自增值不变；</li><li>如果X≥Y，就需要把当前自增值修改为新的自增值。</li></ol><p><strong>新的自增值生成算法是</strong>：从auto_increment_offset开始，以auto_increment_increment为步长，持续叠加，直到找到第一个大于X的值，作为新的自增值。</p><p>其中，auto_increment_offset 和 auto_increment_increment是两个系统参数，分别用来表示自增的初始值和步长，默认值都是1。</p><blockquote><p>备注：在一些场景下，使用的就不全是默认值。比如，双M的主备结构里要求双写的时候，我们就可能会设置成auto_increment_increment=2，让一个库的自增id都是奇数，另一个库的自增id都是偶数，避免两个库生成的主键发生冲突。</p></blockquote><p>当auto_increment_offset和auto_increment_increment都是1的时候，新的自增值生成逻辑很简单，就是：</p><ol><li>如果准备插入的值>=当前自增值，新的自增值就是“准备插入的值+1”；</li><li>否则，自增值不变。</li></ol><p>这就引入了我们文章开头提到的问题，在这两个参数都设置为1的时候，自增主键id却不能保证是连续的，这是什么原因呢？</p><h2 id=自增值的修改时机>自增值的修改时机</h2><p>要回答这个问题，我们就要看一下自增值的修改时机。</p><p>假设，表t里面已经有了(1,1,1)这条记录，这时我再执行一条插入数据命令：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>insert</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>into</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>t</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>values</span><span style=color:#000;font-weight:700>(</span><span style=color:#204a87;font-weight:700>null</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>);</span><span style=color:#f8f8f8;text-decoration:underline> 
</span></span></span></code></pre></div><p>这个语句的执行流程就是：</p><ol><li>执行器调用InnoDB引擎接口写入一行，传入的这一行的值是(0,1,1);</li><li>InnoDB发现用户没有指定自增id的值，获取表t当前的自增值2；</li><li>将传入的行的值改成(2,1,1);</li><li>将表的自增值改成3；</li><li>继续执行插入数据操作，由于已经存在c=1的记录，所以报Duplicate key error，语句返回。</li></ol><p>对应的执行流程图如下：</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211117224449.png style=display:block;width:80% alt=NAME align=center></div><p>可以看到，这个表的自增值改成3，是在真正执行插入数据的操作之前。这个语句真正执行的时候，因为碰到唯一键c冲突，所以id=2这一行并没有插入成功，但也没有将自增值再改回去。</p><p>所以，在这之后，再插入新的数据行时，拿到的自增id就是3。也就是说，出现了自增主键不连续的情况。</p><p>如图3所示就是完整的演示结果。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211117224501.png style=display:block;width:80% alt=NAME align=center></div><p>可以看到，这个操作序列复现了一个自增主键id不连续的现场(没有id=2的行）。可见，<strong>唯一键冲突是导致自增主键id不连续的第一种原因。</strong></p><p>同样地，事务<strong>回滚也会产生类似的现象，这就是第二种原因。</strong></p><p>下面这个语句序列就可以构造不连续的自增id，你可以自己验证一下。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>insert</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>into</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>t</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>values</span><span style=color:#000;font-weight:700>(</span><span style=color:#204a87;font-weight:700>null</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>);</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>begin</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>insert</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>into</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>t</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>values</span><span style=color:#000;font-weight:700>(</span><span style=color:#204a87;font-weight:700>null</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>2</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>2</span><span style=color:#000;font-weight:700>);</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>rollback</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>insert</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>into</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>t</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>values</span><span style=color:#000;font-weight:700>(</span><span style=color:#204a87;font-weight:700>null</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>2</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>2</span><span style=color:#000;font-weight:700>);</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#ce5c00;font-weight:700>//</span><span style=color:#a40000>插入的行是</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>3</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>2</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>2</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><p>你可能会问，为什么在出现唯一键冲突或者回滚的时候，MySQL没有把表t的自增值改回去呢？如果把表t的当前自增值从3改回2，再插入新数据的时候，不就可以生成id=2的一行数据了吗？</p><p>其实，MySQL这么设计是为了提升性能。接下来，我就跟你分析一下这个设计思路，看看<strong>自增值为什么不能回退。</strong></p><p>假设有两个并行执行的事务，在申请自增值的时候，为了避免两个事务申请到相同的自增id，肯定要加锁，然后顺序申请。</p><ol><li>假设事务A申请到了id=2， 事务B申请到id=3，那么这时候表t的自增值是4，之后继续执行。</li><li>事务B正确提交了，但事务A出现了唯一键冲突。</li><li>如果允许事务A把自增id回退，也就是把表t的当前自增值改回2，那么就会出现这样的情况：表里面已经有id=3的行，而当前的自增id值是2。</li><li>接下来，继续执行的其他事务就会申请到id=2，然后再申请到id=3。这时，就会出现插入语句报错“主键冲突”。</li></ol><p>而为了解决这个主键冲突，有两种方法：</p><ol><li>每次申请id之前，先判断表里面是否已经存在这个id。如果存在，就跳过这个id。但是，这个方法的成本很高。因为，本来申请id是一个很快的操作，现在还要再去主键索引树上判断id是否存在。</li><li>把自增id的锁范围扩大，必须等到一个事务执行完成并提交，下一个事务才能再申请自增id。这个方法的问题，就是锁的粒度太大，系统并发能力大大下降。</li></ol><p>可见，这两个方法都会导致性能问题。造成这些麻烦的罪魁祸首，就是我们假设的这个“允许自增id回退”的前提导致的。</p><p>因此，InnoDB放弃了这个设计，语句执行失败也不回退自增id。也正是因为这样，所以才只保证了自增id是递增的，但不保证是连续的。</p><h2 id=自增锁的优化>自增锁的优化</h2><p>可以看到，自增id锁并不是一个事务锁，而是每次申请完就马上释放，以便允许别的事务再申请。其实，在MySQL 5.1版本之前，并不是这样的。</p><p>接下来，我会先给你介绍下自增锁设计的历史，这样有助于你分析接下来的一个问题。</p><p>在MySQL 5.0版本的时候，自增锁的范围是语句级别。也就是说，如果一个语句申请了一个表自增锁，这个锁会等语句执行结束以后才释放。显然，这样设计会影响并发度。</p><p>MySQL 5.1.22版本引入了一个新策略，新增参数innodb_autoinc_lock_mode，默认值是1。</p><ol><li>这个参数的值被设置为0时，表示采用之前MySQL 5.0版本的策略，即语句执行结束后才释放锁；</li><li>这个参数的值被设置为1时：<ul><li>普通insert语句，自增锁在申请之后就马上释放；</li><li>类似insert … select这样的批量插入数据的语句，自增锁还是要等语句结束后才被释放；</li></ul></li><li>这个参数的值被设置为2时，所有的申请自增主键的动作都是申请后就释放锁。</li></ol><p>你一定有两个疑问：<strong>为什么默认设置下，insert … select 要使用语句级的锁？为什么这个参数的默认值不是2？</strong></p><p>答案是，这么设计还是为了数据的一致性。</p><p>我们一起来看一下这个场景：</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211117224604.png style=display:block;width:80% alt=NAME align=center></div><p>在这个例子里，我往表t1中插入了4行数据，然后创建了一个相同结构的表t2，然后两个session同时执行向表t2中插入数据的操作。</p><p>你可以设想一下，如果session B是申请了自增值以后马上就释放自增锁，那么就可能出现这样的情况：</p><ul><li>session B先插入了两个记录，(1,1,1)、(2,2,2)；</li><li>然后，session A来申请自增id得到id=3，插入了（3,5,5)；</li><li>之后，session B继续执行，插入两条记录(4,3,3)、 (5,4,4)。</li></ul><p>你可能会说，这也没关系吧，毕竟session B的语义本身就没有要求表t2的所有行的数据都跟session A相同。</p><p>是的，从数据逻辑上看是对的。但是，如果我们现在的binlog_format=statement，你可以设想下，binlog会怎么记录呢？</p><p>由于两个session是同时执行插入数据命令的，所以binlog里面对表t2的更新日志只有两种情况：要么先记session A的，要么先记session B的。</p><p>但不论是哪一种，这个binlog拿去从库执行，或者用来恢复临时实例，备库和临时实例里面，session B这个语句执行出来，生成的结果里面，id都是连续的。这时，这个库就发生了数据不一致。</p><p>你可以分析一下，出现这个问题的原因是什么？</p><p>其实，这是因为原库session B的insert语句，生成的id不连续。这个不连续的id，用statement格式的binlog来串行执行，是执行不出来的。</p><p>而要解决这个问题，有两种思路：</p><ol><li>一种思路是，让原库的批量插入数据语句，固定生成连续的id值。所以，自增锁直到语句执行结束才释放，就是为了达到这个目的。</li><li>另一种思路是，在binlog里面把插入数据的操作都如实记录进来，到备库执行的时候，不再依赖于自增主键去生成。这种情况，其实就是innodb_autoinc_lock_mode设置为2，同时binlog_format设置为row。</li></ol><p>因此，<strong>在生产上，尤其是有insert … select这种批量插入数据的场景时，从并发插入数据性能的角度考虑，我建议你这样设置：innodb_autoinc_lock_mode=2 ，并且 binlog_format=row</strong>.这样做，既能提升并发性，又不会出现数据一致性问题。</p><p>需要注意的是，我这里说的<strong>批量插入数据，包含的语句类型是insert … select、replace … select和load data语句。</strong></p><p>但是，在普通的insert语句里面包含多个value值的情况下，即使innodb_autoinc_lock_mode设置为1，也不会等语句执行完成才释放锁。因为这类语句在申请自增id的时候，是可以精确计算出需要多少个id的，然后一次性申请，申请完成后锁就可以释放了。</p><p>也就是说，批量插入数据的语句，之所以需要这么设置，是因为“不知道要预先申请多少个id”。</p><p>既然预先不知道要申请多少个自增id，那么一种直接的想法就是需要一个时申请一个。但如果一个select … insert语句要插入10万行数据，按照这个逻辑的话就要申请10万次。显然，这种申请自增id的策略，在大批量插入数据的情况下，不但速度慢，还会影响并发插入的性能。</p><p>因此，对于批量插入数据的语句，MySQL有一个批量申请自增id的策略：</p><ol><li>语句执行过程中，第一次申请自增id，会分配1个；</li><li>1个用完以后，这个语句第二次申请自增id，会分配2个；</li><li>2个用完以后，还是这个语句，第三次申请自增id，会分配4个；</li><li>依此类推，同一个语句去申请自增id，每次申请到的自增id个数都是上一次的两倍。</li></ol><p>举个例子，我们一起看看下面的这个语句序列：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>insert</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>into</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>t</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>values</span><span style=color:#000;font-weight:700>(</span><span style=color:#204a87;font-weight:700>null</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>);</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>insert</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>into</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>t</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>values</span><span style=color:#000;font-weight:700>(</span><span style=color:#204a87;font-weight:700>null</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#0000cf;font-weight:700>2</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>2</span><span style=color:#000;font-weight:700>);</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>insert</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>into</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>t</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>values</span><span style=color:#000;font-weight:700>(</span><span style=color:#204a87;font-weight:700>null</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#0000cf;font-weight:700>3</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>3</span><span style=color:#000;font-weight:700>);</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>insert</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>into</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>t</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>values</span><span style=color:#000;font-weight:700>(</span><span style=color:#204a87;font-weight:700>null</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#0000cf;font-weight:700>4</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>4</span><span style=color:#000;font-weight:700>);</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>create</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>table</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>t2</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>like</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>t</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>insert</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>into</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>t2</span><span style=color:#000;font-weight:700>(</span><span style=color:#204a87;font-weight:700>c</span><span style=color:#000;font-weight:700>,</span><span style=color:#000>d</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>select</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>c</span><span style=color:#000;font-weight:700>,</span><span style=color:#000>d</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>from</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>t</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>insert</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>into</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>t2</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>values</span><span style=color:#000;font-weight:700>(</span><span style=color:#204a87;font-weight:700>null</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#0000cf;font-weight:700>5</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>5</span><span style=color:#000;font-weight:700>);</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><p>insert…select，实际上往表t2中插入了4行数据。但是，这四行数据是分三次申请的自增id，第一次申请到了id=1，第二次被分配了id=2和id=3， 第三次被分配到id=4到id=7。</p><p>由于这条语句实际只用上了4个id，所以id=5到id=7就被浪费掉了。之后，再执行insert into t2 values(null, 5,5)，实际上插入的数据就是（8,5,5)。</p><p><strong>这是主键id出现自增id不连续的第三种原因。</strong></p><h2 id=小结>小结</h2><p>今天，我们从“自增主键为什么会出现不连续的值”这个问题开始，首先讨论了自增值的存储。</p><p>在MyISAM引擎里面，自增值是被写在数据文件上的。而在InnoDB中，自增值是被记录在内存的。MySQL直到8.0版本，才给InnoDB表的自增值加上了持久化的能力，确保重启前后一个表的自增值不变。</p><p>然后，我和你分享了在一个语句执行过程中，自增值改变的时机，分析了为什么MySQL在事务回滚的时候不能回收自增id。</p><p>MySQL 5.1.22版本开始引入的参数innodb_autoinc_lock_mode，控制了自增值申请时的锁范围。从并发性能的角度考虑，我建议你将其设置为2，同时将binlog_format设置为row。我在前面的文章中其实多次提到，binlog_format设置为row，是很有必要的。今天的例子给这个结论多了一个理由。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-b63334801747ae29bc0a483233fbcc37>5.40 - INSERT 相关锁</h1><p>在上一篇文章中，我提到MySQL对自增主键锁做了优化，尽量在申请到自增id以后，就释放自增锁。</p><p>因此，insert语句是一个很轻量的操作。不过，这个结论对于“普通的insert语句”才有效。也就是说，还有些insert语句是属于“特殊情况”的，在执行过程中需要给其他资源加锁，或者无法在申请到自增id以后就立马释放自增锁。</p><p>那么，今天这篇文章，我们就一起来聊聊这个话题。</p><h2 id=insert--select-语句>insert … select 语句</h2><p>我们先从昨天的问题说起吧。表t和t2的表结构、初始化数据语句如下，今天的例子我们还是针对这两个表展开。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>CREATE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>TABLE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>t</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>(</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>id</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87>int</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>11</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>NOT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>NULL</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>AUTO_INCREMENT</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#204a87;font-weight:700>c</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87>int</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>11</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>DEFAULT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>NULL</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>d</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87>int</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>11</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>DEFAULT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>NULL</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>PRIMARY</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>KEY</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>(</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>id</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000;font-weight:700>),</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>UNIQUE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>KEY</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#204a87;font-weight:700>c</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>(</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#204a87;font-weight:700>c</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>ENGINE</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#000>InnoDB</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>insert</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>into</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>t</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>values</span><span style=color:#000;font-weight:700>(</span><span style=color:#204a87;font-weight:700>null</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>);</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>insert</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>into</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>t</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>values</span><span style=color:#000;font-weight:700>(</span><span style=color:#204a87;font-weight:700>null</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#0000cf;font-weight:700>2</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>2</span><span style=color:#000;font-weight:700>);</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>insert</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>into</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>t</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>values</span><span style=color:#000;font-weight:700>(</span><span style=color:#204a87;font-weight:700>null</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#0000cf;font-weight:700>3</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>3</span><span style=color:#000;font-weight:700>);</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>insert</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>into</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>t</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>values</span><span style=color:#000;font-weight:700>(</span><span style=color:#204a87;font-weight:700>null</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#0000cf;font-weight:700>4</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>4</span><span style=color:#000;font-weight:700>);</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>create</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>table</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>t2</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>like</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>t</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><p>现在，我们一起来看看为什么在可重复读隔离级别下，binlog_format=statement时执行：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>insert</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>into</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>t2</span><span style=color:#000;font-weight:700>(</span><span style=color:#204a87;font-weight:700>c</span><span style=color:#000;font-weight:700>,</span><span style=color:#000>d</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>select</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>c</span><span style=color:#000;font-weight:700>,</span><span style=color:#000>d</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>from</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>t</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><p>这个语句时，需要对表t的所有行和间隙加锁呢？</p><p>其实，这个问题我们需要考虑的还是日志和数据的一致性。我们看下这个执行序列：</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211117224717.png style=display:block;width:80% alt=NAME align=center></div><p>实际的执行效果是，如果session B先执行，由于这个语句对表t主键索引加了(-∞,1]这个next-key lock，会在语句执行完成后，才允许session A的insert语句执行。</p><p>但如果没有锁的话，就可能出现session B的insert语句先执行，但是后写入binlog的情况。于是，在binlog_format=statement的情况下，binlog里面就记录了这样的语句序列：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>insert</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>into</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>t</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>values</span><span style=color:#000;font-weight:700>(</span><span style=color:#ce5c00;font-weight:700>-</span><span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>,</span><span style=color:#ce5c00;font-weight:700>-</span><span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>,</span><span style=color:#ce5c00;font-weight:700>-</span><span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>);</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>insert</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>into</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>t2</span><span style=color:#000;font-weight:700>(</span><span style=color:#204a87;font-weight:700>c</span><span style=color:#000;font-weight:700>,</span><span style=color:#000>d</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>select</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>c</span><span style=color:#000;font-weight:700>,</span><span style=color:#000>d</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>from</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>t</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><p>这个语句到了备库执行，就会把id=-1这一行也写到表t2中，出现主备不一致。</p><h2 id=insert-循环写入>insert 循环写入</h2><p>当然了，执行insert … select 的时候，对目标表也不是锁全表，而是只锁住需要访问的资源。</p><p>如果现在有这么一个需求：要往表t2中插入一行数据，这一行的c值是表t中c值的最大值加1。</p><p>此时，我们可以这么写这条SQL语句 ：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>insert</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>into</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>t2</span><span style=color:#000;font-weight:700>(</span><span style=color:#204a87;font-weight:700>c</span><span style=color:#000;font-weight:700>,</span><span style=color:#000>d</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#000;font-weight:700>(</span><span style=color:#204a87;font-weight:700>select</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>c</span><span style=color:#ce5c00;font-weight:700>+</span><span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>d</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>from</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>t</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>force</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>index</span><span style=color:#000;font-weight:700>(</span><span style=color:#204a87;font-weight:700>c</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>order</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>by</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>c</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>desc</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>limit</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>);</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><p>这个语句的加锁范围，就是表t索引c上的(4,supremum]这个next-key lock和主键索引上id=4这一行。</p><p>它的执行流程也比较简单，从表t中按照索引c倒序，扫描第一行，拿到结果写入到表t2中。</p><p>因此整条语句的扫描行数是1。</p><p>这个语句执行的慢查询日志（slow log），如下图所示：</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211117224731.png style=display:block;width:80% alt=NAME align=center></div><p>通过这个慢查询日志，我们看到Rows_examined=1，正好验证了执行这条语句的扫描行数为1。</p><p>那么，如果我们是要把这样的一行数据插入到表t中的话：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>insert</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>into</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>t</span><span style=color:#000;font-weight:700>(</span><span style=color:#204a87;font-weight:700>c</span><span style=color:#000;font-weight:700>,</span><span style=color:#000>d</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#000;font-weight:700>(</span><span style=color:#204a87;font-weight:700>select</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>c</span><span style=color:#ce5c00;font-weight:700>+</span><span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>d</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>from</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>t</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>force</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>index</span><span style=color:#000;font-weight:700>(</span><span style=color:#204a87;font-weight:700>c</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>order</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>by</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>c</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>desc</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>limit</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>);</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><p>语句的执行流程是怎样的？扫描行数又是多少呢？</p><p>这时候，我们再看慢查询日志就会发现不对了。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211117224742.png style=display:block;width:80% alt=NAME align=center></div><p>可以看到，这时候的Rows_examined的值是5。</p><p>我在前面的文章中提到过，希望你都能够学会用explain的结果来“脑补”整条语句的执行过程。今天，我们就来一起试试。</p><p>如图4所示就是这条语句的explain结果。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211117224751.png style=display:block;width:80% alt=NAME align=center></div><p>从Extra字段可以看到“Using temporary”字样，表示这个语句用到了临时表。也就是说，执行过程中，需要把表t的内容读出来，写入临时表。</p><p>图中rows显示的是1，我们不妨先对这个语句的执行流程做一个猜测：如果说是把子查询的结果读出来（扫描1行），写入临时表，然后再从临时表读出来（扫描1行），写回表t中。那么，这个语句的扫描行数就应该是2，而不是5。</p><p>所以，这个猜测不对。实际上，Explain结果里的rows=1是因为受到了limit 1 的影响。</p><p>从另一个角度考虑的话，我们可以看看InnoDB扫描了多少行。如图5所示，是在执行这个语句前后查看Innodb_rows_read的结果。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211117224802.png style=display:block;width:80% alt=NAME align=center></div><p>可以看到，这个语句执行前后，Innodb_rows_read的值增加了4。因为默认临时表是使用Memory引擎的，所以这4行查的都是表t，也就是说对表t做了全表扫描。</p><p>这样，我们就把整个执行过程理清楚了：</p><ol><li>创建临时表，表里有两个字段c和d。</li><li>按照索引c扫描表t，依次取c=4、3、2、1，然后回表，读到c和d的值写入临时表。这时，Rows_examined=4。</li><li>由于语义里面有limit 1，所以只取了临时表的第一行，再插入到表t中。这时，Rows_examined的值加1，变成了5。</li></ol><p>也就是说，这个语句会导致在表t上做全表扫描，并且会给索引c上的所有间隙都加上共享的next-key lock。所以，这个语句执行期间，其他事务不能在这个表上插入数据。</p><p>至于这个语句的执行为什么需要临时表，原因是这类一边遍历数据，一边更新数据的情况，如果读出来的数据直接写回原表，就可能在遍历过程中，读到刚刚插入的记录，新插入的记录如果参与计算逻辑，就跟语义不符。</p><p>由于实现上这个语句没有在子查询中就直接使用limit 1，从而导致了这个语句的执行需要遍历整个表t。它的优化方法也比较简单，就是用前面介绍的方法，先insert into到临时表temp_t，这样就只需要扫描一行；然后再从表temp_t里面取出这行数据插入表t1。</p><p>当然，由于这个语句涉及的数据量很小，你可以考虑使用内存临时表来做这个优化。使用内存临时表优化时，语句序列的写法如下：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>create</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>temporary</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>table</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>temp_t</span><span style=color:#000;font-weight:700>(</span><span style=color:#204a87;font-weight:700>c</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87>int</span><span style=color:#000;font-weight:700>,</span><span style=color:#000>d</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87>int</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>engine</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#000>memory</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>insert</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>into</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>temp_t</span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#000;font-weight:700>(</span><span style=color:#204a87;font-weight:700>select</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>c</span><span style=color:#ce5c00;font-weight:700>+</span><span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>d</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>from</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>t</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>force</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>index</span><span style=color:#000;font-weight:700>(</span><span style=color:#204a87;font-weight:700>c</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>order</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>by</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>c</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>desc</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>limit</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>);</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>insert</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>into</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>t</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>select</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>*</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>from</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>temp_t</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>drop</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>table</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>temp_t</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><h2 id=insert-唯一键冲突>insert 唯一键冲突</h2><p>前面的两个例子是使用insert … select的情况，接下来我要介绍的这个例子就是最常见的insert语句出现唯一键冲突的情况。</p><p>对于有唯一键的表，插入数据时出现唯一键冲突也是常见的情况了。我先给你举一个简单的唯一键冲突的例子。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211117224819.png style=display:block;width:80% alt=NAME align=center></div><p>这个例子也是在可重复读（repeatable read）隔离级别下执行的。可以看到，session B要执行的insert语句进入了锁等待状态。</p><p>也就是说，session A执行的insert语句，发生主键冲突的时候，并不只是简单地报错返回，还在冲突的索引上加了锁。我们前面说过，一个next-key lock就是由它右边界的值定义的。这时候，session A持有索引c上的(5,10]共享next-key lock（读锁）。</p><p>至于为什么要加这个读锁，其实我也没有找到合理的解释。从作用上来看，这样做可以避免这一行被别的事务删掉。</p><p>这里<a href=https://dev.mysql.com/doc/refman/8.0/en/innodb-locks-set.html>官方文档</a>有一个描述错误，认为如果冲突的是主键索引，就加记录锁，唯一索引才加next-key lock。但实际上，这两类索引冲突加的都是next-key lock。</p><blockquote><p>备注：这个bug，是我在写这篇文章查阅文档时发现的，已经<a href="https://bugs.mysql.com/bug.php?id=93806">发给官方</a>并被verified了。</p></blockquote><p>有同学在前面文章的评论区问到，在有多个唯一索引的表中并发插入数据时，会出现死锁。但是，由于他没有提供复现方法或者现场，我也无法做分析。所以，我建议你在评论区发问题的时候，尽量同时附上复现方法，或者现场信息，这样我才好和你一起分析问题。</p><p>这里，我就先和你分享一个经典的死锁场景，如果你还遇到过其他唯一键冲突导致的死锁场景，也欢迎给我留言。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211117224836.png style=display:block;width:80% alt=NAME align=center></div><p>在session A执行rollback语句回滚的时候，session C几乎同时发现死锁并返回。</p><p>这个死锁产生的逻辑是这样的：</p><ol><li>在T1时刻，启动session A，并执行insert语句，此时在索引c的c=5上加了记录锁。注意，这个索引是唯一索引，因此退化为记录锁（如果你的印象模糊了，可以回顾下第21篇文章介绍的加锁规则）。</li><li>在T2时刻，session B要执行相同的insert语句，发现了唯一键冲突，加上读锁；同样地，session C也在索引c上，c=5这一个记录上，加了读锁。</li><li>T3时刻，session A回滚。这时候，session B和session C都试图继续执行插入操作，都要加上写锁。两个session都要等待对方的行锁，所以就出现了死锁。</li></ol><p>这个流程的状态变化图如下所示。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211117224854.png style=display:block;width:80% alt=NAME align=center></div><h2 id=insert-into--on-duplicate-key-update>insert into … on duplicate key update</h2><p>上面这个例子是主键冲突后直接报错，如果是改写成</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>insert</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>into</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>t</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>values</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>11</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>10</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>10</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>on</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>duplicate</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>key</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>update</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>d</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#0000cf;font-weight:700>100</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline> 
</span></span></span></code></pre></div><p>的话，就会给索引c上(5,10] 加一个排他的next-key lock（写锁）。</p><p><strong>insert into … on duplicate key update 这个语义的逻辑是，插入一行数据，如果碰到唯一键约束，就执行后面的更新语句。</strong></p><p>注意，如果有多个列违反了唯一性约束，就会按照索引的顺序，修改跟第一个索引冲突的行。</p><p>现在表t里面已经有了(1,1,1)和(2,2,2)这两行，我们再来看看下面这个语句执行的效果：</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211117224909.png style=display:block;width:80% alt=NAME align=center></div><p>可以看到，主键id是先判断的，MySQL认为这个语句跟id=2这一行冲突，所以修改的是id=2的行。</p><p>需要注意的是，执行这条语句的affected rows返回的是2，很容易造成误解。实际上，真正更新的只有一行，只是在代码实现上，insert和update都认为自己成功了，update计数加了1， insert计数也加了1。</p><h2 id=小结>小结</h2><p>今天这篇文章，我和你介绍了几种特殊情况下的insert语句。</p><p>insert … select 是很常见的在两个表之间拷贝数据的方法。你需要注意，在可重复读隔离级别下，这个语句会给select的表里扫描到的记录和间隙加读锁。</p><p>而如果insert和select的对象是同一个表，则有可能会造成循环写入。这种情况下，我们需要引入用户临时表来做优化。</p><p>insert 语句如果出现唯一键冲突，会在冲突的唯一值上加共享的next-key lock(S锁)。因此，碰到由于唯一键约束导致报错后，要尽快提交或回滚事务，避免加锁时间过长。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-0f37df922c2c496cc572639d8e1133cf>5.41 - CH41-表快速复制</h1><p>我在上一篇文章最后，给你留下的问题是怎么在两张表中拷贝数据。如果可以控制对源表的扫描行数和加锁范围很小的话，我们简单地使用insert … select 语句即可实现。</p><p>当然，为了避免对源表加读锁，更稳妥的方案是先将数据写到外部文本文件，然后再写回目标表。这时，有两种常用的方法。接下来的内容，我会和你详细展开一下这两种方法。</p><p>为了便于说明，我还是先创建一个表db1.t，并插入1000行数据，同时创建一个相同结构的表db2.t。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>create</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>database</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>db1</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#000>use</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>db1</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>create</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>table</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>t</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>id</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87>int</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>primary</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>key</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>a</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87>int</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>b</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87>int</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>index</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>a</span><span style=color:#000;font-weight:700>))</span><span style=color:#000>engine</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#000>innodb</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>delimiter</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>;;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>create</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>procedure</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>idata</span><span style=color:#000;font-weight:700>()</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>begin</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>    </span><span style=color:#204a87;font-weight:700>declare</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>i</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87>int</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>    </span><span style=color:#204a87;font-weight:700>set</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>i</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>    </span><span style=color:#000>while</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>i</span><span style=color:#ce5c00;font-weight:700>&lt;=</span><span style=color:#0000cf;font-weight:700>1000</span><span style=color:#000;font-weight:700>)</span><span style=color:#204a87;font-weight:700>do</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>      </span><span style=color:#204a87;font-weight:700>insert</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>into</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>t</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>values</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>i</span><span style=color:#000;font-weight:700>,</span><span style=color:#000>i</span><span style=color:#000;font-weight:700>,</span><span style=color:#000>i</span><span style=color:#000;font-weight:700>);</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>      </span><span style=color:#204a87;font-weight:700>set</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>i</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#000>i</span><span style=color:#ce5c00;font-weight:700>+</span><span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>    </span><span style=color:#204a87;font-weight:700>end</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>while</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>end</span><span style=color:#000;font-weight:700>;;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>delimiter</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>call</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>idata</span><span style=color:#000;font-weight:700>();</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>create</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>database</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>db2</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>create</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>table</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>db2</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>t</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>like</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>db1</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>t</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><p>假设，我们要把db1.t里面a>900的数据行导出来，插入到db2.t中。</p><h2 id=mysqldump方法>mysqldump方法</h2><p>一种方法是，使用mysqldump命令将数据导出成一组INSERT语句。你可以使用下面的命令：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#000>mysqldump</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>-</span><span style=color:#000>h$host</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>-</span><span style=color:#000>P$port</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>-</span><span style=color:#000>u$user</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#8f5902;font-style:italic>--add-locks --no-create-info --single-transaction  --set-gtid-purged=OFF db1 t --where=&#34;a&gt;900&#34; --result-file=/client_tmp/t.sql
</span></span></span></code></pre></div><p>把结果输出到临时文件。</p><p>这条命令中，主要参数含义如下：</p><ol><li>–single-transaction的作用是，在导出数据的时候不需要对表db1.t加表锁，而是使用START TRANSACTION WITH CONSISTENT SNAPSHOT的方法；</li><li>–add-locks设置为0，表示在输出的文件结果里，不增加" LOCK TABLES <code>t</code> WRITE;" ；</li><li>–no-create-info的意思是，不需要导出表结构；</li><li>–set-gtid-purged=off表示的是，不输出跟GTID相关的信息；</li><li>–result-file指定了输出文件的路径，其中client表示生成的文件是在客户端机器上的。</li></ol><p>通过这条mysqldump命令生成的t.sql文件中就包含了如图1所示的INSERT语句。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211117225004.png style=display:block;width:80% alt=NAME align=center></div><p>可以看到，一条INSERT语句里面会包含多个value对，这是为了后续用这个文件来写入数据的时候，执行速度可以更快。</p><p>如果你希望生成的文件中一条INSERT语句只插入一行数据的话，可以在执行mysqldump命令时，加上参数–skip-extended-insert。</p><p>然后，你可以通过下面这条命令，将这些INSERT语句放到db2库里去执行。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#000>mysql</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>-</span><span style=color:#000>h127</span><span style=color:#000;font-weight:700>.</span><span style=color:#0000cf;font-weight:700>0</span><span style=color:#000;font-weight:700>.</span><span style=color:#0000cf;font-weight:700>0</span><span style=color:#000;font-weight:700>.</span><span style=color:#0000cf;font-weight:700>1</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>-</span><span style=color:#000>P13000</span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#ce5c00;font-weight:700>-</span><span style=color:#000>uroot</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>db2</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>-</span><span style=color:#000>e</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#4e9a06>&#34;source /client_tmp/t.sql&#34;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><p>需要说明的是，source并不是一条SQL语句，而是一个客户端命令。mysql客户端执行这个命令的流程是这样的：</p><ol><li>打开文件，默认以分号为结尾读取一条条的SQL语句；</li><li>将SQL语句发送到服务端执行。</li></ol><p>也就是说，服务端执行的并不是这个“source t.sql"语句，而是INSERT语句。所以，不论是在慢查询日志（slow log），还是在binlog，记录的都是这些要被真正执行的INSERT语句。</p><h2 id=导出csv文件>导出CSV文件</h2><p>另一种方法是直接将结果导出成.csv文件。MySQL提供了下面的语法，用来将查询结果导出到服务端本地目录：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>select</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>*</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>from</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>db1</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>t</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>where</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>a</span><span style=color:#ce5c00;font-weight:700>&gt;</span><span style=color:#0000cf;font-weight:700>900</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>into</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>outfile</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#4e9a06>&#39;/server_tmp/t.csv&#39;</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><p>我们在使用这条语句时，需要注意如下几点。</p><ol><li>这条语句会将结果保存在服务端。如果你执行命令的客户端和MySQL服务端不在同一个机器上，客户端机器的临时目录下是不会生成t.csv文件的。</li><li>into outfile指定了文件的生成位置（/server_tmp/），这个位置必须受参数secure_file_priv的限制。参数secure_file_priv的可选值和作用分别是：<ul><li>如果设置为empty，表示不限制文件生成的位置，这是不安全的设置；</li><li>如果设置为一个表示路径的字符串，就要求生成的文件只能放在这个指定的目录，或者它的子目录；</li><li>如果设置为NULL，就表示禁止在这个MySQL实例上执行select … into outfile 操作。</li></ul></li><li>这条命令不会帮你覆盖文件，因此你需要确保/server_tmp/t.csv这个文件不存在，否则执行语句时就会因为有同名文件的存在而报错。</li><li>这条命令生成的文本文件中，原则上一个数据行对应文本文件的一行。但是，如果字段中包含换行符，在生成的文本中也会有换行符。不过类似换行符、制表符这类符号，前面都会跟上“\”这个转义符，这样就可以跟字段之间、数据行之间的分隔符区分开。</li></ol><p>得到.csv导出文件后，你就可以用下面的load data命令将数据导入到目标表db2.t中。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>load</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>data</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>infile</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#4e9a06>&#39;/server_tmp/t.csv&#39;</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>into</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>table</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>db2</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>t</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><p>这条语句的执行流程如下所示。</p><ol><li>打开文件/server_tmp/t.csv，以制表符(\t)作为字段间的分隔符，以换行符（\n）作为记录之间的分隔符，进行数据读取；</li><li>启动事务。</li><li>判断每一行的字段数与表db2.t是否相同：<ul><li>若不相同，则直接报错，事务回滚；</li><li>若相同，则构造成一行，调用InnoDB引擎接口，写入到表中。</li></ul></li><li>重复步骤3，直到/server_tmp/t.csv整个文件读入完成，提交事务。</li></ol><p>你可能有一个疑问，<strong>如果binlog_format=statement，这个load语句记录到binlog里以后，怎么在备库重放呢？</strong></p><p>由于/server_tmp/t.csv文件只保存在主库所在的主机上，如果只是把这条语句原文写到binlog中，在备库执行的时候，备库的本地机器上没有这个文件，就会导致主备同步停止。</p><p>所以，这条语句执行的完整流程，其实是下面这样的。</p><ol><li>主库执行完成后，将/server_tmp/t.csv文件的内容直接写到binlog文件中。</li><li>往binlog文件中写入语句load data local infile ‘/tmp/SQL_LOAD_MB-1-0’ INTO TABLE <code>db2</code>.<code>t</code>。</li><li>把这个binlog日志传到备库。</li><li>备库的apply线程在执行这个事务日志时：
a. 先将binlog中t.csv文件的内容读出来，写入到本地临时目录/tmp/SQL_LOAD_MB-1-0 中；
b. 再执行load data语句，往备库的db2.t表中插入跟主库相同的数据。</li></ol><p>执行流程如图2所示：</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211117225021.png style=display:block;width:80% alt=NAME align=center></div><p>注意，这里备库执行的load data语句里面，多了一个“local”。它的意思是“将执行这条命令的客户端所在机器的本地文件/tmp/SQL_LOAD_MB-1-0的内容，加载到目标表db2.t中”。</p><p>也就是说，<strong>load data命令有两种用法</strong>：</p><ol><li>不加“local”，是读取服务端的文件，这个文件必须在secure_file_priv指定的目录或子目录下；</li><li>加上“local”，读取的是客户端的文件，只要mysql客户端有访问这个文件的权限即可。这时候，MySQL客户端会先把本地文件传给服务端，然后执行上述的load data流程。</li></ol><p>另外需要注意的是，<strong>select …into outfile方法不会生成表结构文件</strong>, 所以我们导数据时还需要单独的命令得到表结构定义。mysqldump提供了一个–tab参数，可以同时导出表结构定义文件和csv数据文件。这条命令的使用方法如下：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#000>mysqldump</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>-</span><span style=color:#000>h$host</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>-</span><span style=color:#000>P$port</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>-</span><span style=color:#000>u$user</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#8f5902;font-style:italic>---single-transaction  --set-gtid-purged=OFF db1 t --where=&#34;a&gt;900&#34; --tab=$secure_file_priv
</span></span></span></code></pre></div><p>这条命令会在$secure_file_priv定义的目录下，创建一个t.sql文件保存建表语句，同时创建一个t.txt文件保存CSV数据。</p><h2 id=物理拷贝方法>物理拷贝方法</h2><p>前面我们提到的mysqldump方法和导出CSV文件的方法，都是逻辑导数据的方法，也就是将数据从表db1.t中读出来，生成文本，然后再写入目标表db2.t中。</p><p>你可能会问，有物理导数据的方法吗？比如，直接把db1.t表的.frm文件和.ibd文件拷贝到db2目录下，是否可行呢？</p><p>答案是不行的。</p><p>因为，一个InnoDB表，除了包含这两个物理文件外，还需要在数据字典中注册。直接拷贝这两个文件的话，因为数据字典中没有db2.t这个表，系统是不会识别和接受它们的。</p><p>不过，在MySQL 5.6版本引入了<strong>可传输表空间</strong>(transportable tablespace)的方法，可以通过导出+导入表空间的方式，实现物理拷贝表的功能。</p><p>假设我们现在的目标是在db1库下，复制一个跟表t相同的表r，具体的执行步骤如下：</p><ol><li>执行 create table r like t，创建一个相同表结构的空表；</li><li>执行alter table r discard tablespace，这时候r.ibd文件会被删除；</li><li>执行flush table t for export，这时候db1目录下会生成一个t.cfg文件；</li><li>在db1目录下执行cp t.cfg r.cfg; cp t.ibd r.ibd；这两个命令；</li><li>执行unlock tables，这时候t.cfg文件会被删除；</li><li>执行alter table r import tablespace，将这个r.ibd文件作为表r的新的表空间，由于这个文件的数据内容和t.ibd是相同的，所以表r中就有了和表t相同的数据。</li></ol><p>至此，拷贝表数据的操作就完成了。这个流程的执行过程图如下：</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211117225035.png style=display:block;width:80% alt=NAME align=center></div><p>关于拷贝表的这个流程，有以下几个注意点：</p><ol><li>在第3步执行完flsuh table命令之后，db1.t整个表处于只读状态，直到执行unlock tables命令后才释放读锁；</li><li>在执行import tablespace的时候，为了让文件里的表空间id和数据字典中的一致，会修改t.ibd的表空间id。而这个表空间id存在于每一个数据页中。因此，如果是一个很大的文件（比如TB级别），每个数据页都需要修改，所以你会看到这个import语句的执行是需要一些时间的。当然，如果是相比于逻辑导入的方法，import语句的耗时是非常短的。</li></ol><h2 id=小结>小结</h2><p>今天这篇文章，我和你介绍了三种将一个表的数据导入到另外一个表中的方法。</p><p>我们来对比一下这三种方法的优缺点。</p><ol><li>物理拷贝的方式速度最快，尤其对于大表拷贝来说是最快的方法。如果出现误删表的情况，用备份恢复出误删之前的临时库，然后再把临时库中的表拷贝到生产库上，是恢复数据最快的方法。但是，这种方法的使用也有一定的局限性：<ul><li>必须是全表拷贝，不能只拷贝部分数据；</li><li>需要到服务器上拷贝数据，在用户无法登录数据库主机的场景下无法使用；</li><li>由于是通过拷贝物理文件实现的，源表和目标表都是使用InnoDB引擎时才能使用。</li></ul></li><li>用mysqldump生成包含INSERT语句文件的方法，可以在where参数增加过滤条件，来实现只导出部分数据。这个方式的不足之一是，不能使用join这种比较复杂的where条件写法。</li><li>用select … into outfile的方法是最灵活的，支持所有的SQL写法。但，这个方法的缺点之一就是，每次只能导出一张表的数据，而且表结构也需要另外的语句单独备份。</li></ol><p>后两种方式都是逻辑备份方式，是可以跨引擎使用的。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-ed8d3e3e94c1b3f3e80059ed212b894f>5.42 - CH42-GRANT 授权</h1><p>在MySQL里面，grant语句是用来给用户赋权的。不知道你有没有见过一些操作文档里面提到，grant之后要马上跟着执行一个flush privileges命令，才能使赋权语句生效。我最开始使用MySQL的时候，就是照着一个操作文档的说明按照这个顺序操作的。</p><p>那么，grant之后真的需要执行flush privileges吗？如果没有执行这个flush命令的话，赋权语句真的不能生效吗？</p><p>接下来，我就先和你介绍一下grant语句和flush privileges语句分别做了什么事情，然后再一起来分析这个问题。</p><p>为了便于说明，我先创建一个用户：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>create</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>user</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#4e9a06>&#39;ua&#39;</span><span style=color:#ce5c00;font-weight:700>@</span><span style=color:#4e9a06>&#39;%&#39;</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>identified</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>by</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#4e9a06>&#39;pa&#39;</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><p>这条语句的逻辑是创建一个用户’ua’@’%’，密码是pa。注意，在MySQL里面，用户名(user)+地址(host)才表示一个用户，因此 ua@ip1 和 ua@ip2代表的是两个不同的用户。</p><p>这条命令做了两个动作：</p><ol><li>磁盘上，往mysql.user表里插入一行，由于没有指定权限，所以这行数据上所有表示权限的字段的值都是N；</li><li>内存里，往数组acl_users里插入一个acl_user对象，这个对象的access字段值为0。</li></ol><p>图1就是这个时刻用户ua在user表中的状态。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211117225124.png style=display:block;width:80% alt=NAME align=center></div><p>在MySQL中，用户权限是有不同的范围的。接下来，我就按照用户权限范围从大到小的顺序依次和你说明。</p><h2 id=全局权限>全局权限</h2><p>全局权限，作用于整个MySQL实例，这些权限信息保存在mysql库的user表里。如果我要给用户ua赋一个最高权限的话，语句是这么写的：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>grant</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>all</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>privileges</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>on</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>*</span><span style=color:#000;font-weight:700>.</span><span style=color:#ce5c00;font-weight:700>*</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>to</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#4e9a06>&#39;ua&#39;</span><span style=color:#ce5c00;font-weight:700>@</span><span style=color:#4e9a06>&#39;%&#39;</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>with</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>grant</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>option</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><p>这个grant命令做了两个动作：</p><ol><li>磁盘上，将mysql.user表里，用户’ua’@’%&lsquo;这一行的所有表示权限的字段的值都修改为‘Y’；</li><li>内存里，从数组acl_users中找到这个用户对应的对象，将access值（权限位）修改为二进制的“全1”。</li></ol><p>在这个grant命令执行完成后，如果有新的客户端使用用户名ua登录成功，MySQL会为新连接维护一个线程对象，然后从acl_users数组里查到这个用户的权限，并将权限值拷贝到这个线程对象中。之后在这个连接中执行的语句，所有关于全局权限的判断，都直接使用线程对象内部保存的权限位。</p><p>基于上面的分析我们可以知道：</p><ol><li>grant 命令对于全局权限，同时更新了磁盘和内存。命令完成后即时生效，接下来新创建的连接会使用新的权限。</li><li>对于一个已经存在的连接，它的全局权限不受grant命令的影响。</li></ol><p>需要说明的是，<strong>一般在生产环境上要合理控制用户权限的范围</strong>。我们上面用到的这个grant语句就是一个典型的错误示范。如果一个用户有所有权限，一般就不应该设置为所有IP地址都可以访问。</p><p>如果要回收上面的grant语句赋予的权限，你可以使用下面这条命令：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>revoke</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>all</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>privileges</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>on</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>*</span><span style=color:#000;font-weight:700>.</span><span style=color:#ce5c00;font-weight:700>*</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>from</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#4e9a06>&#39;ua&#39;</span><span style=color:#ce5c00;font-weight:700>@</span><span style=color:#4e9a06>&#39;%&#39;</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><p>这条revoke命令的用法与grant类似，做了如下两个动作：</p><ol><li>磁盘上，将mysql.user表里，用户’ua’@’%&lsquo;这一行的所有表示权限的字段的值都修改为“N”；</li><li>内存里，从数组acl_users中找到这个用户对应的对象，将access的值修改为0。</li></ol><h2 id=db权限>db权限</h2><p>除了全局权限，MySQL也支持库级别的权限定义。如果要让用户ua拥有库db1的所有权限，可以执行下面这条命令：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>grant</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>all</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>privileges</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>on</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>db1</span><span style=color:#000;font-weight:700>.</span><span style=color:#ce5c00;font-weight:700>*</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>to</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#4e9a06>&#39;ua&#39;</span><span style=color:#ce5c00;font-weight:700>@</span><span style=color:#4e9a06>&#39;%&#39;</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>with</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>grant</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>option</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><p>基于库的权限记录保存在mysql.db表中，在内存里则保存在数组acl_dbs中。这条grant命令做了如下两个动作：</p><ol><li>磁盘上，往mysql.db表中插入了一行记录，所有权限位字段设置为“Y”；</li><li>内存里，增加一个对象到数组acl_dbs中，这个对象的权限位为“全1”。</li></ol><p>图2就是这个时刻用户ua在db表中的状态。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211117225142.png style=display:block;width:80% alt=NAME align=center></div><p>每次需要判断一个用户对一个数据库读写权限的时候，都需要遍历一次acl_dbs数组，根据user、host和db找到匹配的对象，然后根据对象的权限位来判断。</p><p>也就是说，grant修改db权限的时候，是同时对磁盘和内存生效的。</p><p>grant操作对于已经存在的连接的影响，在全局权限和基于db的权限效果是不同的。接下来，我们做一个对照试验来分别看一下。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211117225157.png style=display:block;width:80% alt=NAME align=center></div><p>需要说明的是，图中set global sync_binlog这个操作是需要super权限的。</p><p>可以看到，虽然用户ua的super权限在T3时刻已经通过revoke语句回收了，但是在T4时刻执行set global的时候，权限验证还是通过了。这是因为super是全局权限，这个权限信息在线程对象中，而revoke操作影响不到这个线程对象。</p><p>而在T5时刻去掉ua对db1库的所有权限后，在T6时刻session B再操作db1库的表，就会报错“权限不足”。这是因为acl_dbs是一个全局数组，所有线程判断db权限都用这个数组，这样revoke操作马上就会影响到session B。</p><p>这里在代码实现上有一个特别的逻辑，如果当前会话已经处于某一个db里面，之前use这个库的时候拿到的库权限会保存在会话变量中。</p><p>你可以看到在T6时刻，session C和session B对表t的操作逻辑是一样的。但是session B报错，而session C可以执行成功。这是因为session C在T2 时刻执行的use db1，拿到了这个库的权限，在切换出db1库之前，session C对这个库就一直有权限。</p><h2 id=表权限和列权限>表权限和列权限</h2><p>除了db级别的权限外，MySQL支持更细粒度的表权限和列权限。其中，表权限定义存放在表mysql.tables_priv中，列权限定义存放在表mysql.columns_priv中。这两类权限，组合起来存放在内存的hash结构column_priv_hash中。</p><p>这两类权限的赋权命令如下：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>create</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>table</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>db1</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>t1</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>id</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87>int</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>a</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87>int</span><span style=color:#000;font-weight:700>);</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>grant</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>all</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>privileges</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>on</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>db1</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>t1</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>to</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#4e9a06>&#39;ua&#39;</span><span style=color:#ce5c00;font-weight:700>@</span><span style=color:#4e9a06>&#39;%&#39;</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>with</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>grant</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>option</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>GRANT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>SELECT</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>id</span><span style=color:#000;font-weight:700>),</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>INSERT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>(</span><span style=color:#000>id</span><span style=color:#000;font-weight:700>,</span><span style=color:#000>a</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>ON</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>mydb</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>mytbl</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>TO</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#4e9a06>&#39;ua&#39;</span><span style=color:#ce5c00;font-weight:700>@</span><span style=color:#4e9a06>&#39;%&#39;</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>with</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>grant</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>option</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><p>跟db权限类似，这两个权限每次grant的时候都会修改数据表，也会同步修改内存中的hash结构。因此，对这两类权限的操作，也会马上影响到已经存在的连接。</p><p>看到这里，你一定会问，看来grant语句都是即时生效的，那这么看应该就不需要执行flush privileges语句了呀。</p><p>答案也确实是这样的。</p><p>flush privileges命令会清空acl_users数组，然后从mysql.user表中读取数据重新加载，重新构造一个acl_users数组。也就是说，以数据表中的数据为准，会将全局权限内存数组重新加载一遍。</p><p>同样地，对于db权限、表权限和列权限，MySQL也做了这样的处理。</p><p>也就是说，如果内存的权限数据和磁盘数据表相同的话，不需要执行flush privileges。而如果我们都是用grant/revoke语句来执行的话，内存和数据表本来就是保持同步更新的。</p><p><strong>因此，正常情况下，grant命令之后，没有必要跟着执行flush privileges命令。</strong></p><h2 id=flush-privileges使用场景>flush privileges使用场景</h2><p>那么，flush privileges是在什么时候使用呢？显然，当数据表中的权限数据跟内存中的权限数据不一致的时候，flush privileges语句可以用来重建内存数据，达到一致状态。</p><p>这种不一致往往是由不规范的操作导致的，比如直接用DML语句操作系统权限表。我们来看一下下面这个场景：</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211117225216.png style=display:block;width:80% alt=NAME align=center></div><p>可以看到，T3时刻虽然已经用delete语句删除了用户ua，但是在T4时刻，仍然可以用ua连接成功。原因就是，这时候内存中acl_users数组中还有这个用户，因此系统判断时认为用户还正常存在。</p><p>在T5时刻执行过flush命令后，内存更新，T6时刻再要用ua来登录的话，就会报错“无法访问”了。</p><p>直接操作系统表是不规范的操作，这个不一致状态也会导致一些更“诡异”的现象发生。比如，前面这个通过delete语句删除用户的例子，就会出现下面的情况：</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211117225226.png style=display:block;width:80% alt=NAME align=center></div><p>可以看到，由于在T3时刻直接删除了数据表的记录，而内存的数据还存在。这就导致了：</p><ol><li>T4时刻给用户ua赋权限失败，因为mysql.user表中找不到这行记录；</li><li>而T5时刻要重新创建这个用户也不行，因为在做内存判断的时候，会认为这个用户还存在。</li></ol><h2 id=小结>小结</h2><p>今天这篇文章，我和你介绍了MySQL用户权限在数据表和内存中的存在形式，以及grant和revoke命令的执行逻辑。</p><p>grant语句会同时修改数据表和内存，判断权限的时候使用的是内存数据。因此，规范地使用grant和revoke语句，是不需要随后加上flush privileges语句的。</p><p>flush privileges语句本身会用数据表的数据重建一份内存权限数据，所以在权限数据可能存在不一致的情况下再使用。而这种不一致往往是由于直接用DML语句操作系统权限表导致的，所以我们尽量不要使用这类语句。</p><p>另外，在使用grant语句赋权时，你可能还会看到这样的写法：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>grant</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>super</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>on</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>*</span><span style=color:#000;font-weight:700>.</span><span style=color:#ce5c00;font-weight:700>*</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>to</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#4e9a06>&#39;ua&#39;</span><span style=color:#ce5c00;font-weight:700>@</span><span style=color:#4e9a06>&#39;%&#39;</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>identified</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>by</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#4e9a06>&#39;pa&#39;</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><p>这条命令加了identified by ‘密码’， 语句的逻辑里面除了赋权外，还包含了：</p><ol><li>如果用户’ua’@’%&lsquo;不存在，就创建这个用户，密码是pa；</li><li>如果用户ua已经存在，就将密码修改成pa。</li></ol><p>这也是一种不建议的写法，因为这种写法很容易就会不慎把密码给改了。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-fd30e526e9e2682ba8fa3c42b6302654>5.43 - CH43-分区表</h1><p>我经常被问到这样一个问题：分区表有什么问题，为什么公司规范不让使用分区表呢？今天，我们就来聊聊分区表的使用行为，然后再一起回答这个问题。</p><h1 id=分区表是什么>分区表是什么？</h1><p>为了说明分区表的组织形式，我先创建一个表t：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>CREATE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>TABLE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>t</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>(</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>ftime</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>datetime</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>NOT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>NULL</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#204a87;font-weight:700>c</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87>int</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>11</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>DEFAULT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>NULL</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>KEY</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>(</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>ftime</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>ENGINE</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#000>InnoDB</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>DEFAULT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>CHARSET</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#000>latin1</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#000>PARTITION</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>BY</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>RANGE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>(</span><span style=color:#204a87;font-weight:700>YEAR</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>ftime</span><span style=color:#000;font-weight:700>))</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#000;font-weight:700>(</span><span style=color:#000>PARTITION</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>p_2017</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>VALUES</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>LESS</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>THAN</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>2017</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>ENGINE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>InnoDB</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>PARTITION</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>p_2018</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>VALUES</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>LESS</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>THAN</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>2018</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>ENGINE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>InnoDB</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>PARTITION</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>p_2019</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>VALUES</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>LESS</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>THAN</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>2019</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>ENGINE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>InnoDB</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#000>PARTITION</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>p_others</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>VALUES</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>LESS</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>THAN</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>MAXVALUE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>ENGINE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>InnoDB</span><span style=color:#000;font-weight:700>);</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>insert</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>into</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>t</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>values</span><span style=color:#000;font-weight:700>(</span><span style=color:#4e9a06>&#39;2017-4-1&#39;</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>),(</span><span style=color:#4e9a06>&#39;2018-4-1&#39;</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>);</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211117225330.png style=display:block;width:80% alt=NAME align=center></div><p>我在表t中初始化插入了两行记录，按照定义的分区规则，这两行记录分别落在p_2018和p_2019这两个分区上。</p><p>可以看到，这个表包含了一个.frm文件和4个.ibd文件，每个分区对应一个.ibd文件。也就是说：</p><ul><li>对于引擎层来说，这是4个表；</li><li>对于Server层来说，这是1个表。</li></ul><p>你可能会觉得这两句都是废话。其实不然，这两句话非常重要，可以帮我们理解分区表的执行逻辑。</p><h2 id=分区表的引擎层行为>分区表的引擎层行为</h2><p>我先给你举个在分区表加间隙锁的例子，目的是说明对于InnoDB来说，这是4个表。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211117225341.png style=display:block;width:80% alt=NAME align=center></div><p>这里顺便复习一下，我在第21篇文章和你介绍的间隙锁加锁规则。</p><p>我们初始化表t的时候，只插入了两行数据， ftime的值分别是，‘2017-4-1’ 和’2018-4-1’ 。session A的select语句对索引ftime上这两个记录之间的间隙加了锁。如果是一个普通表的话，那么T1时刻，在表t的ftime索引上，间隙和加锁状态应该是图3这样的。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211117225357.png style=display:block;width:80% alt=NAME align=center></div><p>也就是说，‘2017-4-1’ 和’2018-4-1’ 这两个记录之间的间隙是会被锁住的。那么，sesion B的两条插入语句应该都要进入锁等待状态。</p><p>但是，从上面的实验效果可以看出，session B的第一个insert语句是可以执行成功的。这是因为，对于引擎来说，p_2018和p_2019是两个不同的表，也就是说2017-4-1的下一个记录并不是2018-4-1，而是p_2018分区的supremum。所以T1时刻，在表t的ftime索引上，间隙和加锁的状态其实是图4这样的：</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211117225409.png style=display:block;width:80% alt=NAME align=center></div><p>由于分区表的规则，session A的select语句其实只操作了分区p_2018，因此加锁范围就是图4中深绿色的部分。</p><p>所以，session B要写入一行ftime是2018-2-1的时候是可以成功的，而要写入2017-12-1这个记录，就要等session A的间隙锁。</p><p>图5就是这时候的show engine innodb status的部分结果。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211117225421.png style=display:block;width:80% alt=NAME align=center></div><p>看完InnoDB引擎的例子，我们再来一个MyISAM分区表的例子。</p><p>我首先用alter table t engine=myisam，把表t改成MyISAM表；然后，我再用下面这个例子说明，对于MyISAM引擎来说，这是4个表。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211117225431.png style=display:block;width:80% alt=NAME align=center></div><p>在session A里面，我用sleep(100)将这条语句的执行时间设置为100秒。由于MyISAM引擎只支持表锁，所以这条update语句会锁住整个表t上的读。</p><p>但我们看到的结果是，session B的第一条查询语句是可以正常执行的，第二条语句才进入锁等待状态。</p><p>这正是因为MyISAM的表锁是在引擎层实现的，session A加的表锁，其实是锁在分区p_2018上。因此，只会堵住在这个分区上执行的查询，落到其他分区的查询是不受影响的。</p><p>看到这里，你可能会说，分区表看来还不错嘛，为什么不让用呢？我们使用分区表的一个重要原因就是单表过大。那么，如果不使用分区表的话，我们就是要使用手动分表的方式。</p><p>接下来，我们一起看看手动分表和分区表有什么区别。</p><p>比如，按照年份来划分，我们就分别创建普通表t_2017、t_2018、t_2019等等。手工分表的逻辑，也是找到需要更新的所有分表，然后依次执行更新。在性能上，这和分区表并没有实质的差别。</p><p>分区表和手工分表，一个是由server层来决定使用哪个分区，一个是由应用层代码来决定使用哪个分表。因此，从引擎层看，这两种方式也是没有差别的。</p><p>其实这两个方案的区别，主要是在server层上。从server层看，我们就不得不提到分区表一个被广为诟病的问题：打开表的行为。</p><h2 id=分区策略>分区策略</h2><p>每当第一次访问一个分区表的时候，MySQL需要把所有的分区都访问一遍。<strong>一个典型的报错情况</strong>是这样的：如果一个分区表的分区很多，比如超过了1000个，而MySQL启动的时候，open_files_limit参数使用的是默认值1024，那么就会在访问这个表的时候，由于需要打开所有的文件，导致打开表文件的个数超过了上限而报错。</p><p>下图就是我创建的一个包含了很多分区的表t_myisam，执行一条插入语句后报错的情况。</p><p>可以看到，这条insert语句，明显只需要访问一个分区，但语句却无法执行。</p><p>这时，你一定从表名猜到了，这个表我用的是MyISAM引擎。是的，因为使用InnoDB引擎的话，并不会出现这个问题。</p><p>MyISAM分区表使用的分区策略，我们称为<strong>通用分区策略</strong>（generic partitioning），每次访问分区都由server层控制。通用分区策略，是MySQL一开始支持分区表的时候就存在的代码，在文件管理、表管理的实现上很粗糙，因此有比较严重的性能问题。</p><p>从MySQL 5.7.9开始，InnoDB引擎引入了<strong>本地分区策略</strong>（native partitioning）。这个策略是在InnoDB内部自己管理打开分区的行为。</p><p>MySQL从5.7.17开始，将MyISAM分区表标记为即将弃用(deprecated)，意思是“从这个版本开始不建议这么使用，请使用替代方案。在将来的版本中会废弃这个功能”。</p><p>从MySQL 8.0版本开始，就不允许创建MyISAM分区表了，只允许创建已经实现了本地分区策略的引擎。目前来看，只有InnoDB和NDB这两个引擎支持了本地分区策略。</p><p>接下来，我们再看一下分区表在server层的行为。</p><h2 id=分区表的server层行为>分区表的server层行为</h2><p>如果从server层看的话，一个分区表就只是一个表。</p><p>这句话是什么意思呢？接下来，我就用下面这个例子来和你说明。如图8和图9所示，分别是这个例子的操作序列和执行结果图。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211117225453.png style=display:block;width:80% alt=NAME align=center></div><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211117225500.png style=display:block;width:80% alt=NAME align=center></div><p>可以看到，虽然session B只需要操作p_2107这个分区，但是由于session A持有整个表t的MDL锁，就导致了session B的alter语句被堵住。</p><p>这也是DBA同学经常说的，分区表，在做DDL的时候，影响会更大。如果你使用的是普通分表，那么当你在truncate一个分表的时候，肯定不会跟另外一个分表上的查询语句，出现MDL锁冲突。</p><p>到这里我们小结一下：</p><ol><li>MySQL在第一次打开分区表的时候，需要访问所有的分区；</li><li>在server层，认为这是同一张表，因此所有分区共用同一个MDL锁；</li><li>在引擎层，认为这是不同的表，因此MDL锁之后的执行过程，会根据分区表规则，只访问必要的分区。</li></ol><p>而关于“必要的分区”的判断，就是根据SQL语句中的where条件，结合分区规则来实现的。比如我们上面的例子中，where ftime=‘2018-4-1’，根据分区规则year函数算出来的值是2018，那么就会落在p_2019这个分区。</p><p>但是，如果这个where 条件改成 where ftime>=‘2018-4-1’，虽然查询结果相同，但是这时候根据where条件，就要访问p_2019和p_others这两个分区。</p><p>如果查询语句的where条件中没有分区key，那就只能访问所有分区了。当然，这并不是分区表的问题。即使是使用业务分表的方式，where条件中没有使用分表的key，也必须访问所有的分表。</p><p>我们已经理解了分区表的概念，那么什么场景下适合使用分区表呢？</p><h2 id=分区表的应用场景>分区表的应用场景</h2><p>分区表的一个显而易见的优势是对业务透明，相对于用户分表来说，使用分区表的业务代码更简洁。还有，分区表可以很方便的清理历史数据。</p><p>如果一项业务跑的时间足够长，往往就会有根据时间删除历史数据的需求。这时候，按照时间分区的分区表，就可以直接通过alter table t drop partition …这个语法删掉分区，从而删掉过期的历史数据。</p><p>这个alter table t drop partition …操作是直接删除分区文件，效果跟drop普通表类似。与使用delete语句删除数据相比，优势是速度快、对系统影响小。</p><h2 id=小结>小结</h2><p>这篇文章，我主要和你介绍的是server层和引擎层对分区表的处理方式。我希望通过这些介绍，你能够对是否选择使用分区表，有更清晰的想法。</p><p>需要注意的是，我是以范围分区（range）为例和你介绍的。实际上，MySQL还支持hash分区、list分区等分区方法。你可以在需要用到的时候，再翻翻<a href=https://dev.mysql.com/doc/refman/8.0/en/partitioning-types.html>手册</a>。</p><p>实际使用时，分区表跟用户分表比起来，有两个绕不开的问题：一个是第一次访问的时候需要访问所有分区，另一个是共用MDL锁。</p><p>因此，如果要使用分区表，就不要创建太多的分区。我见过一个用户做了按天分区策略，然后预先创建了10年的分区。这种情况下，访问分区表的性能自然是不好的。这里有两个问题需要注意：</p><ol><li>分区并不是越细越好。实际上，单表或者单分区的数据一千万行，只要没有特别大的索引，对于现在的硬件能力来说都已经是小表了。</li><li>分区也不要提前预留太多，在使用之前预先创建即可。比如，如果是按月分区，每年年底时再把下一年度的12个新分区创建上即可。对于没有数据的历史分区，要及时的drop掉。</li></ol><p>至于分区表的其他问题，比如查询需要跨多个分区取数据，查询性能就会比较慢，基本上就不是分区表本身的问题，而是数据量的问题或者说是使用方式的问题了。</p><p>当然，如果你的团队已经维护了成熟的分库分表中间件，用业务分表，对业务开发同学没有额外的复杂性，对DBA也更直观，自然是更好的。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-ebc9290eef1e6eb88a30545292b21094>5.44 - CH44-问题答疑</h1><h2 id=join的写法>join的写法</h2><p>在第35篇文章中，我在介绍join执行顺序的时候，用的都是straight_join。@郭健 同学在文后提出了两个问题：</p><ol><li>如果用left join的话，左边的表一定是驱动表吗？</li><li>如果两个表的join包含多个条件的等值匹配，是都要写到on里面呢，还是只把一个条件写到on里面，其他条件写到where部分？</li></ol><p>为了同时回答这两个问题，我来构造两个表a和b：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>create</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>table</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>a</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>f1</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87>int</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>f2</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87>int</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>index</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>f1</span><span style=color:#000;font-weight:700>))</span><span style=color:#000>engine</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#000>innodb</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>create</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>table</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>b</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>f1</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87>int</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>f2</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87>int</span><span style=color:#000;font-weight:700>)</span><span style=color:#000>engine</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#000>innodb</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>insert</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>into</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>a</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>values</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>),(</span><span style=color:#0000cf;font-weight:700>2</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>2</span><span style=color:#000;font-weight:700>),(</span><span style=color:#0000cf;font-weight:700>3</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>3</span><span style=color:#000;font-weight:700>),(</span><span style=color:#0000cf;font-weight:700>4</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>4</span><span style=color:#000;font-weight:700>),(</span><span style=color:#0000cf;font-weight:700>5</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>5</span><span style=color:#000;font-weight:700>),(</span><span style=color:#0000cf;font-weight:700>6</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>6</span><span style=color:#000;font-weight:700>);</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>insert</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>into</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>b</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>values</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>3</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>3</span><span style=color:#000;font-weight:700>),(</span><span style=color:#0000cf;font-weight:700>4</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>4</span><span style=color:#000;font-weight:700>),(</span><span style=color:#0000cf;font-weight:700>5</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>5</span><span style=color:#000;font-weight:700>),(</span><span style=color:#0000cf;font-weight:700>6</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>6</span><span style=color:#000;font-weight:700>),(</span><span style=color:#0000cf;font-weight:700>7</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>7</span><span style=color:#000;font-weight:700>),(</span><span style=color:#0000cf;font-weight:700>8</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>8</span><span style=color:#000;font-weight:700>);</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><p>表a和b都有两个字段f1和f2，不同的是表a的字段f1上有索引。然后，我往两个表中都插入了6条记录，其中在表a和b中同时存在的数据有4行。</p><p>@郭健 同学提到的第二个问题，其实就是下面这两种写法的区别：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>select</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>*</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>from</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>a</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>left</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>join</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>b</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>on</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>a</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>f1</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#000>b</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>f1</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>and</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>(</span><span style=color:#000>a</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>f2</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#000>b</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>f2</span><span style=color:#000;font-weight:700>);</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#8f5902;font-style:italic>/*Q1*/</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>select</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>*</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>from</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>a</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>left</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>join</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>b</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>on</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>a</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>f1</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#000>b</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>f1</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>where</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>(</span><span style=color:#000>a</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>f2</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#000>b</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>f2</span><span style=color:#000;font-weight:700>);</span><span style=color:#8f5902;font-style:italic>/*Q2*/</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><p>我把这两条语句分别记为Q1和Q2。</p><p>首先，需要说明的是，这两个left join语句的语义逻辑并不相同。我们先来看一下它们的执行结果。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211117225632.png style=display:block;width:80% alt=NAME align=center></div><p>可以看到：</p><ul><li>语句Q1返回的数据集是6行，表a中即使没有满足匹配条件的记录，查询结果中也会返回一行，并将表b的各个字段值填成NULL。</li><li>语句Q2返回的是4行。从逻辑上可以这么理解，最后的两行，由于表b中没有匹配的字段，结果集里面b.f2的值是空，不满足where 部分的条件判断，因此不能作为结果集的一部分。</li></ul><p>接下来，我们看看实际执行这两条语句时，MySQL是怎么做的。</p><p>我们先一起看看语句Q1的explain结果：</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211117225645.png style=display:block;width:80% alt=NAME align=center></div><p>可以看到，这个结果符合我们的预期：</p><ul><li>驱动表是表a，被驱动表是表b；</li><li>由于表b的f1字段上没有索引，所以使用的是Block Nexted Loop Join（简称BNL） 算法。</li></ul><p>看到BNL算法，你就应该知道这条语句的执行流程其实是这样的：</p><ol><li>把表a的内容读入join_buffer 中。因为是select * ，所以字段f1和f2都被放入join_buffer了。</li><li>顺序扫描表b，对于每一行数据，判断join条件（也就是a.f1=b.f1 and a.f2=b.f2)是否满足，满足条件的记录, 作为结果集的一行返回。如果语句中有where子句，需要先判断where部分满足条件后，再返回。</li><li>表b扫描完成后，对于没有被匹配的表a的行（在这个例子中就是(1,1)、(2,2)这两行），把剩余字段补上NULL，再放入结果集中。</li></ol><p>对应的流程图如下：</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211117225658.png style=display:block;width:80% alt=NAME align=center></div><p>可以看到，这条语句确实是以表a为驱动表，而且从执行效果看，也和使用straight_join是一样的。</p><p>你可能会想，语句Q2的查询结果里面少了最后两行数据，是不是就是把上面流程中的步骤3去掉呢？我们还是先看一下语句Q2的expain结果吧。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211117225709.png style=display:block;width:80% alt=NAME align=center></div><p>这里先和你说一句题外话，专栏马上就结束了，我也和你一起根据explain结果“脑补”了很多次一条语句的执行流程了，所以我希望你已经具备了这个能力。今天，我们再一起分析一次SQL语句的explain结果。</p><p>可以看到，这条语句是以表b为驱动表的。而如果一条join语句的Extra字段什么都没写的话，就表示使用的是Index Nested-Loop Join（简称NLJ）算法。</p><p>因此，语句Q2的执行流程是这样的：顺序扫描表b，每一行用b.f1到表a中去查，匹配到记录后判断a.f2=b.f2是否满足，满足条件的话就作为结果集的一部分返回。</p><p>那么，**为什么语句Q1和Q2这两个查询的执行流程会差距这么大呢？**其实，这是因为优化器基于Q2这个查询的语义做了优化。</p><p>为了理解这个问题，我需要再和你交代一个背景知识点：在MySQL里，NULL跟任何值执行等值判断和不等值判断的结果，都是NULL。这里包括， select NULL = NULL 的结果，也是返回NULL。</p><p>因此，语句Q2里面where a.f2=b.f2就表示，查询结果里面不会包含b.f2是NULL的行，这样这个left join的语义就是“找到这两个表里面，f1、f2对应相同的行。对于表a中存在，而表b中匹配不到的行，就放弃”。</p><p>这样，这条语句虽然用的是left join，但是语义跟join是一致的。</p><p>因此，优化器就把这条语句的left join改写成了join，然后因为表a的f1上有索引，就把表b作为驱动表，这样就可以用上NLJ 算法。在执行explain之后，你再执行show warnings，就能看到这个改写的结果，如图5所示。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211117225721.png style=display:block;width:80% alt=NAME align=center></div><p>这个例子说明，即使我们在SQL语句中写成left join，执行过程还是有可能不是从左到右连接的。也就是说，<strong>使用left join时，左边的表不一定是驱动表。</strong></p><p>这样看来，**如果需要left join的语义，就不能把被驱动表的字段放在where条件里面做等值判断或不等值判断，必须都写在on里面。**那如果是join语句呢？</p><p>这时候，我们再看看这两条语句：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>select</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>*</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>from</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>a</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>join</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>b</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>on</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>a</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>f1</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#000>b</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>f1</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>and</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>(</span><span style=color:#000>a</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>f2</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#000>b</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>f2</span><span style=color:#000;font-weight:700>);</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#8f5902;font-style:italic>/*Q3*/</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>select</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>*</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>from</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>a</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>join</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>b</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>on</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>a</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>f1</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#000>b</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>f1</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>where</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>(</span><span style=color:#000>a</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>f2</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#000>b</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>f2</span><span style=color:#000;font-weight:700>);</span><span style=color:#8f5902;font-style:italic>/*Q4*/</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><p>我们再使用一次看explain 和 show warnings的方法，看看优化器是怎么做的。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211117225734.png style=display:block;width:80% alt=NAME align=center></div><p>可以看到，这两条语句都被改写成：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>select</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>*</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>from</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>a</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>join</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>b</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>where</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>(</span><span style=color:#000>a</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>f1</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#000>b</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>f1</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>and</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>(</span><span style=color:#000>a</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>f2</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#000>b</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>f2</span><span style=color:#000;font-weight:700>);</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><p>执行计划自然也是一模一样的。</p><p>也就是说，在这种情况下，join将判断条件是否全部放在on部分就没有区别了。</p><h2 id=simple-nested-loop-join-的性能问题>Simple Nested Loop Join 的性能问题</h2><p>我们知道，join语句使用不同的算法，对语句的性能影响会很大。在第34篇文章的评论区中，@书策稠浊 和 @朝夕心 两位同学提了一个很不错的问题。</p><p>我们在文中说到，虽然BNL算法和Simple Nested Loop Join 算法都是要判断M*N次（M和N分别是join的两个表的行数），但是Simple Nested Loop Join 算法的每轮判断都要走全表扫描，因此性能上BNL算法执行起来会快很多。</p><p>为了便于说明，我还是先为你简单描述一下这两个算法。</p><p>BNL算法的执行逻辑是：</p><ol><li>首先，将驱动表的数据全部读入内存join_buffer中，这里join_buffer是无序数组；</li><li>然后，顺序遍历被驱动表的所有行，每一行数据都跟join_buffer中的数据进行匹配，匹配成功则作为结果集的一部分返回。</li></ol><p>Simple Nested Loop Join算法的执行逻辑是：顺序取出驱动表中的每一行数据，到被驱动表去做全表扫描匹配，匹配成功则作为结果集的一部分返回。</p><p>这两位同学的疑问是，Simple Nested Loop Join算法，其实也是把数据读到内存里，然后按照匹配条件进行判断，为什么性能差距会这么大呢？</p><p>解释这个问题，需要用到MySQL中索引结构和Buffer Pool的相关知识点：</p><ol><li>在对被驱动表做全表扫描的时候，如果数据没有在Buffer Pool中，就需要等待这部分数据从磁盘读入；
从磁盘读入数据到内存中，会影响正常业务的Buffer Pool命中率，而且这个算法天然会对被驱动表的数据做多次访问，更容易将这些数据页放到Buffer Pool的头部（请参考第35篇文章中的相关内容)；</li><li>即使被驱动表数据都在内存中，每次查找“下一个记录的操作”，都是类似指针操作。而join_buffer中是数组，遍历的成本更低。</li></ol><p>所以说，BNL算法的性能会更好。</p><h2 id=distinct-和-group-by的性能>distinct 和 group by的性能</h2><p>在第37篇文章中，@老杨同志 提了一个好问题：如果只需要去重，不需要执行聚合函数，distinct 和group by哪种效率高一些呢？</p><p>我来展开一下他的问题：如果表t的字段a上没有索引，那么下面这两条语句：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>select</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>a</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>from</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>t</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>group</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>by</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>a</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>order</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>by</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>null</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>select</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>distinct</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>a</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>from</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>t</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><p>的性能是不是相同的?</p><p>首先需要说明的是，这种group by的写法，并不是SQL标准的写法。标准的group by语句，是需要在select部分加一个聚合函数，比如：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>select</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>a</span><span style=color:#000;font-weight:700>,</span><span style=color:#204a87;font-weight:700>count</span><span style=color:#000;font-weight:700>(</span><span style=color:#ce5c00;font-weight:700>*</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>from</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>t</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>group</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>by</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>a</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>order</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>by</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>null</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><p>这条语句的逻辑是：按照字段a分组，计算每组的a出现的次数。在这个结果里，由于做的是聚合计算，相同的a只出现一次。</p><blockquote><p>备注：这里你可以顺便复习一下第37篇文章中关于group by的相关内容。</p></blockquote><p>没有了count(*)以后，也就是不再需要执行“计算总数”的逻辑时，第一条语句的逻辑就变成是：按照字段a做分组，相同的a的值只返回一行。而这就是distinct的语义，所以不需要执行聚合函数时，distinct 和group by这两条语句的语义和执行流程是相同的，因此执行性能也相同。</p><p>这两条语句的执行流程是下面这样的。</p><ol><li>创建一个临时表，临时表有一个字段a，并且在这个字段a上创建一个唯一索引；</li><li>遍历表t，依次取数据插入临时表中：<ul><li>如果发现唯一键冲突，就跳过；</li><li>否则插入成功；</li></ul></li><li>遍历完成后，将临时表作为结果集返回给客户端。</li></ol><h2 id=备库自增主键问题>备库自增主键问题</h2><p>除了性能问题，大家对细节的追问也很到位。在第39篇文章评论区，@帽子掉了 同学问到：在binlog_format=statement时，语句A先获取id=1，然后语句B获取id=2；接着语句B提交，写binlog，然后语句A再写binlog。这时候，如果binlog重放，是不是会发生语句B的id为1，而语句A的id为2的不一致情况呢？</p><p>首先，这个问题默认了“自增id的生成顺序，和binlog的写入顺序可能是不同的”，这个理解是正确的。</p><p>其次，这个问题限定在statement格式下，也是对的。因为row格式的binlog就没有这个问题了，Write row event里面直接写了每一行的所有字段的值。</p><p>而至于为什么不会发生不一致的情况，我们来看一下下面的这个例子。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>create</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>table</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>t</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>id</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87>int</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>auto_increment</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>primary</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>key</span><span style=color:#000;font-weight:700>);</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>insert</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>into</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>t</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>values</span><span style=color:#000;font-weight:700>(</span><span style=color:#204a87;font-weight:700>null</span><span style=color:#000;font-weight:700>);</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211117225847.png style=display:block;width:80% alt=NAME align=center></div><p>可以看到，在insert语句之前，还有一句SET INSERT_ID=1。这条命令的意思是，这个线程里下一次需要用到自增值的时候，不论当前表的自增值是多少，固定用1这个值。</p><p>这个SET INSERT_ID语句是固定跟在insert语句之前的，比如@帽子掉了同学提到的场景，主库上语句A的id是1，语句B的id是2，但是写入binlog的顺序先B后A，那么binlog就变成：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#204a87;font-weight:700>SET</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>INSERT_ID</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#0000cf;font-weight:700>2</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#a40000>语句</span><span style=color:#000>B</span><span style=color:#a40000>；</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>SET</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>INSERT_ID</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#a40000>语句</span><span style=color:#000>A</span><span style=color:#a40000>；</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><p>你看，在备库上语句B用到的INSERT_ID依然是2，跟主库相同。</p><p>因此，即使两个INSERT语句在主备库的执行顺序不同，自增主键字段的值也不会不一致。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-4b14a7394e1dbce5cdcb3d0f4ba659af>6 - MySQL 内幕</h1></div><div class=td-content style=page-break-before:always><h1 id=pg-9653d45f3d65839c479cbf585b3db5c7>7 - Redis</h1></div><div class=td-content><h1 id=pg-15dc494595c2bd4672f094c19c69802f>7.1 - CH01-基本类型</h1><h2 id=概览>概览</h2><p>Redis 中所有的 Key 都是字符串。我们在谈基础数据结构时，讨论的是存储值的数据类型，主要包括常见的5种数据类型，分别是：String、List、Set、Zset、Hash。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210504125755.png style=display:block;width:50% alt=NAME align=center></div><table><thead><tr><th>结构类型</th><th>值的形式</th><th>读写能力</th></tr></thead><tbody><tr><td><strong>String</strong></td><td>字符串、整数、浮点数</td><td>对整个字符串或字符串的一部分进行操作；对整数或浮点数进行自增或自减操作；</td></tr><tr><td><strong>List</strong></td><td>由字符串构造的链表</td><td>对链表的两端进行push和pop操作，读取单个或多个元素；根据值查找或删除元素；</td></tr><tr><td><strong>Set</strong></td><td>由无重复字符串构成的集合</td><td>字符串的集合，包含基础的方法有看是否存在添加、获取、删除；还包含计算交集、并集、差集等</td></tr><tr><td><strong>Hash</strong></td><td>由键值对构成的无序散列表</td><td>包含方法有添加、获取、删除单个元素</td></tr><tr><td><strong>Zset</strong></td><td>由键值对构成的有序集合</td><td>字符串成员与浮点数分数之间的有序映射；元素的排列顺序由分数的大小决定；包含方法有添加、获取、删除单个元素以及根据分值范围或成员来获取元素</td></tr></tbody></table><h2 id=string>String</h2><p>String是redis中最基本的数据类型，一个key对应一个value。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210504130432.png style=display:block;width:50% alt=NAME align=center></div><h3 id=常用命令>常用命令</h3><table><thead><tr><th>命令</th><th>简述</th><th>使用</th></tr></thead><tbody><tr><td>GET</td><td>获取存储在给定键中的值</td><td>GET name</td></tr><tr><td>SET</td><td>设置存储在给定键中的值</td><td>SET name value</td></tr><tr><td>DEL</td><td>删除存储在给定键中的值</td><td>DEL name</td></tr><tr><td>INCR</td><td>将键存储的值加1</td><td>INCR key</td></tr><tr><td>DECR</td><td>将键存储的值减1</td><td>DECR key</td></tr><tr><td>INCRBY</td><td>将键存储的值加上整数</td><td>INCRBY key amount</td></tr><tr><td>DECRBY</td><td>将键存储的值减去整数</td><td>DECRBY key amount</td></tr></tbody></table><h3 id=应用场景>应用场景</h3><ul><li><p><strong>缓存</strong>： 经典使用场景，把常用信息，字符串，图片或者视频等信息放到redis中，redis作为缓存层，mysql做持久化层，降低mysql的读写压力。</p></li><li><p><strong>计数器</strong>：redis是单线程模型，一个命令执行完才会执行下一个，同时数据可以一步落地到其他的数据源。</p></li><li><p><strong>session</strong>：常见方案spring session + redis实现session共享</p></li></ul><h2 id=list>List</h2><p>Redis中的List其实就是链表（Redis用双端链表实现List）。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210504130444.png style=display:block;width:50% alt=NAME align=center></div><h3 id=常用命令-1>常用命令</h3><table><thead><tr><th>命令</th><th>简述</th><th>使用</th></tr></thead><tbody><tr><td>RPUSH</td><td>将给定值推入到列表右端</td><td>RPUSH key value</td></tr><tr><td>LPUSH</td><td>将给定值推入到列表左端</td><td>LPUSH key value</td></tr><tr><td>RPOP</td><td>从列表的右端弹出一个值，并返回被弹出的值</td><td>RPOP key</td></tr><tr><td>LPOP</td><td>从列表的左端弹出一个值，并返回被弹出的值</td><td>LPOP key</td></tr><tr><td>LRANGE</td><td>获取列表在给定范围上的所有值</td><td>LRANGE key 0 -1</td></tr><tr><td>LINDEX</td><td>通过索引获取列表中的元素。你也可以使用负数下标，以 -1 表示列表的最后一个元素， -2 表示列表的倒数第二个元素，以此类推。</td><td>LINEX key index</td></tr></tbody></table><h3 id=应用场景-1>应用场景</h3><ul><li><strong>微博TimeLine</strong>: 有人发布微博，用lpush加入时间轴，展示新的列表信息。</li><li><strong>消息队列</strong></li></ul><h2 id=set>Set</h2><p>Redis 的 Set 是 String 类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据。</p><p>Redis 中集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210504130624.png style=display:block;width:50% alt=NAME align=center></div><h3 id=常用命令-2>常用命令</h3><table><thead><tr><th>命令</th><th>简述</th><th>使用</th></tr></thead><tbody><tr><td>SADD</td><td>向集合添加一个或多个成员</td><td>SADD key value</td></tr><tr><td>SCARD</td><td>获取集合的成员数</td><td>SCARD key</td></tr><tr><td>SMEMBER</td><td>返回集合中的所有成员</td><td>SMEMBER key member</td></tr><tr><td>SISMEMBER</td><td>判断 member 元素是否是集合 key 的成员</td><td>SISMEMBER key member</td></tr></tbody></table><h3 id=应用场景-2>应用场景</h3><p><strong>实战场景</strong></p><ul><li><strong>标签</strong>（tag）,给用户添加标签，或者用户给消息添加标签，这样有同一标签或者类似标签的可以给推荐关注的事或者关注的人。</li><li><strong>点赞，或点踩，收藏等</strong>，可以放到set中实现</li></ul><h2 id=hash>Hash</h2><p>Redis hash 是一个 string 类型的 field（字段） 和 value（值） 的映射表，hash 特别适合用于存储对象。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210504130731.png style=display:block;width:50% alt=NAME align=center></div><h3 id=常用命令-3>常用命令</h3><table><thead><tr><th>命令</th><th>简述</th><th>使用</th></tr></thead><tbody><tr><td>HSET</td><td>添加键值对</td><td>HSET hash-key sub-key1 value1</td></tr><tr><td>HGET</td><td>获取指定散列键的值</td><td>HGET hash-key key1</td></tr><tr><td>HGETALL</td><td>获取散列中包含的所有键值对</td><td>HGETALL hash-key</td></tr><tr><td>HDEL</td><td>如果给定键存在于散列中，那么就移除这个键</td><td>HDEL hash-key sub-key1</td></tr></tbody></table><h3 id=应用场景-3>应用场景</h3><ul><li><strong>缓存</strong>： 能直观，相比string更节省空间，的维护缓存信息，如用户信息，视频信息等。</li></ul><h2 id=zset>ZSet</h2><p>Redis 有序集合和集合一样也是 string 类型元素的集合,且不允许重复的成员。不同的是每个元素都会关联一个 double 类型的分数。redis 正是通过分数来为集合中的成员进行从小到大的排序。</p><p>有序集合的成员是唯一的,但分数(score)却可以重复。集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210504130854.png style=display:block;width:50% alt=NAME align=center></div><h3 id=常用命令-4>常用命令</h3><table><thead><tr><th>命令</th><th>简述</th><th>使用</th></tr></thead><tbody><tr><td>ZADD</td><td>将一个带有给定分值的成员添加到哦有序集合里面</td><td>ZADD zset-key 178 member1</td></tr><tr><td>ZRANGE</td><td>根据元素在有序集合中所处的位置，从有序集合中获取多个元素</td><td>ZRANGE zset-key 0-1 withccores</td></tr><tr><td>ZREM</td><td>如果给定元素成员存在于有序集合中，那么就移除这个元素</td><td>ZREM zset-key member1</td></tr></tbody></table><h3 id=应用场景-4>应用场景</h3><ul><li><strong>排行榜</strong>：有序集合经典使用场景。例如小说视频等网站需要对用户上传的小说视频做排行榜，榜单可以按照用户关注数，更新时间，字数等打分，做排行。</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-74fbd382412792c903e2f596fdcce9b7>7.2 - CH02-高级类型</h1><h2 id=hyperloglogs基数>HyperLogLogs：基数</h2><h3 id=什么是基数>什么是基数</h3><p>举个例子，A = {1, 2, 3, 4, 5}， B = {3, 5, 6, 7, 9}；那么基数（不重复的元素）= 1, 2, 4, 6, 7, 9； （允许容错，即可以接受一定误差）</p><h3 id=基本用途>基本用途</h3><p>这个结构可以非常省内存的去统计各种计数，比如注册 IP 数、每日访问 IP 数、页面实时UV、在线用户数，共同好友数等。</p><h3 id=结构优点>结构优点</h3><p>一个大型的网站，每天 IP 比如有 100 万，粗算一个 IP 消耗 15 字节，那么 100 万个 IP 就是 15M。而 HyperLogLog 在 Redis 中每个键占用的内容都是 12K，理论存储近似接近 2^64 个值，不管存储的内容是什么，它一个基于基数估算的算法，只能比较准确的估算出基数，可以使用少量固定的内存去存储并识别集合中的唯一元素。而且这个估算的基数并不一定准确，是一个带有 0.81% 标准错误的近似值（对于可以接受一定容错的业务场景，比如IP数统计，UV等，是可以忽略不计的）。</p><h3 id=操作命令>操作命令</h3><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>127.0.0.1:6379&gt; pfadd key1 a b c d e f g h i	<span style=color:#8f5902;font-style:italic># 创建第一组元素</span>
</span></span><span style=display:flex><span><span style=color:#ce5c00;font-weight:700>(</span>integer<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#0000cf;font-weight:700>1</span>
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; pfcount key1					<span style=color:#8f5902;font-style:italic># 统计元素的基数数量</span>
</span></span><span style=display:flex><span><span style=color:#ce5c00;font-weight:700>(</span>integer<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#0000cf;font-weight:700>9</span>
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; pfadd key2 c j k l m e g a		<span style=color:#8f5902;font-style:italic># 创建第二组元素</span>
</span></span><span style=display:flex><span><span style=color:#ce5c00;font-weight:700>(</span>integer<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#0000cf;font-weight:700>1</span>
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; pfcount key2
</span></span><span style=display:flex><span><span style=color:#ce5c00;font-weight:700>(</span>integer<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#0000cf;font-weight:700>8</span>
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; pfmerge key3 key1 key2			<span style=color:#8f5902;font-style:italic># 合并两组：key1 key2 -&gt; key3 并集</span>
</span></span><span style=display:flex><span>OK
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; pfcount key3
</span></span><span style=display:flex><span><span style=color:#ce5c00;font-weight:700>(</span>integer<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#0000cf;font-weight:700>13</span>
</span></span></code></pre></div><h2 id=bitmap位图>Bitmap：位图</h2><p>Bitmap 即位图数据结构，都是操作二进制位来进行记录，只有0 和 1 两个状态。</p><h3 id=基本用途-1>基本用途</h3><p>比如：统计用户信息，活跃，不活跃！ 登录，未登录！ 打卡，不打卡！ <strong>两个状态的，都可以使用 Bitmaps</strong>！</p><p>如果存储一年的打卡状态需要多少内存呢？ 365 天 = 365 bit 1字节 = 8bit 46 个字节左右！</p><h3 id=操作命令-1>操作命令</h3><p>使用bitmap 来记录 周一到周日的打卡！ 周一：1 周二：0 周三：0 周四：1 &mldr;&mldr;</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>127.0.0.1:6379&gt; setbit sign <span style=color:#0000cf;font-weight:700>0</span> <span style=color:#0000cf;font-weight:700>1</span>
</span></span><span style=display:flex><span><span style=color:#ce5c00;font-weight:700>(</span>integer<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#0000cf;font-weight:700>0</span>
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; setbit sign <span style=color:#0000cf;font-weight:700>1</span> <span style=color:#0000cf;font-weight:700>1</span>
</span></span><span style=display:flex><span><span style=color:#ce5c00;font-weight:700>(</span>integer<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#0000cf;font-weight:700>0</span>
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; setbit sign <span style=color:#0000cf;font-weight:700>2</span> <span style=color:#0000cf;font-weight:700>0</span>
</span></span><span style=display:flex><span><span style=color:#ce5c00;font-weight:700>(</span>integer<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#0000cf;font-weight:700>0</span>
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; setbit sign <span style=color:#0000cf;font-weight:700>3</span> <span style=color:#0000cf;font-weight:700>1</span>
</span></span><span style=display:flex><span><span style=color:#ce5c00;font-weight:700>(</span>integer<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#0000cf;font-weight:700>0</span>
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; setbit sign <span style=color:#0000cf;font-weight:700>4</span> <span style=color:#0000cf;font-weight:700>0</span>
</span></span><span style=display:flex><span><span style=color:#ce5c00;font-weight:700>(</span>integer<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#0000cf;font-weight:700>0</span>
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; setbit sign <span style=color:#0000cf;font-weight:700>5</span> <span style=color:#0000cf;font-weight:700>0</span>
</span></span><span style=display:flex><span><span style=color:#ce5c00;font-weight:700>(</span>integer<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#0000cf;font-weight:700>0</span>
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; setbit sign <span style=color:#0000cf;font-weight:700>6</span> <span style=color:#0000cf;font-weight:700>1</span>
</span></span><span style=display:flex><span><span style=color:#ce5c00;font-weight:700>(</span>integer<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#0000cf;font-weight:700>0</span>
</span></span></code></pre></div><p>查看某一天是否有打卡！</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>127.0.0.1:6379&gt; getbit sign <span style=color:#0000cf;font-weight:700>3</span>
</span></span><span style=display:flex><span><span style=color:#ce5c00;font-weight:700>(</span>integer<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#0000cf;font-weight:700>1</span>
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; getbit sign <span style=color:#0000cf;font-weight:700>5</span>
</span></span><span style=display:flex><span><span style=color:#ce5c00;font-weight:700>(</span>integer<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#0000cf;font-weight:700>0</span>
</span></span></code></pre></div><p>统计操作，统计 打卡的天数！</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>127.0.0.1:6379&gt; bitcount sign <span style=color:#8f5902;font-style:italic># 统计这周的打卡记录，就可以看到是否有全勤！</span>
</span></span><span style=display:flex><span><span style=color:#ce5c00;font-weight:700>(</span>integer<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#0000cf;font-weight:700>3</span>
</span></span></code></pre></div><h2 id=geospatial地理位置>Geospatial：地理位置</h2><p>用于地理位置坐标的存储与计算。</p><h3 id=添加地理位置>添加地理位置</h3><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>127.0.0.1:6379&gt; geoadd china:city 118.76 32.04 manjing 112.55 37.86 taiyuan 123.43 41.80 shenyang
</span></span><span style=display:flex><span><span style=color:#ce5c00;font-weight:700>(</span>integer<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#0000cf;font-weight:700>3</span>
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; geoadd china:city 144.05 22.52 shengzhen 120.16 30.24 hangzhou 108.96 34.26 xian
</span></span><span style=display:flex><span><span style=color:#ce5c00;font-weight:700>(</span>integer<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#0000cf;font-weight:700>3</span>
</span></span></code></pre></div><h3 id=获取地理位置>获取地理位置</h3><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>127.0.0.1:6379&gt; geopos china:city taiyuan manjing
</span></span><span style=display:flex><span>1<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;112.54999905824661255&#34;</span>
</span></span><span style=display:flex><span>   1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;37.86000073876942196&#34;</span>
</span></span><span style=display:flex><span>2<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;118.75999957323074341&#34;</span>
</span></span><span style=display:flex><span>   1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;32.03999960287850968&#34;</span>
</span></span></code></pre></div><h3 id=计算距离>计算距离</h3><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>127.0.0.1:6379&gt; geodist china:city taiyuan shenyang m
</span></span><span style=display:flex><span><span style=color:#4e9a06>&#34;1026439.1070&#34;</span>
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; geodist china:city taiyuan shenyang km
</span></span><span style=display:flex><span><span style=color:#4e9a06>&#34;1026.4391&#34;</span>
</span></span></code></pre></div><h3 id=范围查找>范围查找</h3><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span><span style=color:#8f5902;font-style:italic># 以 100,30 这个坐标为中心, 寻找半径为1000km的城市</span>
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; georadius china:city <span style=color:#0000cf;font-weight:700>110</span> <span style=color:#0000cf;font-weight:700>30</span> <span style=color:#0000cf;font-weight:700>1000</span> km
</span></span><span style=display:flex><span>1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;xian&#34;</span>
</span></span><span style=display:flex><span>2<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;hangzhou&#34;</span>
</span></span><span style=display:flex><span>3<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;manjing&#34;</span>
</span></span><span style=display:flex><span>4<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;taiyuan&#34;</span>
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; georadius china:city <span style=color:#0000cf;font-weight:700>110</span> <span style=color:#0000cf;font-weight:700>30</span> <span style=color:#0000cf;font-weight:700>500</span> km
</span></span><span style=display:flex><span>1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;xian&#34;</span>
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; georadius china:city <span style=color:#0000cf;font-weight:700>110</span> <span style=color:#0000cf;font-weight:700>30</span> <span style=color:#0000cf;font-weight:700>500</span> km withdist
</span></span><span style=display:flex><span>1<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;xian&#34;</span>
</span></span><span style=display:flex><span>   2<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;483.8340&#34;</span>
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; georadius china:city <span style=color:#0000cf;font-weight:700>110</span> <span style=color:#0000cf;font-weight:700>30</span> <span style=color:#0000cf;font-weight:700>1000</span> km withcoord withdist count <span style=color:#0000cf;font-weight:700>2</span>
</span></span><span style=display:flex><span>1<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;xian&#34;</span>
</span></span><span style=display:flex><span>   2<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;483.8340&#34;</span>
</span></span><span style=display:flex><span>   3<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;108.96000176668167114&#34;</span>
</span></span><span style=display:flex><span>      2<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;34.25999964418929977&#34;</span>
</span></span><span style=display:flex><span>2<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;manjing&#34;</span>
</span></span><span style=display:flex><span>   2<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;864.9816&#34;</span>
</span></span><span style=display:flex><span>   3<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;118.75999957323074341&#34;</span>
</span></span><span style=display:flex><span>      2<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;32.03999960287850968&#34;</span>
</span></span></code></pre></div><p>参数：key 经度 纬度 半径 单位 显示结果的经度和纬度 显示结果的距离 显示的结果的数量</p><h3 id=范围相交>范围相交</h3><p>显示与指定成员一定半径范围内的其他成员：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>127.0.0.1:6379&gt; georadiusbymember china:city taiyuan <span style=color:#0000cf;font-weight:700>1000</span> km
</span></span><span style=display:flex><span>1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;manjing&#34;</span>
</span></span><span style=display:flex><span>2<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;taiyuan&#34;</span>
</span></span><span style=display:flex><span>3<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;xian&#34;</span>
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; georadiusbymember china:city taiyuan <span style=color:#0000cf;font-weight:700>1000</span> km withcoord withdist count <span style=color:#0000cf;font-weight:700>2</span>
</span></span><span style=display:flex><span>1<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;taiyuan&#34;</span>
</span></span><span style=display:flex><span>   2<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;0.0000&#34;</span>
</span></span><span style=display:flex><span>   3<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;112.54999905824661255&#34;</span>
</span></span><span style=display:flex><span>      2<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;37.86000073876942196&#34;</span>
</span></span><span style=display:flex><span>2<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;xian&#34;</span>
</span></span><span style=display:flex><span>   2<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;514.2264&#34;</span>
</span></span><span style=display:flex><span>   3<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;108.96000176668167114&#34;</span>
</span></span><span style=display:flex><span>      2<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;34.25999964418929977&#34;</span>
</span></span></code></pre></div><h3 id=取-hash-值>取 Hash 值</h3><p>将二维的经纬度转换为一维的字符串, 如果两个字符串越接近, 则距离越近</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>127.0.0.1:6379&gt; geohash china:city taiyuan shenyang
</span></span><span style=display:flex><span>1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;ww8p3hhqmp0&#34;</span>
</span></span><span style=display:flex><span>2<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;wxrvb9qyxk0&#34;</span>
</span></span></code></pre></div><h3 id=底层实现>底层实现</h3><p>geo底层的实现原理实际上就是Zset, 我们可以通过Zset命令来操作geo：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>127.0.0.1:6379&gt; <span style=color:#204a87>type</span> china:city
</span></span><span style=display:flex><span>zset
</span></span></code></pre></div><p>查看全部元素 删除指定的元素：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>127.0.0.1:6379&gt; zrange china:city <span style=color:#0000cf;font-weight:700>0</span> -1 withscores
</span></span><span style=display:flex><span> 1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;xian&#34;</span>
</span></span><span style=display:flex><span> 2<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;4040115445396757&#34;</span>
</span></span><span style=display:flex><span> 3<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;hangzhou&#34;</span>
</span></span><span style=display:flex><span> 4<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;4054133997236782&#34;</span>
</span></span><span style=display:flex><span> 5<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;manjing&#34;</span>
</span></span><span style=display:flex><span> 6<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;4066006694128997&#34;</span>
</span></span><span style=display:flex><span> 7<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;taiyuan&#34;</span>
</span></span><span style=display:flex><span> 8<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;4068216047500484&#34;</span>
</span></span><span style=display:flex><span> 9<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;shenyang&#34;</span>
</span></span><span style=display:flex><span>1<span style=color:#ce5c00;font-weight:700>)</span>  <span style=color:#4e9a06>&#34;4072519231994779&#34;</span>
</span></span><span style=display:flex><span>2<span style=color:#ce5c00;font-weight:700>)</span>  <span style=color:#4e9a06>&#34;shengzhen&#34;</span>
</span></span><span style=display:flex><span>3<span style=color:#ce5c00;font-weight:700>)</span>  <span style=color:#4e9a06>&#34;4154606886655324&#34;</span>
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; zrem china:city manjing
</span></span><span style=display:flex><span><span style=color:#ce5c00;font-weight:700>(</span>integer<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#0000cf;font-weight:700>1</span>
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; zrange china:city <span style=color:#0000cf;font-weight:700>0</span> -1
</span></span><span style=display:flex><span>1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;xian&#34;</span>
</span></span><span style=display:flex><span>2<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;hangzhou&#34;</span>
</span></span><span style=display:flex><span>3<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;taiyuan&#34;</span>
</span></span><span style=display:flex><span>4<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;shenyang&#34;</span>
</span></span><span style=display:flex><span>5<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;shengzhen&#34;</span>
</span></span></code></pre></div></div><div class=td-content style=page-break-before:always><h1 id=pg-fa602568c373b012706150061f875875>7.3 - CH03-Stream</h1><h2 id=概览>概览</h2><p>Redis5.0 中还增加了一个数据结构Stream，从字面上看是流类型，但其实从功能上看，应该是Redis对消息队列（MQ，Message Queue）的完善实现。</p><p>用过Redis做消息队列的都了解，基于Reids的消息队列实现有很多种，例如：</p><ul><li>PUB/SUB，订阅/发布模式：<ul><li>但是发布订阅模式是无法持久化的，如果出现网络断开、Redis 宕机等，消息就会被丢弃；</li></ul></li><li>基于 List LPUSH+BRPOP 或者基于Sorted-Set 的实现：<ul><li>支持了持久化，但是不支持多播，分组消费等</li></ul></li></ul><p>为什么上面的结构无法满足广泛的MQ场景？ 这里便引出一个核心的问题：如果我们期望设计一种数据结构来实现消息队列，最重要的就是要理解<strong>设计一个消息队列需要考虑什么</strong>？初步的我们很容易想到</p><ul><li>消息的生产</li><li>消息的消费<ul><li>单播和多播（多对多）</li><li>阻塞和非阻塞读取</li></ul></li><li>消息有序性</li><li>消息的持久化</li></ul><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210504132556.png style=display:block;width:50% alt=NAME align=center></div><h2 id=基本结构>基本结构</h2><p>每个 Stream 都有唯一的名称，它就是 Redis 的 key，在我们首次使用 xadd 指令追加消息时自动创建。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210504132658.png style=display:block;width:50% alt=NAME align=center></div><p>上图解析：</p><ul><li><code>Consumer Group</code> ：消费组，使用 XGROUP CREATE 命令创建，一个消费组有多个消费者(Consumer), 这些消费者之间是竞争关系。</li><li><code>last_delivered_id</code> ：游标，每个消费组会有个游标 last_delivered_id，任意一个消费者读取了消息都会使游标 last_delivered_id 往前移动。</li><li><code>pending_ids</code> ：消费者(Consumer)的状态变量，作用是维护消费者的未确认的 id。 pending_ids 记录了当前已经被客户端读取的消息，但是还没有 <code>ack</code> (Acknowledge character：确认字符）。如果客户端没有ack，这个变量里面的消息ID会越来越多，一旦某个消息被ack，它就开始减少。这个pending_ids变量在Redis官方被称之为PEL，也就是Pending Entries List，这是一个很核心的数据结构，它用来确保客户端至少消费了消息一次，而不会在网络传输的中途丢失了没处理。</li></ul><p>此外我们还需要理解两点：</p><ul><li><code>消息ID</code>: 消息ID的形式是timestampInMillis-sequence，例如1527846880572-5，它表示当前的消息在毫米时间戳1527846880572时产生，并且是该毫秒内产生的第5条消息。消息ID可以由服务器自动生成，也可以由客户端自己指定，但是形式必须是整数-整数，而且必须是后面加入的消息的ID要大于前面的消息ID。</li><li><code>消息内容</code>: 消息内容就是键值对，形如hash结构的键值对，这没什么特别之处。</li></ul><h2 id=基本操作>基本操作</h2><p>消息队列相关命令：</p><ul><li>XADD - 添加消息到末尾</li><li>XTRIM - 对流进行修剪，限制长度</li><li>XDEL - 删除消息</li><li>XLEN - 获取流包含的元素数量，即消息长度</li><li>XRANGE - 获取消息列表，会自动过滤已经删除的消息</li><li>XREVRANGE - 反向获取消息列表，ID 从大到小</li><li>XREAD - 以阻塞或非阻塞方式获取消息列表</li></ul><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span><span style=color:#8f5902;font-style:italic># *号表示服务器自动生成ID，后面顺序跟着一堆key/value</span>
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; xadd codehole * name laoqian age <span style=color:#0000cf;font-weight:700>30</span>  <span style=color:#8f5902;font-style:italic>#  名字叫laoqian，年龄30岁</span>
</span></span><span style=display:flex><span>1527849609889-0  <span style=color:#8f5902;font-style:italic># 生成的消息ID</span>
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; xadd codehole * name xiaoyu age <span style=color:#0000cf;font-weight:700>29</span>
</span></span><span style=display:flex><span>1527849629172-0
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; xadd codehole * name xiaoqian age <span style=color:#0000cf;font-weight:700>1</span>
</span></span><span style=display:flex><span>1527849637634-0
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; xlen codehole
</span></span><span style=display:flex><span><span style=color:#ce5c00;font-weight:700>(</span>integer<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#0000cf;font-weight:700>3</span>
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; xrange codehole - +  <span style=color:#8f5902;font-style:italic># -表示最小值, +表示最大值</span>
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; xrange codehole - +
</span></span><span style=display:flex><span>1<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> 1527849609889-0
</span></span><span style=display:flex><span>   1<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;name&#34;</span>
</span></span><span style=display:flex><span>      1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;laoqian&#34;</span>
</span></span><span style=display:flex><span>      2<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;age&#34;</span>
</span></span><span style=display:flex><span>      3<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;30&#34;</span>
</span></span><span style=display:flex><span>2<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> 1527849629172-0
</span></span><span style=display:flex><span>   1<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;name&#34;</span>
</span></span><span style=display:flex><span>      1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;xiaoyu&#34;</span>
</span></span><span style=display:flex><span>      2<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;age&#34;</span>
</span></span><span style=display:flex><span>      3<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;29&#34;</span>
</span></span><span style=display:flex><span>3<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> 1527849637634-0
</span></span><span style=display:flex><span>   1<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;name&#34;</span>
</span></span><span style=display:flex><span>      1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;xiaoqian&#34;</span>
</span></span><span style=display:flex><span>      2<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;age&#34;</span>
</span></span><span style=display:flex><span>      3<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;1&#34;</span>
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; xrange codehole 1527849629172-0 +  <span style=color:#8f5902;font-style:italic># 指定最小消息ID的列表</span>
</span></span><span style=display:flex><span>1<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> 1527849629172-0
</span></span><span style=display:flex><span>   2<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;name&#34;</span>
</span></span><span style=display:flex><span>      2<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;xiaoyu&#34;</span>
</span></span><span style=display:flex><span>      3<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;age&#34;</span>
</span></span><span style=display:flex><span>      4<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;29&#34;</span>
</span></span><span style=display:flex><span>2<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> 1527849637634-0
</span></span><span style=display:flex><span>   2<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;name&#34;</span>
</span></span><span style=display:flex><span>      2<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;xiaoqian&#34;</span>
</span></span><span style=display:flex><span>      3<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;age&#34;</span>
</span></span><span style=display:flex><span>      4<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;1&#34;</span>
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; xrange codehole - 1527849629172-0  <span style=color:#8f5902;font-style:italic># 指定最大消息ID的列表</span>
</span></span><span style=display:flex><span>1<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> 1527849609889-0
</span></span><span style=display:flex><span>   2<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;name&#34;</span>
</span></span><span style=display:flex><span>      2<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;laoqian&#34;</span>
</span></span><span style=display:flex><span>      3<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;age&#34;</span>
</span></span><span style=display:flex><span>      4<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;30&#34;</span>
</span></span><span style=display:flex><span>2<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> 1527849629172-0
</span></span><span style=display:flex><span>   2<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;name&#34;</span>
</span></span><span style=display:flex><span>      2<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;xiaoyu&#34;</span>
</span></span><span style=display:flex><span>      3<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;age&#34;</span>
</span></span><span style=display:flex><span>      4<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;29&#34;</span>
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; xdel codehole 1527849609889-0
</span></span><span style=display:flex><span><span style=color:#ce5c00;font-weight:700>(</span>integer<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#0000cf;font-weight:700>1</span>
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; xlen codehole  <span style=color:#8f5902;font-style:italic># 长度不受影响</span>
</span></span><span style=display:flex><span><span style=color:#ce5c00;font-weight:700>(</span>integer<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#0000cf;font-weight:700>3</span>
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; xrange codehole - +  <span style=color:#8f5902;font-style:italic># 被删除的消息没了</span>
</span></span><span style=display:flex><span>1<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> 1527849629172-0
</span></span><span style=display:flex><span>   2<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;name&#34;</span>
</span></span><span style=display:flex><span>      2<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;xiaoyu&#34;</span>
</span></span><span style=display:flex><span>      3<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;age&#34;</span>
</span></span><span style=display:flex><span>      4<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;29&#34;</span>
</span></span><span style=display:flex><span>2<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> 1527849637634-0
</span></span><span style=display:flex><span>   2<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;name&#34;</span>
</span></span><span style=display:flex><span>      2<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;xiaoqian&#34;</span>
</span></span><span style=display:flex><span>      3<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;age&#34;</span>
</span></span><span style=display:flex><span>      4<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;1&#34;</span>
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; del codehole  <span style=color:#8f5902;font-style:italic># 删除整个Stream</span>
</span></span><span style=display:flex><span><span style=color:#ce5c00;font-weight:700>(</span>integer<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#0000cf;font-weight:700>1</span>
</span></span></code></pre></div><h2 id=独立消费>独立消费</h2><p>我们可以在不定义消费组的情况下进行Stream消息的独立消费，当Stream没有新消息时，甚至可以阻塞等待。Redis设计了一个单独的消费指令xread，可以将Stream当成普通的消息队列(list)来使用。使用xread时，我们可以完全忽略消费组(Consumer Group)的存在，就好比Stream就是一个普通的列表(list)。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#8f5902;font-style:italic># 从Stream头部读取两条消息</span>
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; xread count <span style=color:#0000cf;font-weight:700>2</span> streams codehole 0-0
</span></span><span style=display:flex><span>1<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;codehole&#34;</span>
</span></span><span style=display:flex><span>   2<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> 1527851486781-0
</span></span><span style=display:flex><span>         2<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;name&#34;</span>
</span></span><span style=display:flex><span>            2<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;laoqian&#34;</span>
</span></span><span style=display:flex><span>            3<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;age&#34;</span>
</span></span><span style=display:flex><span>            4<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;30&#34;</span>
</span></span><span style=display:flex><span>      2<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> 1527851493405-0
</span></span><span style=display:flex><span>         2<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;name&#34;</span>
</span></span><span style=display:flex><span>            2<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;yurui&#34;</span>
</span></span><span style=display:flex><span>            3<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;age&#34;</span>
</span></span><span style=display:flex><span>            4<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;29&#34;</span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic># 从Stream尾部读取一条消息，毫无疑问，这里不会返回任何消息</span>
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; xread count <span style=color:#0000cf;font-weight:700>1</span> streams codehole $
</span></span><span style=display:flex><span><span style=color:#ce5c00;font-weight:700>(</span>nil<span style=color:#ce5c00;font-weight:700>)</span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic># 从尾部阻塞等待新消息到来，下面的指令会堵住，直到新消息到来</span>
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; xread block <span style=color:#0000cf;font-weight:700>0</span> count <span style=color:#0000cf;font-weight:700>1</span> streams codehole $
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic># 我们从新打开一个窗口，在这个窗口往Stream里塞消息</span>
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; xadd codehole * name youming age <span style=color:#0000cf;font-weight:700>60</span>
</span></span><span style=display:flex><span>1527852774092-0
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic># 再切换到前面的窗口，我们可以看到阻塞解除了，返回了新的消息内容</span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic># 而且还显示了一个等待时间，这里我们等待了93s</span>
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; xread block <span style=color:#0000cf;font-weight:700>0</span> count <span style=color:#0000cf;font-weight:700>1</span> streams codehole $
</span></span><span style=display:flex><span>1<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;codehole&#34;</span>
</span></span><span style=display:flex><span>   2<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> 1527852774092-0
</span></span><span style=display:flex><span>         2<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;name&#34;</span>
</span></span><span style=display:flex><span>            2<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;youming&#34;</span>
</span></span><span style=display:flex><span>            3<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;age&#34;</span>
</span></span><span style=display:flex><span>            4<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;60&#34;</span>
</span></span><span style=display:flex><span><span style=color:#ce5c00;font-weight:700>(</span>93.11s<span style=color:#ce5c00;font-weight:700>)</span>
</span></span></code></pre></div><p>客户端如果想要使用xread进行顺序消费，一定要记住当前消费到哪里了，也就是返回的消息ID。下次继续调用xread时，将上次返回的最后一个消息ID作为参数传递进去，就可以继续消费后续的消息。</p><p>block 0表示永远阻塞，直到消息到来，block 1000表示阻塞1s，如果1s内没有任何消息到来，就返回nil</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>127.0.0.1:6379&gt; xread block <span style=color:#0000cf;font-weight:700>1000</span> count <span style=color:#0000cf;font-weight:700>1</span> streams codehole $
</span></span><span style=display:flex><span><span style=color:#ce5c00;font-weight:700>(</span>nil<span style=color:#ce5c00;font-weight:700>)</span>
</span></span><span style=display:flex><span><span style=color:#ce5c00;font-weight:700>(</span>1.07s<span style=color:#ce5c00;font-weight:700>)</span>
</span></span></code></pre></div><h2 id=按组消费>按组消费</h2><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210504133052.png style=display:block;width:50% alt=NAME align=center></div><h3 id=相关命令>相关命令</h3><ul><li>XGROUP CREATE - 创建消费者组</li><li>XREADGROUP GROUP - 读取消费者组中的消息</li><li>XACK - 将消息标记为"已处理"</li><li>XGROUP SETID - 为消费者组设置新的最后递送消息ID</li><li>XGROUP DELCONSUMER - 删除消费者</li><li>XGROUP DESTROY - 删除消费者组</li><li>XPENDING - 显示待处理消息的相关信息</li><li>XCLAIM - 转移消息的归属权</li><li>XINFO - 查看流和消费者组的相关信息；</li><li>XINFO GROUPS - 打印消费者组的信息；</li><li>XINFO STREAM - 打印流信息</li></ul><p>Stream通过xgroup create指令创建消费组(Consumer Group)，需要传递起始消息ID参数用来初始化last_delivered_id变量。</p><p>Stream提供了xreadgroup指令可以进行消费组的组内消费，需要提供消费组名称、消费者名称和起始消息ID。它同xread一样，也可以阻塞等待新消息。读到新消息后，对应的消息ID就会进入消费者的PEL(正在处理的消息)结构里，客户端处理完毕后使用xack指令通知服务器，本条消息已经处理完毕，该消息ID就会从PEL中移除。</p><h3 id=信息监控>信息监控</h3><p>Stream提供了XINFO来实现对服务器信息的监控，可以查询：</p><ul><li>查看队列信息</li><li>消费组信息</li><li>消费者组成员信息</li></ul><h3 id=应用场景>应用场景</h3><p>可用作时通信等，大数据分析，异地数据备份等</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210504135014.png style=display:block;width:50% alt=NAME align=center></div><p>客户端可以平滑扩展，提高处理能力</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210504135029.png style=display:block;width:50% alt=NAME align=center></div><h3 id=消息id的设计是否考虑了时间回拨的问题>消息ID的设计是否考虑了时间回拨的问题</h3><p>XADD生成的1553439850328-0，就是Redis生成的消息ID，由两部分组成:<strong>时间戳-序号</strong>。时间戳是毫秒级单位，是生成消息的Redis服务器时间，它是个64位整型（int64）。序号是在这个毫秒时间点内的消息序号，它也是个64位整型。</p><p>可以通过multi批处理，来验证序号的递增：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>127.0.0.1:6379&gt; MULTI
</span></span><span style=display:flex><span>OK
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; XADD memberMessage * msg one
</span></span><span style=display:flex><span>QUEUED
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; XADD memberMessage * msg two
</span></span><span style=display:flex><span>QUEUED
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; XADD memberMessage * msg three
</span></span><span style=display:flex><span>QUEUED
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; XADD memberMessage * msg four
</span></span><span style=display:flex><span>QUEUED
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; XADD memberMessage * msg five
</span></span><span style=display:flex><span>QUEUED
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; EXEC
</span></span><span style=display:flex><span>1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;1553441006884-0&#34;</span>
</span></span><span style=display:flex><span>2<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;1553441006884-1&#34;</span>
</span></span><span style=display:flex><span>3<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;1553441006884-2&#34;</span>
</span></span><span style=display:flex><span>4<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;1553441006884-3&#34;</span>
</span></span><span style=display:flex><span>5<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;1553441006884-4&#34;</span>
</span></span></code></pre></div><p>由于一个redis命令的执行很快，所以可以看到在同一时间戳内，是通过序号递增来表示消息的。</p><p>为了保证消息是有序的，因此Redis生成的ID是单调递增有序的。由于ID中包含时间戳部分，为了避免服务器时间错误而带来的问题（例如服务器时间延后了），Redis的每个Stream类型数据都维护一个latest_generated_id属性，用于记录最后一个消息的ID。<strong>若发现当前时间戳退后（小于latest_generated_id所记录的），则采用时间戳不变而序号递增的方案来作为新消息ID</strong>（这也是序号为什么使用int64的原因，保证有足够多的的序号），从而保证ID的单调递增性质。</p><p>强烈建议使用Redis的方案生成消息ID，因为这种时间戳+序号的单调递增的ID方案，几乎可以满足你全部的需求。但同时，记住ID是支持自定义的，别忘了！</p><h3 id=消费者崩溃带来的会不会消息丢失问题>消费者崩溃带来的会不会消息丢失问题</h3><p>为了解决组内消息读取但处理期间消费者崩溃带来的消息丢失问题，STREAM 设计了 Pending 列表，用于记录读取但并未处理完毕的消息。命令XPENDIING 用来获消费组或消费内消费者的未处理完毕的消息。演示如下：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>127.0.0.1:6379&gt; XPENDING mq mqGroup <span style=color:#8f5902;font-style:italic># mpGroup的Pending情况</span>
</span></span><span style=display:flex><span>1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>(</span>integer<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#0000cf;font-weight:700>5</span> <span style=color:#8f5902;font-style:italic># 5个已读取但未处理的消息</span>
</span></span><span style=display:flex><span>2<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;1553585533795-0&#34;</span> <span style=color:#8f5902;font-style:italic># 起始ID</span>
</span></span><span style=display:flex><span>3<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;1553585533795-4&#34;</span> <span style=color:#8f5902;font-style:italic># 结束ID</span>
</span></span><span style=display:flex><span>4<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;consumerA&#34;</span> <span style=color:#8f5902;font-style:italic># 消费者A有3个</span>
</span></span><span style=display:flex><span>      2<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;3&#34;</span>
</span></span><span style=display:flex><span>   2<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;consumerB&#34;</span> <span style=color:#8f5902;font-style:italic># 消费者B有1个</span>
</span></span><span style=display:flex><span>      2<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;1&#34;</span>
</span></span><span style=display:flex><span>   3<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;consumerC&#34;</span> <span style=color:#8f5902;font-style:italic># 消费者C有1个</span>
</span></span><span style=display:flex><span>      2<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;1&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; XPENDING mq mqGroup - + <span style=color:#0000cf;font-weight:700>10</span> <span style=color:#8f5902;font-style:italic># 使用 start end count 选项可以获取详细信息</span>
</span></span><span style=display:flex><span>1<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;1553585533795-0&#34;</span> <span style=color:#8f5902;font-style:italic># 消息ID</span>
</span></span><span style=display:flex><span>   2<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;consumerA&#34;</span> <span style=color:#8f5902;font-style:italic># 消费者</span>
</span></span><span style=display:flex><span>   3<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>(</span>integer<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#0000cf;font-weight:700>1654355</span> <span style=color:#8f5902;font-style:italic># 从读取到现在经历了1654355ms，IDLE</span>
</span></span><span style=display:flex><span>   4<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>(</span>integer<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#0000cf;font-weight:700>5</span> <span style=color:#8f5902;font-style:italic># 消息被读取了5次，delivery counter</span>
</span></span><span style=display:flex><span>2<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;1553585533795-1&#34;</span>
</span></span><span style=display:flex><span>   2<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;consumerA&#34;</span>
</span></span><span style=display:flex><span>   3<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>(</span>integer<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#0000cf;font-weight:700>1654355</span>
</span></span><span style=display:flex><span>   4<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>(</span>integer<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#0000cf;font-weight:700>4</span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic># 共5个，余下3个省略 ...</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; XPENDING mq mqGroup - + <span style=color:#0000cf;font-weight:700>10</span> consumerA <span style=color:#8f5902;font-style:italic># 在加上消费者参数，获取具体某个消费者的Pending列表</span>
</span></span><span style=display:flex><span>1<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;1553585533795-0&#34;</span>
</span></span><span style=display:flex><span>   2<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;consumerA&#34;</span>
</span></span><span style=display:flex><span>   3<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>(</span>integer<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#0000cf;font-weight:700>1641083</span>
</span></span><span style=display:flex><span>   4<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>(</span>integer<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#0000cf;font-weight:700>5</span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic># 共3个，余下2个省略 ...</span>
</span></span></code></pre></div><p>每个Pending的消息有4个属性：</p><ul><li>消息ID</li><li>所属消费者</li><li>IDLE，已读取时长</li><li>delivery counter，消息被读取次数</li></ul><p>上面的结果我们可以看到，我们之前读取的消息，都被记录在Pending列表中，说明全部读到的消息都没有处理，仅仅是读取了。那如何表示消费者处理完毕了消息呢？使用命令 XACK 完成告知消息处理完成，演示如下：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>127.0.0.1:6379&gt; XACK mq mqGroup 1553585533795-0 <span style=color:#8f5902;font-style:italic># 通知消息处理结束，用消息ID标识</span>
</span></span><span style=display:flex><span><span style=color:#ce5c00;font-weight:700>(</span>integer<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#0000cf;font-weight:700>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; XPENDING mq mqGroup <span style=color:#8f5902;font-style:italic># 再次查看Pending列表</span>
</span></span><span style=display:flex><span>1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>(</span>integer<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#0000cf;font-weight:700>4</span> <span style=color:#8f5902;font-style:italic># 已读取但未处理的消息已经变为4个</span>
</span></span><span style=display:flex><span>2<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;1553585533795-1&#34;</span>
</span></span><span style=display:flex><span>3<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;1553585533795-4&#34;</span>
</span></span><span style=display:flex><span>4<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;consumerA&#34;</span> <span style=color:#8f5902;font-style:italic># 消费者A，还有2个消息处理</span>
</span></span><span style=display:flex><span>      2<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;2&#34;</span>
</span></span><span style=display:flex><span>   2<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;consumerB&#34;</span>
</span></span><span style=display:flex><span>      2<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;1&#34;</span>
</span></span><span style=display:flex><span>   3<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;consumerC&#34;</span>
</span></span><span style=display:flex><span>      2<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;1&#34;</span>
</span></span><span style=display:flex><span>127.0.0.1:6379&gt;
</span></span></code></pre></div><p>有了这样一个Pending机制，就意味着在某个消费者读取消息但未处理后，消息是不会丢失的。等待消费者再次上线后，可以读取该Pending列表，就可以继续处理该消息了，保证消息的有序和不丢失。</p><h3 id=消费者彻底宕机后如何转移给其它消费者处理>消费者彻底宕机后如何转移给其它消费者处理</h3><blockquote><p>还有一个问题，就是若某个消费者宕机之后，没有办法再上线了，那么就需要将该消费者Pending的消息，转移给其他的消费者处理，就是消息转移。</p></blockquote><p>消息转移的操作时将某个消息转移到自己的Pending列表中。使用语法XCLAIM来实现，需要设置组、转移的目标消费者和消息ID，同时需要提供IDLE（已被读取时长），只有超过这个时长，才能被转移。演示如下：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#8f5902;font-style:italic># 当前属于消费者A的消息1553585533795-1，已经15907,787ms未处理了</span>
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; XPENDING mq mqGroup - + <span style=color:#0000cf;font-weight:700>10</span>
</span></span><span style=display:flex><span>1<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;1553585533795-1&#34;</span>
</span></span><span style=display:flex><span>   2<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;consumerA&#34;</span>
</span></span><span style=display:flex><span>   3<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>(</span>integer<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#0000cf;font-weight:700>15907787</span>
</span></span><span style=display:flex><span>   4<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>(</span>integer<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#0000cf;font-weight:700>4</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic># 转移超过3600s的消息1553585533795-1到消费者B的Pending列表</span>
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; XCLAIM mq mqGroup consumerB <span style=color:#0000cf;font-weight:700>3600000</span> 1553585533795-1
</span></span><span style=display:flex><span>1<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;1553585533795-1&#34;</span>
</span></span><span style=display:flex><span>   2<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;msg&#34;</span>
</span></span><span style=display:flex><span>      2<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;2&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic># 消息1553585533795-1已经转移到消费者B的Pending中。</span>
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; XPENDING mq mqGroup - + <span style=color:#0000cf;font-weight:700>10</span>
</span></span><span style=display:flex><span>1<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;1553585533795-1&#34;</span>
</span></span><span style=display:flex><span>   2<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;consumerB&#34;</span>
</span></span><span style=display:flex><span>   3<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>(</span>integer<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#0000cf;font-weight:700>84404</span> <span style=color:#8f5902;font-style:italic># 注意IDLE，被重置了</span>
</span></span><span style=display:flex><span>   4<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>(</span>integer<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#0000cf;font-weight:700>5</span> <span style=color:#8f5902;font-style:italic># 注意，读取次数也累加了1次</span>
</span></span></code></pre></div><p>以上代码，完成了一次消息转移。转移除了要指定ID外，还需要指定IDLE，保证是长时间未处理的才被转移。被转移的消息的IDLE会被重置，用以保证不会被重复转移，以为可能会出现将过期的消息同时转移给多个消费者的并发操作，设置了IDLE，则可以避免后面的转移不会成功，因为IDLE不满足条件。例如下面的连续两条转移，第二条不会成功。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>127.0.0.1:6379&gt; XCLAIM mq mqGroup consumerB <span style=color:#0000cf;font-weight:700>3600000</span> 1553585533795-1
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; XCLAIM mq mqGroup consumerC <span style=color:#0000cf;font-weight:700>3600000</span> 1553585533795-1
</span></span></code></pre></div><p>这就是消息转移。至此我们使用了一个Pending消息的ID，所属消费者和IDLE的属性，还有一个属性就是消息被读取次数，delivery counter，该属性的作用由于统计消息被读取的次数，包括被转移也算。这个属性主要用在判定是否为错误数据上。</p><h3 id=坏消息问题dead-letter死信问题>坏消息问题，Dead Letter，死信问题</h3><p>正如上面所说，如果某个消息，不能被消费者处理，也就是不能被XACK，这是要长时间处于Pending列表中，即使被反复的转移给各个消费者也是如此。此时该消息的delivery counter就会累加（上一节的例子可以看到），当累加到某个我们预设的临界值时，我们就认为是坏消息（也叫死信，DeadLetter，无法投递的消息），由于有了判定条件，我们将坏消息处理掉即可，删除即可。删除一个消息，使用XDEL语法，演示如下：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#8f5902;font-style:italic># 删除队列中的消息</span>
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; XDEL mq 1553585533795-1
</span></span><span style=display:flex><span><span style=color:#ce5c00;font-weight:700>(</span>integer<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#0000cf;font-weight:700>1</span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic># 查看队列中再无此消息</span>
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; XRANGE mq - +
</span></span><span style=display:flex><span>1<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;1553585533795-0&#34;</span>
</span></span><span style=display:flex><span>   2<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;msg&#34;</span>
</span></span><span style=display:flex><span>      2<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;1&#34;</span>
</span></span><span style=display:flex><span>2<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;1553585533795-2&#34;</span>
</span></span><span style=display:flex><span>   2<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;msg&#34;</span>
</span></span><span style=display:flex><span>      2<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;3&#34;</span>
</span></span></code></pre></div><p>注意本例中，并没有删除Pending中的消息因此你查看Pending，消息还会在。可以执行XACK标识其处理完毕！</p></div><div class=td-content style=page-break-before:always><h1 id=pg-f39b5b7bdbb59acf255fb62ce2763d03>7.4 - CH04-对象机制</h1><h2 id=结构概览>结构概览</h2><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210504135719.png style=display:block;width:50% alt=NAME align=center></div><p>上图反映了Redis的每种对象其实都由<strong>对象结构(redisObject)</strong> 与 <strong>对应编码的数据结构</strong>组合而成，而每种对象类型对应若干编码方式，不同的编码方式所对应的底层数据结构是不同的。</p><p>所以，我们需要从几个个角度来着手底层研究：</p><ul><li><strong>对象设计机制</strong>: 对象结构(redisObject)</li><li><strong>编码类型和底层数据结构</strong>: 对应编码的数据结构</li></ul><h2 id=redisobject>RedisObject</h2><p>在redis的命令中，用于对键进行处理的命令占了很大一部分，而对于键所保存的值的类型，键能执行的命令又各不相同。如： <code>LPUSH</code> 和 <code>LLEN</code> 只能用于列表键, 而 <code>SADD</code> 和 <code>SRANDMEMBER</code> 只能用于集合键; 另外一些命令, 比如 <code>DEL</code>、 <code>TTL</code> 和 <code>TYPE</code>, 可以用于任何类型的键；但是要正确实现这些命令, 必须为不同类型的键设置不同的处理方式: 比如说, 删除一个列表键和删除一个字符串键的操作过程就不太一样。</p><p>以上的描述说明, <strong>Redis 必须让每个键都带有类型信息, 使得程序可以检查键的类型, 并为它选择合适的处理方式</strong>.</p><p>比如说， 集合类型就可以由字典和整数集合两种不同的数据结构实现， 但是， 当用户执行 ZADD 命令时，应该不必关心集合使用的是什么编码， 只要 Redis 能按照 ZADD 命令的指示， 将新元素添加到集合就可以了。</p><p>这说明, <strong>操作数据类型的命令除了要对键的类型进行检查之外, 还需要根据数据类型的不同编码进行多态处理</strong>.</p><p>为了解决以上问题, <strong>Redis 构建了自己的类型系统</strong>, 这个系统的主要功能包括:</p><ul><li>redisObject 对象.</li><li>基于 redisObject 对象的类型检查.</li><li>基于 redisObject 对象的显式多态函数.</li><li>对 redisObject 进行分配、共享和销毁的机制.</li></ul><h3 id=数据结构>数据结构</h3><p>redisObject 是 Redis 类型系统的核心, 数据库中的每个键、值, 以及 Redis 本身处理的参数, 都表示为这种数据类型。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#8f5902;font-style:italic>/*
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic> * Redis 对象
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic> */</span>
</span></span><span style=display:flex><span><span style=color:#204a87;font-weight:700>typedef</span> <span style=color:#204a87;font-weight:700>struct</span> <span style=color:#000>redisObject</span> <span style=color:#000;font-weight:700>{</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8f5902;font-style:italic>// 类型
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span>    <span style=color:#204a87;font-weight:700>unsigned</span> <span style=color:#f57900>type</span><span style=color:#000;font-weight:700>:</span><span style=color:#0000cf;font-weight:700>4</span><span style=color:#000;font-weight:700>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8f5902;font-style:italic>// 编码方式
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span>    <span style=color:#204a87;font-weight:700>unsigned</span> <span style=color:#f57900>encoding</span><span style=color:#000;font-weight:700>:</span><span style=color:#0000cf;font-weight:700>4</span><span style=color:#000;font-weight:700>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8f5902;font-style:italic>// LRU - 24位, 记录最末一次访问时间（相对于lru_clock）; 或者 LFU（最少使用的数据：8位频率，16位访问时间）
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span>    <span style=color:#204a87;font-weight:700>unsigned</span> <span style=color:#f57900>lru</span><span style=color:#000;font-weight:700>:</span><span style=color:#000>LRU_BITS</span><span style=color:#000;font-weight:700>;</span> <span style=color:#8f5902;font-style:italic>// LRU_BITS: 24
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span>
</span></span><span style=display:flex><span>    <span style=color:#8f5902;font-style:italic>// 引用计数
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span>    <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>refcount</span><span style=color:#000;font-weight:700>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8f5902;font-style:italic>// 指向底层数据结构实例
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span>    <span style=color:#204a87;font-weight:700>void</span> <span style=color:#ce5c00;font-weight:700>*</span><span style=color:#000>ptr</span><span style=color:#000;font-weight:700>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>}</span> <span style=color:#000>robj</span><span style=color:#000;font-weight:700>;</span>
</span></span></code></pre></div><p>下图对应上面的结构：</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210504140122.png style=display:block;width:50% alt=NAME align=center></div><p><strong>其中type、encoding和ptr是最重要的三个属性</strong>。</p><ul><li><strong>type记录了对象所保存的值的类型</strong>，它的值可能是以下常量中的一个：</li></ul><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#8f5902;font-style:italic>/*
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>* 对象类型
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>*/</span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>#define OBJ_STRING 0 </span><span style=color:#8f5902;font-style:italic>// 字符串
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span><span style=color:#8f5902;font-style:italic>#define OBJ_LIST 1 </span><span style=color:#8f5902;font-style:italic>// 列表
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span><span style=color:#8f5902;font-style:italic>#define OBJ_SET 2 </span><span style=color:#8f5902;font-style:italic>// 集合
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span><span style=color:#8f5902;font-style:italic>#define OBJ_ZSET 3 </span><span style=color:#8f5902;font-style:italic>// 有序集
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span><span style=color:#8f5902;font-style:italic>#define OBJ_HASH 4 </span><span style=color:#8f5902;font-style:italic>// 哈希表
</span></span></span></code></pre></div><ul><li><strong>encoding记录了对象所保存的值的编码</strong>，它的值可能是以下常量中的一个：</li></ul><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#8f5902;font-style:italic>/*
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>* 对象编码
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>*/</span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>#define OBJ_ENCODING_RAW 0     </span><span style=color:#8f5902;font-style:italic>/* Raw representation */</span><span style=color:#8f5902;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>#define OBJ_ENCODING_INT 1     </span><span style=color:#8f5902;font-style:italic>/* Encoded as integer */</span><span style=color:#8f5902;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>#define OBJ_ENCODING_HT 2      </span><span style=color:#8f5902;font-style:italic>/* Encoded as hash table */</span><span style=color:#8f5902;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>#define OBJ_ENCODING_ZIPMAP 3  </span><span style=color:#8f5902;font-style:italic>/* 注意：版本2.6后不再使用. */</span><span style=color:#8f5902;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>#define OBJ_ENCODING_LINKEDLIST 4 </span><span style=color:#8f5902;font-style:italic>/* 注意：不再使用了，旧版本2.x中String的底层之一. */</span><span style=color:#8f5902;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>#define OBJ_ENCODING_ZIPLIST 5 </span><span style=color:#8f5902;font-style:italic>/* Encoded as ziplist */</span><span style=color:#8f5902;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>#define OBJ_ENCODING_INTSET 6  </span><span style=color:#8f5902;font-style:italic>/* Encoded as intset */</span><span style=color:#8f5902;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>#define OBJ_ENCODING_SKIPLIST 7  </span><span style=color:#8f5902;font-style:italic>/* Encoded as skiplist */</span><span style=color:#8f5902;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>#define OBJ_ENCODING_EMBSTR 8  </span><span style=color:#8f5902;font-style:italic>/* Embedded sds string encoding */</span><span style=color:#8f5902;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>#define OBJ_ENCODING_QUICKLIST 9 </span><span style=color:#8f5902;font-style:italic>/* Encoded as linked list of ziplists */</span><span style=color:#8f5902;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>#define OBJ_ENCODING_STREAM 10 </span><span style=color:#8f5902;font-style:italic>/* Encoded as a radix tree of listpacks */</span><span style=color:#8f5902;font-style:italic>
</span></span></span></code></pre></div><ul><li><p><strong>ptr是一个指针，指向实际保存值的数据结构</strong>，这个数据结构由type和encoding属性决定。举个例子， 如果一个redisObject 的type 属性为<code>OBJ_LIST</code> ， encoding 属性为<code>OBJ_ENCODING_QUICKLIST</code> ，那么这个对象就是一个Redis 列表（List)，它的值保存在一个QuickList的数据结构内，而ptr 指针就指向quicklist的对象；</p></li><li><p><strong>lru属性: 记录了对象最后一次被命令程序访问的时间</strong></p></li></ul><p><strong>空转时长</strong>：当前时间减去键的值对象的lru时间，就是该键的空转时长。Object idletime命令可以打印出给定键的空转时长</p><p>如果服务器打开了maxmemory选项，并且服务器用于回收内存的算法为volatile-lru或者allkeys-lru，那么当服务器占用的内存数超过了maxmemory选项所设置的上限值时，空转时长较高的那部分键会优先被服务器释放，从而回收内存。</p><h2 id=命令的类型检查与多态>命令的类型检查与多态</h2><p><strong>当执行一个处理数据类型命令的时候，redis执行以下步骤</strong></p><ul><li>根据给定的key，在数据库字典中查找和他相对应的redisObject，如果没找到，就返回NULL；</li><li>检查redisObject的type属性和执行命令所需的类型是否相符，如果不相符，返回类型错误；</li><li>根据redisObject的encoding属性所指定的编码，选择合适的操作函数来处理底层的数据结构；</li><li>返回数据结构的操作结果作为命令的返回值。</li></ul><p>比如现在执行LPOP命令：</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210504140457.png style=display:block;width:50% alt=NAME align=center></div><h2 id=对象共享>对象共享</h2><blockquote><p>redis一般会把一些常见的值放到一个共享对象中，这样可使程序避免了重复分配的麻烦，也节约了一些CPU时间。</p></blockquote><p><strong>redis预分配的值对象如下</strong>：</p><ul><li>各种命令的返回值，比如成功时返回的OK，错误时返回的ERROR，命令入队事务时返回的QUEUE，等等</li><li>包括0 在内，小于REDIS_SHARED_INTEGERS的所有整数（REDIS_SHARED_INTEGERS的默认值是10000）</li></ul><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210504140534.png style=display:block;width:50% alt=NAME align=center></div><blockquote><p>注意：共享对象只能被字典和双向链表这类能带有指针的数据结构使用。像整数集合和压缩列表这些只能保存字符串、整数等字面值的内存数据结构。</p></blockquote><p><strong>为什么redis不共享列表对象、哈希对象、集合对象、有序集合对象，只共享字符串对象</strong>？</p><ul><li>列表对象、哈希对象、集合对象、有序集合对象，本身可以包含字符串对象，复杂度较高。</li><li>如果共享对象是保存字符串对象，那么验证操作的复杂度为O(1)</li><li>如果共享对象是保存字符串值的字符串对象，那么验证操作的复杂度为O(N)</li><li>如果共享对象是包含多个值的对象，其中值本身又是字符串对象，即其它对象中嵌套了字符串对象，比如列表对象、哈希对象，那么验证操作的复杂度将会是O(N的平方)</li></ul><p>如果对复杂度较高的对象创建共享对象，需要消耗很大的CPU，用这种消耗去换取内存空间，是不合适的。</p><h2 id=引用计数以及对象的消毁>引用计数以及对象的消毁</h2><blockquote><p>redisObject中有refcount属性，是对象的引用计数，显然计数0那么就是可以回收。</p></blockquote><ul><li>每个redisObject结构都带有一个refcount属性，指示这个对象被引用了多少次；</li><li>当新创建一个对象时，它的refcount属性被设置为1；</li><li>当对一个对象进行共享时，redis将这个对象的refcount加一；</li><li>当使用完一个对象后，或者消除对一个对象的引用之后，程序将对象的refcount减一；</li><li>当对象的refcount降至0 时，这个RedisObject结构，以及它引用的数据结构的内存都会被释放。</li></ul><h2 id=总结>总结</h2><ul><li><p>redis使用自己实现的对象机制（redisObject)来实现类型判断、命令多态和基于引用次数的垃圾回收；</p></li><li><p>redis会预分配一些常用的数据对象，并通过共享这些对象来减少内存占用，和避免频繁的为小对象分配内存。</p></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-d6ad1d4083c795b0ad006b6fb71ea3c7>7.5 - CH05-底层结构</h1><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210504140959.png style=display:block;width:50% alt=NAME align=center></div><h2 id=简单动态字符串sds>简单动态字符串：SDS</h2><blockquote><p>Redis 是用 C 语言写的，但是对于Redis的字符串，却不是 C 语言中的字符串（即以空字符’\0’结尾的字符数组），它是自己构建了一种名为 <strong>简单动态字符串（simple dynamic string,SDS</strong>）的抽象类型，并将 SDS 作为 Redis的默认字符串表示。</p></blockquote><h3 id=定义>定义</h3><blockquote><p>这是一种用于存储二进制数据的一种结构, 具有动态扩容的特点. 其实现位于src/sds.h与src/sds.c中。</p></blockquote><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210504141111.png style=display:block;width:50% alt=NAME align=center></div><p>其中<code>sdshdr</code>是头部, <code>buf</code>是真实存储用户数据的地方. 另外注意, 从命名上能看出来, 这个数据结构除了能存储二进制数据, 显然是用于设计作为字符串使用的, 所以在buf中, 用户数据后总跟着一个\0. 即图中 <code>"数据" + "\0"</code>是为所谓的buf。</p><p>SDS有五种不同的头部. 其中sdshdr5实际并未使用到. 所以实际上有四种不同的头部, 分别如下:</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210504145202.png style=display:block;width:50% alt=NAME align=center></div><p>其中：</p><ul><li><code>len</code> 保存了SDS保存字符串的长度</li><li><code>buf[]</code> 数组用来保存字符串的每个元素</li><li><code>alloc</code>分别以uint8, uint16, uint32, uint64表示整个SDS, 除过头部与末尾的\0, 剩余的字节数.</li><li><code>flags</code> 始终为一字节, 以低三位标示着头部的类型, 高5位未使用.</li></ul><h3 id=为什么使用sds>为什么使用SDS</h3><blockquote><p><strong>为什么不使用C语言字符串实现，而是使用 SDS呢</strong>？这样实现有什么好处？</p></blockquote><ul><li><p><strong>常数复杂度获取字符串长度</strong></p><p>由于 len 属性的存在，我们获取 SDS 字符串的长度只需要读取 len 属性，时间复杂度为 O(1)。而对于 C 语言，获取字符串的长度通常是经过遍历计数来实现的，时间复杂度为 O(n)。通过 <code>strlen key</code> 命令可以获取 key 的字符串长度。</p></li><li><p><strong>杜绝缓冲区溢出</strong></p><p>我们知道在 C 语言中使用 <code>strcat</code> 函数来进行两个字符串的拼接，一旦没有分配足够长度的内存空间，就会造成缓冲区溢出。而对于 SDS 数据类型，在进行字符修改的时候，<strong>会首先根据记录的 len 属性检查内存空间是否满足需求</strong>，如果不满足，会进行相应的空间扩展，然后在进行修改操作，所以不会出现缓冲区溢出。</p></li><li><p><strong>减少修改字符串的内存重新分配次数</strong></p><p>C语言由于不记录字符串的长度，所以如果要修改字符串，必须要重新分配内存（先释放再申请），因为如果没有重新分配，字符串长度增大时会造成内存缓冲区溢出，字符串长度减小时会造成内存泄露。</p><p>而对于SDS，由于<code>len</code>属性和<code>alloc</code>属性的存在，对于修改字符串SDS实现了<strong>空间预分配</strong>和<strong>惰性空间释放</strong>两种策略：</p><ul><li><p><code>空间预分配</code>：对字符串进行空间扩展的时候，扩展的内存比实际需要的多，这样可以减少连续执行字符串增长操作所需的内存重分配次数。</p></li><li><p><code>惰性空间释放</code>：对字符串进行缩短操作时，程序不立即使用内存重新分配来回收缩短后多余的字节，而是使用 <code>alloc</code> 属性将这些字节的数量记录下来，等待后续使用。（当然SDS也提供了相应的API，当我们有需要时，也可以手动释放这些未使用的空间。）</p></li></ul></li><li><p><strong>二进制安全</strong></p><p>因为C字符串以空字符作为字符串结束的标识，而对于一些二进制文件（如图片等），内容可能包括空字符串，因此C字符串无法正确存取；而所有 SDS 的API 都是以处理二进制的方式来处理 <code>buf</code> 里面的元素，并且 SDS 不是以空字符串来判断是否结束，而是以 len 属性表示的长度来判断字符串是否结束。</p></li><li><p><strong>兼容部分 C 字符串函数</strong></p></li></ul><p>虽然 SDS 是二进制安全的，但是一样遵从每个字符串都是以空字符串结尾的惯例，这样可以重用 C 语言库<code>&lt;string.h></code> 中的一部分函数。</p><h3 id=空间预分配补进一步理解>空间预分配补进一步理解</h3><p>当执行追加操作时，比如现在给<code>key=‘Hello World’</code>的字符串后追加<code>‘ again!’</code>则这时的len=18，free由0变成了18，此时的<code>buf='Hello World again!\0....................'</code>(.表示空格)，也就是buf的内存空间是18+18+1=37个字节，其中‘\0’占1个字节redis给字符串多分配了18个字节的预分配空间，所以下次还有append追加的时候，如果预分配空间足够，就无须在进行空间分配了。在当前版本中，当新字符串的长度小于1M时，redis会分配他们所需大小一倍的空间，当大于1M的时候，就为他们额外多分配1M的空间。</p><p>思考：<strong>这种分配策略会浪费内存资源吗</strong>？</p><p>答：执行过APPEND 命令的字符串会带有额外的预分配空间，这些预分配空间不会被释放，除非该字符串所对应的键被删除，或者等到关闭Redis 之后，再次启动时重新载入的字符串对象将不会有预分配空间。因为执行APPEND 命令的字符串键数量通常并不多，占用内存的体积通常也不大，所以这一般并不算什么问题。另一方面，如果执行APPEND 操作的键很多，而字符串的体积又很大的话，那可能就需要修改Redis 服务器，让它定时释放一些字符串键的预分配空间，从而更有效地使用内存。</p><h3 id=小结>小结</h3><p>redis的字符串表示为sds，而不是C字符串（以\0结尾的char*）， 它是Redis 底层所使用的字符串表示，它被用在几乎所有的Redis 模块中。可以看如下对比：</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210504145607.png style=display:block;width:50% alt=NAME align=center></div><p>一般来说，SDS 除了保存数据库中的字符串值以外，SDS 还可以作为缓冲区（buffer）：包括 AOF 模块中的AOF缓冲区以及客户端状态中的输入缓冲区</p><h2 id=压缩列表ziplist>压缩列表：ZipList</h2><blockquote><p>ziplist是为了提高存储效率而设计的一种特殊编码的双向链表。它可以存储字符串或者整数，存储整数时是采用整数的二进制而不是字符串形式存储。他能在O(1)的时间复杂度下完成list两端的push和pop操作。但是因为每次操作都需要重新分配ziplist的内存，所以实际复杂度和ziplist的内存使用量相关。</p></blockquote><h3 id=ziplist-结构>ZipList 结构</h3><p>整个ziplist在内存中的存储格式如下：</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210504145727.png style=display:block;width:50% alt=NAME align=center></div><ul><li><p><code>zlbytes</code>字段的类型是uint32_t, 这个字段中存储的是整个ziplist所占用的内存的字节数</p></li><li><p><code>zltail</code>字段的类型是uint32_t, 它指的是ziplist中最后一个entry的偏移量. 用于快速定位最后一个entry, 以快速完成pop等操作</p></li><li><p><code>zllen</code>字段的类型是uint16_t, 它指的是整个ziplit中entry的数量. 这个值只占2bytes（16位）: 如果ziplist中entry的数目小于65535(2的16次方), 那么该字段中存储的就是实际entry的值. 若等于或超过65535, 那么该字段的值固定为65535, 但实际数量需要一个个entry的去遍历所有entry才能得到.</p></li><li><p><code>zlend</code>是一个终止字节, 其值为全F, 即0xff. ziplist保证任何情况下, 一个entry的首字节都不会是255</p></li></ul><h3 id=entry-结构>Entry 结构</h3><p><strong>第一种情况</strong>：一般结构 <code>&lt;prevlen> &lt;encoding> &lt;entry-data></code></p><p><code>prevlen</code>：前一个entry的大小，编码方式见下文；</p><p><code>encoding</code>：不同的情况下值不同，用于表示当前entry的类型和长度；</p><p><code>entry-data</code>：真是用于存储entry表示的数据；</p><p><strong>第二种情况</strong>：在entry中存储的是int类型时，encoding和entry-data会合并在encoding中表示，此时没有entry-data字段；</p><p>redis中，在存储数据时，会先尝试将string转换成int存储，节省空间；</p><p>此时entry结构：<code>&lt;prevlen> &lt;encoding></code></p><ul><li><strong>prevlen编码</strong></li></ul><p>当前一个元素长度小于254（255用于zlend）的时候，prevlen长度为1个字节，值即为前一个entry的长度，如果长度大于等于254的时候，prevlen用5个字节表示，第一字节设置为254，后面4个字节存储一个小端的无符号整型，表示前一个entry的长度；</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>&lt;prevlen from <span style=color:#0000cf;font-weight:700>0</span> to 253&gt; &lt;encoding&gt; &lt;entry&gt;      //长度小于254结构
</span></span><span style=display:flex><span>0xFE &lt;<span style=color:#0000cf;font-weight:700>4</span> bytes unsigned little endian prevlen&gt; &lt;encoding&gt; &lt;entry&gt;   //长度大于等于254
</span></span></code></pre></div><ul><li><strong>encoding编码</strong></li></ul><p>encoding的长度和值根据保存的是int还是string，还有数据的长度而定；</p><p>前两位用来表示类型，当为“11”时，表示entry存储的是int类型，其他表示存储的是string；</p><p><strong>存储string时</strong>：</p><p><code>|00pppppp|</code> ：此时encoding长度为1个字节，该字节的后六位表示entry中存储的string长度，因为是6位，所以entry中存储的string长度不能超过63；</p><p><code>|01pppppp|qqqqqqqq|</code> 此时encoding长度为两个字节；此时encoding的后14位用来存储string长度，长度不能超过16383；</p><p><code>|10000000|qqqqqqqq|rrrrrrrr|ssssssss|ttttttt|</code> 此时encoding长度为5个字节，后面的4个字节用来表示encoding中存储的字符串长度，长度不能超过2^32 - 1;</p><p><strong>存储int时</strong>：</p><p><code>|11000000|</code> encoding为3个字节，后2个字节表示一个int16；</p><p><code>|11010000|</code> encoding为5个字节，后4个字节表示一个int32;</p><p><code>|11100000|</code> encoding 为9个字节，后8字节表示一个int64;</p><p><code>|11110000|</code> encoding为4个字节，后3个字节表示一个有符号整型；</p><p><code>|11111110|</code> encoding为2字节，后1个字节表示一个有符号整型；</p><p><code>|1111xxxx|</code> encoding长度就只有1个字节，xxxx表示一个0 - 12的整数值；</p><p><code>|11111111|</code> 还记得zlend么？</p><ul><li><strong>源码中数据结构支撑</strong></li></ul><p>你可以看到为了操作上的简易实际还增加了几个属性</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#8f5902;font-style:italic>/* We use this function to receive information about a ziplist entry.
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic> * Note that this is not how the data is actually encoded, is just what we
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic> * get filled by a function in order to operate more easily. */</span>
</span></span><span style=display:flex><span><span style=color:#204a87;font-weight:700>typedef</span> <span style=color:#204a87;font-weight:700>struct</span> <span style=color:#000>zlentry</span> <span style=color:#000;font-weight:700>{</span>
</span></span><span style=display:flex><span>    <span style=color:#204a87;font-weight:700>unsigned</span> <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>prevrawlensize</span><span style=color:#000;font-weight:700>;</span> <span style=color:#8f5902;font-style:italic>/* Bytes used to encode the previous entry len*/</span>
</span></span><span style=display:flex><span>    <span style=color:#204a87;font-weight:700>unsigned</span> <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>prevrawlen</span><span style=color:#000;font-weight:700>;</span>     <span style=color:#8f5902;font-style:italic>/* Previous entry len. */</span>
</span></span><span style=display:flex><span>    <span style=color:#204a87;font-weight:700>unsigned</span> <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>lensize</span><span style=color:#000;font-weight:700>;</span>        <span style=color:#8f5902;font-style:italic>/* Bytes used to encode this entry type/len.
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>                                    For example strings have a 1, 2 or 5 bytes
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>                                    header. Integers always use a single byte.*/</span>
</span></span><span style=display:flex><span>    <span style=color:#204a87;font-weight:700>unsigned</span> <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>len</span><span style=color:#000;font-weight:700>;</span>            <span style=color:#8f5902;font-style:italic>/* Bytes used to represent the actual entry.
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>                                    For strings this is just the string length
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>                                    while for integers it is 1, 2, 3, 4, 8 or
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>                                    0 (for 4 bit immediate) depending on the
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>                                    number range. */</span>
</span></span><span style=display:flex><span>    <span style=color:#204a87;font-weight:700>unsigned</span> <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>headersize</span><span style=color:#000;font-weight:700>;</span>     <span style=color:#8f5902;font-style:italic>/* prevrawlensize + lensize. */</span>
</span></span><span style=display:flex><span>    <span style=color:#204a87;font-weight:700>unsigned</span> <span style=color:#204a87;font-weight:700>char</span> <span style=color:#000>encoding</span><span style=color:#000;font-weight:700>;</span>      <span style=color:#8f5902;font-style:italic>/* Set to ZIP_STR_* or ZIP_INT_* depending on
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>                                    the entry encoding. However for 4 bits
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>                                    immediate integers this can assume a range
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>                                    of values and must be range-checked. */</span>
</span></span><span style=display:flex><span>    <span style=color:#204a87;font-weight:700>unsigned</span> <span style=color:#204a87;font-weight:700>char</span> <span style=color:#ce5c00;font-weight:700>*</span><span style=color:#000>p</span><span style=color:#000;font-weight:700>;</span>            <span style=color:#8f5902;font-style:italic>/* Pointer to the very start of the entry, that
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>                                    is, this points to prev-entry-len field. */</span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>}</span> <span style=color:#000>zlentry</span><span style=color:#000;font-weight:700>;</span>
</span></span></code></pre></div><ul><li><code>prevrawlensize</code>表示 previous_entry_length字段的长度</li><li><code>prevrawlen</code>表示 previous_entry_length字段存储的内容</li><li><code>lensize</code>表示 encoding字段的长度</li><li><code>len</code>表示数据内容长度</li><li><code>headersize</code> 表示当前元素的首部长度，即previous_entry_length字段长度与encoding字段长度之和</li><li><code>encoding</code>表示数据类型</li><li><code>p</code>表示当前元素首地址</li></ul><h3 id=为什么ziplist特别省内存>为什么ZipList特别省内存</h3><ul><li>ziplist节省内存是相对于普通的list来说的，如果是普通的数组，那么它每个元素占用的内存是一样的且取决于最大的那个元素（很明显它是需要预留空间的）；</li><li>所以ziplist在设计时就很容易想到要尽量让每个元素按照实际的内容大小存储，<strong>所以增加encoding字段</strong>，针对不同的encoding来细化存储大小；</li><li>这时候还需要解决的一个问题是遍历元素时如何定位下一个元素呢？在普通数组中每个元素定长，所以不需要考虑这个问题；但是ziplist中每个data占据的内存不一样，所以为了解决遍历，需要增加记录上一个元素的length，<strong>所以增加了prelen字段</strong>。</li></ul><p><strong>为什么我们去研究ziplist特别节省内存的数据结构</strong>？ 在实际应用中，大量存储字符串的优化是需要你对底层的数据结构有一定的理解的，而ziplist在场景优化的时候也被考虑采用的首选。</p><h3 id=缺点>缺点</h3><ul><li>ziplist也不预留内存空间, 并且在移除结点后, 也是立即缩容, 这代表每次写操作都会进行内存分配操作.</li><li>结点如果扩容, 导致结点占用的内存增长, 并且超过254字节的话, 可能会导致链式反应: 其后一个结点的entry.prevlen需要从一字节扩容至五字节.<ul><li><strong>最坏情况下, 第一个结点的扩容, 会导致整个ziplist表中的后续所有结点的entry.prevlen字段扩容</strong>.</li><li>虽然这个内存重分配的操作依然只会发生一次, 但代码中的时间复杂度是o(N)级别, 因为链式扩容只能一步一步的计算.</li><li>但这种情况的概率十分的小, 一般情况下链式扩容能连锁反映五六次就很不幸了.</li><li>这样的坏场景下, 其实时间复杂度并不高: 依次计算每个entry新的空间占用, 也就是o(N), 总体占用计算出来后, 只执行一次内存重分配, 与对应的memmove操作, 就可以了.</li></ul></li></ul><h2 id=快表quicklist>快表：QuickList</h2><blockquote><p>quicklist这个结构是Redis在3.2版本后新加的, 之前的版本是list(即linkedlist)， 用于String数据类型中。</p></blockquote><p>它是一种以ziplist为结点的双端链表结构. 宏观上, quicklist是一个链表, 微观上, 链表中的每个结点都是一个ziplist。</p><h3 id=quicklist-结构>QuickList 结构</h3><p>内部定义了6个结构体:</p><ul><li><code>quicklistNode</code>, 宏观上, quicklist是一个链表, 这个结构描述的就是链表中的结点. 它通过zl字段持有底层的ziplist. 简单来讲, 它描述了一个ziplist实例</li><li><code>quicklistLZF</code>, ziplist是一段连续的内存, 用LZ4算法压缩后, 就可以包装成一个quicklistLZF结构. 是否压缩quicklist中的每个ziplist实例是一个可配置项. 若这个配置项是开启的, 那么quicklistNode.zl字段指向的就不是一个ziplist实例, 而是一个压缩后的quicklistLZF实例</li><li><code>quicklistBookmark</code>, 在quicklist尾部增加的一个书签，它只有在大量节点的多余内存使用量可以忽略不计的情况且确实需要分批迭代它们，才会被使用。当不使用它们时，它们不会增加任何内存开销。</li><li><code>quicklist</code>. 这就是一个双链表的定义. head, tail分别指向头尾指针. len代表链表中的结点. count指的是整个quicklist中的所有ziplist中的entry的数目. fill字段影响着每个链表结点中ziplist的最大占用空间, compress影响着是否要对每个ziplist以LZ4算法进行进一步压缩以更节省内存空间.</li><li><code>quicklistIter</code>是一个迭代器</li><li><code>quicklistEntry</code>是对ziplist中的entry概念的封装. quicklist作为一个封装良好的数据结构, 不希望使用者感知到其内部的实现, 所以需要把ziplist.entry的概念重新包装一下.</li></ul><h3 id=内存布局图>内存布局图</h3><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210504150301.png style=display:block;width:50% alt=NAME align=center></div><h3 id=更多信息>更多信息</h3><p>下面是有关quicklist的更多额外信息:</p><ul><li><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>quicklist.fill
</span></span></code></pre></div><p>的值影响着每个链表结点中, ziplist的长度.</p><ol><li>当数值为负数时, 代表以字节数限制单个ziplist的最大长度. 具体为:</li><li>-1 不超过4kb</li><li>-2 不超过 8kb</li><li>-3 不超过 16kb</li><li>-4 不超过 32kb</li><li>-5 不超过 64kb</li><li>当数值为正数时, 代表以entry数目限制单个ziplist的长度. 值即为数目. 由于该字段仅占16位, 所以以entry数目限制ziplist的容量时, 最大值为2^15个</li></ol></li><li><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>quicklist.compress
</span></span></code></pre></div><p>的值影响着quicklistNode.zl字段指向的是原生的ziplist, 还是经过压缩包装后的quicklistLZF</p><ol><li>0 表示不压缩, zl字段直接指向ziplist</li><li>1 表示quicklist的链表头尾结点不压缩, 其余结点的zl字段指向的是经过压缩后的quicklistLZF</li><li>2 表示quicklist的链表头两个, 与末两个结点不压缩, 其余结点的zl字段指向的是经过压缩后的quicklistLZF</li><li>以此类推, 最大值为2^16</li></ol></li><li><p><code>quicklistNode.encoding</code>字段, 以指示本链表结点所持有的ziplist是否经过了压缩. 1代表未压缩, 持有的是原生的ziplist, 2代表压缩过</p></li><li><p><code>quicklistNode.container</code>字段指示的是每个链表结点所持有的数据类型是什么. 默认的实现是ziplist, 对应的该字段的值是2, 目前Redis没有提供其它实现. 所以实际上, 该字段的值恒为2</p></li><li><p><code>quicklistNode.recompress</code>字段指示的是当前结点所持有的ziplist是否经过了解压. 如果该字段为1即代表之前被解压过, 且需要在下一次操作时重新压缩.</p></li></ul><p>quicklist的具体实现代码篇幅很长, 这里就不贴代码片断了, 从内存布局上也能看出来, 由于每个结点持有的ziplist是有上限长度的, 所以在与操作时要考虑的分支情况比较多。</p><p>quicklist有自己的优点, 也有缺点, 对于使用者来说, 其使用体验类似于线性数据结构, list作为最传统的双链表, 结点通过指针持有数据, 指针字段会耗费大量内存. ziplist解决了耗费内存这个问题. 但引入了新的问题: 每次写操作整个ziplist的内存都需要重分配. quicklist在两者之间做了一个平衡. 并且使用者可以通过自定义<code>quicklist.fill</code>, 根据实际业务情况, 经验主义调参.</p><h2 id=字典dict>字典：Dict</h2><h3 id=数据结构>数据结构</h3><p><strong>哈希表结构定义</strong>：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#204a87;font-weight:700>typedef</span> <span style=color:#204a87;font-weight:700>struct</span> <span style=color:#000>dictht</span><span style=color:#000;font-weight:700>{</span>
</span></span><span style=display:flex><span>    <span style=color:#8f5902;font-style:italic>//哈希表数组
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span>    <span style=color:#000>dictEntry</span> <span style=color:#ce5c00;font-weight:700>**</span><span style=color:#000>table</span><span style=color:#000;font-weight:700>;</span>
</span></span><span style=display:flex><span>    <span style=color:#8f5902;font-style:italic>//哈希表大小
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span>    <span style=color:#204a87;font-weight:700>unsigned</span> <span style=color:#204a87;font-weight:700>long</span> <span style=color:#000>size</span><span style=color:#000;font-weight:700>;</span>
</span></span><span style=display:flex><span>    <span style=color:#8f5902;font-style:italic>//哈希表大小掩码，用于计算索引值
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span>    <span style=color:#8f5902;font-style:italic>//总是等于 size-1
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span>    <span style=color:#204a87;font-weight:700>unsigned</span> <span style=color:#204a87;font-weight:700>long</span> <span style=color:#000>sizemask</span><span style=color:#000;font-weight:700>;</span>
</span></span><span style=display:flex><span>    <span style=color:#8f5902;font-style:italic>//该哈希表已有节点的数量
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span>    <span style=color:#204a87;font-weight:700>unsigned</span> <span style=color:#204a87;font-weight:700>long</span> <span style=color:#000>used</span><span style=color:#000;font-weight:700>;</span>
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>}</span><span style=color:#000>dictht</span>
</span></span></code></pre></div><p>哈希表是由数组 table 组成，table 中每个元素都是指向 dict.h/dictEntry 结构，dictEntry 结构定义如下：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#204a87;font-weight:700>typedef</span> <span style=color:#204a87;font-weight:700>struct</span> <span style=color:#000>dictEntry</span><span style=color:#000;font-weight:700>{</span>
</span></span><span style=display:flex><span>     <span style=color:#8f5902;font-style:italic>//键
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span>     <span style=color:#204a87;font-weight:700>void</span> <span style=color:#ce5c00;font-weight:700>*</span><span style=color:#000>key</span><span style=color:#000;font-weight:700>;</span>
</span></span><span style=display:flex><span>     <span style=color:#8f5902;font-style:italic>//值
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span>     <span style=color:#204a87;font-weight:700>union</span><span style=color:#000;font-weight:700>{</span>
</span></span><span style=display:flex><span>          <span style=color:#204a87;font-weight:700>void</span> <span style=color:#ce5c00;font-weight:700>*</span><span style=color:#000>val</span><span style=color:#000;font-weight:700>;</span>
</span></span><span style=display:flex><span>          <span style=color:#000>uint64_tu64</span><span style=color:#000;font-weight:700>;</span>
</span></span><span style=display:flex><span>          <span style=color:#000>int64_ts64</span><span style=color:#000;font-weight:700>;</span>
</span></span><span style=display:flex><span>     <span style=color:#000;font-weight:700>}</span><span style=color:#000>v</span><span style=color:#000;font-weight:700>;</span>
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>     <span style=color:#8f5902;font-style:italic>//指向下一个哈希表节点，形成链表
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span>     <span style=color:#204a87;font-weight:700>struct</span> <span style=color:#000>dictEntry</span> <span style=color:#ce5c00;font-weight:700>*</span><span style=color:#000>next</span><span style=color:#000;font-weight:700>;</span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>}</span><span style=color:#000>dictEntry</span>
</span></span></code></pre></div><p>key 用来保存键，val 属性用来保存值，值可以是一个指针，也可以是uint64_t整数，也可以是int64_t整数。</p><p>注意这里还有一个指向下一个哈希表节点的指针，我们知道哈希表最大的问题是存在哈希冲突，如何解决哈希冲突，有开放地址法和链地址法。这里采用的便是链地址法，通过next这个指针可以将多个哈希值相同的键值对连接在一起，用来<strong>解决哈希冲突</strong>。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210504150508.png style=display:block;width:50% alt=NAME align=center></div><h3 id=要点理解>要点理解</h3><ul><li><strong>哈希算法</strong>：Redis计算哈希值和索引值方法如下：</li></ul><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#8f5902;font-style:italic>#1、使用字典设置的哈希函数，计算键 key 的哈希值</span>
</span></span><span style=display:flex><span><span style=color:#204a87>hash</span> <span style=color:#ce5c00;font-weight:700>=</span> dict-&gt;type-&gt;hashFunction<span style=color:#ce5c00;font-weight:700>(</span>key<span style=color:#ce5c00;font-weight:700>)</span><span style=color:#000;font-weight:700>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>#2、使用哈希表的sizemask属性和第一步得到的哈希值，计算索引值</span>
</span></span><span style=display:flex><span><span style=color:#000>index</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87>hash</span> <span style=color:#000;font-weight:700>&amp;</span> dict-&gt;ht<span style=color:#ce5c00;font-weight:700>[</span>x<span style=color:#ce5c00;font-weight:700>]</span>.sizemask<span style=color:#000;font-weight:700>;</span>
</span></span></code></pre></div><ul><li><p><strong>解决哈希冲突</strong>：这个问题上面我们介绍了，方法是链地址法。通过字典里面的 *next 指针指向下一个具有相同索引值的哈希表节点。</p></li><li><p><strong>扩容和收缩</strong>：当哈希表保存的键值对太多或者太少时，就要通过 rerehash(重新散列）来对哈希表进行相应的扩展或者收缩。具体步骤：</p><ul><li><p>1、如果执行扩展操作，会基于原哈希表创建一个大小等于 <code>ht[0].used*2n</code> 的哈希表（也就是每次扩展都是根据原哈希表已使用的空间扩大一倍创建另一个哈希表）。相反如果执行的是收缩操作，每次收缩是根据已使用空间缩小一倍创建一个新的哈希表。</p></li><li><p>2、重新利用上面的哈希算法，计算索引值，然后将键值对放到新的哈希表位置上。</p></li><li><p>3、所有键值对都迁徙完毕后，释放原哈希表的内存空间。</p></li></ul></li><li><p><strong>触发扩容的条件</strong>：</p><ul><li><p>1、服务器目前没有执行 BGSAVE 命令或者 BGREWRITEAOF 命令，并且负载因子大于等于1。</p></li><li><p>2、服务器目前正在执行 BGSAVE 命令或者 BGREWRITEAOF 命令，并且负载因子大于等于5。</p></li><li><p>ps：负载因子 = 哈希表已保存节点数量 / 哈希表大小。</p></li></ul></li><li><p><strong>渐近式 rehash</strong></p><ul><li>什么叫渐进式 rehash？也就是说扩容和收缩操作不是一次性、集中式完成的，而是分多次、渐进式完成的。如果保存在Redis中的键值对只有几个几十个，那么 rehash 操作可以瞬间完成，但是如果键值对有几百万，几千万甚至几亿，那么要一次性的进行 rehash，势必会造成Redis一段时间内不能进行别的操作。所以Redis采用渐进式 rehash,这样在进行渐进式rehash期间，字典的删除查找更新等操作可能会在两个哈希表上进行，第一个哈希表没有找到，就会去第二个哈希表上进行查找。但是进行 增加操作，一定是在新的哈希表上进行的。</li></ul></li></ul><h2 id=整数集intset>整数集：IntSet</h2><blockquote><p>整数集合（intset）是集合类型的底层实现之一，当一个集合只包含整数值元素，并且这个集合的元素数量不多时，Redis 就会使用整数集合作为集合键的底层实现。</p></blockquote><h3 id=结构>结构</h3><p>首先看源码结构</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#204a87;font-weight:700>typedef</span> <span style=color:#204a87;font-weight:700>struct</span> <span style=color:#000>intset</span> <span style=color:#000;font-weight:700>{</span>
</span></span><span style=display:flex><span>    <span style=color:#204a87;font-weight:700>uint32_t</span> <span style=color:#000>encoding</span><span style=color:#000;font-weight:700>;</span>
</span></span><span style=display:flex><span>    <span style=color:#204a87;font-weight:700>uint32_t</span> <span style=color:#000>length</span><span style=color:#000;font-weight:700>;</span>
</span></span><span style=display:flex><span>    <span style=color:#204a87;font-weight:700>int8_t</span> <span style=color:#000>contents</span><span style=color:#000;font-weight:700>[];</span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>}</span> <span style=color:#000>intset</span><span style=color:#000;font-weight:700>;</span>
</span></span></code></pre></div><ul><li><p><code>encoding</code> 表示编码方式，的取值有三个：INTSET_ENC_INT16, INTSET_ENC_INT32, INTSET_ENC_INT64</p></li><li><p><code>length</code> 代表其中存储的整数的个数</p></li><li><p><code>contents</code> 指向实际存储数值的连续内存区域, 就是一个数组；整数集合的每个元素都是 contents 数组的一个数组项（item），各个项在数组中按值得大小<strong>从小到大有序排序</strong>，且数组中不包含任何重复项。（虽然 intset 结构将 contents 属性声明为 int8_t 类型的数组，但实际上 contents 数组并不保存任何 int8_t 类型的值，contents 数组的真正类型取决于 encoding 属性的值）</p></li></ul><h3 id=内存布局>内存布局</h3><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210504150750.png style=display:block;width:50% alt=NAME align=center></div><p>content数组里面每个元素的数据类型是由encoding来决定的，那么如果原来的数据类型是int16, 当我们再插入一个int32类型的数据时怎么办呢？这就是下面要说的intset的升级。</p><h3 id=升级>升级</h3><p>当在一个int16类型的整数集合中插入一个int32类型的值，整个集合的所有元素都会转换成32类型。 整个过程有三步：</p><ul><li>根据新元素的类型（比如int32），扩展整数集合底层数组的空间大小，并为新元素分配空间。</li><li>将底层数组现有的所有元素都转换成与新元素相同的类型， 并将类型转换后的元素放置到正确的位上， 而且在放置元素的过程中， 需要继续维持底层数组的有序性质不变。</li><li>最后改变encoding的值，length+1。</li></ul><p><strong>那么如果我们删除掉刚加入的int32类型时，会不会做一个降级操作呢</strong>？</p><p>不会。主要还是减少开销的权衡。</p><h2 id=跳表zskiplist>跳表：ZSkipList</h2><blockquote><p>跳跃表结构在 Redis 中的运用场景只有一个，那就是作为有序列表 (Zset) 的使用。跳跃表的性能可以保证在查找，删除，添加等操作的时候在对数期望时间内完成，这个性能是可以和平衡树来相比较的，而且在实现方面比平衡树要优雅，这就是跳跃表的长处。</p><p>跳跃表的缺点就是需要的存储空间比较大，属于利用空间来换取时间的数据结构。</p></blockquote><h3 id=跳跃表>跳跃表</h3><p>对于于一个单链表来讲，即便链表中存储的数据是有序的，如果我们要想在其中查找某个数据，也只能从头到尾遍历链表。这样查找效率就会很低，时间复杂度会很高，是 O(n)。比如查找12，需要7次查找：</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210504150943.png style=display:block;width:50% alt=NAME align=center></div><p>如果我们增加如下两级索引，那么它搜索次数就变成了3次：</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210504151003.png style=display:block;width:50% alt=NAME align=center></div><h3 id=redis-跳跃表>Redis 跳跃表</h3><p>redis跳跃表并没有在单独的类（比如skplist.c)中定义，而是其定义在server.h中, 如下:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#8f5902;font-style:italic>/* ZSETs use a specialized version of Skiplists */</span>
</span></span><span style=display:flex><span><span style=color:#204a87;font-weight:700>typedef</span> <span style=color:#204a87;font-weight:700>struct</span> <span style=color:#000>zskiplistNode</span> <span style=color:#000;font-weight:700>{</span>
</span></span><span style=display:flex><span>    <span style=color:#000>sds</span> <span style=color:#000>ele</span><span style=color:#000;font-weight:700>;</span>
</span></span><span style=display:flex><span>    <span style=color:#204a87;font-weight:700>double</span> <span style=color:#000>score</span><span style=color:#000;font-weight:700>;</span>
</span></span><span style=display:flex><span>    <span style=color:#204a87;font-weight:700>struct</span> <span style=color:#000>zskiplistNode</span> <span style=color:#ce5c00;font-weight:700>*</span><span style=color:#000>backward</span><span style=color:#000;font-weight:700>;</span>
</span></span><span style=display:flex><span>    <span style=color:#204a87;font-weight:700>struct</span> <span style=color:#000>zskiplistLevel</span> <span style=color:#000;font-weight:700>{</span>
</span></span><span style=display:flex><span>        <span style=color:#204a87;font-weight:700>struct</span> <span style=color:#000>zskiplistNode</span> <span style=color:#ce5c00;font-weight:700>*</span><span style=color:#000>forward</span><span style=color:#000;font-weight:700>;</span>
</span></span><span style=display:flex><span>        <span style=color:#204a87;font-weight:700>unsigned</span> <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>span</span><span style=color:#000;font-weight:700>;</span>
</span></span><span style=display:flex><span>    <span style=color:#000;font-weight:700>}</span> <span style=color:#000>level</span><span style=color:#000;font-weight:700>[];</span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>}</span> <span style=color:#000>zskiplistNode</span><span style=color:#000;font-weight:700>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#204a87;font-weight:700>typedef</span> <span style=color:#204a87;font-weight:700>struct</span> <span style=color:#000>zskiplist</span> <span style=color:#000;font-weight:700>{</span>
</span></span><span style=display:flex><span>    <span style=color:#204a87;font-weight:700>struct</span> <span style=color:#000>zskiplistNode</span> <span style=color:#ce5c00;font-weight:700>*</span><span style=color:#000>header</span><span style=color:#000;font-weight:700>,</span> <span style=color:#ce5c00;font-weight:700>*</span><span style=color:#000>tail</span><span style=color:#000;font-weight:700>;</span>
</span></span><span style=display:flex><span>    <span style=color:#204a87;font-weight:700>unsigned</span> <span style=color:#204a87;font-weight:700>long</span> <span style=color:#000>length</span><span style=color:#000;font-weight:700>;</span>
</span></span><span style=display:flex><span>    <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>level</span><span style=color:#000;font-weight:700>;</span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>}</span> <span style=color:#000>zskiplist</span><span style=color:#000;font-weight:700>;</span>
</span></span></code></pre></div><p>内存布局：</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210504151129.png style=display:block;width:50% alt=NAME align=center></div><p><strong>zskiplist的核心设计要点</strong></p><ul><li><p><strong>头结点</strong>不持有任何数据, 且其level[]的长度为32</p></li><li><p>每个结点</p><ul><li><p><code>ele</code>字段，持有数据，是sds类型</p></li><li><p><code>score</code>字段, 其标示着结点的得分, 结点之间凭借得分来判断先后顺序, 跳跃表中的结点按结点的得分升序排列.</p></li><li><p><code>backward</code>指针, 这是原版跳跃表中所没有的. 该指针指向结点的前一个紧邻结点.</p></li><li><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>level
</span></span></code></pre></div><p>字段, 用以记录所有结点(除过头结点外)；每个结点中最多持有32个zskiplistLevel结构. 实际数量在结点创建时, 按幂次定律随机生成(不超过32). 每个zskiplistLevel中有两个字段</p><ul><li><code>forward</code>字段指向比自己得分高的某个结点(不一定是紧邻的), 并且, 若当前zskiplistLevel实例在level[]中的索引为X, 则其forward字段指向的结点, 其level[]字段的容量至少是X+1. 这也是上图中, 为什么forward指针总是画的水平的原因.</li><li><code>span</code>字段代表forward字段指向的结点, 距离当前结点的距离. 紧邻的两个结点之间的距离定义为1.</li></ul></li></ul></li></ul><h3 id=为什么不选择平衡树或哈希表>为什么不选择平衡树或哈希表</h3><p>作者：</p><blockquote><p>There are a few reasons:</p><p>They are not very memory intensive. It&rsquo;s up to you basically. Changing parameters about the probability of a node to have a given number of levels will make then less memory intensive than btrees.
A sorted set is often target of many ZRANGE or ZREVRANGE operations, that is, traversing the skip list as a linked list. With this operation the cache locality of skip lists is at least as good as with other kind of balanced trees.</p><p>They are simpler to implement, debug, and so forth. For instance thanks to the skip list simplicity I received a patch (already in Redis master) with augmented skip lists implementing ZRANK in O(log(N)). It required little changes to the code.</p><p>About the Append Only durability & speed, I don&rsquo;t think it is a good idea to optimize Redis at cost of more code and more complexity for a use case that IMHO should be rare for the Redis target (fsync() at every command). Almost no one is using this feature even with ACID SQL databases, as the performance hint is big anyway.
About threads: our experience shows that Redis is mostly I/O bound. I&rsquo;m using threads to serve things from Virtual Memory. The long term solution to exploit all the cores, assuming your link is so fast that you can saturate a single core, is running multiple instances of Redis (no locks, almost fully scalable linearly with number of cores), and using the &ldquo;Redis Cluster&rdquo; solution that I plan to develop in the future.</p></blockquote><p>简而言之就是实现简单且达到了类似效果。</p><p>skiplist和各种平衡树（如AVL、红黑树等）的元素是有序排列的，而哈希表不是有序的。因此，在哈希表上只能做单个key的查找，不适宜做范围查找。所谓范围查找，指的是查找那些大小在指定的两个值之间的所有节点。</p><p>在做范围查找的时候，平衡树比skiplist操作要复杂。在平衡树上，我们找到指定范围的小值之后，还需要以中序遍历的顺序继续寻找其它不超过大值的节点。如果不对平衡树进行一定的改造，这里的中序遍历并不容易实现。而在skiplist上进行范围查找就非常简单，只需要在找到小值之后，对第1层链表进行若干步的遍历就可以实现。</p><p>平衡树的插入和删除操作可能引发子树的调整，逻辑复杂，而skiplist的插入和删除只需要修改相邻节点的指针，操作简单又快速。</p><p>从内存占用上来说，skiplist比平衡树更灵活一些。一般来说，平衡树每个节点包含2个指针（分别指向左右子树），而skiplist每个节点包含的指针数目平均为1/(1-p)，具体取决于参数p的大小。如果像Redis里的实现一样，取p=1/4，那么平均每个节点包含1.33个指针，比平衡树更有优势。</p><p>查找单个key，skiplist和平衡树的时间复杂度都为O(log n)，大体相当；而哈希表在保持较低的哈希值冲突概率的前提下，查找时间复杂度接近O(1)，性能更高一些。所以我们平常使用的各种Map或dictionary结构，大都是基于哈希表实现的。</p><p>从算法实现难度上来比较，skiplist比平衡树要简单得多。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-e23ea9a97b8e45f6fe4f13ffc2073690>7.6 - CH06-缓存机制</h1><p>在实际的工作项目中， 缓存成为高并发、高性能架构的关键组件 ，那么Redis为什么可以作为缓存使用呢？首先可以作为缓存的两个主要特征：</p><ul><li>在分层系统中处于内存/CPU具有访问性能良好，</li><li>缓存数据饱和，有良好的数据淘汰机制</li></ul><p>由于 Redis 天然就具有这两个特征，Redis 基于内存操作的，且其具有完善的数据淘汰机制，十分适合作为缓存组件。</p><p>其中，基于内存操作，容量可以为 32-96GB，且操作时间平均为 100ns，操作效率高。而且数据淘汰机制众多，在Redis 4.0 后就有 8 种了促使 Redis 作为缓存可以适用很多场景。</p><h2 id=淘汰机制>淘汰机制</h2><p>Redis 对于缓存被写满的情况，就需要缓存数据淘汰机制，通过一定淘汰规则将一些数据刷选出来删除，让缓存服务可再使用。那么 Redis 使用哪些淘汰策略进行刷选删除数据？</p><p>在 Redis 4.0 之后，Redis 缓存淘汰策略 6+2 种，包括分成三大类：</p><ul><li>不淘汰数据<ul><li>noeviction ，不进行数据淘汰，当缓存被写满后，Redis不提供服务直接返回错误。</li></ul></li><li>在设置过期时间的键值对中，<ul><li>volatile-random ，在设置过期时间的键值对中随机删除</li><li>volatile-ttl ，在设置过期时间的键值对，基于过期时间的先后进行删除，越早过期的越先被删除。</li><li>volatile-lru ， 基于LRU(Least Recently Used) 算法筛选设置了过期时间的键值对， 最近最少使用的原则来筛选数据</li><li>volatile-lfu ，使用 LFU( Least Frequently Used ) 算法选择设置了过期时间的键值对, 使用频率最少的键值对,来筛选数据。</li></ul></li><li>在所有的键值对中<ul><li>allkeys-random， 从所有键值对中随机选择并删除数据</li><li>allkeys-lru， 使用 LRU 算法在所有数据中进行筛选</li><li>allkeys-lfu， 使用 LFU 算法在所有数据中进行筛选</li></ul></li></ul><blockquote><p><strong>Note</strong>: LRU( 最近最少使用，Least Recently Used)算法， LRU维护一个双向链表 ，链表的头和尾分别表示 MRU 端和 LRU 端，分别代表最近最常使用的数据和最近最不常用的数据。</p><p>LRU 算法在实际实现时，需要用链表管理所有的缓存数据，这会带来额外的空间开销。而且，当有数据被访问时，需要在链表上把该数据移动到 MRU 端，如果有大量数据被访问，就会带来很多链表移动操作，会很耗时，进而会降低 Redis 缓存性能。</p></blockquote><p>其中，LRU和LFU 基于Redis的对象结构<code>redisObject</code>的<code>lru</code>和<code>refcount</code>属性实现的:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#204a87;font-weight:700>typedef</span> <span style=color:#204a87;font-weight:700>struct</span> <span style=color:#000>redisObject</span> <span style=color:#000;font-weight:700>{</span>
</span></span><span style=display:flex><span>  <span style=color:#204a87;font-weight:700>unsigned</span> <span style=color:#f57900>type</span><span style=color:#000;font-weight:700>:</span><span style=color:#0000cf;font-weight:700>4</span><span style=color:#000;font-weight:700>;</span>
</span></span><span style=display:flex><span>  <span style=color:#204a87;font-weight:700>unsigned</span> <span style=color:#f57900>encoding</span><span style=color:#000;font-weight:700>:</span><span style=color:#0000cf;font-weight:700>4</span><span style=color:#000;font-weight:700>;</span>
</span></span><span style=display:flex><span>  <span style=color:#8f5902;font-style:italic>// 对象最后一次被访问的时间
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span>  <span style=color:#204a87;font-weight:700>unsigned</span> <span style=color:#f57900>lru</span><span style=color:#000;font-weight:700>:</span><span style=color:#000>LRU_BITS</span><span style=color:#000;font-weight:700>;</span> <span style=color:#8f5902;font-style:italic>/* LRU time (relative to global lru_clock) or
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>                            * LFU data (least significant 8 bits frequency
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>  // 引用计数               * and most significant 16 bits access time). */</span>
</span></span><span style=display:flex><span>  <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>refcount</span><span style=color:#000;font-weight:700>;</span>
</span></span><span style=display:flex><span>  <span style=color:#204a87;font-weight:700>void</span> <span style=color:#ce5c00;font-weight:700>*</span><span style=color:#000>ptr</span><span style=color:#000;font-weight:700>;</span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>}</span> <span style=color:#000>robj</span><span style=color:#000;font-weight:700>;</span>
</span></span></code></pre></div><p><code>Redis</code>的<code>LRU</code>会使用<code>redisObject</code>的<code>lru</code>记录最近一次被访问的时间，随机选取参数<code>maxmemory-samples</code> 配置的数量作为候选集合，在其中选择 <code>lru</code> 属性值最小的数据淘汰出去。</p><p>在实际项目中，那么该如何选择数据淘汰机制呢？</p><ul><li>优先选择 <code>allkeys-lru</code>算法，将最近最常访问的数据留在缓存中，提升应用的访问性能。</li><li>有顶置数据使用 <code>volatile-lru</code>算法 ,顶置数据不设置缓存过期时间，其他数据设置过期时间，基于LRU 规则进行筛选 。</li></ul><p>在理解了Redis缓存淘汰机制后，来看看Redis作为缓存共有多少种模式呢？</p><h2 id=缓存模式>缓存模式</h2><p>Redis 缓存模式基于是否接收写请求，可以分成只读缓存和读写缓存：</p><ul><li><p>只读缓存：只处理读操作，所有的更新操作都在数据库中，这样数据不会有丢失的风险。</p><ul><li>Cache Aside模式</li><li><div><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20220219174644.png style=display:block;margin-left:auto;margin-right:auto;width:80% alt=20220219174644></div></li></ul></li><li><p>读写缓存：读写操作都在缓存中执行，出现宕机故障，会导致数据丢失。缓存写回数据到数据库有分成两种同步和异步：</p><ul><li><p>同步：访问性能偏低，其更加侧重于保证数据可靠性</p><ul><li>Read-Throug模式</li><li>Write-Through模式</li></ul></li><li><p>异步：有数据丢失风险，其侧重于提供低延迟访问</p><ul><li>Write-Behind模式</li></ul></li><li><div><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20220219174748.png style=display:block;margin-left:auto;margin-right:auto;width:80% alt=20220219174748></div></li></ul></li></ul><h3 id=cache-aside-模式>Cache Aside 模式</h3><p>查询数据先从缓存读取数据，如果缓存中不存在，则再到数据库中读取数据，获取到数据之后更新到缓存Cache中，<strong>但更新数据操作，会先去更新数据库种的数据，然后将缓存种的数据失效。</strong></p><p>而且Cache Aside模式会存在并发风险：执行读操作未命中缓存，然后查询数据库中取数据，数据已经查询到还没放入缓存，同时一个更新写操作让缓存失效，然后读操作再把查询到数据加载缓存，导致缓存的脏数据。</p><h3 id=readwrite-throug-模式>Read/Write-Throug 模式</h3><p>查询数据和更新数据都直接访问缓存服务，<strong>缓存服务同步方式地将数据更新到数据库</strong>。出现脏数据的概率较低，但是就强依赖缓存，对缓存服务的稳定性有较大要求，但同步更新会导致其性能不好。</p><h3 id=write-behind-模式>Write Behind 模式</h3><p>查询数据和更新数据都直接访问缓存服务，<strong>但缓存服务使用异步方式地将数据更新到数据库（通过异步任务）</strong> 速度快，效率会非常高，但是数据的一致性比较差，还可能会有数据的丢失情况，实现逻辑也较为复杂。</p><h2 id=生产实践>生产实践</h2><p>在实际项目开发中根据实际的业务场景需求来进行选择缓存模式。那了解上述后，我们的应用中为什么需要使用到<code>redis</code>缓存呢？</p><p>在应用使用<code>Redis</code>缓存可以提高系统性能和并发，主要体现在</p><ul><li>高性能：基于内存查询，KV结构，简单逻辑运算</li><li>高并发：<code>Mysql</code> 每秒只能支持2000左右的请求，<code>Redis</code>轻松每秒1W以上。让80%以上查询走缓存，20%以下查询走数据库，能让系统吞吐量有很大的提高</li></ul><p>虽然使用Redis缓存可以大大提升系统的性能，但是使用了缓存，会出现一些问题，比如，缓存与数据库双向不一致、缓存雪崩等，对于出现的这些问题该怎么解决呢？</p><h2 id=常见问题>常见问题</h2><p>使用了缓存，会出现一些问题，主要体现在：</p><ul><li>缓存与数据库双写不一致</li><li>缓存雪崩: Redis 缓存无法处理大量的应用请求，转移到数据库层导致数据库层的压力激增;</li><li>缓存穿透：访问数据不存在在Redis缓存中和数据库中，导致大量访问穿透缓存直接转移到数据库导致数据库层的压力激增;</li><li>缓存击穿：缓存无法处理高频热点数据，导致直接高频访问数据库导致数据库层的压力激增;</li></ul><h3 id=数据一致性>数据一致性</h3><h4 id=只读缓存cache-aside模式><strong>只读缓存(Cache Aside模式)</strong></h4><p>对于<strong>只读缓存(<code>Cache Aside</code>模式)</strong>，读操作都发生在缓存中，数据不一致只会发生在删改操作上（新增操作不会，因为新增只会在数据库处理），当发生删改操作时，缓存将数据中标志为无效和更新数据库。因此在更新数据库和删除缓存值的过程中，无论这两个操作的执行顺序谁先谁后，只要有一个操作失败了就会出现数据不一致的情况。</p><p>总结出，<strong>当不存在并发的情况使用重试机制（消息队列使用），当存在高并发的情况，使用延迟双删除(在第一次删除后，睡眠一定时间后，再进行删除)</strong>，具体如下：</p><table><thead><tr><th>操作顺序</th><th>高并发</th><th>潜在问题</th><th>现象</th><th>应对方案</th></tr></thead><tbody><tr><td>先删除缓存，再更新数据库</td><td>否</td><td>缓存删除成功，数据库更新失败</td><td>读到数据库的旧值</td><td>重试机制（数据库更新）</td></tr><tr><td>先更新数据库，再删除缓存</td><td>否</td><td>数据库更新成功，缓存删除失败</td><td>读到缓存的旧值</td><td>重试机制（缓存删除）</td></tr><tr><td>先删除缓存，再更新数据库</td><td>是</td><td>缓存删除后，尚未更新数据库，有并发读请求</td><td>并发读请求读到数据库旧值，并更新到缓存，导致之后的读请求读到旧值</td><td>延迟双删</td></tr><tr><td>先更新数据库，再删除缓存</td><td>是</td><td>数据库更新成功，尚未删除缓存</td><td>读到缓存的旧值</td><td>不一致的情况短暂存在，对业务影响较小</td></tr></tbody></table><blockquote><p>延迟双删除伪代码：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>redis.delKey(X)
</span></span><span style=display:flex><span>db.update(X)
</span></span><span style=display:flex><span>Thread.sleep(N)
</span></span><span style=display:flex><span>redis.delKey(X)
</span></span></code></pre></div></blockquote><h4 id=读写缓存readwrite-througwrite-behind模式-><strong>读写缓存（Read/Write-Throug、Write Behind模式 ）</strong></h4><p>对于读写缓存，写操作都发生在缓存中，后再更新数据库，只要有一个操作失败了就会出现数据不一致的情况。</p><p>总结出，当不存在并发的情况使用重试机制（消息队列使用），当存在高并发的情况，使用分布锁。具体如下：</p><table><thead><tr><th>操作顺序</th><th>高 并发</th><th>潜在问题</th><th>现象</th><th>应对方案</th></tr></thead><tbody><tr><td>先更新缓存，再更新数据库</td><td>否</td><td>缓存更新成功，数据库更新失败</td><td>会从缓存中读到最新值，短期影响不大</td><td>重试机制（数据库更新）</td></tr><tr><td>先更新数据库，再更新缓存</td><td>否</td><td>数据库更新成功，缓存更新失败</td><td>会从缓存读到旧值</td><td>重试机制（缓存删除）</td></tr><tr><td>先更新数据库，再更新缓存</td><td>写+读并发</td><td>线程A先更新数据库，之后线程B读取数据，之后线程A更新缓存</td><td>B会命中缓存，读取到旧值</td><td>A更新缓存前，对业务有短暂影响</td></tr><tr><td>先更新缓存，再更新数据库</td><td>写+读并发</td><td>线程A先更新缓存成功，之后线程B读取数据，此时线程B命中缓存，读取到最新值后返回，之后线程A更新数据库成功</td><td>B会命中缓存，读取到最新值</td><td>业务没影响</td></tr><tr><td>先更新数据库，再更新缓存</td><td>写+写并发</td><td>线程A和线程B同时更新同一条数据，更新数据库的顺序是先A后B，但更新缓存时顺序是先B后A，这会导致数据库和缓存的不一致</td><td>数据库和缓存的不一致</td><td>写操作加分布式锁</td></tr><tr><td>先更新缓存，再更新数据库</td><td>写+写并发</td><td>线程A和线程B同时更新同一条数据，更新缓存的顺序是先A后B，但是更新数据库的顺序是先B后A，这也会导致数据库和缓存的不一致</td><td>数据库和缓存的不一致</td><td>写操作加分布式锁</td></tr></tbody></table><h3 id=缓存雪崩>缓存雪崩</h3><p>缓存雪崩，由于缓存中有大量数据同时过期失效或者缓存出现宕机，大量的应用请求无法在 Redis 缓存中进行处理，进而发送到数据库层导致数据库层的压力激增，严重的会造成数据库宕机。</p><p>对于缓存中有大量数据同时过期，导致大量请求无法得到处理， 解决方式：</p><ul><li><p><strong>数据预热</strong>，<strong>将发生大并发访问前手动触发加载缓存不同的key， 可以避免在用户请求的时候，先查询数据库</strong></p></li><li><p><strong>设置不同的过期时间，让缓存失效的时间点尽量均匀</strong></p></li><li><p><strong>双层缓存策略， 在原始缓存上加上拷贝缓存，原始缓存失效时可以访问拷贝缓存，且原始缓存失效时间设置为短期，拷贝缓存设置为长期</strong></p></li><li><p><strong>服务降级 ， 发生缓存雪崩时，针对不同的数据采取不同的降级方案</strong> ，比如，非核心数据直接返回预定义信息、空值或是错误信息</p></li></ul><p>对于缓存出现宕机，解决方式：</p><ul><li><strong>业务系统中实现服务熔断或请求限流机制，防止大量访问导致数据库出现宕机</strong></li></ul><h3 id=缓存穿透>缓存穿透</h3><p>缓存穿透，数据在数据库和缓存中都不存在，这样就导致查询数据，在缓存中找不到对应<code>key</code>的<code>value</code>，都要去数据库再查询一遍，然后返回空（相当于进行了两次无用的查询）。</p><p>当有大量访问请求，且其绕过缓存直接查数据库，导致数据库层的压力激增，严重的会造成数据库宕机。</p><p>对于缓存穿透，解决方式：</p><ul><li>缓存空值或缺省值，当一个查询返回的数据为空时， 空结果也将进行缓存，并将它的过期时间设置比较短，下次访问直接从缓存中取值，避免了把大量请求发送给数据库处理，造成数据库出问题。</li><li>布隆过滤器( <strong>BloomFilter</strong> )，将所有可能查询数据<code>key</code>哈希到一个足够大的<code>bitmap</code>中 , 在查询的时候先去<code>BloomFilter</code>去查询<code>key</code>是否存在，如果不存在就直接返回，存在再去查询缓存，缓存中没有再去查询数据库 ，从而避免了数据库层的压力激增出现宕机。</li></ul><h3 id=缓存击穿>缓存击穿</h3><p>缓存击穿，针对某个访问非常频繁的热点数据过期失效，导致访问无法在缓存中进行处理，进而会有导致大量的直接请求数据库，从而使得数据库层的压力激增，严重的会造成数据库宕机。</p><p>对于缓存击穿，解决方式：</p><ul><li>不设置过期时间，对于访问特别频繁的热点数据，不设置过期时间。</li></ul><h3 id=问题总结>问题总结</h3><p>在大多数业务场景下，Redis缓存作为只读缓存使用。针对只读缓存来说， 优先使用先更新数据库再删除缓存的方法保证数据一致性 。</p><p>其中，缓存雪崩，缓存穿透，缓存击穿三大问题的原因和解决方式</p><table><thead><tr><th>问题</th><th>原因</th><th>解决方式</th></tr></thead><tbody><tr><td>缓存雪崩</td><td>大量数据同时过期失效缓存出现宕机</td><td>数据预热设置不同的过期时间双层缓存策略服务降级服务熔断限流机制</td></tr><tr><td>缓存穿透</td><td>数据在数据库和缓存中都不存在</td><td>缓存空值或缺省值布隆过滤器( <strong>BloomFilter</strong> )</td></tr><tr><td>缓存击穿</td><td>访问非常频繁的热点数据过期失效</td><td>对于访问特别频繁的热点数据，不设置过期时间</td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-76cf898359b51ee9f123cd859135b47d>7.7 - CH07-高可用性</h1><h2 id=主从复制>主从复制</h2><p>Redis 主从复制模式可以将主节点的数据同步给从节点，从而保障当主节点不可达的情况下，从节点可以作为后备顶上来，并且可以保障数据尽量不丢失。主从复制可以保障最终一致性</p><p>从节点可以扩展主节点的读能力，一旦主节点不能支持大规模并发量的读操作，从节点可以在一定程度上分担主节点的压力。</p><div><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20220219220108.png style=display:block;margin-left:auto;margin-right:auto;width:80% alt=20220219220108></div><p>主从复制面临的问题：</p><ol><li>当主节点发生故障的时候，需要手动的将一个从节点晋升为主节点，同时通知应用方修改主节点地址并重启应用，同时需要命令其它从节点复制新的主节点，整个过程需要人工干预。</li><li>主节点的写能力受到单机的限制。</li><li>主节点的存储能力受到单机的限制。</li></ol><h3 id=复制过程>复制过程</h3><p>一般当<code>slave</code>第一次启动连接<code>master</code>，或者“被认为是第一次连接”，是主从采用全量复制。全量复制的执行流程如下：</p><ol><li><code>slave redis</code>启动. 会从<code>redis.conf</code>中读取<code>master ip</code>和<code>host</code>。</li><li>定时任务每秒检查是否有新的<code>mater</code>需要连接，如果发现就与<code>master</code>建立<code>socket</code>连接。</li><li><code>slave</code>发送<code>ping</code>指令到<code>mater</code>。</li><li>如果<code>mater</code>配置<code>require pass</code>，<code>slave</code>需要发送认证给<code>master</code>。</li><li><code>Salve</code>会发送<code>sync</code>命令到<code>Master</code>。</li><li><code>Master</code>启动一个后台进程，将<code>Redis</code>中的数据快照<code>rdb</code>保存到文件中。</li><li>启动后台进程的同时，<code>Master</code>会将保存数据快照期间接收到的写命令缓存起来。</li><li><code>Master</code>完成写文件操作后，将<code>rdb</code>发送给<code>Salve</code>。</li><li><code>Salve</code>将<code>rdb</code>保存到磁盘上，然后加载<code>rdb</code>到<code>redis</code>内存中。</li><li>当<code>Salve</code>完成数据快照的恢复后，<code>aster</code>将这期间收集的写命令发送给<code>Salve</code>端。</li><li>后续<code>Master</code>收集到的写命令都会通过之前建立的连接. 增量发送给<code>salve</code>端。</li></ol><div><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20220219220824.png style=display:block;margin-left:auto;margin-right:auto;width:80% alt=20220219220824></div><h3 id=增量复制>增量复制</h3><p>当<code>slave</code>节点与<code>master</code>全量同步后，<code>master</code>节点上数据再次发生更新，就会触发增量复制。</p><p>当我们在 <code>master</code> 服务器增减数据的时候，就会触发 <code>replicationFeedSalves()</code>函数，接下来在 <code>Master</code> 服务器上调用的每一个命令都会使用<code>replicationFeedSlaves()</code> 函数来同步到<code>Slave</code>服务器。当然，在执行此函数之前<code>master</code>服务器会判断用户执行的命令是否有数据更新，如果有数据更新并且<code>slave</code>服务器不为空，才会执行此函数，函数主要的工作就是把用户执行的命令发送到所有的 <code>slave</code>服务器，让<code>slave</code>服务器执行。
流程如下图：</p><div><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20220219220856.png style=display:block;margin-left:auto;margin-right:auto;width:30% alt=20220219220856></div><h3 id=断点续传>断点续传</h3><p>断点续传或者说是断点恢复复制，也就是说 slave 因为某种原因与<code>master</code>断开连接了一段时间，然后又与<code>master</code>发生重连。<code>redis2.8</code>以后对于这种场景进行了优化，开始加入了<code>PSYNC</code>同步策略。这种策略性能一定是大于全量复制的。</p><ol><li>从服务器向主服务器发送<code>PSYNC</code>命令，携带主服务器的<code>runid</code>和复制偏移量；</li><li>主服务器验证<code>runid</code>和自身<code>runid</code>是否一致，如不一致，则进行全量复制；</li><li>主服务器验证复制偏移量是否在积压缓冲区内，如不在，则进行全量复制；</li><li>如都验证通过，则主服务器将保持在积压区内的偏移量后的所有数据发送给从服务器，主从服务器再次回到一致状态。</li></ol><div><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20220219220940.png style=display:block;margin-left:auto;margin-right:auto;width:50% alt=20220219220940></div><h4 id=psync-核心参数>PSYNC 核心参数</h4><p>断点续传的几个核心参数，<code>offset</code>、<code>backlog</code>、<code>runid</code>。这三个参数在 PSYNC 中起到了至关重要的作用，下面我们来一一介绍一下。</p><ul><li><code>offet</code>复制偏移量 , <code>offset</code>是用来记录<code>master</code>和<code>lslave</code>某个时段的数据版本状态的，<code>slave</code>每秒会向<code>master</code>上报<code>offset</code>，<code>master</code>保存下来，当触发 PSYNC 时再拿来和<code>master</code>的<code>offset</code>数据作对比。说白了，它就是记录数据在某一时刻的快照，用来对比 master 和 slave 数据差异用的。</li><li><code>backlog</code>积压缓冲区<ol><li>这个也是一个非常核心的参数，它默认大小为<code>1mb</code>，复制积压缓冲区是由<code>Master</code>维护的一个固定长度的<code>FIFO</code>队列，它的作用是缓存已经传播出去的命令。当<code>Master</code>进行命令传播时，不仅将命令发送给所有<code>Slave</code>，还会将命令写入到复制积压缓冲区里面。</li><li>全量复制的时候，<code>master</code>的数据更新（读写操作，主动过期删除等）会临时存放在<code>backlog</code>中待全量复制完成后增量发到slave，必须为此保留足够的空间。</li><li>断点续传时，<code>backlog</code>会存下<code>slave</code>断开连接后，<code>master</code>变更的数据。当然由于它大小有限制，而且先进先出特性，所以达到缓冲大小后会弹出老数据。这样，就可以把它作为一个衡量执行<code>sync</code>还是<code>psync</code>的一个标准<code>（backlog = offset : 部分同步，backlog &lt; offset 执行全量同步）</code>。一般为了避免，大规模全量复制，我们都会给一个恰当的值，根据公式<code>second*write_size_per_second</code>来估算：其中<code>second</code>为从服务器断线后重新连接上主服务器所需的平均时间（以秒计算）；而<code>write_size_per_second</code>则是主服务器平均每秒产生的写命令数据量（协议格式的写命令的长度总和）；</li></ol></li><li>master run id, <code>master</code>唯一标示，<code>slave</code>连接<code>master</code>时会传<code>runid</code>，<code>master</code>每次重启<code>runid</code>都发生变化，当<code>slave</code>发现<code>master</code>的<code>runid</code>变化时都会触发全量复制流程。</li></ul><h3 id=优缺点>优缺点</h3><p><strong>优点：</strong></p><ol><li>高可靠性：一方面，采用双机主备架构，能够在主库出现故障时自动进行主备切换，从库提升为主库提供服务，保证服务平稳运行；另一方面，开启数据持久化功能和配置合理的备份策略，能有效的解决数据误操作和数据异常丢失的问题；</li><li>读写分离策略：从节点可以扩展主库节点的读能力，有效应对大并发量的读操作。</li></ol><p><strong>缺点：</strong></p><ol><li>故障恢复复杂，如果没有<code>RedisHA</code>系统（需要开发），当主库节点出现故障时，需要手动将一个从节点晋升为主节点，同时需要通知业务方变更配置，并且需要让其它从库节点去复制新主库节点，整个过程需要人为干预，比较繁琐；</li><li>主库的写能力受到单机的限制，可以考虑分片；</li><li>主库的存储能力受到单机的限制，可以考虑<code>Pika</code>；</li><li>原生复制的弊端在早期的版本中也会比较突出，如：<code>Redis</code>复制中断后，<code>Slave</code>会发起<code>psync</code>，此时如果同步不成功，则会进行全量同步，主库执行全量备份的同时可能会造成毫秒或秒级的卡顿；又由于<code>COW</code>机制，导致极端情况下的主库内存溢出，程序异常退出或宕机；主库节点生成备份文件导致服务器磁盘<code>IO</code>和<code>CPU</code>（压缩）资源消耗；发送数<code>GB</code>大小的备份文件导致服务器出口带宽暴增，阻塞请求，建议升级到最新版本。</li></ol><h2 id=redis-sentinel>Redis Sentinel</h2><div><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20220219220207.png style=display:block;margin-left:auto;margin-right:auto;width:80% alt=20220219220207></div><p>当主节点出现故障时，Redis Sentinel 能自动完成故障发现和故障转移，并通知应用方，从而实现真正的高可用。RedisSentinel 是一个分布式架构，其中包含若干个 Sentinel 节点和 Redis 数据节点，每个 Sentinel 节点会对数据节点和其余 Sentinel 节点进行监控，当它发现节点不可达时，会对节点做下线标识。如果被标识的是<strong>主节点</strong>，它还会和其他的 Sentinel 节点进行协商，当大多数 Sentinel 节点都认为主节点不可达时，它们会选举一个 Sentinel 节点来完成自动故障转移的工作，同时会将这个变化实时通知给 Redis 应用方。整个过程是自动的，不需要人工干预，解决了Redis 的高可用问题。</p><p>Redis Sentinel 包含了若干个 Sentinel 节点，这样做也带来了两个好处：</p><ol><li>对节点的故障判断是由多个 Sentinel 节点共同完成，这样可以有效的防止误判。</li><li>Sentinel 节点集合是由若干个 Sentinel 节点组成的，这样即使个别 Sentinel 节点不可用，整个Sentinel节点集合依然是健壮的。</li></ol><p>Redis Sentinel 具有以下几个功能：</p><ol><li>监控：Sentinel 会定期检测 Redis 数据节点、其余 Sentinel 节点是否可到达</li><li>通知：Sentinel 会将故障转移的结果通知给应用方。</li><li>主节点故障转移：实现从节点晋升为主节点并维护后续正确的主从关系。</li><li>配置提供者：在 RedisSentinel 结构中，客户端在初始化的时候连接的是 Sentinel 节点集合，从中获取主节点信息。</li></ol><p>RedisSentinel 处理流程：</p><ol><li>Sentinel 集群通过给定的配置文件发现 master，启动时会监控 master。通过向 master 发送 info 信息获得该服务器下面的所有从服务器。</li><li>Sentinel 集群通过命令连接向被监视的主从服务器发送 hello 信息（每秒一次），该信息包括 Sentinel 本身的 IP、端口、id 等内容，以此来向其他 Sentinel 宣告自己的存在。</li><li>Sentinel 集群通过订阅连接接收其他 Sentinel 发送的 hello 信息，以此来发现监视同一个主服务器的其他 Sentinel；集群之间会互相创建命令连接用于通信，因为已经有主从服务器作为发送和接收 hello 信息的中介，Sentinel 之间不会创建订阅连接。</li><li>Sentinel 集群使用 ping 命令来检测实例的状态，如果在指定的时间内（down-after-milliseconds）没有回复或则返回错误的回复，那么该实例被判为下线。</li><li>当 failover 主备切换被触发后，failover 并不会马上进行，Sentinel 中的大多数 Sentinel 授权后才可以进行 failover，即进行 failover 的 Sentinel 会去获得指定 quorum 个的 Sentinel 的授权，成功后进入 ODOWN 状态。如在 5 个 Sentinel 中配置了 2 个 quorum，等到 2 个 Sentinel 认为 master 死了就执行 failover。</li><li>Sentinel 向选为 master 的 slave 发送 SLAVEOF NO ONE 命令，选择 slave 的条件是 Sentinel 首先会根据 slaves 的优先级来进行排序，优先级越小排名越靠前。如果优先级相同，则查看复制的下标，哪个从 master 接收的复制数据多，哪个就靠前。如果优先级和下标都相同，就选择进程 ID 较小的。</li><li>Sentinel 被授权后，它将会获得宕掉的 master 的一份最新配置版本号 (config-epoch)，当 failover 执行结束以后，这个版本号将会被用于最新的配置，通过广播形式通知其它 Sentinel，其它的 Sentinel 则更新对应 master 的配置。</li></ol><p>1 到 3 是自动发现机制:</p><ul><li>以 10 秒一次的频率，向被监视的 master 发送 info 命令，根据回复获取 master 当前信息。</li><li>以 1 秒一次的频率，向所有 redis 服务器、包含 Sentinel 在内发送 PING 命令，通过回复判断服务器是否在线。与主节点，从节点，其余 Sentinel 都建立起连接，实现了对每个节点的监控。</li><li>以 2 秒一次的频率，通过向所有被监视的 master，slave 服务器发送当前 Sentinel master 信息的消息。这个定时任务可以完成以下两个工作：<ul><li>发现新的 Sentinel 节点：通过订阅主节点的 <em>Sentinel</em>:hello 了解其他 Sentinel 节点信息。如果是新加入的 Sentinel 节点，将该 Sentinel 节点信息保存起来，并与该 Sentinel 节点创建连接</li><li>Sentinel 节点之间交换主节点状态，作为后面客观下线以及领导者选举的依据</li></ul></li></ul><p>4 是检测机制，5 和 6 是 failover 机制，7 是更新配置机制</p><h3 id=leader-选举>Leader 选举</h3><p>其实在 sentinels 故障转移中，仍然需要一个 Leader 来调度整个过程：master 的选举以及 slave 的重配置和同步。当集群中有多个 sentinel 实例时，如何选举其中一个 sentinel 为 leader 呢？</p><p>在配置文件中 can-failover、quorum 参数，以及 is-master-down-by-addr 指令配合来完成整个过程。</p><ol><li>can-failover 用来表明当前 sentinel 是否可以参与 failover 过程，如果为 YES 则表明它将有能力参与 Leader 的选举，否则它将作为 Observer ，observer 参与 leader 选举投票但不能被选举；</li><li>quorum 不仅用来控制 master ODOWN 状态确认，同时还用来选举 leader 时最小「赞同票」数；</li><li>is-master-down-by-addr，在上文中以及提到，它可以用来检测 ip + port 的 master 是否已经处于 SDOWN 状态，不过此指令不仅能够获得 master 是否处于 SDOWN，同时它还额外的返回当前 sentinel 本地「投票选举」的 Leader 信息 (runid);</li></ol><p>每个 sentinel 实例都持有其他的 sentinels 信息，在 Leader 选举过程中（当为 leader 的 sentinel 实例失效时，有可能 master server 并没失效，注意分开理解），sentinel 实例将从所有的 sentinels 集合中去除 can-failover = no 和状态为 SDOWN 的 sentinels，在剩余的 sentinels 列表中按照 runid 按照「字典」顺序排序后，取出 runid 最小的 sentinel 实例，并将它「投票选举」为 Leader，并在其他 sentinel 发送的 is-master-down-by-addr 指令时将推选的 runid 追加到响应中。每个 sentinel 实例都会检测 is-master-down-by-addr 的响应结果，如果「投票选举」的 leader 为自己，且状态正常的 sentinels 实例中，赞同者的自己的 sentinel 个数不小于(>=) 50% + 1,且不小与 ，那么此 sentinel 就会认为选举成功且 leader 为自己。</p><p>在 sentinel.conf 文件中，我们期望有足够多的 sentinel 实例配置 can-failovers，这样能够确保当 leader 失效时，能够选举某个 sentinel 为 leader，以便进行 failover。如果 leader 无法产生，比如较少的 sentinels 实例有效，那么 failover 过程将续。</p><h3 id=failover-过程>failover 过程</h3><p>在 Leader 触发 failover 之前，首先 wait 数秒（随机 0~5），以便让其他 sentinel 实例准备和调整，如果一切正常，那么 leader 就需要开始将一个 salve 提升为 master，此 slave 必须为状态良好（不能处于 SDOWN/ODOWN 状态）且权重值最低（redis.conf中）的，当 master 身份被确认后，开始 failover：</p><ol><li>+failover-triggered: Leader 开始进行 failover，此后紧跟着 +failover-state-wait-start ，wait 数秒。</li><li>+failover-state-select-slave: Leader 开始查找合适的 slave</li><li>+selected-slave: 已经找到合适的 slave</li><li>+failover-state-sen-slaveof-noone: Leader 向 slave 发送 slaveof no one 指令，此时 slave 已经完成角色转换，此 slave 即为 master</li><li>+failover-state-wait-promotition: 等待其他 sentinel 确认 slave</li><li>+promoted-slave：确认成功</li><li>+failover-state-reconf-slaves: 开始对 slaves 进行 reconfig 操作。</li><li>+slave-reconf-sent: 向指定的 slave 发送 slaveof 指令，告知此 slave 跟随新的 master</li><li>+slave-reconf-inprog: 此 slave 正在执行 slaveof + SYNC 过程，如过 slave 收到 +slave-reconf-sent 之后将会执行 slaveof 操作。</li><li>+slave-reconf-done: 此 slave 同步完成，此后 leader 可以继续下一个 slave 的 reconfig 操作。循环步骤 10</li><li>+failover-end: 故障转移结束</li><li>+switch-master：故障转移成功后，各个 sentinel 实例开始监控新的 master。</li></ol><h3 id=总结>总结</h3><p>Redis-Sentinel 是 Redis 官方推荐的高可用性解决方案，Redis-sentinel 本身也是一个独立运行的进程，它能监控多个 master-slave 集群，发现 master 宕机后能进行自动切换。Sentinel 可以监视任意多个主服务器（复用），以及主服务器属下的从服务器，并在被监视的主服务器下线时，自动执行故障转移操作。</p><div><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20220219220545.png style=display:block;margin-left:auto;margin-right:auto;width:80% alt=20220219220545></div><p>为了防止 sentinel 的单点故障，可以对 sentinel 进行集群化，创建多个 sentinel。</p><div><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20220219220607.png style=display:block;margin-left:auto;margin-right:auto;width:40% alt=20220219220607></div><h2 id=redis-cluster>Redis Cluster</h2><p><code>Redis</code> 集群是一个分布式（<code>distributed</code>）、容错（<code>fault-tolerant</code>）的 <code>Redis</code> 实现， 集群可以使用的功能是普通单机 <code>Redis</code> 所能使用的功能的一个子集（<code>subset</code>）。</p><p><code>Redis</code> 集群中不存在中心（<code>central</code>）节点或者代理（<code>proxy</code>）节点， 集群的其中一个主要设计目标是达到线性可扩展性（<code>linear scalability</code>）。</p><p><code>Redis</code> 集群提供了一种运行 <code>Redis</code> 的方式，其中数据在多个 <code>Redis</code> 节点间自动分区。<code>Redis</code> 集群还在分区期间提供一定程度的可用性，即在实际情况下能够在某些节点发生故障或无法通信时继续运行。但是，如果发生较大故障（例如，大多数主站不可用时），集群会停止运行。</p><h3 id=集群模型>集群模型</h3><div><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20220219221214.png style=display:block;margin-left:auto;margin-right:auto;width:50% alt=20220219221214></div><p>所有的节点通过服务通道直接相连，各个节点之间通过二进制协议优化传输的速度和带宽。</p><p>客户端与节点之间通过 ascii 协议进行通信。</p><p>客户端与节点直连，不需要中间 Proxy 层。客户端不需要连接集群所有节点，连接集群中任何一个可用节点即可。</p><p>尽管这些节点彼此相连，功能相同，但是仍然分为两种节点：master 和 slave。</p><h3 id=节点间传递信息>节点间传递信息</h3><div><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20220219221317.png style=display:block;margin-left:auto;margin-right:auto;width:60% alt=20220219221317></div><p>各个节点之间通过 PING-PONG 机制通信，下面是一段关于 PING-PONG 机制的会话”内容”。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>节点M：PING，嘿，朋友你好吗？我是 XYZ 哈希槽的 master ，配置信息是 FF89X1JK。
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>节点N：PONG，我很好朋友，我也是 XYZ 哈希槽的 master ，配置信息是 FF89X1JK。
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>节点M：我这里有一些关于我最近收到的其他节点的信息 ，A 节点回复了我的 PING 消息，我认为 A 节点是正常的。B 没有回应我的消息，我猜它现在可能出问题了，但是我需要一些 ACK(Acknowledgement) 消息来确认。
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>节点N：我也想给你分享一些关于其它节点的信息，C 和 D 节点在指定的时间内回应了我， 我认为它们都是正常的，但是 B 也没有回应我，我觉得它现在可能已经挂掉了。
</span></span></code></pre></div><p>每个节点会向集群中的其他节点发送节点状态信息，如果某个节点挂掉停止了服务，那么会执行投票容错机制，关于这个机制，会在下面讲到。</p><h3 id=hash-槽slot>Hash 槽(slot)</h3><p>Redis 集群不使用一致的散列，而是一种不同的分片形式，其中每个键在概念上都是我们称之为散列槽的一部分，目的是使数据均匀的存储在诸多节点中。这点类似于 HashMap 中的桶(bucket)。</p><div><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20220219221405.png style=display:block;margin-left:auto;margin-right:auto;width:50% alt=20220219221405></div><p>Redis 集群中有 16384 个散列槽，为了计算给定密钥的散列槽，Redis 对 key 采用 CRC16 算法，以下是负责将键映射到槽的算法：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>slot = crc16(key) mod NUMER_SLOTS
</span></span></code></pre></div><p>例如，你可能有 3 个节点，其中一个集群：</p><ul><li>节点 A 包含从 0 到 5500 的散列槽。</li><li>节点 B 包含从 5501 到 11000 的散列槽。</li><li>节点 C 包含 从 11001 到 16383 的散列槽。</li></ul><p>Hash 槽可以轻松地添加和删除集群中的节点。例如，如果我想添加一个新节点 D，我需要将节点 A，B，C 中的一些散列槽移动到 D。同样，如果我想从节点 A 中删除节点 A，可以只移动由 A 服务的散列槽到 B 和 C。当节点 A 为空时，可以将它从群集中彻底删除。</p><div><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20220219221447.png style=display:block;margin-left:auto;margin-right:auto;width:60% alt=20220219221447></div><ol><li>对象保存到 Redis 之前先经过 CRC16 哈希到一个指定的 Node 上，例如 Object4 最终 Hash 到了 Node1 上。</li><li>每个 Node 被平均分配了一个 Slot 段，对应着 0-16384，Slot 不能重复也不能缺失，否则会导致对象重复存储或无法存储。</li><li>Node 之间也互相监听，一旦有 Node 退出或者加入，会按照 Slot 为单位做数据的迁移。例如 Node1 如果掉线了，0-5640 这些 Slot 将会平均分摊到 Node2 和 Node3 上,由于 Node2 和 Node3 本身维护的 Slot 还会在自己身上不会被重新分配，所以迁移过程中不会影响到 5641-16384Slot 段的使用。</li></ol><div><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20220219221600.png style=display:block;margin-left:auto;margin-right:auto;width:60% alt=20220219221600></div><p>想扩展并发读就添加 Slaver，想扩展并发写就添加 Master，想扩容也就是添加 Master，任何一个 Slaver 或者几个 Master 挂了都不会是灾难性的故障。</p><p>简单总结下哈希 Slot 的优缺点：</p><p>缺点：每个 Node 承担着互相监听、高并发数据写入、高并发数据读出，工作任务繁重</p><p>优点：将 Redis 的写操作分摊到了多个节点上，提高写的并发能力，扩容简单。</p><h3 id=容错>容错</h3><div><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20220219221622.png style=display:block;margin-left:auto;margin-right:auto;width:60% alt=20220219221622></div><ul><li>集群中的节点不断的 <code>PING</code> 其他的节点，当一个节点向另一个节点发送 <code>PING</code> 命令， 但是目标节点未能在给定的时限内回复， 那么发送命令的节点会将目标节点标记为 <code>PFAIL</code>(<code>possible failure</code>，可能已失效)。</li><li>当节点接收到其他节点发来的信息时， 它会记下那些被其他节点标记为失效的节点。 这被称为失效报告（<code>failure report</code>）。</li><li>如果节点已经将某个节点标记为 <code>PFAIL</code> ， 并且根据节点所收到的失效报告显式， 集群中的大部分其他主节点也认为那个节点进入了失效状态， 那么节点会将那个失效节点的状态标记为 <code>FAIL</code> 。</li><li>一旦某个节点被标记为 <code>FAIL</code> ， 关于这个节点已失效的信息就会被广播到整个集群， 所有接收到这条信息的节点都会将失效节点标记为 <code>FAIL</code> 。</li></ul><p>简单来说， 一个节点要将另一个节点标记为失效， 必须先询问其他节点的意见， 并且得到大部分主节点的同意才行。</p><p>如果被标记为 <code>FAIL</code> 的是从节点， 那么当这个节点重新上线时， <code>FAIL</code> 标记就会被移除。 一个从节点是否处于 <code>FAIL</code> 状态， 决定了这个从节点在有需要时能否被提升为主节点。</p><p>如果一个主节点被打上 <code>FAIL</code> 标记之后， 经过了节点超时时限的四倍时间， 再加上十秒钟之后， 针对这个主节点的槽的故障转移操作仍未完成， 并且这个主节点已经重新上线的话， 那么移除对这个节点的 <code>FAIL</code> 标记。在不符合上面的条件后，一旦某个主节点进入 <code>FAIL</code> 状态， 如果这个主节点有一个或多个从节点存在， 那么其中一个从节点会被升级为新的主节点， 而其他从节点则会开始对这个新的主节点进行复制。</p><h3 id=优缺点-1>优缺点</h3><p><strong>优点：</strong></p><ol><li>无中心架构；</li><li>数据按照<code>slot</code>存储分布在多个节点，节点间数据共享，可动态调整数据分布；</li><li>可扩展性：可线性扩展到 1000 多个节点，节点可动态添加或删除；</li><li>高可用性：部分节点不可用时，集群仍可用。通过增加<code>Slave</code>做<code>standby</code>数据副本，能够实现故障自动<code>failover</code>，节点之间通过<code>gossip</code>协议交换状态信息，用投票机制完成<code>Slave</code>到<code>Master</code>的角色提升；</li><li>降低运维成本，提高系统的扩展性和可用性。</li></ol><p><strong>缺点：</strong></p><ol><li><code>Client</code>实现复杂，驱动要求实现<code>Smart Client</code>，缓存<code>slots mapping</code>信息并及时更新，提高了开发难度，客户端的不成熟影响业务的稳定性。目前仅<code>JedisCluster</code>相对成熟，异常处理部分还不完善，比如常见的<code>“max redirect exception”</code>。</li><li>节点会因为某些原因发生阻塞（阻塞时间大于<code>clutser-node-timeout</code>），被判断下线，这种<code>failover</code>是没有必要的。</li><li>数据通过异步复制，不保证数据的强一致性。</li><li>多个业务使用同一套集群时，无法根据统计区分冷热数据，资源隔离性较差，容易出现相互影响的情况。</li><li><code>Slave</code>在集群中充当“冷备”，不能缓解读压力，当然可以通过<code>SDK</code>的合理设计来提高<code>Slave</code>资源的利用率。</li><li><code>Key</code>批量操作限制，如使用<code>mset</code>、<code>mget</code>目前只支持具有相同<code>slot</code>值的<code>Key</code>执行批量操作。对于映射为不同<code>slot</code>值的<code>Key</code>由于<code>Keys</code>不支持跨<code>slot</code>查询，所以执行<code>mset</code>、<code>mget</code>、<code>sunion</code>等操作支持不友好。</li><li><code>Key</code>事务操作支持有限，只支持多<code>key</code>在同一节点上的事务操作，当多个<code>Key</code>分布于不同的节点上时无法使用事务功能。</li><li><code>Key</code>作为数据分区的最小粒度，不能将一个很大的键值对象如<code>hash</code>、<code>list</code>等映射到不同的节点。</li><li>不支持多数据库空间，单机下的<code>redis</code>可以支持到 16 个数据库，集群模式下只能使用 1 个数据库空间，即 db 0。</li><li>复制结构只支持一层，从节点只能复制主节点，不支持嵌套树状复制结构。</li><li>避免产生<code>hot-key</code>，导致主库节点成为系统的短板。</li><li>避免产生<code>big-key</code>，导致网卡撑爆、慢查询等。</li><li>重试时间应该大于<code>cluster-node-time</code>时间。</li><li><code>Redis Cluster</code>不建议使用<code>pipeline</code>和<code>multi-keys</code>操作，减少<code>max redirect</code>产生的场景。</li></ol><h2 id=codis>Codis</h2><p><code>Codis</code> 是一个代理中间件，如下图，<code>Codis</code> 在系统的位置是这样的。</p><div><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20220219221752.png style=display:block;margin-left:auto;margin-right:auto;width:60% alt=20220219221752></div><p><code>Codis</code>分为四个部分，分别是<code>Codis Proxy</code> (<code>codis-proxy</code>)、<code>Codis Dashboard</code> (<code>codis-config</code>)、<code>Codis Redis</code>(<code>codis-server</code>)和<code>ZooKeeper/Etcd</code>.
<code>Codis</code>就是起着一个中间代理的作用，能够把所有的<code>Redis</code>实例当成一个来使用，在客户端操作着<code>SDK</code>的时候和操作<code>Redis</code>的时候是一样的，没有差别。
因为<code>Codis</code>是一个无状态的，所以可以增加多个<code>Codis</code>来提升<code>QPS</code>,同时也可以起着容灾的作用。</p><h3 id=分片原理>分片原理</h3><p>在<code>Codis</code>中，<code>Codis</code>会把所有的<code>key</code>分成 1024 个槽，这 1024 个槽对应着的就是<code>Redis</code>的集群，这个在<code>Codis</code>中是会在内存中维护着这 1024 个槽与<code>Redis</code>实例的映射关系。这个槽是可以配置，可以设置成 2048 或者是 4096 个。看你的<code>Redis</code>的节点数量有多少，偏多的话，可以设置槽多一些。
<code>Codis</code>中<code>key</code>的分配算法，先是把<code>key</code>进行<code>CRC32</code> 后，得到一个 32 位的数字，然后再<code>hash%1024</code>后得到一个余数，这个值就是这个<code>key</code>对应着的槽，这槽后面对应着的就是<code>redis</code>的实例。(可以思考一下，为什么 Codis 很多命令行不支持，例如 KEYS 操作)</p><blockquote><p><code>CRC32</code>:<code>CRC</code>本身是“冗余校验码”的意思，<code>CRC32</code>则表示会产生一个<code>32bit</code>（8 位十六进制数）的校验值。由于<code>CRC32</code>产生校验值时源数据块的每一个<code>bit</code>（位）都参与了计算，所以数据块中即使只有一位发生了变化，也会得到不同的<code>CRC32</code>值。</p></blockquote><p>Codis中Key的算法代码如下：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>hash = crc32(command.key)
</span></span><span style=display:flex><span>slot_index = hash % 1024
</span></span><span style=display:flex><span>redis = slots[slot_index].redis
</span></span><span style=display:flex><span>redis.do(command)
</span></span></code></pre></div><h3 id=槽位同步>槽位同步</h3><blockquote><p>思考一个问题：如果这个 Codis 节点只在自己的内存里面维护着槽位与实例的关系,那么它的槽位信息怎么在多个实例间同步呢？</p></blockquote><p>Codis 把这个工作交给了 ZooKeeper 来管理，当 Codis 的 Codis Dashbord 改变槽位的信息的时候，其他的 Codis 节点会监听到 ZooKeeper 的槽位变化，会及时同步过来。如图：</p><div><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20220219221951.png style=display:block;margin-left:auto;margin-right:auto;width:60% alt=20220219221951></div><h3 id=节点扩容>节点扩容</h3><blockquote><p>思考一个问题：在 Codis 中增加了 Redis 节点后,槽位的信息怎么变化，原来的 key 怎么迁移和分配？如果在扩容的时候，这个时候有新的 key 进来，Codis 的处理策略是怎么样的？</p></blockquote><p>因为<code>Codis</code>是一个代理中间件，所以这个当需要扩容<code>Redis</code>实例的时候，可以直接增加<code>redis</code>节点。在槽位分配的时候，可以手动指定<code>Codis Dashbord</code>来为新增的节点来分配特定的槽位。</p><p>在<code>Codis</code>中实现了自定义的扫描指令<code>SLOTSSCAN</code>，可以扫描指定的<code>slot</code>下的所有的<code>key</code>，将这些<code>key</code>迁移到新的<code>Redis</code>的节点中(话外语：这个是<code>Codis</code>定制化的其中一个好处)。</p><p>首先，在迁移的时候，会在原来的<code>Redis</code>节点和新的<code>Redis</code>里都保存着迁移的槽位信息，在迁移的过程中，如果有<code>key</code>打进将要迁移或者正在迁移的旧槽位的时候，这个时候<code>Codis</code>的处理机制是，先是将这个<code>key</code>强制迁移到新的<code>Redis</code>节点中，然后再告诉<code>Codis</code>,下次如果有新的<code>key</code>的打在这个槽位中的话，那么转发到新的节点。代码策略如下：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#000>slot_index</span> <span style=color:#ce5c00;font-weight:700>=</span> crc32<span style=color:#ce5c00;font-weight:700>(</span>command.key<span style=color:#ce5c00;font-weight:700>)</span> % <span style=color:#0000cf;font-weight:700>1024</span>
</span></span><span style=display:flex><span><span style=color:#204a87;font-weight:700>if</span> slot_index in migrating_slots:
</span></span><span style=display:flex><span>    do_migrate_key<span style=color:#ce5c00;font-weight:700>(</span>command.key<span style=color:#ce5c00;font-weight:700>)</span>  <span style=color:#8f5902;font-style:italic># 强制执行迁移</span>
</span></span><span style=display:flex><span>    <span style=color:#000>redis</span> <span style=color:#ce5c00;font-weight:700>=</span> slots<span style=color:#ce5c00;font-weight:700>[</span>slot_index<span style=color:#ce5c00;font-weight:700>]</span>.new_redis
</span></span><span style=display:flex><span><span style=color:#204a87;font-weight:700>else</span>:
</span></span><span style=display:flex><span>    <span style=color:#000>redis</span> <span style=color:#ce5c00;font-weight:700>=</span> slots<span style=color:#ce5c00;font-weight:700>[</span>slot_index<span style=color:#ce5c00;font-weight:700>]</span>.redis
</span></span><span style=display:flex><span>redis.do<span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87>command</span><span style=color:#ce5c00;font-weight:700>)</span>
</span></span></code></pre></div><h4 id=自动均衡策略>自动均衡策略</h4><p>面对着上面讲的迁移策略，如果有成千上万个节点新增进来，都需要我们手动去迁移吗？那岂不是得累死啊。当然，<code>Codis</code>也是考虑到了这一点，所以提供了自动均衡策略。自动均衡策略是这样的，<code>Codis</code> 会在机器空闲的时候，观察<code>Redis</code>中的实例对应着的<code>slot</code>数，如果不平衡的话就会自动进行迁移。</p><h4 id=codis-的牺牲>Codis 的牺牲</h4><p>因为<code>Codis</code>在<code>Redis</code>的基础上的改造，所以在<code>Codis</code>上是不支持事务的，同时也会有一些命令行不支持，在官方的文档上有(<code>Codis</code>不支持的命令)
官方的建议是单个集合的总容量不要超过 1M,否则在迁移的时候会有卡顿感。在<code>Codis</code>中，增加了<code>proxy</code>来当中转层，所以在网络开销上，是会比单个的<code>Redis</code>节点的性能有所下降的，所以这部分会有些的性能消耗。可以增加<code>proxy</code>的数量来避免掉这块的性能损耗。</p><h4 id=mget-的过程>MGET 的过程</h4><blockquote><p>思考一个问题：如果熟悉 Redis 中的 MGET、MSET 和 MSETNX 命令的话，就会知道这三个命令都是原子性的命令。但是，为什么 Codis 支持 MGET 和 MSET,却不支持 MSETNX 命令呢？</p></blockquote><div><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20220219222034.png style=display:block;margin-left:auto;margin-right:auto;width:60% alt=20220219222034></div><p>原因如下:</p><p>在<code>Codis</code>中的<code>MGET</code>命令的原理是这样的，先是在<code>Redis</code>中的各个实例里获取到符合的<code>key</code>，然后再汇总到<code>Codis</code>中，如果是<code>MSETNX</code>的话，因为<code>key</code>可能存在在多个<code>Redis</code>的实例中，如果某个实例的设值成功，而另一个实例的设值不成功，从本质上讲这是不成功的，但是分布在多个实例中的<code>Redis</code>是没有回滚机制的，所以会产生脏数据，所以 MSETNX 就是不能支持了。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-609363fe593c01d2ba6ab13171671b34>7.8 - CH08-百亿量级</h1><h2 id=需求背景>需求背景</h2><p>该应用场景为 DMP 缓存存储需求，DMP 需要管理非常多的第三方 id 数据，其中包括各媒体 cookie 与自身 cookie（以下统称 supperid）的 mapping 关系，还包括了 supperid 的人口标签、移动端id（主要是idfa和imei）的人口标签，以及一些黑名单id、ip等数据。</p><p>在 hdfs 的帮助下离线存储千亿记录并不困难，然而 DMP 还需要提供毫秒级的实时查询。由于 cookie 这种 id 本身具有不稳定性，所以很多的真实用户的浏览行为会导致大量的新 cookie 生成，只有及时同步 mapping 的数据才能命中 DMP 的人口标签，无法通过预热来获取较高的命中，这就跟缓存存储带来了极大的挑战。</p><p>经过实际测试，对于上述数据，常规存储超过五十亿的kv记录就需要1T多的内存，如果需要做高可用多副本那带来的消耗是巨大的，另外kv的长短不齐也会带来很多内存碎片，这就需要超大规模的存储方案来解决上述问题。</p><h2 id=缓存内容>缓存内容</h2><p>人⼝标签主要是 cookie、imei、idfa 以及其对应的 gender（性别）、age（年龄段）、geo（地域）等；mapping 关系主要是媒体 cookie 对 supperid 的映射。以下是数据存储⽰示例：</p><p><strong>1、PC端的ID：</strong></p><p>媒体编号-媒体 cookie=>supperid</p><ul><li><code>supperid => { age=>年龄段编码，gender=>性别编码，geo=>地理位置编码 }</code></li></ul><p><strong>2、Device 端的 ID：</strong></p><ul><li><code>imei or idfa => { age=>年龄段编码，gender=>性别编码，geo=>地理位置编码 }</code></li></ul><p>显然 PC 数据需要存储两种 key=>value 还有 key=>hashmap，⽽ Device 数据需要存储一种 key=>hashmap 即可。</p><h2 id=数据特点>数据特点</h2><p>短 key 短 value：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>其中superid为21位数字：比如1605242015141689522；
</span></span><span style=display:flex><span>imei为小写md5：比如2d131005dc0f37d362a5d97094103633；
</span></span><span style=display:flex><span>idfa为大写带”-”md5：比如：51DFFC83-9541-4411-FA4F-356927E39D04；
</span></span></code></pre></div><ul><li>媒体自身的 cookie 长短不一；</li><li>需要为全量数据提供服务，supperid 是百亿级、媒体映射是千亿级、移动 id 是几十亿级；</li><li>每天有十亿级别的 mapping 关系产生；</li><li>对于较大时间窗口内可以预判热数据（有一些存留的稳定 cookie）；</li><li>对于当前 mapping 数据无法预判热数据，有很多是新生成的 cookie；</li></ul><h2 id=技术挑战>技术挑战</h2><ol><li>长短不一容易造成内存碎片；</li><li>由于指针大量存在，内存膨胀率比较高，一般在7倍，纯内存存储通病；</li><li>虽然可以通过cookie的行为预判其热度，但每天新生成的id依然很多（百分比比较敏感，暂不透露）；</li><li>由于服务要求在公网环境（国内公网延迟60ms以下）下100ms以内，所以原则上当天新更新的 mapping 和人口标签需要全部 in memory，而不会让请求落到后端的冷数据；</li><li>业务方面，所有数据原则上至少保留35天甚至更久；</li><li>内存至今也比较昂贵，百亿级Key乃至千亿级存储方案势在必行！</li></ol><h2 id=解决方案>解决方案</h2><h3 id=淘汰策略>淘汰策略</h3><p>存储吃紧的一个重要原因在于每天会有很多新数据入库，所以及时清理数据尤为重要。主要方法就是发现和保留热数据淘汰冷数据。</p><p>网民的量级远远达不到几十亿的规模，id 有一定的生命周期，会不断的变化。所以很大程度上我们存储的id实际上是无效的。而查询其实前端的逻辑就是广告曝光，跟人的行为有关，所以一个 id 在某个时间窗口的（可能是一个campaign，半个月、几个月）访问行为上会有一定的重复性。</p><p>数据初始化之前，我们先利用 HBase 将日志的id聚合去重，划定TTL的范围，一般是35天，这样可以砍掉近35天未出现的id。另外在 Redis 中设置过期时间是35天，当有访问并命中时，对 key 进行续命，延长过期时间，未在 35 天出现的自然淘汰。这样可以针对稳定 cookie 或 id 有效，实际证明，续命的方法对 idfa 和 imei 比较实用，长期积累可达到非常理想的命中。</p><h3 id=减少膨胀>减少膨胀</h3><p>Hash 表空间大小和 Key 的个数决定了冲突率（或者用负载因子衡量），再合理的范围内，key 越多自然hash表空间越大，消耗的内存自然也会很大。再加上大量指针本身是长整型，所以内存存储的膨胀十分可观。先来谈谈如何把 key 的个数减少。</p><p>大家先来了解一种存储结构。我们期望将 key1=>value1 存储在 redis 中，那么可以按照如下过程去存储。先用固定长度的随机散列md5(key)值作为 redis 的 key，我们称之为 BucketId，而将key1=>value1存储在hashmap结构中，这样在查询的时候就可以让client按照上面的过程计算出散列，从而查询到 value1。</p><p>过程变化简单描述为：get(key1) -> hget(md5(key1), key1) 从而得到 value1。</p><p>如果我们通过预先计算，让很多key可以在BucketId空间里碰撞，那么可以认为一个BucketId下面挂了多个key。比如平均每个BucketId下面挂10个key，那么理论上我们将会减少超过90%的redis key的个数。</p><p>具体实现起来有一些麻烦，而且用这个方法之前你要想好容量规模。我们通常使用的 md5 是 32 位的 hexString（16进制字符），它的空间是 128bit，这个量级太大了，我们需要存储的是百亿级，大约是 33 bit（2的33次方），所以我们需要有一种机制计算出合适位数的散列，而且为了节约内存，我们需要利用全部字符类型（ASCII码在0~127之间）来填充，而不用 HexString，这样 Key 的长度可以缩短到一半。</p><p>下面是具体的实现方式：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>static</span> <span style=color:#204a87;font-weight:700>byte</span> <span style=color:#ce5c00;font-weight:700>[]</span> <span style=color:#000>getBucketId</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>byte</span> <span style=color:#ce5c00;font-weight:700>[]</span> <span style=color:#000>key</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>Integer</span> <span style=color:#000>bit</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
</span></span><span style=display:flex><span>    <span style=color:#000>MessageDigest</span> <span style=color:#000>mdInst</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>MessageDigest</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>getInstance</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#4e9a06>&#34;MD5&#34;</span><span style=color:#ce5c00;font-weight:700>);</span>
</span></span><span style=display:flex><span>    <span style=color:#000>mdInst</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>update</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>key</span><span style=color:#ce5c00;font-weight:700>);</span>
</span></span><span style=display:flex><span>    <span style=color:#204a87;font-weight:700>byte</span> <span style=color:#ce5c00;font-weight:700>[]</span> <span style=color:#000>md</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>mdInst</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>digest</span><span style=color:#ce5c00;font-weight:700>();</span>
</span></span><span style=display:flex><span>    <span style=color:#204a87;font-weight:700>byte</span> <span style=color:#ce5c00;font-weight:700>[]</span> <span style=color:#000>r</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#204a87;font-weight:700>byte</span><span style=color:#ce5c00;font-weight:700>[(</span><span style=color:#000>bit</span><span style=color:#ce5c00;font-weight:700>-</span><span style=color:#000>1</span><span style=color:#ce5c00;font-weight:700>)/</span><span style=color:#000>7</span> <span style=color:#ce5c00;font-weight:700>+</span> <span style=color:#000>1</span><span style=color:#ce5c00;font-weight:700>];</span><span style=color:#8f5902;font-style:italic>// 因为一个字节中只有7位能够表示成单字符，ascii码是7位
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span>    <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>a</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>int</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#000>Math</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>pow</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>2</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>bit</span><span style=color:#ce5c00;font-weight:700>%</span><span style=color:#000>7</span><span style=color:#ce5c00;font-weight:700>)-</span><span style=color:#000>2</span><span style=color:#ce5c00;font-weight:700>;</span>
</span></span><span style=display:flex><span>    <span style=color:#000>md</span><span style=color:#ce5c00;font-weight:700>[</span><span style=color:#000>r</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>length</span><span style=color:#ce5c00;font-weight:700>-</span><span style=color:#000>1</span><span style=color:#ce5c00;font-weight:700>]</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>byte</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>md</span><span style=color:#ce5c00;font-weight:700>[</span><span style=color:#000>r</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>length</span><span style=color:#ce5c00;font-weight:700>-</span><span style=color:#000>1</span><span style=color:#ce5c00;font-weight:700>]</span> <span style=color:#ce5c00;font-weight:700>&amp;</span> <span style=color:#000>a</span><span style=color:#ce5c00;font-weight:700>);</span>
</span></span><span style=display:flex><span>    <span style=color:#000>System</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>arraycopy</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>md</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>0</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>r</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>0</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>r</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>length</span><span style=color:#ce5c00;font-weight:700>);</span>
</span></span><span style=display:flex><span>    <span style=color:#204a87;font-weight:700>for</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>i</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#000>0</span><span style=color:#ce5c00;font-weight:700>;</span><span style=color:#000>i</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>r</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>length</span><span style=color:#ce5c00;font-weight:700>;</span><span style=color:#000>i</span><span style=color:#ce5c00;font-weight:700>++)</span> <span style=color:#ce5c00;font-weight:700>{</span>
</span></span><span style=display:flex><span>    	<span style=color:#204a87;font-weight:700>if</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>r</span><span style=color:#ce5c00;font-weight:700>[</span><span style=color:#000>i</span><span style=color:#ce5c00;font-weight:700>]&lt;</span><span style=color:#000>0</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#000>r</span><span style=color:#ce5c00;font-weight:700>[</span><span style=color:#000>i</span><span style=color:#ce5c00;font-weight:700>]</span> <span style=color:#ce5c00;font-weight:700>&amp;=</span> <span style=color:#000>127</span><span style=color:#ce5c00;font-weight:700>;</span>    
</span></span><span style=display:flex><span>    <span style=color:#ce5c00;font-weight:700>}</span>    
</span></span><span style=display:flex><span>    <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>r</span><span style=color:#ce5c00;font-weight:700>;</span>
</span></span><span style=display:flex><span><span style=color:#ce5c00;font-weight:700>}</span>
</span></span></code></pre></div><p>参数 bit 决定了最终 BucketId 空间的大小，空间大小集合是2的整数幂次的离散值。这里解释一下为何一个字节中只有7位可用，是因为 redis 存储 key 时需要是 ASCII（0~127），而不是 byte array。如果规划百亿级存储，计划每个桶分担10个kv，那么我们只需 2^30=1073741824 的桶个数即可，也就是最终 key 的个数。</p><h3 id=减少碎片>减少碎片</h3><p>碎片主要原因在于内存无法对齐、过期删除后，内存无法重新分配。通过上文描述的方式，我们可以将人口标签和mapping数据按照上面的方式去存储，这样的好处就是redis key是等长的。另外对于hashmap中的key我们也做了相关优化，截取cookie或者deviceid的后六位作为key，这样也可以保证内存对齐，理论上会有冲突的可能性，但在同一个桶内后缀相同的概率极低(试想id几乎是随机的字符串，随意10个由较长字符组成的id后缀相同的概率*桶样本数=发生冲突的期望值&#171;0.05,也就是说出现一个冲突样本则是极小概率事件，而且这个概率可以通过调整后缀保留长度控制期望值)。而 value 只存储 age、gender、geo 的编码，用三个字节去存储。</p><p>另外提一下，减少碎片还有个很 low 但是有效的方法，将 slave 重启，然后强制的 failover 切换主从，这样相当于给master整理的内存的碎片。</p><p>推荐 Google-tcmalloc， facebook-jemalloc 内存分配，可以在 value 不大时减少内存碎片和内存消耗。有人测过大 value 情况下反而libc更节约。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-52ebc52fef800cc7b90e32b1026ac24d>7.9 - CH09-实现搜索</h1><h2 id=场景>场景</h2><p>下面以一个例子开始，这是某购物网站的搜索条件，如果让你实现这样的一个搜索接口，你会如何实现？</p><div><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20220219223547.png style=display:block;margin-left:auto;margin-right:auto;width:80% alt=20220219223547></div><p>从上图中可以看出，搜索总共分为6大类，每大类中又分了各个子类。这中间，各大类条件之间是取的交集，各子类中有单选、多选、以及自定义的情况，最终输出符合条件的结果集。</p><p>好了，既然需求很明确了，我们就开始来实现。</p><h2 id=实现一>实现一</h2><p>以下面这段代码为例：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>select ... from table_1
</span></span><span style=display:flex><span>left join table_2
</span></span><span style=display:flex><span>left join table_3
</span></span><span style=display:flex><span>left join (select ... from table_x where ...) tmp_1
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span>where ...
</span></span><span style=display:flex><span>order by ...
</span></span><span style=display:flex><span>limit m,n
</span></span></code></pre></div><p>代码在测试环境跑了一把，结果好像都匹配上了，于是准备上预发。这一上预发，问题就开始暴露出来。预发为了尽可能的逼真线上环境，所以数据量自然而然要比测试大的多。所以这么一个复杂的 SQL，它的执行效率可想而知。</p><h2 id=实现二>实现二</h2><p>通过了<code>explain</code>关键字进行SQL性能分析，对该加索引的地方都加上了索引。同时将一条复杂SQL拆分成多条SQL，计算结果在程序内存中进行计算。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>
</span></span><span style=display:flex><span>$result_1 = query(&#39;select ... from table_1 where ...&#39;);
</span></span><span style=display:flex><span>$result_2 = query(&#39;select ... from table_2 where ...&#39;);
</span></span><span style=display:flex><span>$result_3 = query(&#39;select ... from table_3 where ...&#39;);
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span>$result = array_intersect($result_1, $result_2, $result_3, ...);
</span></span></code></pre></div><p>这种方案从性能上明显比第一种要好很多，但查询速度不够快。每次查询都会向数据库查询多次，而且有些历史原因，部分条件是做不到单表查询的，所以查询等待的时间是避免不了的。</p><h2 id=实现三>实现三</h2><p>从上面的方案中看到了优化的空间。方案二在思路上是没问题的，将复杂条件拆分，计算各个子维度的结果集，最后将所有的子结果集进行一个汇总合并，得到最终想要的结果。</p><p>如果事先将各个子维度的结果集给缓存起来，这要查询的时候直接去取想要的子集，而不用每次去查库计算。</p><p>这里采用 Redis 来存储缓存数据，用它的主要原因是，它提供了多种数据结构，并且在 Redis 中进行集合的交并集操作是一件很容易的事情。</p><p>具体方案，如图所示：</p><div><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20220219223927.png style=display:block;margin-left:auto;margin-right:auto;width:80% alt=20220219223927></div><p>这里每个条件都事先将计算好的结果集ID存入对应的key中，选用的数据结构是集合（Set）。查询操作包括：</p><ul><li>子类单选：直接根据条件 key，获取对应结果集；</li><li>子类多选：根据多个条件 Key，进行并集操作，获取对应结果集；</li><li>最终结果：将获取的所有子类结果集进行交集操作，得到最终结果；</li></ul><p><em>这其实就是所谓的反向索引。</em></p><p>这里会发现，漏了一个价格的条件。从需求中可知，价格条件是个区间，并且是无穷举的。所以上述的这种穷举条件的 Key-Value 方式是做不到的。这里我们采用 Redis 的另一种数据结构进行实现，有序集合（Sorted Set）：</p><div><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20220219224001.png style=display:block;margin-left:auto;margin-right:auto;width:80% alt=20220219224001></div><p>将所有商品加入 Key 为价格的有序集合中，值为商品ID，每个值对应的分数为商品价格的数值。这样在 Redis 的有序集合中就可以通过<code>ZRANGEBYSCORE</code>命令，根据分数（价格）区间，获取相应结果集。</p><p>至此，方案三的优化已全部结束，将数据的查询与计算通过缓存的手段，进行了分离。在每次查找时，只需要简单的查找 Redis 几次就能得出结果。查询速度上符合了验收的要求。</p><h2 id=扩展>扩展</h2><h3 id=分页>分页</h3><p>这里你或许发现了一个严重的功能缺陷，列表查询怎么能没有分页。是的，我们马上来看 Redis 是如何实现分页的。</p><p>分页主要涉及排序，这里简单起见，就以创建时间为例。</p><p>如图所示：</p><div><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20220219224033.png style=display:block;margin-left:auto;margin-right:auto;width:80% alt=20220219224033></div><p>图中蓝色部分是以创建时间为分值的商品有序集合，蓝色下方的结果集即为条件计算而得的结果，通过<code>ZINTERSTORE</code>命令，赋结果集权重为0，商品时间结果为1，取交集而得的结果集赋予创建时间分值的新有序集合。对新结果集的操作即能得到分页所需的各个数据：</p><ul><li>页面总数为：<code>ZCOUNT</code>命令</li><li>当前页内容：<code>ZRANGE</code>命令</li><li>若以倒序排列：<code>ZREVRANGE</code>命令</li></ul><h3 id=更新>更新</h3><p>关于索引数据更新的问题，有两种方式来进行。一种是通过商品数据的修改，来即时触发更新操作，一种是通过定时脚本来进行批量更新。这里要注意的是，关于索引内容的更新，如果暴力的删除 Key，再重新设置 Key。因为 Redis 中两个操作不会是原子性进行的，所以中间可能存在空白间隙，建议采用仅移除集合中失效元素，添加新元素的方式进行。</p><h2 id=性能优化>性能优化</h2><p>Redis 是内存级操作，所以单次的查询会很快。但是如果我们的实现中会进行多次的 Redis 操作，Redis 的多次连接时间可能是不必要时间消耗。通过使用<code>MULTI</code>命令，开启一个事务，将 Redis 的多次操作放在一个事务中，最后通过<code>EXEC</code>来进行原子性执行（<em>注意：这里所谓的事务，只是将多个操作在一次连接中执行，如果执行过程中遇到失败，是不会回滚的</em>）。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-0651586b1071ed29fcfe45d22825ffb0>7.10 - CH10-常见问题</h1><h2 id=操作问题>操作问题</h2><h3 id=过期时间意外丢失><strong>过期时间意外丢失？</strong></h3><p>SET 除了可以设置 key-value 之外，还可以设置 key 的过期时间，就像下面这样：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>127.0.0.1:6379&gt; SET testkey val1 EX 60
</span></span><span style=display:flex><span>OK
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; TTL testkey
</span></span><span style=display:flex><span>(integer) 59
</span></span></code></pre></div><p>此时如果你想修改 key 的值，但只是单纯地使用 SET 命令，而没有加上「过期时间」的参数，那这个 key 的过期时间将会被「擦除」。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>127.0.0.1:6379&gt; SET testkey val2
</span></span><span style=display:flex><span>OK
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; TTL testkey  // key永远不过期了！
</span></span><span style=display:flex><span>(integer) -1
</span></span></code></pre></div><p>看到了么？testkey 变成永远不过期了！</p><p><strong>SET 命令如果不设置过期时间，那么 Redis 会自动「擦除」这个 key 的过期时间。</strong></p><h3 id=del-竟然也会阻塞-redis><strong>DEL 竟然也会阻塞 Redis？</strong></h3><p>删除一个 key，你肯定会用 DEL 命令，不知道你没有思考过它的时间复杂度是多少？</p><p>O(1)？其实不一定。</p><p>如果你有认真阅读 Redis 的官方文档，就会发现：<strong>删除一个 key 的耗时，与这个 key 的类型有关。</strong></p><p>Redis 官方文档在介绍 DEL 命令时，是这样描述的：</p><ul><li>key 是 String 类型，DEL 时间复杂度是 O(1)</li><li>key 是 List/Hash/Set/ZSet 类型，DEL 时间复杂度是 O(M)，M 为元素数量</li></ul><p><strong>也就是说，如果你要删除的是一个非 String 类型的 key，这个 key 的元素越多，那么在执行 DEL 时耗时就越久！</strong></p><p>原因在于，删除这种 key 时，Redis 需要依次释放每个元素的内存，元素越多，这个过程就会越耗时。</p><p>而这么长的操作耗时，势必会阻塞整个 Redis 实例，影响 Redis 的性能。</p><p>所以，当你在删除 List/Hash/Set/ZSet 类型的 key 时，一定要格外注意，不能无脑执行 DEL，而是应该用以下方式删除：</p><ol><li>查询元素数量：执行 LLEN/HLEN/SCARD/ZCARD 命令</li><li>判断元素数量：如果元素数量较少，可直接执行 DEL 删除，否则分批删除</li><li>分批删除：执行 LRANGE/HSCAN/SSCAN/ZSCAN + LPOP/RPOP/HDEL/SREM/ZREM 删除</li></ol><p>我们再来分析下，删除一个 String 类型的 key 会不会有这种问题？其实这也不一定！如果一个 Key 存储了 500MB 的数据也会出现一样的问题。</p><p>这是因为，Redis 释放这么大的内存给操作系统，也是需要时间的，所以操作耗时也会变长。所以，对于 String 类型来说，你最好也不要存储过大的数据，否则在删除它时，也会有性能问题。</p><p>此时，你可能会想：<strong>Redis 4.0 不是推出了 lazy-free 机制么？打开这个机制，释放内存的操作会放到后台线程中执行，那是不是就不会阻塞主线程了？</strong></p><p>即使 Redis 打开了 lazy-free，在删除一个 String 类型的 bigkey 时，它仍旧是在主线程中处理，而不是放到后台线程中执行。所以，依旧有阻塞 Redis 的风险！</p><h3 id=randomkey-竟然也会阻塞-redis><strong>RANDOMKEY 竟然也会阻塞 Redis？</strong></h3><p>如果你想随机查看 Redis 中的一个 key，通常会使用 RANDOMKEY 这个命令。这个命令会从 Redis 中「随机」取出一个 key。</p><p>如果你对 Redis 的过期策略有所了解，应该知道 Redis 清理过期 key，是采用定时清理 + 懒惰清理 2 种方式结合来做的。整个流程就是这样的：</p><ol><li>master 随机取出一个 key，判断是否已过期</li><li>如果 key 已过期，删除它，继续随机取 key</li><li>以此循环往复，直到找到一个不过期的 key，返回</li></ol><p>但这里就有一个问题了：<strong>如果此时 Redis 中，有大量 key 已经过期，但还未来得及被清理掉，那这个循环就会持续很久才能结束，而且，这个耗时都花费在了清理过期 key + 寻找不过期 key 上。</strong></p><p>导致的结果就是，RANDOMKEY 执行耗时变长，影响 Redis 性能。</p><p>以上流程，其实是在 master 上执行的。如果在 slave 上执行 RANDOMEKY，那么问题会更严重！</p><p>主要原因就在于，slave 自己是不会清理过期 key。那 slave 什么时候删除过期 key 呢？</p><p>其实，当一个 key 要过期时，master 会先清理删除它，之后 master 向 slave 发送一个 DEL 命令，告知 slave 也删除这个 key，以此达到主从库的数据一致性。</p><p>还是同样的场景：Redis 中存在大量已过期，但还未被清理的 key，那在 slave 上执行 RANDOMKEY 时，就会发生以下问题：</p><ol><li>slave 随机取出一个 key，判断是否已过期</li><li>key 已过期，但 slave 不会删除它，而是继续随机寻找不过期的 key</li><li>由于大量 key 都已过期，那 slave 就会寻找不到符合条件的 key，此时就会陷入「<strong>死循环</strong>」！</li></ol><p><strong>也就是说，在 slave 上执行 RANDOMKEY，有可能会造成整个 Redis 实例卡死！</strong></p><p>修复的解决方案是，在 slave 上执行 RANDOMKEY 时，会先判断整个实例所有 key 是否都设置了过期时间，如果是，为了避免长时间找不到符合条件的 key，<strong>slave 最多只会在哈希表中寻找 100 次</strong>，无论是否能找到，都会退出循环。这个方案就是增加上了一个最大重试次数，这样一来，就避免了陷入死循环。</p><p>虽然这个方案可以避免了 slave 陷入死循环、卡死整个实例的问题，但是，在 master 上执行这个命令时，依旧有概率导致耗时变长。</p><p>所以，你在使用 RANDOMKEY 时，如果发现 Redis 发生了「抖动」，很有可能是因为这个原因导致的！</p><h3 id=o1-复杂度的-setbit竟然会导致-redis-oom><strong>O(1) 复杂度的 SETBIT，竟然会导致 Redis OOM？</strong></h3><p>在使用 Redis 的 String 类型时，除了直接写入一个字符串之外，还可以把它当做 bitmap 来用。</p><p>具体来讲就是，我们可以把一个 String 类型的 key，拆分成一个个 bit 来操作，就像下面这样：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>127.0.0.1:6379&gt; SETBIT testkey 10 1
</span></span><span style=display:flex><span>(integer) 1
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; GETBIT testkey 10
</span></span><span style=display:flex><span>(integer) 1
</span></span></code></pre></div><div><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20220219225235.png style=display:block;margin-left:auto;margin-right:auto;width:50% alt=20220219225235></div><p>其中，操作的每一个 bit 位叫做 offset。如果这个 key 不存在，或者 key 的内存使用很小，此时你要操作的 offset 非常大，那么 Redis 就需要分配「更大的内存空间」，这个操作耗时就会变长，影响性能。</p><div><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20220219225247.png style=display:block;margin-left:auto;margin-right:auto;width:60% alt=20220219225247></div><p>所以，当你在使用 SETBIT 时，也一定要注意 offset 的大小，操作过大的 offset 也会引发 Redis 卡顿。</p><p>这种类型的 key，也是典型的 bigkey，除了分配内存影响性能之外，在删除它时，耗时同样也会变长。</p><h3 id=执行-monitor-也会导致-redis-oom><strong>执行 MONITOR 也会导致 Redis OOM？</strong></h3><p>当你在执行 MONITOR 命令时，Redis 会把每一条命令写到客户端的「输出缓冲区」中，然后客户端从这个缓冲区读取服务端返回的结果。</p><div><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20220219225329.png style=display:block;margin-left:auto;margin-right:auto;width:80% alt=20220219225329></div><p>但是，如果你的 Redis QPS 很高，这将会导致这个输出缓冲区内存持续增长，占用 Redis 大量的内存资源，如果恰好你的机器的内存资源不足，那 Redis 实例就会面临被 OOM 的风险。</p><p>所以，你需要谨慎使用 MONITOR，尤其在 QPS 很高的情况下。</p><h2 id=持久化问题>持久化问题</h2><p>Redis 的数据持久化，分为 RDB 和 AOF 两种方式。其中，RDB 是数据快照，而 AOF 会记录每一个写命令到日志文件中。</p><h3 id=master-宕机slave-数据也丢失了><strong>master 宕机，slave 数据也丢失了？</strong></h3><p>如果你的 Redis 采用如下模式部署，就会发生数据丢失的问题：</p><ul><li>master-slave + 哨兵部署实例</li><li>master 没有开启数据持久化功能</li><li>Redis 进程使用 supervisor 管理，并配置为「进程宕机，自动重启」</li></ul><p>如果此时 master 宕机，就会导致下面的问题：</p><ul><li>master 宕机，哨兵还未发起切换，此时 master 进程立即被 supervisor 自动拉起</li><li>但 master 没有开启任何数据持久化，启动后是一个「空」实例</li><li>此时 slave 为了与 master 保持一致，它会自动「清空」实例中的所有数据，slave 也变成了一个「空」实例</li></ul><p>看到了么？在这个场景下，master / slave 的数据就全部丢失了。</p><p>这时，业务应用在访问 Redis 时，发现缓存中没有任何数据，就会把请求全部打到后端数据库上，这还会进一步引发「缓存雪崩」，对业务影响非常大。</p><p>所以，你一定要避免这种情况发生，我给你的建议是：</p><ol><li>Redis 实例不使用进程管理工具自动拉起</li><li>master 宕机后，让哨兵发起切换，把 slave 提升为 master</li><li>切换完成后，再重启 master，让其退化成 slave</li></ol><h3 id=aof-everysec-真的不会阻塞主线程吗><strong>AOF everysec 真的不会阻塞主线程吗？</strong></h3><p>当 Redis 开启 AOF 时，需要配置 AOF 的刷盘策略。基于性能和数据安全的平衡，你肯定会采用 appendfsync everysec 这种方案。</p><p>这种方案的工作模式为，Redis 的后台线程每间隔 1 秒，就把 AOF page cache 的数据，刷到磁盘（fsync）上。</p><p>其优势在于，把 AOF 刷盘的耗时操作，放到了后台线程中去执行，避免了对主线程的影响。</p><p>但真的不会影响主线程吗？答案是否定的。</p><p>其实存在这样一种场景：<strong>Redis 后台线程在执行 AOF page cache 刷盘（fysnc）时，如果此时磁盘 IO 负载过高，那么调用 fsync 就会被阻塞住。</strong></p><p>此时，主线程仍然接收写请求进来，那么此时的主线程会先判断，上一次后台线程是否已刷盘成功。</p><p>如何判断呢？</p><p>后台线程在刷盘成功后，都会记录刷盘的时间。</p><p>主线程会根据这个时间来判断，距离上一次刷盘已经过去多久了。整个流程是这样的：</p><ol><li>主线程在写 AOF page cache（write系统调用）前，先检查后台 fsync 是否已完成？</li><li>fsync 已完成，主线程直接写 AOF page cache</li><li>fsync 未完成，则检查距离上次 fsync 过去多久？</li><li>如果距离上次 fysnc 成功在 2 秒内，那么主线程会直接返回，不写 AOF page cache</li><li>如果距离上次 fysnc 成功超过了 2 秒，那主线程会强制写 AOF page cache（write系统调用）</li><li>由于磁盘 IO 负载过高，此时，后台线程 fynsc 会发生阻塞，那主线程在写 AOF page cache 时，也会发生阻塞等待（操作同一个 fd，fsync 和 write 是互斥的，一方必须等另一方成功才可以继续执行，否则阻塞等待）</li></ol><div><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20220219225617.png style=display:block;margin-left:auto;margin-right:auto;width:80% alt=20220219225617></div><p>通过分析我们可以发现，即使你配置的 AOF 刷盘策略是 appendfsync everysec，也依旧会有阻塞主线程的风险。</p><p>其实，产生这个问题的重点在于，磁盘 IO 负载过高导致 fynsc 阻塞，进而导致主线程写 AOF page cache 也发生阻塞。</p><p>所以，你一定要保证磁盘有充足的 IO 资源，避免这个问题。</p><h3 id=aof-everysec-真的只会丢失-1-秒数据><strong>AOF everysec 真的只会丢失 1 秒数据？</strong></h3><p>如上所述，这里我们需要重点关注上面的步骤 4。</p><p>也就是：主线程在写 AOF page cache 时，会先判断上一次 fsync 成功的时间，如果距离上次 fysnc 成功在 2 秒内，那么主线程会直接返回，不再写 AOF page cache。</p><p>这就意味着，<strong>后台线程在执行 fsync 刷盘时，主线程最多等待 2 秒不会写 AOF page cache。</strong></p><p>如果此时 Redis 发生了宕机，那么，AOF 文件中丢失是 2 秒的数据，而不是 1 秒！</p><p>我们继续分析，Redis 主线程为什么要等待 2 秒不写 AOF page cache 呢？</p><p>其实，Redis AOF 配置为 appendfsync everysec 时，正常来讲，后台线程每隔 1 秒执行一次 fsync 刷盘，如果磁盘资源充足，是不会被阻塞住的。</p><p>也就是说，Redis 主线程其实根本不用关心后台线程是否刷盘成功，只要无脑写 AOF page cache 即可。</p><p>但是，Redis 作者考虑到，如果此时的磁盘 IO 资源比较紧张，那么后台线程 fsync 就有概率发生阻塞风险。</p><p>所以，Redis 作者在主线程写 AOF page cache 之前，先检查一下距离上一次 fsync 成功的时间，如果大于 1 秒没有成功，那么主线程此时就能知道，fsync 可能阻塞了。</p><p>所以，主线程会等待 2 秒不写 AOF page cache，其目的在于：</p><ol><li>降低主线程阻塞的风险（如果无脑写 AOF page cache，主线程则会立即阻塞住）</li><li>如果 fsync 阻塞，主线程就会给后台线程留出 1 秒的时间，等待 fsync 成功</li></ol><p>但代价就是，如果此时发生宕机，AOF 丢失的就是 2 秒的数据，而不是 1 秒。</p><p>这个方案应该是 Redis 作者对性能和数据安全性的进一步权衡。</p><p>无论如何，这里你只需要知道的是，即使 AOF 配置为每秒刷盘，在发生上述极端情况时，AOF 丢失的数据其实是 2 秒。</p><h3 id=rdb-和-aof-rewrite-时redis-发生-oom><strong>RDB 和 AOF rewrite 时，Redis 发生 OOM？</strong></h3><p>最后，我们来看一下，当 Redis 在执行 RDB 快照和 AOF rewrite 时，会发生的问题。</p><p>Redis 在做 RDB 快照和 AOF rewrite 时，会采用创建子进程的方式，把实例中的数据持久化到磁盘上。</p><p>创建子进程，会调用操作系统的 fork 函数。</p><p>fork 执行完成后，父进程和子进程会同时共享同一份内存数据。</p><p>但此时的主进程依旧是可以接收写请求的，而进来的写请求，会采用 Copy On Write（写时复制）的方式操作内存数据。</p><p>也就是说，主进程一旦有数据需要修改，Redis 并不会直接修改现有内存中的数据，而是先将这块内存数据拷贝出来，再修改这块新内存的数据，这就是所谓的「写时复制」。</p><p>写时复制你也可以理解成，谁需要发生写操作，谁就先拷贝，再修改。</p><p>你应该发现了，如果父进程要修改一个 key，就需要拷贝原有的内存数据，到新内存中，这个过程涉及到了「新内存」的申请。</p><p>如果你的业务特点是「写多读少」，而且 OPS 非常高，那在 RDB 和 AOF rewrite 期间，就会产生大量的内存拷贝工作。</p><p>这会有什么问题呢？</p><p><strong>因为写请求很多，这会导致 Redis 父进程会申请非常多的内存。在这期间，修改 key 的范围越广，新内存的申请就越多。</strong></p><p>如果你的机器内存资源不足，这就会导致 Redis 面临被 OOM 的风险！</p><div><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20220219225805.png style=display:block;margin-left:auto;margin-right:auto;width:80% alt=20220219225805></div><p>这就是你会从 DBA 同学那里听到的，要给 Redis 机器预留内存的原因。</p><p>其目的就是避免在 RDB 和 AOF rewrite 期间，防止 Redis OOM。</p><p>以上这些，就是「数据持久化」会遇到的坑，你踩到过几个？</p><p>下面我们再来看「主从复制」会存在哪些问题。</p><h2 id=主从复制问题>主从复制问题</h2><p>Redis 为了保证高可用，提供了主从复制的方式，这样就可以保证 Redis 有多个「副本」，当主库宕机后，我们依旧有从库可以使用。</p><h3 id=主从复制会丢数据吗><strong>主从复制会丢数据吗？</strong></h3><p>首先，你需要知道，Redis 的主从复制是采用「异步」的方式进行的。</p><p>这就意味着，如果 master 突然宕机，可能存在有部分数据还未同步到 slave 的情况发生。</p><p>这会导致什么问题呢？</p><p>如果你把 Redis 当做纯缓存来使用，那对业务来说没有什么影响。</p><p>master 未同步到 slave 的数据，业务应用可以从后端数据库中重新查询到。</p><p>但是，对于把 Redis 当做数据库，或是当做分布式锁来使用的业务，有可能因为异步复制的问题，导致数据丢失 / 锁丢失。</p><blockquote><p>关于 Redis 分布式锁可靠性的更多细节，这里先不展开，后面会单独写一篇文章详细剖析这个知识点。这里你只需要先知道，Redis 主从复制是有概率发生数据丢失的。</p></blockquote><h3 id=同样命令查询一个-key主从库却返回不同的结果><strong>同样命令查询一个 key，主从库却返回不同的结果？</strong></h3><p>不知道你是否思考过这样一个问题：<strong>如果一个 key 已过期，但这个 key 还未被 master 清理，此时在 slave 上查询这个 key，会返回什么结果呢？</strong></p><ol><li>slave 正常返回 key 的值</li><li>slave 返回 NULL</li></ol><p>你认为是哪一种？可以思考一下。</p><p>答案是：<strong>不一定</strong>。</p><p>嗯？为什么会不一定？</p><p>其实，返回什么结果，这要取决于以下 3 个因素：</p><ol><li>Redis 的版本</li><li>具体执行的命令</li><li>机器时钟</li></ol><p>先来看 Redis 版本。</p><p>如果你使用的是 Redis 3.2 以下版本，只要这个 key 还未被 master 清理，那么，在 slave 上查询这个 key，它会永远返回 value 给你。</p><p><strong>也就是说，即使这个 key 已过期，在 slave 上依旧可以查询到这个 key。</strong></p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>// Redis 2.8 版本 在 slave 上执行
</span></span><span style=display:flex><span>127.0.0.1:6479&gt; TTL testkey
</span></span><span style=display:flex><span>(integer) -2    // 已过期
</span></span><span style=display:flex><span>127.0.0.1:6479&gt; GET testkey
</span></span><span style=display:flex><span>&#34;testval&#34;       // 还能查询到!
</span></span></code></pre></div><p>但如果此时在 master 上查询这个 key，发现已经过期，就会把它清理掉，然后返回 NULL。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>// Redis 2.8 版本 在 master 上执行
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; TTL testkey
</span></span><span style=display:flex><span>(integer) -2
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; GET testkey
</span></span><span style=display:flex><span>(nil)
</span></span></code></pre></div><p>发现了吗？在 master 和 slave 上查询同一个 key，结果竟然不一样？</p><p>其实，slave 应该要与 master 保持一致，key 已过期，就应该给客户端返回 NULL，而不是还正常返回 key 的值。</p><p>为什么会发生这种情况？</p><p>其实这是 Redis 的一个 Bug：<strong>3.2 以下版本的 Redis，在 slave 上查询一个 key 时，并不会判断这个 key 是否已过期，而是直接无脑返回给客户端结果。</strong></p><p>这个 Bug 在 3.2 版本进行了修复，但是，它修复得「不够彻底」。</p><p>什么叫修复得「不够彻底」？</p><p>这就要结合前面提到的，第 2 个影响因素「具体执行的命令」来解释了。</p><p>Redis 3.2 虽然修复了这个 Bug，但却遗漏了一个命令：<strong>EXISTS</strong>。</p><p>也就是说，一个 key 已过期，在 slave 直接查询它的数据，例如执行 GET/LRANGE/HGETALL/SMEMBERS/ZRANGE 这类命令时，slave 会返回 NULL。</p><p>但如果执行的是 EXISTS，slave 依旧会返回：<strong>key 还存在</strong>。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>// Redis 3.2 版本 在 slave 上执行
</span></span><span style=display:flex><span>127.0.0.1:6479&gt; GET testkey
</span></span><span style=display:flex><span>(nil)           // key 已逻辑过期
</span></span><span style=display:flex><span>127.0.0.1:6479&gt; EXISTS testkey
</span></span><span style=display:flex><span>(integer) 1     // 还存在！
</span></span></code></pre></div><p>原因在于，EXISTS 与查询数据的命令，使用的不是同一个方法。</p><p>Redis 作者只在查询数据时增加了过期时间的校验，但 EXISTS 命令依旧没有这么做。</p><p>直到 Redis 4.0.11 这个版本，Redis 才真正把这个遗漏的 Bug 完全修复。</p><p>如果你使用的是这个之上的版本，那在 slave 上执行数据查询或 EXISTS，对于已过期的 key，就都会返回「不存在」了。</p><p>这里我们先小结一下，slave 查询过期 key，经历了 3 个阶段：</p><ol><li>3.2 以下版本，key 过期未被清理，无论哪个命令，查询 slave，均正常返回 value</li><li>3.2 - 4.0.11 版本，查询数据返回 NULL，但 EXISTS 依旧返回 true</li><li>4.0.11 以上版本，所有命令均已修复，过期 key 在 slave 上查询，均返回「不存在」</li></ol><p>最后，我们来看影响查询结果的第 3 个因素：「机器时钟」。</p><p>假设我们已规避了上面提到的版本 Bug，例如，我们使用 Redis 5.0 版本，在 slave 查询一个 key，还会和 master 结果不同吗？</p><p>答案是，还是有可能会的。</p><p>这就与 master / slave 的机器时钟有关了。</p><p>无论是 master 还是 slave，在判断一个 key 是否过期时，都是基于「本机时钟」来判断的。</p><p>如果 slave 的机器时钟比 master 走得「快」，那就会导致，即使这个 key 还未过期，但以 slave 上视角来看，这个 key 其实已经过期了，那客户端在 slave 上查询时，就会返回 NULL。</p><p>是不是很有意思？一个小小的过期 key，竟然藏匿这么多猫腻。</p><p>如果你也遇到了类似的情况，就可以通过上述步骤进行排查，确认是否踩到了这个坑。</p><h3 id=主从切换会导致缓存雪崩><strong>主从切换会导致缓存雪崩？</strong></h3><p>这个问题是上一个问题的延伸。</p><p>我们假设，slave 的机器时钟比 master 走得「快」，而且是「快很多」。</p><p>此时，从 slave 角度来看，Redis 中的数据存在「大量过期」。</p><p>如果此时操作「主从切换」，把 slave 提升为新的 master。</p><p>它成为 master 后，就会开始大量清理过期 key，此时就会导致以下结果：</p><ol><li>master 大量清理过期 key，主线程发生阻塞，无法及时处理客户端请求</li><li>Redis 中数据大量过期，引发缓存雪崩</li></ol><p>你看，当 master / slave 机器时钟严重不一致时，对业务的影响非常大！</p><p>所以，如果你是 DBA 运维，一定要保证主从库的机器时钟一致性，避免发生这些问题。</p><h3 id=master--slave-大量数据不一致><strong>master / slave 大量数据不一致？</strong></h3><p>还有一种场景，会导致 master / slave 的数据存在大量不一致。</p><p>这就涉及到 Redis 的 maxmemory 配置了。</p><p>Redis 的 maxmemory 可以控制整个实例的内存使用上限，超过这个上限，并且配置了淘汰策略，那么实例就开始淘汰数据。</p><p>但这里有个问题：<strong>假设 master / slave 配置的 maxmemory 不一样，那此时就会发生数据不一致。</strong></p><p>例如，master 配置的 maxmemory 为 5G，而 slave 的 maxmemory 为 3G，当 Redis 中的数据超过 3G 时，slave 就会「提前」开始淘汰数据，此时主从库数据发生不一致。</p><div><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20220219230213.png style=display:block;margin-left:auto;margin-right:auto;width:80% alt=20220219230213></div><p>另外，尽管 master / slave 设置的 maxmemory 相同，如果你要调整它们的上限，也要格外注意，否则也会导致 slave 淘汰数据：</p><ul><li>调大 maxmemory 时，先调整 slave，再调整 master</li><li>调小 maxmemory 时，先调整 master，再调整 slave</li></ul><p>以此方式操作，就避免了 slave 提前超过 maxmemory 的问题。</p><p>其实，你可以思考一下，发生这些问题的关键在哪？</p><p>其根本原因在于，<strong>slave 超过 maxmemory 后，会「自行」淘汰数据</strong>。</p><p>如果不让 slave 自己淘汰数据，那这些问题是不是都可以规避了？</p><p>没错。</p><p>针对这个问题，Redis 官方应该也收到了很多用户的反馈。在 Redis 5.0 版本，官方终于把这个问题彻底解决了！</p><p>Redis 5.0 增加了一个配置项：replica-ignore-maxmemory，默认 yes。</p><p>这个参数表示，尽管 slave 内存超过了 maxmemory，也不会自行淘汰数据了！</p><p><strong>这样一来，slave 永远会向 master 看齐，只会老老实实地复制 master 发送过来的数据，不会自己再搞「小动作」。</strong></p><p>至此，master / slave 的数据就可以保证完全一致了！</p><blockquote><p>如果你使用的恰好是 5.0 版本，就不用担心这个问题了。</p></blockquote><h3 id=slave-竟然会有内存泄露问题><strong>slave 竟然会有内存泄露问题？</strong></h3><p>是的，你没看错。</p><p>这是怎么发生的？我们具体来看一下。</p><p>当你在使用 Redis 时，符合以下场景，就会触发 slave 内存泄露：</p><ul><li>Redis 使用的是 4.0 以下版本</li><li>slave 配置项为 read-only=no（从库可写）</li><li>向 slave 写入了有过期时间的 key</li></ul><p>这时的 slave 就会发生内存泄露：<strong>slave 中的 key，即使到了过期时间，也不会自动清理。</strong></p><p>如果你不主动删除它，那这些 key 就会一直残留在 slave 内存中，消耗 slave 的内存。</p><p>最麻烦的是，你使用命令查询这些 key，却还查不到任何结果！</p><p>这就 slave 「内存泄露」问题。</p><div><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20220219230244.png style=display:block;margin-left:auto;margin-right:auto;width:80% alt=20220219230244></div><p>这其实也是 Redis 的一个 Bug，Redis 4.0 才修复了这个问题。</p><p>解决方案是，<strong>在可写的 slave 上，写入带有过期时间 key 时，slave 会「记录」下来这些 key。</strong></p><p>然后 slave 会定时扫描这些 key，如果到达过期时间，则清理之。</p><p>如果你的业务需要在 slave 上临时存储数据，而且这些 key 也都设置了过期时间，那么就要注意这个问题了。</p><p>你需要确认你的 Redis 版本，如果是 4.0 以下版本，一定要避免踩这个坑。</p><p>其实，最好的方案是，制定一个 Redis 使用规范，slave 必须强制设置为 read-only，不允许写，这样不仅可以保证 master / slave 的数据一致性，还避免了 slave 内存泄露问题。</p><h3 id=为什么主从全量同步一直失败><strong>为什么主从全量同步一直失败？</strong></h3><p>在主从全量同步时，你可能会遇到同步失败的问题，具体场景如下：</p><p>slave 向 master 发起全量同步请求，master 生成 RDB 后发给 slave，slave 加载 RDB。</p><p>由于 RDB 数据太大，slave 加载耗时也会变得很长。</p><p>此时你会发现，slave 加载 RDB 还未完成，master 和 slave 的连接却断开了，数据同步也失败了。</p><p>之后你又会发现，slave 又发起了全量同步，master 又生成 RDB 发送给 slave。</p><p>同样地，slave 在加载 RDB 时，master / slave 同步又失败了，以此往复。</p><p>这是怎么回事？</p><p>其实，这就是 Redis 的「复制风暴」问题。</p><p>什么是复制风暴？</p><p>就像刚才描述的：<strong>主从全量同步失败，又重新开始同步，之后又同步失败，以此往复，恶性循环，持续浪费机器资源。</strong></p><p>为什么会导致这种问题呢？</p><p>如果你的 Redis 有以下特点，就有可能发生这种问题：</p><ul><li>master 的实例数据过大，slave 在加载 RDB 时耗时太长</li><li>复制缓冲区（slave client-output-buffer-limit）配置过小</li><li>master 写请求量很大</li></ul><p>主从在全量同步数据时，master 接收到的写请求，会先写到主从「复制缓冲区」中，这个缓冲区的「上限」是配置决定的。</p><p>当 slave 加载 RDB 太慢时，就会导致 slave 无法及时读取「复制缓冲区」的数据，这就引发了复制缓冲区「溢出」。</p><p>为了避免内存持续增长，此时的 master 会「强制」断开 slave 的连接，这时全量同步就会失败。</p><p>之后，同步失败的 slave 又会「重新」发起全量同步，进而又陷入上面描述的问题中，以此往复，恶性循环，这就是所谓的「复制风暴」。</p><p>如何解决这个问题呢？我给你以下几点建议：</p><ol><li>Redis 实例不要太大，避免过大的 RDB</li><li>复制缓冲区配置的尽量大一些，给 slave 加载 RDB 留足时间，降低全量同步失败的概率</li></ol><p>如果你也踩到了这个坑，可以通过这个方案来解决。</p></div></main></div></div><footer class="bg-dark py-5 row d-print-none"><div class="container-fluid mx-sm-5"><div class=row><div class="col-6 col-sm-4 text-xs-center order-sm-2"></div><div class="col-6 col-sm-4 text-right text-xs-center order-sm-3"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Weibo aria-label=Weibo><a class=text-white target=_blank rel="noopener noreferrer" href=https://weibo.com/u/3848950217><i class="fab fa-weibo"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Twitter aria-label=Twitter><a class=text-white target=_blank rel="noopener noreferrer" href=https://twitter.com/zhange_zzg><i class="fab fa-twitter"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="Stack Overflow" aria-label="Stack Overflow"><a class=text-white target=_blank rel="noopener noreferrer" href=https://stackoverflow.com><i class="fab fa-stack-overflow"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=GitHub aria-label=GitHub><a class=text-white target=_blank rel="noopener noreferrer" href=https://github.com/infilos/infilos.com><i class="fab fa-github"></i></a></li></ul></div><div class="col-12 col-sm-4 text-center py-2 order-sm-2"><small class=text-white>&copy; 2022 infilos.com All Rights Reserved</small></div></div></div></footer></div><script src=/js/popper.min.js integrity=sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49 crossorigin=anonymous></script>
<script src=/js/bootstrap.min.js integrity=sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy crossorigin=anonymous></script>
<script src=/js/main.min.234862a61a98834daa49494cfddb4df5f6d0196eaeb7db34a9ce068e7f17863e.js integrity="sha256-I0hiphqYg02qSUlM/dtN9fbQGW6ut9s0qc4Gjn8Xhj4=" crossorigin=anonymous></script></body></html>