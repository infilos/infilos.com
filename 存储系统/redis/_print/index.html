<!doctype html><html lang=en class=no-js><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=generator content="Hugo 0.104.0"><meta name=ROBOTS content="INDEX, FOLLOW"><link rel=canonical type=text/html href=/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/redis/><link rel="shortcut icon" href=/favicons/favicon.ico><link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180><link rel=icon type=image/png href=/favicons/favicon-16x16.png sizes=16x16><link rel=icon type=image/png href=/favicons/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/favicons/android-36x36.png sizes=36x36><link rel=icon type=image/png href=/favicons/android-48x48.png sizes=48x48><link rel=icon type=image/png href=/favicons/android-72x72.png sizes=72x72><link rel=icon type=image/png href=/favicons/android-96x96.png sizes=96x96><link rel=icon type=image/png href=/favicons/android-144x144.png sizes=144x144><link rel=icon type=image/png href=/favicons/android-192x192.png sizes=192x192><title>Redis | infilos.com</title><meta property="og:title" content="Redis"><meta property="og:description" content="Infilos Wiki Website"><meta property="og:type" content="website"><meta property="og:url" content="/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/redis/"><meta property="og:site_name" content="infilos.com"><meta itemprop=name content="Redis"><meta itemprop=description content="Infilos Wiki Website"><meta name=twitter:card content="summary"><meta name=twitter:title content="Redis"><meta name=twitter:description content="Infilos Wiki Website"><script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-123062585-1","auto"),ga("send","pageview"))</script><script async src=https://www.google-analytics.com/analytics.js></script>
<link rel=preload href=/scss/main.min.5f60a6da3ce936fccd1096f5a4541bd9d925f00a0dd08f1363f26c26bfbfda5b.css as=style><link href=/scss/main.min.5f60a6da3ce936fccd1096f5a4541bd9d925f00a0dd08f1363f26c26bfbfda5b.css rel=stylesheet integrity><script src=/js/jquery-3.5.1.min.js integrity="sha256-9/aliU8dGd2tb6OSsuzixeV4y/faTqgFtohetphbbj0=" crossorigin=anonymous></script></head><body class=td-section><header><nav class="js-navbar-scroll navbar navbar-expand-lg navbar-dark td-navbar"><a class=navbar-brand href=/><span class=navbar-logo><svg id="Capa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 512 512" style="enable-background:new 0 0 512 512"><path style="fill:#ffc107" d="M432.384 143.616c-4.165-4.164-10.917-4.164-15.083.0l-60.352 60.352c-4.164 4.165-4.164 10.917.0 15.083 21.187 20.463 54.951 19.876 75.413-1.311 19.962-20.668 19.962-53.435.0-74.102L432.384 143.616z"/><path style="fill:#607d8b" d="M42.667 277.334c-5.891.003-10.669-4.771-10.672-10.662-.002-4.338 2.623-8.245 6.64-9.882l234.667-96c5.455-2.233 11.687.38 13.92 5.835s-.38 11.687-5.835 13.92l-234.667 96C45.433 277.069 44.056 277.337 42.667 277.334z"/><path style="fill:#546e7a" d="M391.552 56.448l-32-32C343.938 8.745 322.689-.059 300.544.0h-3.755c-46.082.024-83.432 37.374-83.456 83.456v3.755c-.053 22.138 8.75 43.377 24.448 58.987l32 32c4.165 4.164 10.917 4.164 15.083.0L391.531 71.531C395.701 67.372 395.71 60.62 391.552 56.448z"/><path style="fill:#607d8b" d="M160 469.334c-3.279.006-6.379-1.497-8.405-4.075L34.261 315.926c-3.635-4.636-2.823-11.341 1.813-14.976s11.341-2.823 14.976 1.813l117.333 149.333c3.629 4.641 2.809 11.344-1.832 14.973C164.681 468.533 162.375 469.329 160 469.334z"/><path style="fill:#455a64" d="M487.467 86.848l-3.669-3.648c-37.687-36.557-97.71-36.197-134.955.811l-51.413 51.413c-36.996 37.25-37.357 97.263-.811 134.955l3.584 3.669c1.7 2.457 4.671 3.706 7.616 3.2 2.831.005 5.548-1.115 7.552-3.115l172.181-172.181c4.189-4.143 4.226-10.896.083-15.085-.028-.028-.055-.056-.083-.083L487.467 86.848z"/><g><path style="fill:#ffc107" d="M501.333 192H480c-5.891.0-10.667-4.776-10.667-10.667s4.776-10.667 10.667-10.667h21.333c5.891.0 10.667 4.776 10.667 10.667S507.225 192 501.333 192z"/><path style="fill:#ffc107" d="M394.667 298.667c-5.891.0-10.667-4.776-10.667-10.667v-21.333c0-5.891 4.776-10.667 10.667-10.667 5.891.0 10.667 4.776 10.667 10.667V288C405.333 293.891 400.558 298.667 394.667 298.667z"/><path style="fill:#ffc107" d="M480 277.334c-2.831.005-5.548-1.115-7.552-3.115l-21.333-21.333c-4.093-4.237-3.975-10.99.262-15.083 4.134-3.993 10.687-3.993 14.821.0l21.333 21.333c4.159 4.172 4.148 10.926-.024 15.085C485.514 276.209 482.815 277.327 480 277.334z"/></g><g><path style="fill:#455a64" d="M266.667 448H96c-29.455.0-53.333 23.878-53.333 53.333.0 5.891 4.776 10.667 10.667 10.667h256c5.891.0 10.667-4.776 10.667-10.667C320 471.878 296.122 448 266.667 448z"/><circle style="fill:#455a64" cx="32" cy="288" r="32"/></g><g/><g/><g/><g/><g/><g/><g/><g/><g/><g/><g/><g/><g/><g/><g/></svg></span><span class=font-weight-bold>infilos.com</span></a>
<button class=navbar-toggler type=button data-toggle=collapse data-target=#navbarSupportedContent aria-controls=navbarSupportedContent aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span></button><div class="collapse navbar-collapse" id=navbarSupportedContent><ul class="navbar-nav mr-auto"><li class=nav-item style=max-width:90px;min-width:10px><a class=nav-link href=/%e5%9f%ba%e7%a1%80%e7%9f%a5%e8%af%86><span>基础</span></a></li><li class=nav-item style=max-width:90px;min-width:10px><a class=nav-link href=/%e7%bc%96%e7%a8%8b%e8%af%ad%e8%a8%80><span>语言</span></a></li><li class=nav-item style=max-width:90px;min-width:10px><a class=nav-link href=/%e6%a1%86%e6%9e%b6%e4%b8%8e%e5%ba%93><span>框架库</span></a></li><li class="nav-item dropdown" style=max-width:90px;min-width:10px><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>分布式
<span>+</span></a><div class=dropdown-menu aria-labelledby=navbarDropdown><a class=dropdown-item href=/%e5%88%86%e5%b8%83%e5%bc%8f/base>基本构成</a></div></li><li class="nav-item dropdown" style=max-width:90px;min-width:10px><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>大数据
<span>+</span></a><div class=dropdown-menu aria-labelledby=navbarDropdown><a class=dropdown-item href=/%e5%ad%98%e5%82%a8%e7%b3%bb%e7%bb%9f>存储系统</a>
<a class=dropdown-item href=/%e6%9f%a5%e8%af%a2%e7%b3%bb%e7%bb%9f>查询系统</a>
<a class=dropdown-item href=/%e6%b6%88%e6%81%af%e7%b3%bb%e7%bb%9f>消息系统</a>
<a class=dropdown-item href=/%e5%a4%84%e7%90%86%e7%b3%bb%e7%bb%9f>处理系统</a>
<a class=dropdown-item href=/%e6%95%b0%e6%8d%ae%e6%b2%bb%e7%90%86>数据治理</a></div></li><li class="nav-item dropdown" style=max-width:90px;min-width:10px><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>中后台
<span>+</span></a><div class=dropdown-menu aria-labelledby=navbarDropdown><a class=dropdown-item href=/%e5%9f%ba%e7%a1%80%e8%ae%be%e6%96%bd>基础设施</a>
<a class=dropdown-item href=/%e7%94%a8%e6%88%b7%e7%b3%bb%e7%bb%9f>用户系统</a>
<a class=dropdown-item href=/%e4%ba%a4%e4%ba%92%e7%95%8c%e9%9d%a2>交互界面</a>
<a class=dropdown-item href=/%e4%b8%9a%e5%8a%a1%e7%b3%bb%e7%bb%9f>业务系统</a></div></li><li class=nav-item style=max-width:90px;min-width:10px><a class=nav-link href=/%e6%a8%a1%e5%bc%8f%e6%9e%b6%e6%9e%84><span>模式架构</span></a></li><li class=nav-item style=max-width:90px;min-width:10px><a class=nav-link href=/%e9%9d%a2%e8%af%95%e9%97%ae%e7%ad%94><span>面试</span></a></li><li class=nav-item style=max-width:90px;min-width:10px><a class=nav-link href=/%e7%ae%a1%e7%90%86%e8%b7%af%e5%be%84><span>管理</span></a></li><li class=nav-item style=max-width:90px;min-width:10px><a class=nav-link href=/%e5%bc%80%e6%ba%90%e9%a1%b9%e7%9b%ae><span>开源⭐</span></a></li></ul><div class="form-inline my-2 my-lg-0"><div class="nav-item nav-search-item my-2 my-md-0"><input type=search class="form-control td-search-input" placeholder="&#xf002; Search this site…" aria-label="Search this site…" autocomplete=off></div></div></div></nav></header><div class="container-fluid td-outer"><div class=td-main><div class="row flex-xl-nowrap"><div class="col-12 col-md-3 col-xl-2 td-sidebar d-print-none"></div><div class="d-none d-xl-block col-xl-2 td-toc d-print-none"></div><main class="col-12 col-md-9 col-xl-8 pl-md-5" role=main><div class=td-content><div class="pageinfo pageinfo-primary d-print-none"><p>This the multi-page printable view of this section.
<a href=# onclick="return print(),!1">Click here to print</a>.</p><p><a href=/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/redis/>Return to the regular view of this page</a>.</p></div><h1 class=title>Redis</h1><ul><li>1: <a href=#pg-15dc494595c2bd4672f094c19c69802f>CH01-基本类型</a></li><li>2: <a href=#pg-74fbd382412792c903e2f596fdcce9b7>CH02-高级类型</a></li><li>3: <a href=#pg-fa602568c373b012706150061f875875>CH03-Stream</a></li><li>4: <a href=#pg-f39b5b7bdbb59acf255fb62ce2763d03>CH04-对象机制</a></li><li>5: <a href=#pg-d6ad1d4083c795b0ad006b6fb71ea3c7>CH05-底层结构</a></li><li>6: <a href=#pg-e23ea9a97b8e45f6fe4f13ffc2073690>CH06-缓存机制</a></li><li>7: <a href=#pg-76cf898359b51ee9f123cd859135b47d>CH07-高可用性</a></li><li>8: <a href=#pg-609363fe593c01d2ba6ab13171671b34>CH08-百亿量级</a></li><li>9: <a href=#pg-52ebc52fef800cc7b90e32b1026ac24d>CH09-实现搜索</a></li><li>10: <a href=#pg-0651586b1071ed29fcfe45d22825ffb0>CH10-常见问题</a></li></ul><div class=content></div></div><div class=td-content><h1 id=pg-15dc494595c2bd4672f094c19c69802f>1 - CH01-基本类型</h1><h2 id=概览>概览</h2><p>Redis 中所有的 Key 都是字符串。我们在谈基础数据结构时，讨论的是存储值的数据类型，主要包括常见的5种数据类型，分别是：String、List、Set、Zset、Hash。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210504125755.png style=display:block;width:50% alt=NAME align=center></div><table><thead><tr><th>结构类型</th><th>值的形式</th><th>读写能力</th></tr></thead><tbody><tr><td><strong>String</strong></td><td>字符串、整数、浮点数</td><td>对整个字符串或字符串的一部分进行操作；对整数或浮点数进行自增或自减操作；</td></tr><tr><td><strong>List</strong></td><td>由字符串构造的链表</td><td>对链表的两端进行push和pop操作，读取单个或多个元素；根据值查找或删除元素；</td></tr><tr><td><strong>Set</strong></td><td>由无重复字符串构成的集合</td><td>字符串的集合，包含基础的方法有看是否存在添加、获取、删除；还包含计算交集、并集、差集等</td></tr><tr><td><strong>Hash</strong></td><td>由键值对构成的无序散列表</td><td>包含方法有添加、获取、删除单个元素</td></tr><tr><td><strong>Zset</strong></td><td>由键值对构成的有序集合</td><td>字符串成员与浮点数分数之间的有序映射；元素的排列顺序由分数的大小决定；包含方法有添加、获取、删除单个元素以及根据分值范围或成员来获取元素</td></tr></tbody></table><h2 id=string>String</h2><p>String是redis中最基本的数据类型，一个key对应一个value。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210504130432.png style=display:block;width:50% alt=NAME align=center></div><h3 id=常用命令>常用命令</h3><table><thead><tr><th>命令</th><th>简述</th><th>使用</th></tr></thead><tbody><tr><td>GET</td><td>获取存储在给定键中的值</td><td>GET name</td></tr><tr><td>SET</td><td>设置存储在给定键中的值</td><td>SET name value</td></tr><tr><td>DEL</td><td>删除存储在给定键中的值</td><td>DEL name</td></tr><tr><td>INCR</td><td>将键存储的值加1</td><td>INCR key</td></tr><tr><td>DECR</td><td>将键存储的值减1</td><td>DECR key</td></tr><tr><td>INCRBY</td><td>将键存储的值加上整数</td><td>INCRBY key amount</td></tr><tr><td>DECRBY</td><td>将键存储的值减去整数</td><td>DECRBY key amount</td></tr></tbody></table><h3 id=应用场景>应用场景</h3><ul><li><p><strong>缓存</strong>： 经典使用场景，把常用信息，字符串，图片或者视频等信息放到redis中，redis作为缓存层，mysql做持久化层，降低mysql的读写压力。</p></li><li><p><strong>计数器</strong>：redis是单线程模型，一个命令执行完才会执行下一个，同时数据可以一步落地到其他的数据源。</p></li><li><p><strong>session</strong>：常见方案spring session + redis实现session共享</p></li></ul><h2 id=list>List</h2><p>Redis中的List其实就是链表（Redis用双端链表实现List）。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210504130444.png style=display:block;width:50% alt=NAME align=center></div><h3 id=常用命令-1>常用命令</h3><table><thead><tr><th>命令</th><th>简述</th><th>使用</th></tr></thead><tbody><tr><td>RPUSH</td><td>将给定值推入到列表右端</td><td>RPUSH key value</td></tr><tr><td>LPUSH</td><td>将给定值推入到列表左端</td><td>LPUSH key value</td></tr><tr><td>RPOP</td><td>从列表的右端弹出一个值，并返回被弹出的值</td><td>RPOP key</td></tr><tr><td>LPOP</td><td>从列表的左端弹出一个值，并返回被弹出的值</td><td>LPOP key</td></tr><tr><td>LRANGE</td><td>获取列表在给定范围上的所有值</td><td>LRANGE key 0 -1</td></tr><tr><td>LINDEX</td><td>通过索引获取列表中的元素。你也可以使用负数下标，以 -1 表示列表的最后一个元素， -2 表示列表的倒数第二个元素，以此类推。</td><td>LINEX key index</td></tr></tbody></table><h3 id=应用场景-1>应用场景</h3><ul><li><strong>微博TimeLine</strong>: 有人发布微博，用lpush加入时间轴，展示新的列表信息。</li><li><strong>消息队列</strong></li></ul><h2 id=set>Set</h2><p>Redis 的 Set 是 String 类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据。</p><p>Redis 中集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210504130624.png style=display:block;width:50% alt=NAME align=center></div><h3 id=常用命令-2>常用命令</h3><table><thead><tr><th>命令</th><th>简述</th><th>使用</th></tr></thead><tbody><tr><td>SADD</td><td>向集合添加一个或多个成员</td><td>SADD key value</td></tr><tr><td>SCARD</td><td>获取集合的成员数</td><td>SCARD key</td></tr><tr><td>SMEMBER</td><td>返回集合中的所有成员</td><td>SMEMBER key member</td></tr><tr><td>SISMEMBER</td><td>判断 member 元素是否是集合 key 的成员</td><td>SISMEMBER key member</td></tr></tbody></table><h3 id=应用场景-2>应用场景</h3><p><strong>实战场景</strong></p><ul><li><strong>标签</strong>（tag）,给用户添加标签，或者用户给消息添加标签，这样有同一标签或者类似标签的可以给推荐关注的事或者关注的人。</li><li><strong>点赞，或点踩，收藏等</strong>，可以放到set中实现</li></ul><h2 id=hash>Hash</h2><p>Redis hash 是一个 string 类型的 field（字段） 和 value（值） 的映射表，hash 特别适合用于存储对象。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210504130731.png style=display:block;width:50% alt=NAME align=center></div><h3 id=常用命令-3>常用命令</h3><table><thead><tr><th>命令</th><th>简述</th><th>使用</th></tr></thead><tbody><tr><td>HSET</td><td>添加键值对</td><td>HSET hash-key sub-key1 value1</td></tr><tr><td>HGET</td><td>获取指定散列键的值</td><td>HGET hash-key key1</td></tr><tr><td>HGETALL</td><td>获取散列中包含的所有键值对</td><td>HGETALL hash-key</td></tr><tr><td>HDEL</td><td>如果给定键存在于散列中，那么就移除这个键</td><td>HDEL hash-key sub-key1</td></tr></tbody></table><h3 id=应用场景-3>应用场景</h3><ul><li><strong>缓存</strong>： 能直观，相比string更节省空间，的维护缓存信息，如用户信息，视频信息等。</li></ul><h2 id=zset>ZSet</h2><p>Redis 有序集合和集合一样也是 string 类型元素的集合,且不允许重复的成员。不同的是每个元素都会关联一个 double 类型的分数。redis 正是通过分数来为集合中的成员进行从小到大的排序。</p><p>有序集合的成员是唯一的,但分数(score)却可以重复。集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210504130854.png style=display:block;width:50% alt=NAME align=center></div><h3 id=常用命令-4>常用命令</h3><table><thead><tr><th>命令</th><th>简述</th><th>使用</th></tr></thead><tbody><tr><td>ZADD</td><td>将一个带有给定分值的成员添加到哦有序集合里面</td><td>ZADD zset-key 178 member1</td></tr><tr><td>ZRANGE</td><td>根据元素在有序集合中所处的位置，从有序集合中获取多个元素</td><td>ZRANGE zset-key 0-1 withccores</td></tr><tr><td>ZREM</td><td>如果给定元素成员存在于有序集合中，那么就移除这个元素</td><td>ZREM zset-key member1</td></tr></tbody></table><h3 id=应用场景-4>应用场景</h3><ul><li><strong>排行榜</strong>：有序集合经典使用场景。例如小说视频等网站需要对用户上传的小说视频做排行榜，榜单可以按照用户关注数，更新时间，字数等打分，做排行。</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-74fbd382412792c903e2f596fdcce9b7>2 - CH02-高级类型</h1><h2 id=hyperloglogs基数>HyperLogLogs：基数</h2><h3 id=什么是基数>什么是基数</h3><p>举个例子，A = {1, 2, 3, 4, 5}， B = {3, 5, 6, 7, 9}；那么基数（不重复的元素）= 1, 2, 4, 6, 7, 9； （允许容错，即可以接受一定误差）</p><h3 id=基本用途>基本用途</h3><p>这个结构可以非常省内存的去统计各种计数，比如注册 IP 数、每日访问 IP 数、页面实时UV、在线用户数，共同好友数等。</p><h3 id=结构优点>结构优点</h3><p>一个大型的网站，每天 IP 比如有 100 万，粗算一个 IP 消耗 15 字节，那么 100 万个 IP 就是 15M。而 HyperLogLog 在 Redis 中每个键占用的内容都是 12K，理论存储近似接近 2^64 个值，不管存储的内容是什么，它一个基于基数估算的算法，只能比较准确的估算出基数，可以使用少量固定的内存去存储并识别集合中的唯一元素。而且这个估算的基数并不一定准确，是一个带有 0.81% 标准错误的近似值（对于可以接受一定容错的业务场景，比如IP数统计，UV等，是可以忽略不计的）。</p><h3 id=操作命令>操作命令</h3><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>127.0.0.1:6379&gt; pfadd key1 a b c d e f g h i	<span style=color:#8f5902;font-style:italic># 创建第一组元素</span>
</span></span><span style=display:flex><span><span style=color:#ce5c00;font-weight:700>(</span>integer<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#0000cf;font-weight:700>1</span>
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; pfcount key1					<span style=color:#8f5902;font-style:italic># 统计元素的基数数量</span>
</span></span><span style=display:flex><span><span style=color:#ce5c00;font-weight:700>(</span>integer<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#0000cf;font-weight:700>9</span>
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; pfadd key2 c j k l m e g a		<span style=color:#8f5902;font-style:italic># 创建第二组元素</span>
</span></span><span style=display:flex><span><span style=color:#ce5c00;font-weight:700>(</span>integer<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#0000cf;font-weight:700>1</span>
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; pfcount key2
</span></span><span style=display:flex><span><span style=color:#ce5c00;font-weight:700>(</span>integer<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#0000cf;font-weight:700>8</span>
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; pfmerge key3 key1 key2			<span style=color:#8f5902;font-style:italic># 合并两组：key1 key2 -&gt; key3 并集</span>
</span></span><span style=display:flex><span>OK
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; pfcount key3
</span></span><span style=display:flex><span><span style=color:#ce5c00;font-weight:700>(</span>integer<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#0000cf;font-weight:700>13</span>
</span></span></code></pre></div><h2 id=bitmap位图>Bitmap：位图</h2><p>Bitmap 即位图数据结构，都是操作二进制位来进行记录，只有0 和 1 两个状态。</p><h3 id=基本用途-1>基本用途</h3><p>比如：统计用户信息，活跃，不活跃！ 登录，未登录！ 打卡，不打卡！ <strong>两个状态的，都可以使用 Bitmaps</strong>！</p><p>如果存储一年的打卡状态需要多少内存呢？ 365 天 = 365 bit 1字节 = 8bit 46 个字节左右！</p><h3 id=操作命令-1>操作命令</h3><p>使用bitmap 来记录 周一到周日的打卡！ 周一：1 周二：0 周三：0 周四：1 &mldr;&mldr;</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>127.0.0.1:6379&gt; setbit sign <span style=color:#0000cf;font-weight:700>0</span> <span style=color:#0000cf;font-weight:700>1</span>
</span></span><span style=display:flex><span><span style=color:#ce5c00;font-weight:700>(</span>integer<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#0000cf;font-weight:700>0</span>
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; setbit sign <span style=color:#0000cf;font-weight:700>1</span> <span style=color:#0000cf;font-weight:700>1</span>
</span></span><span style=display:flex><span><span style=color:#ce5c00;font-weight:700>(</span>integer<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#0000cf;font-weight:700>0</span>
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; setbit sign <span style=color:#0000cf;font-weight:700>2</span> <span style=color:#0000cf;font-weight:700>0</span>
</span></span><span style=display:flex><span><span style=color:#ce5c00;font-weight:700>(</span>integer<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#0000cf;font-weight:700>0</span>
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; setbit sign <span style=color:#0000cf;font-weight:700>3</span> <span style=color:#0000cf;font-weight:700>1</span>
</span></span><span style=display:flex><span><span style=color:#ce5c00;font-weight:700>(</span>integer<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#0000cf;font-weight:700>0</span>
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; setbit sign <span style=color:#0000cf;font-weight:700>4</span> <span style=color:#0000cf;font-weight:700>0</span>
</span></span><span style=display:flex><span><span style=color:#ce5c00;font-weight:700>(</span>integer<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#0000cf;font-weight:700>0</span>
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; setbit sign <span style=color:#0000cf;font-weight:700>5</span> <span style=color:#0000cf;font-weight:700>0</span>
</span></span><span style=display:flex><span><span style=color:#ce5c00;font-weight:700>(</span>integer<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#0000cf;font-weight:700>0</span>
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; setbit sign <span style=color:#0000cf;font-weight:700>6</span> <span style=color:#0000cf;font-weight:700>1</span>
</span></span><span style=display:flex><span><span style=color:#ce5c00;font-weight:700>(</span>integer<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#0000cf;font-weight:700>0</span>
</span></span></code></pre></div><p>查看某一天是否有打卡！</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>127.0.0.1:6379&gt; getbit sign <span style=color:#0000cf;font-weight:700>3</span>
</span></span><span style=display:flex><span><span style=color:#ce5c00;font-weight:700>(</span>integer<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#0000cf;font-weight:700>1</span>
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; getbit sign <span style=color:#0000cf;font-weight:700>5</span>
</span></span><span style=display:flex><span><span style=color:#ce5c00;font-weight:700>(</span>integer<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#0000cf;font-weight:700>0</span>
</span></span></code></pre></div><p>统计操作，统计 打卡的天数！</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>127.0.0.1:6379&gt; bitcount sign <span style=color:#8f5902;font-style:italic># 统计这周的打卡记录，就可以看到是否有全勤！</span>
</span></span><span style=display:flex><span><span style=color:#ce5c00;font-weight:700>(</span>integer<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#0000cf;font-weight:700>3</span>
</span></span></code></pre></div><h2 id=geospatial地理位置>Geospatial：地理位置</h2><p>用于地理位置坐标的存储与计算。</p><h3 id=添加地理位置>添加地理位置</h3><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>127.0.0.1:6379&gt; geoadd china:city 118.76 32.04 manjing 112.55 37.86 taiyuan 123.43 41.80 shenyang
</span></span><span style=display:flex><span><span style=color:#ce5c00;font-weight:700>(</span>integer<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#0000cf;font-weight:700>3</span>
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; geoadd china:city 144.05 22.52 shengzhen 120.16 30.24 hangzhou 108.96 34.26 xian
</span></span><span style=display:flex><span><span style=color:#ce5c00;font-weight:700>(</span>integer<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#0000cf;font-weight:700>3</span>
</span></span></code></pre></div><h3 id=获取地理位置>获取地理位置</h3><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>127.0.0.1:6379&gt; geopos china:city taiyuan manjing
</span></span><span style=display:flex><span>1<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;112.54999905824661255&#34;</span>
</span></span><span style=display:flex><span>   1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;37.86000073876942196&#34;</span>
</span></span><span style=display:flex><span>2<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;118.75999957323074341&#34;</span>
</span></span><span style=display:flex><span>   1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;32.03999960287850968&#34;</span>
</span></span></code></pre></div><h3 id=计算距离>计算距离</h3><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>127.0.0.1:6379&gt; geodist china:city taiyuan shenyang m
</span></span><span style=display:flex><span><span style=color:#4e9a06>&#34;1026439.1070&#34;</span>
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; geodist china:city taiyuan shenyang km
</span></span><span style=display:flex><span><span style=color:#4e9a06>&#34;1026.4391&#34;</span>
</span></span></code></pre></div><h3 id=范围查找>范围查找</h3><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span><span style=color:#8f5902;font-style:italic># 以 100,30 这个坐标为中心, 寻找半径为1000km的城市</span>
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; georadius china:city <span style=color:#0000cf;font-weight:700>110</span> <span style=color:#0000cf;font-weight:700>30</span> <span style=color:#0000cf;font-weight:700>1000</span> km
</span></span><span style=display:flex><span>1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;xian&#34;</span>
</span></span><span style=display:flex><span>2<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;hangzhou&#34;</span>
</span></span><span style=display:flex><span>3<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;manjing&#34;</span>
</span></span><span style=display:flex><span>4<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;taiyuan&#34;</span>
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; georadius china:city <span style=color:#0000cf;font-weight:700>110</span> <span style=color:#0000cf;font-weight:700>30</span> <span style=color:#0000cf;font-weight:700>500</span> km
</span></span><span style=display:flex><span>1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;xian&#34;</span>
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; georadius china:city <span style=color:#0000cf;font-weight:700>110</span> <span style=color:#0000cf;font-weight:700>30</span> <span style=color:#0000cf;font-weight:700>500</span> km withdist
</span></span><span style=display:flex><span>1<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;xian&#34;</span>
</span></span><span style=display:flex><span>   2<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;483.8340&#34;</span>
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; georadius china:city <span style=color:#0000cf;font-weight:700>110</span> <span style=color:#0000cf;font-weight:700>30</span> <span style=color:#0000cf;font-weight:700>1000</span> km withcoord withdist count <span style=color:#0000cf;font-weight:700>2</span>
</span></span><span style=display:flex><span>1<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;xian&#34;</span>
</span></span><span style=display:flex><span>   2<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;483.8340&#34;</span>
</span></span><span style=display:flex><span>   3<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;108.96000176668167114&#34;</span>
</span></span><span style=display:flex><span>      2<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;34.25999964418929977&#34;</span>
</span></span><span style=display:flex><span>2<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;manjing&#34;</span>
</span></span><span style=display:flex><span>   2<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;864.9816&#34;</span>
</span></span><span style=display:flex><span>   3<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;118.75999957323074341&#34;</span>
</span></span><span style=display:flex><span>      2<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;32.03999960287850968&#34;</span>
</span></span></code></pre></div><p>参数：key 经度 纬度 半径 单位 显示结果的经度和纬度 显示结果的距离 显示的结果的数量</p><h3 id=范围相交>范围相交</h3><p>显示与指定成员一定半径范围内的其他成员：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>127.0.0.1:6379&gt; georadiusbymember china:city taiyuan <span style=color:#0000cf;font-weight:700>1000</span> km
</span></span><span style=display:flex><span>1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;manjing&#34;</span>
</span></span><span style=display:flex><span>2<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;taiyuan&#34;</span>
</span></span><span style=display:flex><span>3<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;xian&#34;</span>
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; georadiusbymember china:city taiyuan <span style=color:#0000cf;font-weight:700>1000</span> km withcoord withdist count <span style=color:#0000cf;font-weight:700>2</span>
</span></span><span style=display:flex><span>1<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;taiyuan&#34;</span>
</span></span><span style=display:flex><span>   2<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;0.0000&#34;</span>
</span></span><span style=display:flex><span>   3<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;112.54999905824661255&#34;</span>
</span></span><span style=display:flex><span>      2<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;37.86000073876942196&#34;</span>
</span></span><span style=display:flex><span>2<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;xian&#34;</span>
</span></span><span style=display:flex><span>   2<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;514.2264&#34;</span>
</span></span><span style=display:flex><span>   3<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;108.96000176668167114&#34;</span>
</span></span><span style=display:flex><span>      2<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;34.25999964418929977&#34;</span>
</span></span></code></pre></div><h3 id=取-hash-值>取 Hash 值</h3><p>将二维的经纬度转换为一维的字符串, 如果两个字符串越接近, 则距离越近</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>127.0.0.1:6379&gt; geohash china:city taiyuan shenyang
</span></span><span style=display:flex><span>1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;ww8p3hhqmp0&#34;</span>
</span></span><span style=display:flex><span>2<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;wxrvb9qyxk0&#34;</span>
</span></span></code></pre></div><h3 id=底层实现>底层实现</h3><p>geo底层的实现原理实际上就是Zset, 我们可以通过Zset命令来操作geo：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>127.0.0.1:6379&gt; <span style=color:#204a87>type</span> china:city
</span></span><span style=display:flex><span>zset
</span></span></code></pre></div><p>查看全部元素 删除指定的元素：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>127.0.0.1:6379&gt; zrange china:city <span style=color:#0000cf;font-weight:700>0</span> -1 withscores
</span></span><span style=display:flex><span> 1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;xian&#34;</span>
</span></span><span style=display:flex><span> 2<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;4040115445396757&#34;</span>
</span></span><span style=display:flex><span> 3<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;hangzhou&#34;</span>
</span></span><span style=display:flex><span> 4<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;4054133997236782&#34;</span>
</span></span><span style=display:flex><span> 5<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;manjing&#34;</span>
</span></span><span style=display:flex><span> 6<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;4066006694128997&#34;</span>
</span></span><span style=display:flex><span> 7<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;taiyuan&#34;</span>
</span></span><span style=display:flex><span> 8<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;4068216047500484&#34;</span>
</span></span><span style=display:flex><span> 9<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;shenyang&#34;</span>
</span></span><span style=display:flex><span>1<span style=color:#ce5c00;font-weight:700>)</span>  <span style=color:#4e9a06>&#34;4072519231994779&#34;</span>
</span></span><span style=display:flex><span>2<span style=color:#ce5c00;font-weight:700>)</span>  <span style=color:#4e9a06>&#34;shengzhen&#34;</span>
</span></span><span style=display:flex><span>3<span style=color:#ce5c00;font-weight:700>)</span>  <span style=color:#4e9a06>&#34;4154606886655324&#34;</span>
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; zrem china:city manjing
</span></span><span style=display:flex><span><span style=color:#ce5c00;font-weight:700>(</span>integer<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#0000cf;font-weight:700>1</span>
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; zrange china:city <span style=color:#0000cf;font-weight:700>0</span> -1
</span></span><span style=display:flex><span>1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;xian&#34;</span>
</span></span><span style=display:flex><span>2<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;hangzhou&#34;</span>
</span></span><span style=display:flex><span>3<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;taiyuan&#34;</span>
</span></span><span style=display:flex><span>4<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;shenyang&#34;</span>
</span></span><span style=display:flex><span>5<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;shengzhen&#34;</span>
</span></span></code></pre></div></div><div class=td-content style=page-break-before:always><h1 id=pg-fa602568c373b012706150061f875875>3 - CH03-Stream</h1><h2 id=概览>概览</h2><p>Redis5.0 中还增加了一个数据结构Stream，从字面上看是流类型，但其实从功能上看，应该是Redis对消息队列（MQ，Message Queue）的完善实现。</p><p>用过Redis做消息队列的都了解，基于Reids的消息队列实现有很多种，例如：</p><ul><li>PUB/SUB，订阅/发布模式：<ul><li>但是发布订阅模式是无法持久化的，如果出现网络断开、Redis 宕机等，消息就会被丢弃；</li></ul></li><li>基于 List LPUSH+BRPOP 或者基于Sorted-Set 的实现：<ul><li>支持了持久化，但是不支持多播，分组消费等</li></ul></li></ul><p>为什么上面的结构无法满足广泛的MQ场景？ 这里便引出一个核心的问题：如果我们期望设计一种数据结构来实现消息队列，最重要的就是要理解<strong>设计一个消息队列需要考虑什么</strong>？初步的我们很容易想到</p><ul><li>消息的生产</li><li>消息的消费<ul><li>单播和多播（多对多）</li><li>阻塞和非阻塞读取</li></ul></li><li>消息有序性</li><li>消息的持久化</li></ul><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210504132556.png style=display:block;width:50% alt=NAME align=center></div><h2 id=基本结构>基本结构</h2><p>每个 Stream 都有唯一的名称，它就是 Redis 的 key，在我们首次使用 xadd 指令追加消息时自动创建。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210504132658.png style=display:block;width:50% alt=NAME align=center></div><p>上图解析：</p><ul><li><code>Consumer Group</code> ：消费组，使用 XGROUP CREATE 命令创建，一个消费组有多个消费者(Consumer), 这些消费者之间是竞争关系。</li><li><code>last_delivered_id</code> ：游标，每个消费组会有个游标 last_delivered_id，任意一个消费者读取了消息都会使游标 last_delivered_id 往前移动。</li><li><code>pending_ids</code> ：消费者(Consumer)的状态变量，作用是维护消费者的未确认的 id。 pending_ids 记录了当前已经被客户端读取的消息，但是还没有 <code>ack</code> (Acknowledge character：确认字符）。如果客户端没有ack，这个变量里面的消息ID会越来越多，一旦某个消息被ack，它就开始减少。这个pending_ids变量在Redis官方被称之为PEL，也就是Pending Entries List，这是一个很核心的数据结构，它用来确保客户端至少消费了消息一次，而不会在网络传输的中途丢失了没处理。</li></ul><p>此外我们还需要理解两点：</p><ul><li><code>消息ID</code>: 消息ID的形式是timestampInMillis-sequence，例如1527846880572-5，它表示当前的消息在毫米时间戳1527846880572时产生，并且是该毫秒内产生的第5条消息。消息ID可以由服务器自动生成，也可以由客户端自己指定，但是形式必须是整数-整数，而且必须是后面加入的消息的ID要大于前面的消息ID。</li><li><code>消息内容</code>: 消息内容就是键值对，形如hash结构的键值对，这没什么特别之处。</li></ul><h2 id=基本操作>基本操作</h2><p>消息队列相关命令：</p><ul><li>XADD - 添加消息到末尾</li><li>XTRIM - 对流进行修剪，限制长度</li><li>XDEL - 删除消息</li><li>XLEN - 获取流包含的元素数量，即消息长度</li><li>XRANGE - 获取消息列表，会自动过滤已经删除的消息</li><li>XREVRANGE - 反向获取消息列表，ID 从大到小</li><li>XREAD - 以阻塞或非阻塞方式获取消息列表</li></ul><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span><span style=color:#8f5902;font-style:italic># *号表示服务器自动生成ID，后面顺序跟着一堆key/value</span>
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; xadd codehole * name laoqian age <span style=color:#0000cf;font-weight:700>30</span>  <span style=color:#8f5902;font-style:italic>#  名字叫laoqian，年龄30岁</span>
</span></span><span style=display:flex><span>1527849609889-0  <span style=color:#8f5902;font-style:italic># 生成的消息ID</span>
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; xadd codehole * name xiaoyu age <span style=color:#0000cf;font-weight:700>29</span>
</span></span><span style=display:flex><span>1527849629172-0
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; xadd codehole * name xiaoqian age <span style=color:#0000cf;font-weight:700>1</span>
</span></span><span style=display:flex><span>1527849637634-0
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; xlen codehole
</span></span><span style=display:flex><span><span style=color:#ce5c00;font-weight:700>(</span>integer<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#0000cf;font-weight:700>3</span>
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; xrange codehole - +  <span style=color:#8f5902;font-style:italic># -表示最小值, +表示最大值</span>
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; xrange codehole - +
</span></span><span style=display:flex><span>1<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> 1527849609889-0
</span></span><span style=display:flex><span>   1<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;name&#34;</span>
</span></span><span style=display:flex><span>      1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;laoqian&#34;</span>
</span></span><span style=display:flex><span>      2<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;age&#34;</span>
</span></span><span style=display:flex><span>      3<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;30&#34;</span>
</span></span><span style=display:flex><span>2<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> 1527849629172-0
</span></span><span style=display:flex><span>   1<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;name&#34;</span>
</span></span><span style=display:flex><span>      1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;xiaoyu&#34;</span>
</span></span><span style=display:flex><span>      2<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;age&#34;</span>
</span></span><span style=display:flex><span>      3<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;29&#34;</span>
</span></span><span style=display:flex><span>3<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> 1527849637634-0
</span></span><span style=display:flex><span>   1<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;name&#34;</span>
</span></span><span style=display:flex><span>      1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;xiaoqian&#34;</span>
</span></span><span style=display:flex><span>      2<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;age&#34;</span>
</span></span><span style=display:flex><span>      3<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;1&#34;</span>
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; xrange codehole 1527849629172-0 +  <span style=color:#8f5902;font-style:italic># 指定最小消息ID的列表</span>
</span></span><span style=display:flex><span>1<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> 1527849629172-0
</span></span><span style=display:flex><span>   2<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;name&#34;</span>
</span></span><span style=display:flex><span>      2<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;xiaoyu&#34;</span>
</span></span><span style=display:flex><span>      3<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;age&#34;</span>
</span></span><span style=display:flex><span>      4<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;29&#34;</span>
</span></span><span style=display:flex><span>2<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> 1527849637634-0
</span></span><span style=display:flex><span>   2<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;name&#34;</span>
</span></span><span style=display:flex><span>      2<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;xiaoqian&#34;</span>
</span></span><span style=display:flex><span>      3<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;age&#34;</span>
</span></span><span style=display:flex><span>      4<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;1&#34;</span>
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; xrange codehole - 1527849629172-0  <span style=color:#8f5902;font-style:italic># 指定最大消息ID的列表</span>
</span></span><span style=display:flex><span>1<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> 1527849609889-0
</span></span><span style=display:flex><span>   2<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;name&#34;</span>
</span></span><span style=display:flex><span>      2<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;laoqian&#34;</span>
</span></span><span style=display:flex><span>      3<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;age&#34;</span>
</span></span><span style=display:flex><span>      4<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;30&#34;</span>
</span></span><span style=display:flex><span>2<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> 1527849629172-0
</span></span><span style=display:flex><span>   2<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;name&#34;</span>
</span></span><span style=display:flex><span>      2<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;xiaoyu&#34;</span>
</span></span><span style=display:flex><span>      3<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;age&#34;</span>
</span></span><span style=display:flex><span>      4<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;29&#34;</span>
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; xdel codehole 1527849609889-0
</span></span><span style=display:flex><span><span style=color:#ce5c00;font-weight:700>(</span>integer<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#0000cf;font-weight:700>1</span>
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; xlen codehole  <span style=color:#8f5902;font-style:italic># 长度不受影响</span>
</span></span><span style=display:flex><span><span style=color:#ce5c00;font-weight:700>(</span>integer<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#0000cf;font-weight:700>3</span>
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; xrange codehole - +  <span style=color:#8f5902;font-style:italic># 被删除的消息没了</span>
</span></span><span style=display:flex><span>1<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> 1527849629172-0
</span></span><span style=display:flex><span>   2<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;name&#34;</span>
</span></span><span style=display:flex><span>      2<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;xiaoyu&#34;</span>
</span></span><span style=display:flex><span>      3<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;age&#34;</span>
</span></span><span style=display:flex><span>      4<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;29&#34;</span>
</span></span><span style=display:flex><span>2<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> 1527849637634-0
</span></span><span style=display:flex><span>   2<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;name&#34;</span>
</span></span><span style=display:flex><span>      2<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;xiaoqian&#34;</span>
</span></span><span style=display:flex><span>      3<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;age&#34;</span>
</span></span><span style=display:flex><span>      4<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;1&#34;</span>
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; del codehole  <span style=color:#8f5902;font-style:italic># 删除整个Stream</span>
</span></span><span style=display:flex><span><span style=color:#ce5c00;font-weight:700>(</span>integer<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#0000cf;font-weight:700>1</span>
</span></span></code></pre></div><h2 id=独立消费>独立消费</h2><p>我们可以在不定义消费组的情况下进行Stream消息的独立消费，当Stream没有新消息时，甚至可以阻塞等待。Redis设计了一个单独的消费指令xread，可以将Stream当成普通的消息队列(list)来使用。使用xread时，我们可以完全忽略消费组(Consumer Group)的存在，就好比Stream就是一个普通的列表(list)。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#8f5902;font-style:italic># 从Stream头部读取两条消息</span>
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; xread count <span style=color:#0000cf;font-weight:700>2</span> streams codehole 0-0
</span></span><span style=display:flex><span>1<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;codehole&#34;</span>
</span></span><span style=display:flex><span>   2<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> 1527851486781-0
</span></span><span style=display:flex><span>         2<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;name&#34;</span>
</span></span><span style=display:flex><span>            2<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;laoqian&#34;</span>
</span></span><span style=display:flex><span>            3<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;age&#34;</span>
</span></span><span style=display:flex><span>            4<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;30&#34;</span>
</span></span><span style=display:flex><span>      2<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> 1527851493405-0
</span></span><span style=display:flex><span>         2<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;name&#34;</span>
</span></span><span style=display:flex><span>            2<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;yurui&#34;</span>
</span></span><span style=display:flex><span>            3<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;age&#34;</span>
</span></span><span style=display:flex><span>            4<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;29&#34;</span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic># 从Stream尾部读取一条消息，毫无疑问，这里不会返回任何消息</span>
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; xread count <span style=color:#0000cf;font-weight:700>1</span> streams codehole $
</span></span><span style=display:flex><span><span style=color:#ce5c00;font-weight:700>(</span>nil<span style=color:#ce5c00;font-weight:700>)</span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic># 从尾部阻塞等待新消息到来，下面的指令会堵住，直到新消息到来</span>
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; xread block <span style=color:#0000cf;font-weight:700>0</span> count <span style=color:#0000cf;font-weight:700>1</span> streams codehole $
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic># 我们从新打开一个窗口，在这个窗口往Stream里塞消息</span>
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; xadd codehole * name youming age <span style=color:#0000cf;font-weight:700>60</span>
</span></span><span style=display:flex><span>1527852774092-0
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic># 再切换到前面的窗口，我们可以看到阻塞解除了，返回了新的消息内容</span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic># 而且还显示了一个等待时间，这里我们等待了93s</span>
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; xread block <span style=color:#0000cf;font-weight:700>0</span> count <span style=color:#0000cf;font-weight:700>1</span> streams codehole $
</span></span><span style=display:flex><span>1<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;codehole&#34;</span>
</span></span><span style=display:flex><span>   2<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> 1527852774092-0
</span></span><span style=display:flex><span>         2<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;name&#34;</span>
</span></span><span style=display:flex><span>            2<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;youming&#34;</span>
</span></span><span style=display:flex><span>            3<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;age&#34;</span>
</span></span><span style=display:flex><span>            4<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;60&#34;</span>
</span></span><span style=display:flex><span><span style=color:#ce5c00;font-weight:700>(</span>93.11s<span style=color:#ce5c00;font-weight:700>)</span>
</span></span></code></pre></div><p>客户端如果想要使用xread进行顺序消费，一定要记住当前消费到哪里了，也就是返回的消息ID。下次继续调用xread时，将上次返回的最后一个消息ID作为参数传递进去，就可以继续消费后续的消息。</p><p>block 0表示永远阻塞，直到消息到来，block 1000表示阻塞1s，如果1s内没有任何消息到来，就返回nil</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>127.0.0.1:6379&gt; xread block <span style=color:#0000cf;font-weight:700>1000</span> count <span style=color:#0000cf;font-weight:700>1</span> streams codehole $
</span></span><span style=display:flex><span><span style=color:#ce5c00;font-weight:700>(</span>nil<span style=color:#ce5c00;font-weight:700>)</span>
</span></span><span style=display:flex><span><span style=color:#ce5c00;font-weight:700>(</span>1.07s<span style=color:#ce5c00;font-weight:700>)</span>
</span></span></code></pre></div><h2 id=按组消费>按组消费</h2><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210504133052.png style=display:block;width:50% alt=NAME align=center></div><h3 id=相关命令>相关命令</h3><ul><li>XGROUP CREATE - 创建消费者组</li><li>XREADGROUP GROUP - 读取消费者组中的消息</li><li>XACK - 将消息标记为"已处理"</li><li>XGROUP SETID - 为消费者组设置新的最后递送消息ID</li><li>XGROUP DELCONSUMER - 删除消费者</li><li>XGROUP DESTROY - 删除消费者组</li><li>XPENDING - 显示待处理消息的相关信息</li><li>XCLAIM - 转移消息的归属权</li><li>XINFO - 查看流和消费者组的相关信息；</li><li>XINFO GROUPS - 打印消费者组的信息；</li><li>XINFO STREAM - 打印流信息</li></ul><p>Stream通过xgroup create指令创建消费组(Consumer Group)，需要传递起始消息ID参数用来初始化last_delivered_id变量。</p><p>Stream提供了xreadgroup指令可以进行消费组的组内消费，需要提供消费组名称、消费者名称和起始消息ID。它同xread一样，也可以阻塞等待新消息。读到新消息后，对应的消息ID就会进入消费者的PEL(正在处理的消息)结构里，客户端处理完毕后使用xack指令通知服务器，本条消息已经处理完毕，该消息ID就会从PEL中移除。</p><h3 id=信息监控>信息监控</h3><p>Stream提供了XINFO来实现对服务器信息的监控，可以查询：</p><ul><li>查看队列信息</li><li>消费组信息</li><li>消费者组成员信息</li></ul><h3 id=应用场景>应用场景</h3><p>可用作时通信等，大数据分析，异地数据备份等</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210504135014.png style=display:block;width:50% alt=NAME align=center></div><p>客户端可以平滑扩展，提高处理能力</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210504135029.png style=display:block;width:50% alt=NAME align=center></div><h3 id=消息id的设计是否考虑了时间回拨的问题>消息ID的设计是否考虑了时间回拨的问题</h3><p>XADD生成的1553439850328-0，就是Redis生成的消息ID，由两部分组成:<strong>时间戳-序号</strong>。时间戳是毫秒级单位，是生成消息的Redis服务器时间，它是个64位整型（int64）。序号是在这个毫秒时间点内的消息序号，它也是个64位整型。</p><p>可以通过multi批处理，来验证序号的递增：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>127.0.0.1:6379&gt; MULTI
</span></span><span style=display:flex><span>OK
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; XADD memberMessage * msg one
</span></span><span style=display:flex><span>QUEUED
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; XADD memberMessage * msg two
</span></span><span style=display:flex><span>QUEUED
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; XADD memberMessage * msg three
</span></span><span style=display:flex><span>QUEUED
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; XADD memberMessage * msg four
</span></span><span style=display:flex><span>QUEUED
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; XADD memberMessage * msg five
</span></span><span style=display:flex><span>QUEUED
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; EXEC
</span></span><span style=display:flex><span>1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;1553441006884-0&#34;</span>
</span></span><span style=display:flex><span>2<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;1553441006884-1&#34;</span>
</span></span><span style=display:flex><span>3<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;1553441006884-2&#34;</span>
</span></span><span style=display:flex><span>4<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;1553441006884-3&#34;</span>
</span></span><span style=display:flex><span>5<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;1553441006884-4&#34;</span>
</span></span></code></pre></div><p>由于一个redis命令的执行很快，所以可以看到在同一时间戳内，是通过序号递增来表示消息的。</p><p>为了保证消息是有序的，因此Redis生成的ID是单调递增有序的。由于ID中包含时间戳部分，为了避免服务器时间错误而带来的问题（例如服务器时间延后了），Redis的每个Stream类型数据都维护一个latest_generated_id属性，用于记录最后一个消息的ID。<strong>若发现当前时间戳退后（小于latest_generated_id所记录的），则采用时间戳不变而序号递增的方案来作为新消息ID</strong>（这也是序号为什么使用int64的原因，保证有足够多的的序号），从而保证ID的单调递增性质。</p><p>强烈建议使用Redis的方案生成消息ID，因为这种时间戳+序号的单调递增的ID方案，几乎可以满足你全部的需求。但同时，记住ID是支持自定义的，别忘了！</p><h3 id=消费者崩溃带来的会不会消息丢失问题>消费者崩溃带来的会不会消息丢失问题</h3><p>为了解决组内消息读取但处理期间消费者崩溃带来的消息丢失问题，STREAM 设计了 Pending 列表，用于记录读取但并未处理完毕的消息。命令XPENDIING 用来获消费组或消费内消费者的未处理完毕的消息。演示如下：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>127.0.0.1:6379&gt; XPENDING mq mqGroup <span style=color:#8f5902;font-style:italic># mpGroup的Pending情况</span>
</span></span><span style=display:flex><span>1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>(</span>integer<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#0000cf;font-weight:700>5</span> <span style=color:#8f5902;font-style:italic># 5个已读取但未处理的消息</span>
</span></span><span style=display:flex><span>2<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;1553585533795-0&#34;</span> <span style=color:#8f5902;font-style:italic># 起始ID</span>
</span></span><span style=display:flex><span>3<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;1553585533795-4&#34;</span> <span style=color:#8f5902;font-style:italic># 结束ID</span>
</span></span><span style=display:flex><span>4<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;consumerA&#34;</span> <span style=color:#8f5902;font-style:italic># 消费者A有3个</span>
</span></span><span style=display:flex><span>      2<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;3&#34;</span>
</span></span><span style=display:flex><span>   2<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;consumerB&#34;</span> <span style=color:#8f5902;font-style:italic># 消费者B有1个</span>
</span></span><span style=display:flex><span>      2<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;1&#34;</span>
</span></span><span style=display:flex><span>   3<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;consumerC&#34;</span> <span style=color:#8f5902;font-style:italic># 消费者C有1个</span>
</span></span><span style=display:flex><span>      2<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;1&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; XPENDING mq mqGroup - + <span style=color:#0000cf;font-weight:700>10</span> <span style=color:#8f5902;font-style:italic># 使用 start end count 选项可以获取详细信息</span>
</span></span><span style=display:flex><span>1<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;1553585533795-0&#34;</span> <span style=color:#8f5902;font-style:italic># 消息ID</span>
</span></span><span style=display:flex><span>   2<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;consumerA&#34;</span> <span style=color:#8f5902;font-style:italic># 消费者</span>
</span></span><span style=display:flex><span>   3<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>(</span>integer<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#0000cf;font-weight:700>1654355</span> <span style=color:#8f5902;font-style:italic># 从读取到现在经历了1654355ms，IDLE</span>
</span></span><span style=display:flex><span>   4<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>(</span>integer<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#0000cf;font-weight:700>5</span> <span style=color:#8f5902;font-style:italic># 消息被读取了5次，delivery counter</span>
</span></span><span style=display:flex><span>2<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;1553585533795-1&#34;</span>
</span></span><span style=display:flex><span>   2<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;consumerA&#34;</span>
</span></span><span style=display:flex><span>   3<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>(</span>integer<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#0000cf;font-weight:700>1654355</span>
</span></span><span style=display:flex><span>   4<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>(</span>integer<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#0000cf;font-weight:700>4</span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic># 共5个，余下3个省略 ...</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; XPENDING mq mqGroup - + <span style=color:#0000cf;font-weight:700>10</span> consumerA <span style=color:#8f5902;font-style:italic># 在加上消费者参数，获取具体某个消费者的Pending列表</span>
</span></span><span style=display:flex><span>1<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;1553585533795-0&#34;</span>
</span></span><span style=display:flex><span>   2<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;consumerA&#34;</span>
</span></span><span style=display:flex><span>   3<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>(</span>integer<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#0000cf;font-weight:700>1641083</span>
</span></span><span style=display:flex><span>   4<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>(</span>integer<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#0000cf;font-weight:700>5</span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic># 共3个，余下2个省略 ...</span>
</span></span></code></pre></div><p>每个Pending的消息有4个属性：</p><ul><li>消息ID</li><li>所属消费者</li><li>IDLE，已读取时长</li><li>delivery counter，消息被读取次数</li></ul><p>上面的结果我们可以看到，我们之前读取的消息，都被记录在Pending列表中，说明全部读到的消息都没有处理，仅仅是读取了。那如何表示消费者处理完毕了消息呢？使用命令 XACK 完成告知消息处理完成，演示如下：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>127.0.0.1:6379&gt; XACK mq mqGroup 1553585533795-0 <span style=color:#8f5902;font-style:italic># 通知消息处理结束，用消息ID标识</span>
</span></span><span style=display:flex><span><span style=color:#ce5c00;font-weight:700>(</span>integer<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#0000cf;font-weight:700>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; XPENDING mq mqGroup <span style=color:#8f5902;font-style:italic># 再次查看Pending列表</span>
</span></span><span style=display:flex><span>1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>(</span>integer<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#0000cf;font-weight:700>4</span> <span style=color:#8f5902;font-style:italic># 已读取但未处理的消息已经变为4个</span>
</span></span><span style=display:flex><span>2<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;1553585533795-1&#34;</span>
</span></span><span style=display:flex><span>3<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;1553585533795-4&#34;</span>
</span></span><span style=display:flex><span>4<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;consumerA&#34;</span> <span style=color:#8f5902;font-style:italic># 消费者A，还有2个消息处理</span>
</span></span><span style=display:flex><span>      2<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;2&#34;</span>
</span></span><span style=display:flex><span>   2<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;consumerB&#34;</span>
</span></span><span style=display:flex><span>      2<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;1&#34;</span>
</span></span><span style=display:flex><span>   3<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;consumerC&#34;</span>
</span></span><span style=display:flex><span>      2<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;1&#34;</span>
</span></span><span style=display:flex><span>127.0.0.1:6379&gt;
</span></span></code></pre></div><p>有了这样一个Pending机制，就意味着在某个消费者读取消息但未处理后，消息是不会丢失的。等待消费者再次上线后，可以读取该Pending列表，就可以继续处理该消息了，保证消息的有序和不丢失。</p><h3 id=消费者彻底宕机后如何转移给其它消费者处理>消费者彻底宕机后如何转移给其它消费者处理</h3><blockquote><p>还有一个问题，就是若某个消费者宕机之后，没有办法再上线了，那么就需要将该消费者Pending的消息，转移给其他的消费者处理，就是消息转移。</p></blockquote><p>消息转移的操作时将某个消息转移到自己的Pending列表中。使用语法XCLAIM来实现，需要设置组、转移的目标消费者和消息ID，同时需要提供IDLE（已被读取时长），只有超过这个时长，才能被转移。演示如下：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#8f5902;font-style:italic># 当前属于消费者A的消息1553585533795-1，已经15907,787ms未处理了</span>
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; XPENDING mq mqGroup - + <span style=color:#0000cf;font-weight:700>10</span>
</span></span><span style=display:flex><span>1<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;1553585533795-1&#34;</span>
</span></span><span style=display:flex><span>   2<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;consumerA&#34;</span>
</span></span><span style=display:flex><span>   3<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>(</span>integer<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#0000cf;font-weight:700>15907787</span>
</span></span><span style=display:flex><span>   4<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>(</span>integer<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#0000cf;font-weight:700>4</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic># 转移超过3600s的消息1553585533795-1到消费者B的Pending列表</span>
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; XCLAIM mq mqGroup consumerB <span style=color:#0000cf;font-weight:700>3600000</span> 1553585533795-1
</span></span><span style=display:flex><span>1<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;1553585533795-1&#34;</span>
</span></span><span style=display:flex><span>   2<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;msg&#34;</span>
</span></span><span style=display:flex><span>      2<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;2&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic># 消息1553585533795-1已经转移到消费者B的Pending中。</span>
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; XPENDING mq mqGroup - + <span style=color:#0000cf;font-weight:700>10</span>
</span></span><span style=display:flex><span>1<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;1553585533795-1&#34;</span>
</span></span><span style=display:flex><span>   2<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;consumerB&#34;</span>
</span></span><span style=display:flex><span>   3<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>(</span>integer<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#0000cf;font-weight:700>84404</span> <span style=color:#8f5902;font-style:italic># 注意IDLE，被重置了</span>
</span></span><span style=display:flex><span>   4<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>(</span>integer<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#0000cf;font-weight:700>5</span> <span style=color:#8f5902;font-style:italic># 注意，读取次数也累加了1次</span>
</span></span></code></pre></div><p>以上代码，完成了一次消息转移。转移除了要指定ID外，还需要指定IDLE，保证是长时间未处理的才被转移。被转移的消息的IDLE会被重置，用以保证不会被重复转移，以为可能会出现将过期的消息同时转移给多个消费者的并发操作，设置了IDLE，则可以避免后面的转移不会成功，因为IDLE不满足条件。例如下面的连续两条转移，第二条不会成功。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>127.0.0.1:6379&gt; XCLAIM mq mqGroup consumerB <span style=color:#0000cf;font-weight:700>3600000</span> 1553585533795-1
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; XCLAIM mq mqGroup consumerC <span style=color:#0000cf;font-weight:700>3600000</span> 1553585533795-1
</span></span></code></pre></div><p>这就是消息转移。至此我们使用了一个Pending消息的ID，所属消费者和IDLE的属性，还有一个属性就是消息被读取次数，delivery counter，该属性的作用由于统计消息被读取的次数，包括被转移也算。这个属性主要用在判定是否为错误数据上。</p><h3 id=坏消息问题dead-letter死信问题>坏消息问题，Dead Letter，死信问题</h3><p>正如上面所说，如果某个消息，不能被消费者处理，也就是不能被XACK，这是要长时间处于Pending列表中，即使被反复的转移给各个消费者也是如此。此时该消息的delivery counter就会累加（上一节的例子可以看到），当累加到某个我们预设的临界值时，我们就认为是坏消息（也叫死信，DeadLetter，无法投递的消息），由于有了判定条件，我们将坏消息处理掉即可，删除即可。删除一个消息，使用XDEL语法，演示如下：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#8f5902;font-style:italic># 删除队列中的消息</span>
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; XDEL mq 1553585533795-1
</span></span><span style=display:flex><span><span style=color:#ce5c00;font-weight:700>(</span>integer<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#0000cf;font-weight:700>1</span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic># 查看队列中再无此消息</span>
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; XRANGE mq - +
</span></span><span style=display:flex><span>1<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;1553585533795-0&#34;</span>
</span></span><span style=display:flex><span>   2<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;msg&#34;</span>
</span></span><span style=display:flex><span>      2<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;1&#34;</span>
</span></span><span style=display:flex><span>2<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;1553585533795-2&#34;</span>
</span></span><span style=display:flex><span>   2<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;msg&#34;</span>
</span></span><span style=display:flex><span>      2<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;3&#34;</span>
</span></span></code></pre></div><p>注意本例中，并没有删除Pending中的消息因此你查看Pending，消息还会在。可以执行XACK标识其处理完毕！</p></div><div class=td-content style=page-break-before:always><h1 id=pg-f39b5b7bdbb59acf255fb62ce2763d03>4 - CH04-对象机制</h1><h2 id=结构概览>结构概览</h2><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210504135719.png style=display:block;width:50% alt=NAME align=center></div><p>上图反映了Redis的每种对象其实都由<strong>对象结构(redisObject)</strong> 与 <strong>对应编码的数据结构</strong>组合而成，而每种对象类型对应若干编码方式，不同的编码方式所对应的底层数据结构是不同的。</p><p>所以，我们需要从几个个角度来着手底层研究：</p><ul><li><strong>对象设计机制</strong>: 对象结构(redisObject)</li><li><strong>编码类型和底层数据结构</strong>: 对应编码的数据结构</li></ul><h2 id=redisobject>RedisObject</h2><p>在redis的命令中，用于对键进行处理的命令占了很大一部分，而对于键所保存的值的类型，键能执行的命令又各不相同。如： <code>LPUSH</code> 和 <code>LLEN</code> 只能用于列表键, 而 <code>SADD</code> 和 <code>SRANDMEMBER</code> 只能用于集合键; 另外一些命令, 比如 <code>DEL</code>、 <code>TTL</code> 和 <code>TYPE</code>, 可以用于任何类型的键；但是要正确实现这些命令, 必须为不同类型的键设置不同的处理方式: 比如说, 删除一个列表键和删除一个字符串键的操作过程就不太一样。</p><p>以上的描述说明, <strong>Redis 必须让每个键都带有类型信息, 使得程序可以检查键的类型, 并为它选择合适的处理方式</strong>.</p><p>比如说， 集合类型就可以由字典和整数集合两种不同的数据结构实现， 但是， 当用户执行 ZADD 命令时，应该不必关心集合使用的是什么编码， 只要 Redis 能按照 ZADD 命令的指示， 将新元素添加到集合就可以了。</p><p>这说明, <strong>操作数据类型的命令除了要对键的类型进行检查之外, 还需要根据数据类型的不同编码进行多态处理</strong>.</p><p>为了解决以上问题, <strong>Redis 构建了自己的类型系统</strong>, 这个系统的主要功能包括:</p><ul><li>redisObject 对象.</li><li>基于 redisObject 对象的类型检查.</li><li>基于 redisObject 对象的显式多态函数.</li><li>对 redisObject 进行分配、共享和销毁的机制.</li></ul><h3 id=数据结构>数据结构</h3><p>redisObject 是 Redis 类型系统的核心, 数据库中的每个键、值, 以及 Redis 本身处理的参数, 都表示为这种数据类型。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#8f5902;font-style:italic>/*
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic> * Redis 对象
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic> */</span>
</span></span><span style=display:flex><span><span style=color:#204a87;font-weight:700>typedef</span> <span style=color:#204a87;font-weight:700>struct</span> <span style=color:#000>redisObject</span> <span style=color:#000;font-weight:700>{</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8f5902;font-style:italic>// 类型
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span>    <span style=color:#204a87;font-weight:700>unsigned</span> <span style=color:#f57900>type</span><span style=color:#000;font-weight:700>:</span><span style=color:#0000cf;font-weight:700>4</span><span style=color:#000;font-weight:700>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8f5902;font-style:italic>// 编码方式
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span>    <span style=color:#204a87;font-weight:700>unsigned</span> <span style=color:#f57900>encoding</span><span style=color:#000;font-weight:700>:</span><span style=color:#0000cf;font-weight:700>4</span><span style=color:#000;font-weight:700>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8f5902;font-style:italic>// LRU - 24位, 记录最末一次访问时间（相对于lru_clock）; 或者 LFU（最少使用的数据：8位频率，16位访问时间）
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span>    <span style=color:#204a87;font-weight:700>unsigned</span> <span style=color:#f57900>lru</span><span style=color:#000;font-weight:700>:</span><span style=color:#000>LRU_BITS</span><span style=color:#000;font-weight:700>;</span> <span style=color:#8f5902;font-style:italic>// LRU_BITS: 24
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span>
</span></span><span style=display:flex><span>    <span style=color:#8f5902;font-style:italic>// 引用计数
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span>    <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>refcount</span><span style=color:#000;font-weight:700>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8f5902;font-style:italic>// 指向底层数据结构实例
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span>    <span style=color:#204a87;font-weight:700>void</span> <span style=color:#ce5c00;font-weight:700>*</span><span style=color:#000>ptr</span><span style=color:#000;font-weight:700>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>}</span> <span style=color:#000>robj</span><span style=color:#000;font-weight:700>;</span>
</span></span></code></pre></div><p>下图对应上面的结构：</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210504140122.png style=display:block;width:50% alt=NAME align=center></div><p><strong>其中type、encoding和ptr是最重要的三个属性</strong>。</p><ul><li><strong>type记录了对象所保存的值的类型</strong>，它的值可能是以下常量中的一个：</li></ul><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#8f5902;font-style:italic>/*
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>* 对象类型
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>*/</span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>#define OBJ_STRING 0 </span><span style=color:#8f5902;font-style:italic>// 字符串
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span><span style=color:#8f5902;font-style:italic>#define OBJ_LIST 1 </span><span style=color:#8f5902;font-style:italic>// 列表
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span><span style=color:#8f5902;font-style:italic>#define OBJ_SET 2 </span><span style=color:#8f5902;font-style:italic>// 集合
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span><span style=color:#8f5902;font-style:italic>#define OBJ_ZSET 3 </span><span style=color:#8f5902;font-style:italic>// 有序集
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span><span style=color:#8f5902;font-style:italic>#define OBJ_HASH 4 </span><span style=color:#8f5902;font-style:italic>// 哈希表
</span></span></span></code></pre></div><ul><li><strong>encoding记录了对象所保存的值的编码</strong>，它的值可能是以下常量中的一个：</li></ul><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#8f5902;font-style:italic>/*
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>* 对象编码
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>*/</span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>#define OBJ_ENCODING_RAW 0     </span><span style=color:#8f5902;font-style:italic>/* Raw representation */</span><span style=color:#8f5902;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>#define OBJ_ENCODING_INT 1     </span><span style=color:#8f5902;font-style:italic>/* Encoded as integer */</span><span style=color:#8f5902;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>#define OBJ_ENCODING_HT 2      </span><span style=color:#8f5902;font-style:italic>/* Encoded as hash table */</span><span style=color:#8f5902;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>#define OBJ_ENCODING_ZIPMAP 3  </span><span style=color:#8f5902;font-style:italic>/* 注意：版本2.6后不再使用. */</span><span style=color:#8f5902;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>#define OBJ_ENCODING_LINKEDLIST 4 </span><span style=color:#8f5902;font-style:italic>/* 注意：不再使用了，旧版本2.x中String的底层之一. */</span><span style=color:#8f5902;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>#define OBJ_ENCODING_ZIPLIST 5 </span><span style=color:#8f5902;font-style:italic>/* Encoded as ziplist */</span><span style=color:#8f5902;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>#define OBJ_ENCODING_INTSET 6  </span><span style=color:#8f5902;font-style:italic>/* Encoded as intset */</span><span style=color:#8f5902;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>#define OBJ_ENCODING_SKIPLIST 7  </span><span style=color:#8f5902;font-style:italic>/* Encoded as skiplist */</span><span style=color:#8f5902;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>#define OBJ_ENCODING_EMBSTR 8  </span><span style=color:#8f5902;font-style:italic>/* Embedded sds string encoding */</span><span style=color:#8f5902;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>#define OBJ_ENCODING_QUICKLIST 9 </span><span style=color:#8f5902;font-style:italic>/* Encoded as linked list of ziplists */</span><span style=color:#8f5902;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>#define OBJ_ENCODING_STREAM 10 </span><span style=color:#8f5902;font-style:italic>/* Encoded as a radix tree of listpacks */</span><span style=color:#8f5902;font-style:italic>
</span></span></span></code></pre></div><ul><li><p><strong>ptr是一个指针，指向实际保存值的数据结构</strong>，这个数据结构由type和encoding属性决定。举个例子， 如果一个redisObject 的type 属性为<code>OBJ_LIST</code> ， encoding 属性为<code>OBJ_ENCODING_QUICKLIST</code> ，那么这个对象就是一个Redis 列表（List)，它的值保存在一个QuickList的数据结构内，而ptr 指针就指向quicklist的对象；</p></li><li><p><strong>lru属性: 记录了对象最后一次被命令程序访问的时间</strong></p></li></ul><p><strong>空转时长</strong>：当前时间减去键的值对象的lru时间，就是该键的空转时长。Object idletime命令可以打印出给定键的空转时长</p><p>如果服务器打开了maxmemory选项，并且服务器用于回收内存的算法为volatile-lru或者allkeys-lru，那么当服务器占用的内存数超过了maxmemory选项所设置的上限值时，空转时长较高的那部分键会优先被服务器释放，从而回收内存。</p><h2 id=命令的类型检查与多态>命令的类型检查与多态</h2><p><strong>当执行一个处理数据类型命令的时候，redis执行以下步骤</strong></p><ul><li>根据给定的key，在数据库字典中查找和他相对应的redisObject，如果没找到，就返回NULL；</li><li>检查redisObject的type属性和执行命令所需的类型是否相符，如果不相符，返回类型错误；</li><li>根据redisObject的encoding属性所指定的编码，选择合适的操作函数来处理底层的数据结构；</li><li>返回数据结构的操作结果作为命令的返回值。</li></ul><p>比如现在执行LPOP命令：</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210504140457.png style=display:block;width:50% alt=NAME align=center></div><h2 id=对象共享>对象共享</h2><blockquote><p>redis一般会把一些常见的值放到一个共享对象中，这样可使程序避免了重复分配的麻烦，也节约了一些CPU时间。</p></blockquote><p><strong>redis预分配的值对象如下</strong>：</p><ul><li>各种命令的返回值，比如成功时返回的OK，错误时返回的ERROR，命令入队事务时返回的QUEUE，等等</li><li>包括0 在内，小于REDIS_SHARED_INTEGERS的所有整数（REDIS_SHARED_INTEGERS的默认值是10000）</li></ul><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210504140534.png style=display:block;width:50% alt=NAME align=center></div><blockquote><p>注意：共享对象只能被字典和双向链表这类能带有指针的数据结构使用。像整数集合和压缩列表这些只能保存字符串、整数等字面值的内存数据结构。</p></blockquote><p><strong>为什么redis不共享列表对象、哈希对象、集合对象、有序集合对象，只共享字符串对象</strong>？</p><ul><li>列表对象、哈希对象、集合对象、有序集合对象，本身可以包含字符串对象，复杂度较高。</li><li>如果共享对象是保存字符串对象，那么验证操作的复杂度为O(1)</li><li>如果共享对象是保存字符串值的字符串对象，那么验证操作的复杂度为O(N)</li><li>如果共享对象是包含多个值的对象，其中值本身又是字符串对象，即其它对象中嵌套了字符串对象，比如列表对象、哈希对象，那么验证操作的复杂度将会是O(N的平方)</li></ul><p>如果对复杂度较高的对象创建共享对象，需要消耗很大的CPU，用这种消耗去换取内存空间，是不合适的。</p><h2 id=引用计数以及对象的消毁>引用计数以及对象的消毁</h2><blockquote><p>redisObject中有refcount属性，是对象的引用计数，显然计数0那么就是可以回收。</p></blockquote><ul><li>每个redisObject结构都带有一个refcount属性，指示这个对象被引用了多少次；</li><li>当新创建一个对象时，它的refcount属性被设置为1；</li><li>当对一个对象进行共享时，redis将这个对象的refcount加一；</li><li>当使用完一个对象后，或者消除对一个对象的引用之后，程序将对象的refcount减一；</li><li>当对象的refcount降至0 时，这个RedisObject结构，以及它引用的数据结构的内存都会被释放。</li></ul><h2 id=总结>总结</h2><ul><li><p>redis使用自己实现的对象机制（redisObject)来实现类型判断、命令多态和基于引用次数的垃圾回收；</p></li><li><p>redis会预分配一些常用的数据对象，并通过共享这些对象来减少内存占用，和避免频繁的为小对象分配内存。</p></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-d6ad1d4083c795b0ad006b6fb71ea3c7>5 - CH05-底层结构</h1><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210504140959.png style=display:block;width:50% alt=NAME align=center></div><h2 id=简单动态字符串sds>简单动态字符串：SDS</h2><blockquote><p>Redis 是用 C 语言写的，但是对于Redis的字符串，却不是 C 语言中的字符串（即以空字符’\0’结尾的字符数组），它是自己构建了一种名为 <strong>简单动态字符串（simple dynamic string,SDS</strong>）的抽象类型，并将 SDS 作为 Redis的默认字符串表示。</p></blockquote><h3 id=定义>定义</h3><blockquote><p>这是一种用于存储二进制数据的一种结构, 具有动态扩容的特点. 其实现位于src/sds.h与src/sds.c中。</p></blockquote><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210504141111.png style=display:block;width:50% alt=NAME align=center></div><p>其中<code>sdshdr</code>是头部, <code>buf</code>是真实存储用户数据的地方. 另外注意, 从命名上能看出来, 这个数据结构除了能存储二进制数据, 显然是用于设计作为字符串使用的, 所以在buf中, 用户数据后总跟着一个\0. 即图中 <code>"数据" + "\0"</code>是为所谓的buf。</p><p>SDS有五种不同的头部. 其中sdshdr5实际并未使用到. 所以实际上有四种不同的头部, 分别如下:</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210504145202.png style=display:block;width:50% alt=NAME align=center></div><p>其中：</p><ul><li><code>len</code> 保存了SDS保存字符串的长度</li><li><code>buf[]</code> 数组用来保存字符串的每个元素</li><li><code>alloc</code>分别以uint8, uint16, uint32, uint64表示整个SDS, 除过头部与末尾的\0, 剩余的字节数.</li><li><code>flags</code> 始终为一字节, 以低三位标示着头部的类型, 高5位未使用.</li></ul><h3 id=为什么使用sds>为什么使用SDS</h3><blockquote><p><strong>为什么不使用C语言字符串实现，而是使用 SDS呢</strong>？这样实现有什么好处？</p></blockquote><ul><li><p><strong>常数复杂度获取字符串长度</strong></p><p>由于 len 属性的存在，我们获取 SDS 字符串的长度只需要读取 len 属性，时间复杂度为 O(1)。而对于 C 语言，获取字符串的长度通常是经过遍历计数来实现的，时间复杂度为 O(n)。通过 <code>strlen key</code> 命令可以获取 key 的字符串长度。</p></li><li><p><strong>杜绝缓冲区溢出</strong></p><p>我们知道在 C 语言中使用 <code>strcat</code> 函数来进行两个字符串的拼接，一旦没有分配足够长度的内存空间，就会造成缓冲区溢出。而对于 SDS 数据类型，在进行字符修改的时候，<strong>会首先根据记录的 len 属性检查内存空间是否满足需求</strong>，如果不满足，会进行相应的空间扩展，然后在进行修改操作，所以不会出现缓冲区溢出。</p></li><li><p><strong>减少修改字符串的内存重新分配次数</strong></p><p>C语言由于不记录字符串的长度，所以如果要修改字符串，必须要重新分配内存（先释放再申请），因为如果没有重新分配，字符串长度增大时会造成内存缓冲区溢出，字符串长度减小时会造成内存泄露。</p><p>而对于SDS，由于<code>len</code>属性和<code>alloc</code>属性的存在，对于修改字符串SDS实现了<strong>空间预分配</strong>和<strong>惰性空间释放</strong>两种策略：</p><ul><li><p><code>空间预分配</code>：对字符串进行空间扩展的时候，扩展的内存比实际需要的多，这样可以减少连续执行字符串增长操作所需的内存重分配次数。</p></li><li><p><code>惰性空间释放</code>：对字符串进行缩短操作时，程序不立即使用内存重新分配来回收缩短后多余的字节，而是使用 <code>alloc</code> 属性将这些字节的数量记录下来，等待后续使用。（当然SDS也提供了相应的API，当我们有需要时，也可以手动释放这些未使用的空间。）</p></li></ul></li><li><p><strong>二进制安全</strong></p><p>因为C字符串以空字符作为字符串结束的标识，而对于一些二进制文件（如图片等），内容可能包括空字符串，因此C字符串无法正确存取；而所有 SDS 的API 都是以处理二进制的方式来处理 <code>buf</code> 里面的元素，并且 SDS 不是以空字符串来判断是否结束，而是以 len 属性表示的长度来判断字符串是否结束。</p></li><li><p><strong>兼容部分 C 字符串函数</strong></p></li></ul><p>虽然 SDS 是二进制安全的，但是一样遵从每个字符串都是以空字符串结尾的惯例，这样可以重用 C 语言库<code>&lt;string.h></code> 中的一部分函数。</p><h3 id=空间预分配补进一步理解>空间预分配补进一步理解</h3><p>当执行追加操作时，比如现在给<code>key=‘Hello World’</code>的字符串后追加<code>‘ again!’</code>则这时的len=18，free由0变成了18，此时的<code>buf='Hello World again!\0....................'</code>(.表示空格)，也就是buf的内存空间是18+18+1=37个字节，其中‘\0’占1个字节redis给字符串多分配了18个字节的预分配空间，所以下次还有append追加的时候，如果预分配空间足够，就无须在进行空间分配了。在当前版本中，当新字符串的长度小于1M时，redis会分配他们所需大小一倍的空间，当大于1M的时候，就为他们额外多分配1M的空间。</p><p>思考：<strong>这种分配策略会浪费内存资源吗</strong>？</p><p>答：执行过APPEND 命令的字符串会带有额外的预分配空间，这些预分配空间不会被释放，除非该字符串所对应的键被删除，或者等到关闭Redis 之后，再次启动时重新载入的字符串对象将不会有预分配空间。因为执行APPEND 命令的字符串键数量通常并不多，占用内存的体积通常也不大，所以这一般并不算什么问题。另一方面，如果执行APPEND 操作的键很多，而字符串的体积又很大的话，那可能就需要修改Redis 服务器，让它定时释放一些字符串键的预分配空间，从而更有效地使用内存。</p><h3 id=小结>小结</h3><p>redis的字符串表示为sds，而不是C字符串（以\0结尾的char*）， 它是Redis 底层所使用的字符串表示，它被用在几乎所有的Redis 模块中。可以看如下对比：</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210504145607.png style=display:block;width:50% alt=NAME align=center></div><p>一般来说，SDS 除了保存数据库中的字符串值以外，SDS 还可以作为缓冲区（buffer）：包括 AOF 模块中的AOF缓冲区以及客户端状态中的输入缓冲区</p><h2 id=压缩列表ziplist>压缩列表：ZipList</h2><blockquote><p>ziplist是为了提高存储效率而设计的一种特殊编码的双向链表。它可以存储字符串或者整数，存储整数时是采用整数的二进制而不是字符串形式存储。他能在O(1)的时间复杂度下完成list两端的push和pop操作。但是因为每次操作都需要重新分配ziplist的内存，所以实际复杂度和ziplist的内存使用量相关。</p></blockquote><h3 id=ziplist-结构>ZipList 结构</h3><p>整个ziplist在内存中的存储格式如下：</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210504145727.png style=display:block;width:50% alt=NAME align=center></div><ul><li><p><code>zlbytes</code>字段的类型是uint32_t, 这个字段中存储的是整个ziplist所占用的内存的字节数</p></li><li><p><code>zltail</code>字段的类型是uint32_t, 它指的是ziplist中最后一个entry的偏移量. 用于快速定位最后一个entry, 以快速完成pop等操作</p></li><li><p><code>zllen</code>字段的类型是uint16_t, 它指的是整个ziplit中entry的数量. 这个值只占2bytes（16位）: 如果ziplist中entry的数目小于65535(2的16次方), 那么该字段中存储的就是实际entry的值. 若等于或超过65535, 那么该字段的值固定为65535, 但实际数量需要一个个entry的去遍历所有entry才能得到.</p></li><li><p><code>zlend</code>是一个终止字节, 其值为全F, 即0xff. ziplist保证任何情况下, 一个entry的首字节都不会是255</p></li></ul><h3 id=entry-结构>Entry 结构</h3><p><strong>第一种情况</strong>：一般结构 <code>&lt;prevlen> &lt;encoding> &lt;entry-data></code></p><p><code>prevlen</code>：前一个entry的大小，编码方式见下文；</p><p><code>encoding</code>：不同的情况下值不同，用于表示当前entry的类型和长度；</p><p><code>entry-data</code>：真是用于存储entry表示的数据；</p><p><strong>第二种情况</strong>：在entry中存储的是int类型时，encoding和entry-data会合并在encoding中表示，此时没有entry-data字段；</p><p>redis中，在存储数据时，会先尝试将string转换成int存储，节省空间；</p><p>此时entry结构：<code>&lt;prevlen> &lt;encoding></code></p><ul><li><strong>prevlen编码</strong></li></ul><p>当前一个元素长度小于254（255用于zlend）的时候，prevlen长度为1个字节，值即为前一个entry的长度，如果长度大于等于254的时候，prevlen用5个字节表示，第一字节设置为254，后面4个字节存储一个小端的无符号整型，表示前一个entry的长度；</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>&lt;prevlen from <span style=color:#0000cf;font-weight:700>0</span> to 253&gt; &lt;encoding&gt; &lt;entry&gt;      //长度小于254结构
</span></span><span style=display:flex><span>0xFE &lt;<span style=color:#0000cf;font-weight:700>4</span> bytes unsigned little endian prevlen&gt; &lt;encoding&gt; &lt;entry&gt;   //长度大于等于254
</span></span></code></pre></div><ul><li><strong>encoding编码</strong></li></ul><p>encoding的长度和值根据保存的是int还是string，还有数据的长度而定；</p><p>前两位用来表示类型，当为“11”时，表示entry存储的是int类型，其他表示存储的是string；</p><p><strong>存储string时</strong>：</p><p><code>|00pppppp|</code> ：此时encoding长度为1个字节，该字节的后六位表示entry中存储的string长度，因为是6位，所以entry中存储的string长度不能超过63；</p><p><code>|01pppppp|qqqqqqqq|</code> 此时encoding长度为两个字节；此时encoding的后14位用来存储string长度，长度不能超过16383；</p><p><code>|10000000|qqqqqqqq|rrrrrrrr|ssssssss|ttttttt|</code> 此时encoding长度为5个字节，后面的4个字节用来表示encoding中存储的字符串长度，长度不能超过2^32 - 1;</p><p><strong>存储int时</strong>：</p><p><code>|11000000|</code> encoding为3个字节，后2个字节表示一个int16；</p><p><code>|11010000|</code> encoding为5个字节，后4个字节表示一个int32;</p><p><code>|11100000|</code> encoding 为9个字节，后8字节表示一个int64;</p><p><code>|11110000|</code> encoding为4个字节，后3个字节表示一个有符号整型；</p><p><code>|11111110|</code> encoding为2字节，后1个字节表示一个有符号整型；</p><p><code>|1111xxxx|</code> encoding长度就只有1个字节，xxxx表示一个0 - 12的整数值；</p><p><code>|11111111|</code> 还记得zlend么？</p><ul><li><strong>源码中数据结构支撑</strong></li></ul><p>你可以看到为了操作上的简易实际还增加了几个属性</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#8f5902;font-style:italic>/* We use this function to receive information about a ziplist entry.
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic> * Note that this is not how the data is actually encoded, is just what we
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic> * get filled by a function in order to operate more easily. */</span>
</span></span><span style=display:flex><span><span style=color:#204a87;font-weight:700>typedef</span> <span style=color:#204a87;font-weight:700>struct</span> <span style=color:#000>zlentry</span> <span style=color:#000;font-weight:700>{</span>
</span></span><span style=display:flex><span>    <span style=color:#204a87;font-weight:700>unsigned</span> <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>prevrawlensize</span><span style=color:#000;font-weight:700>;</span> <span style=color:#8f5902;font-style:italic>/* Bytes used to encode the previous entry len*/</span>
</span></span><span style=display:flex><span>    <span style=color:#204a87;font-weight:700>unsigned</span> <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>prevrawlen</span><span style=color:#000;font-weight:700>;</span>     <span style=color:#8f5902;font-style:italic>/* Previous entry len. */</span>
</span></span><span style=display:flex><span>    <span style=color:#204a87;font-weight:700>unsigned</span> <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>lensize</span><span style=color:#000;font-weight:700>;</span>        <span style=color:#8f5902;font-style:italic>/* Bytes used to encode this entry type/len.
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>                                    For example strings have a 1, 2 or 5 bytes
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>                                    header. Integers always use a single byte.*/</span>
</span></span><span style=display:flex><span>    <span style=color:#204a87;font-weight:700>unsigned</span> <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>len</span><span style=color:#000;font-weight:700>;</span>            <span style=color:#8f5902;font-style:italic>/* Bytes used to represent the actual entry.
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>                                    For strings this is just the string length
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>                                    while for integers it is 1, 2, 3, 4, 8 or
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>                                    0 (for 4 bit immediate) depending on the
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>                                    number range. */</span>
</span></span><span style=display:flex><span>    <span style=color:#204a87;font-weight:700>unsigned</span> <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>headersize</span><span style=color:#000;font-weight:700>;</span>     <span style=color:#8f5902;font-style:italic>/* prevrawlensize + lensize. */</span>
</span></span><span style=display:flex><span>    <span style=color:#204a87;font-weight:700>unsigned</span> <span style=color:#204a87;font-weight:700>char</span> <span style=color:#000>encoding</span><span style=color:#000;font-weight:700>;</span>      <span style=color:#8f5902;font-style:italic>/* Set to ZIP_STR_* or ZIP_INT_* depending on
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>                                    the entry encoding. However for 4 bits
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>                                    immediate integers this can assume a range
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>                                    of values and must be range-checked. */</span>
</span></span><span style=display:flex><span>    <span style=color:#204a87;font-weight:700>unsigned</span> <span style=color:#204a87;font-weight:700>char</span> <span style=color:#ce5c00;font-weight:700>*</span><span style=color:#000>p</span><span style=color:#000;font-weight:700>;</span>            <span style=color:#8f5902;font-style:italic>/* Pointer to the very start of the entry, that
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>                                    is, this points to prev-entry-len field. */</span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>}</span> <span style=color:#000>zlentry</span><span style=color:#000;font-weight:700>;</span>
</span></span></code></pre></div><ul><li><code>prevrawlensize</code>表示 previous_entry_length字段的长度</li><li><code>prevrawlen</code>表示 previous_entry_length字段存储的内容</li><li><code>lensize</code>表示 encoding字段的长度</li><li><code>len</code>表示数据内容长度</li><li><code>headersize</code> 表示当前元素的首部长度，即previous_entry_length字段长度与encoding字段长度之和</li><li><code>encoding</code>表示数据类型</li><li><code>p</code>表示当前元素首地址</li></ul><h3 id=为什么ziplist特别省内存>为什么ZipList特别省内存</h3><ul><li>ziplist节省内存是相对于普通的list来说的，如果是普通的数组，那么它每个元素占用的内存是一样的且取决于最大的那个元素（很明显它是需要预留空间的）；</li><li>所以ziplist在设计时就很容易想到要尽量让每个元素按照实际的内容大小存储，<strong>所以增加encoding字段</strong>，针对不同的encoding来细化存储大小；</li><li>这时候还需要解决的一个问题是遍历元素时如何定位下一个元素呢？在普通数组中每个元素定长，所以不需要考虑这个问题；但是ziplist中每个data占据的内存不一样，所以为了解决遍历，需要增加记录上一个元素的length，<strong>所以增加了prelen字段</strong>。</li></ul><p><strong>为什么我们去研究ziplist特别节省内存的数据结构</strong>？ 在实际应用中，大量存储字符串的优化是需要你对底层的数据结构有一定的理解的，而ziplist在场景优化的时候也被考虑采用的首选。</p><h3 id=缺点>缺点</h3><ul><li>ziplist也不预留内存空间, 并且在移除结点后, 也是立即缩容, 这代表每次写操作都会进行内存分配操作.</li><li>结点如果扩容, 导致结点占用的内存增长, 并且超过254字节的话, 可能会导致链式反应: 其后一个结点的entry.prevlen需要从一字节扩容至五字节.<ul><li><strong>最坏情况下, 第一个结点的扩容, 会导致整个ziplist表中的后续所有结点的entry.prevlen字段扩容</strong>.</li><li>虽然这个内存重分配的操作依然只会发生一次, 但代码中的时间复杂度是o(N)级别, 因为链式扩容只能一步一步的计算.</li><li>但这种情况的概率十分的小, 一般情况下链式扩容能连锁反映五六次就很不幸了.</li><li>这样的坏场景下, 其实时间复杂度并不高: 依次计算每个entry新的空间占用, 也就是o(N), 总体占用计算出来后, 只执行一次内存重分配, 与对应的memmove操作, 就可以了.</li></ul></li></ul><h2 id=快表quicklist>快表：QuickList</h2><blockquote><p>quicklist这个结构是Redis在3.2版本后新加的, 之前的版本是list(即linkedlist)， 用于String数据类型中。</p></blockquote><p>它是一种以ziplist为结点的双端链表结构. 宏观上, quicklist是一个链表, 微观上, 链表中的每个结点都是一个ziplist。</p><h3 id=quicklist-结构>QuickList 结构</h3><p>内部定义了6个结构体:</p><ul><li><code>quicklistNode</code>, 宏观上, quicklist是一个链表, 这个结构描述的就是链表中的结点. 它通过zl字段持有底层的ziplist. 简单来讲, 它描述了一个ziplist实例</li><li><code>quicklistLZF</code>, ziplist是一段连续的内存, 用LZ4算法压缩后, 就可以包装成一个quicklistLZF结构. 是否压缩quicklist中的每个ziplist实例是一个可配置项. 若这个配置项是开启的, 那么quicklistNode.zl字段指向的就不是一个ziplist实例, 而是一个压缩后的quicklistLZF实例</li><li><code>quicklistBookmark</code>, 在quicklist尾部增加的一个书签，它只有在大量节点的多余内存使用量可以忽略不计的情况且确实需要分批迭代它们，才会被使用。当不使用它们时，它们不会增加任何内存开销。</li><li><code>quicklist</code>. 这就是一个双链表的定义. head, tail分别指向头尾指针. len代表链表中的结点. count指的是整个quicklist中的所有ziplist中的entry的数目. fill字段影响着每个链表结点中ziplist的最大占用空间, compress影响着是否要对每个ziplist以LZ4算法进行进一步压缩以更节省内存空间.</li><li><code>quicklistIter</code>是一个迭代器</li><li><code>quicklistEntry</code>是对ziplist中的entry概念的封装. quicklist作为一个封装良好的数据结构, 不希望使用者感知到其内部的实现, 所以需要把ziplist.entry的概念重新包装一下.</li></ul><h3 id=内存布局图>内存布局图</h3><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210504150301.png style=display:block;width:50% alt=NAME align=center></div><h3 id=更多信息>更多信息</h3><p>下面是有关quicklist的更多额外信息:</p><ul><li><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>quicklist.fill
</span></span></code></pre></div><p>的值影响着每个链表结点中, ziplist的长度.</p><ol><li>当数值为负数时, 代表以字节数限制单个ziplist的最大长度. 具体为:</li><li>-1 不超过4kb</li><li>-2 不超过 8kb</li><li>-3 不超过 16kb</li><li>-4 不超过 32kb</li><li>-5 不超过 64kb</li><li>当数值为正数时, 代表以entry数目限制单个ziplist的长度. 值即为数目. 由于该字段仅占16位, 所以以entry数目限制ziplist的容量时, 最大值为2^15个</li></ol></li><li><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>quicklist.compress
</span></span></code></pre></div><p>的值影响着quicklistNode.zl字段指向的是原生的ziplist, 还是经过压缩包装后的quicklistLZF</p><ol><li>0 表示不压缩, zl字段直接指向ziplist</li><li>1 表示quicklist的链表头尾结点不压缩, 其余结点的zl字段指向的是经过压缩后的quicklistLZF</li><li>2 表示quicklist的链表头两个, 与末两个结点不压缩, 其余结点的zl字段指向的是经过压缩后的quicklistLZF</li><li>以此类推, 最大值为2^16</li></ol></li><li><p><code>quicklistNode.encoding</code>字段, 以指示本链表结点所持有的ziplist是否经过了压缩. 1代表未压缩, 持有的是原生的ziplist, 2代表压缩过</p></li><li><p><code>quicklistNode.container</code>字段指示的是每个链表结点所持有的数据类型是什么. 默认的实现是ziplist, 对应的该字段的值是2, 目前Redis没有提供其它实现. 所以实际上, 该字段的值恒为2</p></li><li><p><code>quicklistNode.recompress</code>字段指示的是当前结点所持有的ziplist是否经过了解压. 如果该字段为1即代表之前被解压过, 且需要在下一次操作时重新压缩.</p></li></ul><p>quicklist的具体实现代码篇幅很长, 这里就不贴代码片断了, 从内存布局上也能看出来, 由于每个结点持有的ziplist是有上限长度的, 所以在与操作时要考虑的分支情况比较多。</p><p>quicklist有自己的优点, 也有缺点, 对于使用者来说, 其使用体验类似于线性数据结构, list作为最传统的双链表, 结点通过指针持有数据, 指针字段会耗费大量内存. ziplist解决了耗费内存这个问题. 但引入了新的问题: 每次写操作整个ziplist的内存都需要重分配. quicklist在两者之间做了一个平衡. 并且使用者可以通过自定义<code>quicklist.fill</code>, 根据实际业务情况, 经验主义调参.</p><h2 id=字典dict>字典：Dict</h2><h3 id=数据结构>数据结构</h3><p><strong>哈希表结构定义</strong>：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#204a87;font-weight:700>typedef</span> <span style=color:#204a87;font-weight:700>struct</span> <span style=color:#000>dictht</span><span style=color:#000;font-weight:700>{</span>
</span></span><span style=display:flex><span>    <span style=color:#8f5902;font-style:italic>//哈希表数组
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span>    <span style=color:#000>dictEntry</span> <span style=color:#ce5c00;font-weight:700>**</span><span style=color:#000>table</span><span style=color:#000;font-weight:700>;</span>
</span></span><span style=display:flex><span>    <span style=color:#8f5902;font-style:italic>//哈希表大小
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span>    <span style=color:#204a87;font-weight:700>unsigned</span> <span style=color:#204a87;font-weight:700>long</span> <span style=color:#000>size</span><span style=color:#000;font-weight:700>;</span>
</span></span><span style=display:flex><span>    <span style=color:#8f5902;font-style:italic>//哈希表大小掩码，用于计算索引值
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span>    <span style=color:#8f5902;font-style:italic>//总是等于 size-1
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span>    <span style=color:#204a87;font-weight:700>unsigned</span> <span style=color:#204a87;font-weight:700>long</span> <span style=color:#000>sizemask</span><span style=color:#000;font-weight:700>;</span>
</span></span><span style=display:flex><span>    <span style=color:#8f5902;font-style:italic>//该哈希表已有节点的数量
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span>    <span style=color:#204a87;font-weight:700>unsigned</span> <span style=color:#204a87;font-weight:700>long</span> <span style=color:#000>used</span><span style=color:#000;font-weight:700>;</span>
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>}</span><span style=color:#000>dictht</span>
</span></span></code></pre></div><p>哈希表是由数组 table 组成，table 中每个元素都是指向 dict.h/dictEntry 结构，dictEntry 结构定义如下：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#204a87;font-weight:700>typedef</span> <span style=color:#204a87;font-weight:700>struct</span> <span style=color:#000>dictEntry</span><span style=color:#000;font-weight:700>{</span>
</span></span><span style=display:flex><span>     <span style=color:#8f5902;font-style:italic>//键
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span>     <span style=color:#204a87;font-weight:700>void</span> <span style=color:#ce5c00;font-weight:700>*</span><span style=color:#000>key</span><span style=color:#000;font-weight:700>;</span>
</span></span><span style=display:flex><span>     <span style=color:#8f5902;font-style:italic>//值
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span>     <span style=color:#204a87;font-weight:700>union</span><span style=color:#000;font-weight:700>{</span>
</span></span><span style=display:flex><span>          <span style=color:#204a87;font-weight:700>void</span> <span style=color:#ce5c00;font-weight:700>*</span><span style=color:#000>val</span><span style=color:#000;font-weight:700>;</span>
</span></span><span style=display:flex><span>          <span style=color:#000>uint64_tu64</span><span style=color:#000;font-weight:700>;</span>
</span></span><span style=display:flex><span>          <span style=color:#000>int64_ts64</span><span style=color:#000;font-weight:700>;</span>
</span></span><span style=display:flex><span>     <span style=color:#000;font-weight:700>}</span><span style=color:#000>v</span><span style=color:#000;font-weight:700>;</span>
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>     <span style=color:#8f5902;font-style:italic>//指向下一个哈希表节点，形成链表
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span>     <span style=color:#204a87;font-weight:700>struct</span> <span style=color:#000>dictEntry</span> <span style=color:#ce5c00;font-weight:700>*</span><span style=color:#000>next</span><span style=color:#000;font-weight:700>;</span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>}</span><span style=color:#000>dictEntry</span>
</span></span></code></pre></div><p>key 用来保存键，val 属性用来保存值，值可以是一个指针，也可以是uint64_t整数，也可以是int64_t整数。</p><p>注意这里还有一个指向下一个哈希表节点的指针，我们知道哈希表最大的问题是存在哈希冲突，如何解决哈希冲突，有开放地址法和链地址法。这里采用的便是链地址法，通过next这个指针可以将多个哈希值相同的键值对连接在一起，用来<strong>解决哈希冲突</strong>。</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210504150508.png style=display:block;width:50% alt=NAME align=center></div><h3 id=要点理解>要点理解</h3><ul><li><strong>哈希算法</strong>：Redis计算哈希值和索引值方法如下：</li></ul><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#8f5902;font-style:italic>#1、使用字典设置的哈希函数，计算键 key 的哈希值</span>
</span></span><span style=display:flex><span><span style=color:#204a87>hash</span> <span style=color:#ce5c00;font-weight:700>=</span> dict-&gt;type-&gt;hashFunction<span style=color:#ce5c00;font-weight:700>(</span>key<span style=color:#ce5c00;font-weight:700>)</span><span style=color:#000;font-weight:700>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>#2、使用哈希表的sizemask属性和第一步得到的哈希值，计算索引值</span>
</span></span><span style=display:flex><span><span style=color:#000>index</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87>hash</span> <span style=color:#000;font-weight:700>&amp;</span> dict-&gt;ht<span style=color:#ce5c00;font-weight:700>[</span>x<span style=color:#ce5c00;font-weight:700>]</span>.sizemask<span style=color:#000;font-weight:700>;</span>
</span></span></code></pre></div><ul><li><p><strong>解决哈希冲突</strong>：这个问题上面我们介绍了，方法是链地址法。通过字典里面的 *next 指针指向下一个具有相同索引值的哈希表节点。</p></li><li><p><strong>扩容和收缩</strong>：当哈希表保存的键值对太多或者太少时，就要通过 rerehash(重新散列）来对哈希表进行相应的扩展或者收缩。具体步骤：</p><ul><li><p>1、如果执行扩展操作，会基于原哈希表创建一个大小等于 <code>ht[0].used*2n</code> 的哈希表（也就是每次扩展都是根据原哈希表已使用的空间扩大一倍创建另一个哈希表）。相反如果执行的是收缩操作，每次收缩是根据已使用空间缩小一倍创建一个新的哈希表。</p></li><li><p>2、重新利用上面的哈希算法，计算索引值，然后将键值对放到新的哈希表位置上。</p></li><li><p>3、所有键值对都迁徙完毕后，释放原哈希表的内存空间。</p></li></ul></li><li><p><strong>触发扩容的条件</strong>：</p><ul><li><p>1、服务器目前没有执行 BGSAVE 命令或者 BGREWRITEAOF 命令，并且负载因子大于等于1。</p></li><li><p>2、服务器目前正在执行 BGSAVE 命令或者 BGREWRITEAOF 命令，并且负载因子大于等于5。</p></li><li><p>ps：负载因子 = 哈希表已保存节点数量 / 哈希表大小。</p></li></ul></li><li><p><strong>渐近式 rehash</strong></p><ul><li>什么叫渐进式 rehash？也就是说扩容和收缩操作不是一次性、集中式完成的，而是分多次、渐进式完成的。如果保存在Redis中的键值对只有几个几十个，那么 rehash 操作可以瞬间完成，但是如果键值对有几百万，几千万甚至几亿，那么要一次性的进行 rehash，势必会造成Redis一段时间内不能进行别的操作。所以Redis采用渐进式 rehash,这样在进行渐进式rehash期间，字典的删除查找更新等操作可能会在两个哈希表上进行，第一个哈希表没有找到，就会去第二个哈希表上进行查找。但是进行 增加操作，一定是在新的哈希表上进行的。</li></ul></li></ul><h2 id=整数集intset>整数集：IntSet</h2><blockquote><p>整数集合（intset）是集合类型的底层实现之一，当一个集合只包含整数值元素，并且这个集合的元素数量不多时，Redis 就会使用整数集合作为集合键的底层实现。</p></blockquote><h3 id=结构>结构</h3><p>首先看源码结构</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#204a87;font-weight:700>typedef</span> <span style=color:#204a87;font-weight:700>struct</span> <span style=color:#000>intset</span> <span style=color:#000;font-weight:700>{</span>
</span></span><span style=display:flex><span>    <span style=color:#204a87;font-weight:700>uint32_t</span> <span style=color:#000>encoding</span><span style=color:#000;font-weight:700>;</span>
</span></span><span style=display:flex><span>    <span style=color:#204a87;font-weight:700>uint32_t</span> <span style=color:#000>length</span><span style=color:#000;font-weight:700>;</span>
</span></span><span style=display:flex><span>    <span style=color:#204a87;font-weight:700>int8_t</span> <span style=color:#000>contents</span><span style=color:#000;font-weight:700>[];</span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>}</span> <span style=color:#000>intset</span><span style=color:#000;font-weight:700>;</span>
</span></span></code></pre></div><ul><li><p><code>encoding</code> 表示编码方式，的取值有三个：INTSET_ENC_INT16, INTSET_ENC_INT32, INTSET_ENC_INT64</p></li><li><p><code>length</code> 代表其中存储的整数的个数</p></li><li><p><code>contents</code> 指向实际存储数值的连续内存区域, 就是一个数组；整数集合的每个元素都是 contents 数组的一个数组项（item），各个项在数组中按值得大小<strong>从小到大有序排序</strong>，且数组中不包含任何重复项。（虽然 intset 结构将 contents 属性声明为 int8_t 类型的数组，但实际上 contents 数组并不保存任何 int8_t 类型的值，contents 数组的真正类型取决于 encoding 属性的值）</p></li></ul><h3 id=内存布局>内存布局</h3><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210504150750.png style=display:block;width:50% alt=NAME align=center></div><p>content数组里面每个元素的数据类型是由encoding来决定的，那么如果原来的数据类型是int16, 当我们再插入一个int32类型的数据时怎么办呢？这就是下面要说的intset的升级。</p><h3 id=升级>升级</h3><p>当在一个int16类型的整数集合中插入一个int32类型的值，整个集合的所有元素都会转换成32类型。 整个过程有三步：</p><ul><li>根据新元素的类型（比如int32），扩展整数集合底层数组的空间大小，并为新元素分配空间。</li><li>将底层数组现有的所有元素都转换成与新元素相同的类型， 并将类型转换后的元素放置到正确的位上， 而且在放置元素的过程中， 需要继续维持底层数组的有序性质不变。</li><li>最后改变encoding的值，length+1。</li></ul><p><strong>那么如果我们删除掉刚加入的int32类型时，会不会做一个降级操作呢</strong>？</p><p>不会。主要还是减少开销的权衡。</p><h2 id=跳表zskiplist>跳表：ZSkipList</h2><blockquote><p>跳跃表结构在 Redis 中的运用场景只有一个，那就是作为有序列表 (Zset) 的使用。跳跃表的性能可以保证在查找，删除，添加等操作的时候在对数期望时间内完成，这个性能是可以和平衡树来相比较的，而且在实现方面比平衡树要优雅，这就是跳跃表的长处。</p><p>跳跃表的缺点就是需要的存储空间比较大，属于利用空间来换取时间的数据结构。</p></blockquote><h3 id=跳跃表>跳跃表</h3><p>对于于一个单链表来讲，即便链表中存储的数据是有序的，如果我们要想在其中查找某个数据，也只能从头到尾遍历链表。这样查找效率就会很低，时间复杂度会很高，是 O(n)。比如查找12，需要7次查找：</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210504150943.png style=display:block;width:50% alt=NAME align=center></div><p>如果我们增加如下两级索引，那么它搜索次数就变成了3次：</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210504151003.png style=display:block;width:50% alt=NAME align=center></div><h3 id=redis-跳跃表>Redis 跳跃表</h3><p>redis跳跃表并没有在单独的类（比如skplist.c)中定义，而是其定义在server.h中, 如下:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#8f5902;font-style:italic>/* ZSETs use a specialized version of Skiplists */</span>
</span></span><span style=display:flex><span><span style=color:#204a87;font-weight:700>typedef</span> <span style=color:#204a87;font-weight:700>struct</span> <span style=color:#000>zskiplistNode</span> <span style=color:#000;font-weight:700>{</span>
</span></span><span style=display:flex><span>    <span style=color:#000>sds</span> <span style=color:#000>ele</span><span style=color:#000;font-weight:700>;</span>
</span></span><span style=display:flex><span>    <span style=color:#204a87;font-weight:700>double</span> <span style=color:#000>score</span><span style=color:#000;font-weight:700>;</span>
</span></span><span style=display:flex><span>    <span style=color:#204a87;font-weight:700>struct</span> <span style=color:#000>zskiplistNode</span> <span style=color:#ce5c00;font-weight:700>*</span><span style=color:#000>backward</span><span style=color:#000;font-weight:700>;</span>
</span></span><span style=display:flex><span>    <span style=color:#204a87;font-weight:700>struct</span> <span style=color:#000>zskiplistLevel</span> <span style=color:#000;font-weight:700>{</span>
</span></span><span style=display:flex><span>        <span style=color:#204a87;font-weight:700>struct</span> <span style=color:#000>zskiplistNode</span> <span style=color:#ce5c00;font-weight:700>*</span><span style=color:#000>forward</span><span style=color:#000;font-weight:700>;</span>
</span></span><span style=display:flex><span>        <span style=color:#204a87;font-weight:700>unsigned</span> <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>span</span><span style=color:#000;font-weight:700>;</span>
</span></span><span style=display:flex><span>    <span style=color:#000;font-weight:700>}</span> <span style=color:#000>level</span><span style=color:#000;font-weight:700>[];</span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>}</span> <span style=color:#000>zskiplistNode</span><span style=color:#000;font-weight:700>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#204a87;font-weight:700>typedef</span> <span style=color:#204a87;font-weight:700>struct</span> <span style=color:#000>zskiplist</span> <span style=color:#000;font-weight:700>{</span>
</span></span><span style=display:flex><span>    <span style=color:#204a87;font-weight:700>struct</span> <span style=color:#000>zskiplistNode</span> <span style=color:#ce5c00;font-weight:700>*</span><span style=color:#000>header</span><span style=color:#000;font-weight:700>,</span> <span style=color:#ce5c00;font-weight:700>*</span><span style=color:#000>tail</span><span style=color:#000;font-weight:700>;</span>
</span></span><span style=display:flex><span>    <span style=color:#204a87;font-weight:700>unsigned</span> <span style=color:#204a87;font-weight:700>long</span> <span style=color:#000>length</span><span style=color:#000;font-weight:700>;</span>
</span></span><span style=display:flex><span>    <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>level</span><span style=color:#000;font-weight:700>;</span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>}</span> <span style=color:#000>zskiplist</span><span style=color:#000;font-weight:700>;</span>
</span></span></code></pre></div><p>内存布局：</p><div align=center><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210504151129.png style=display:block;width:50% alt=NAME align=center></div><p><strong>zskiplist的核心设计要点</strong></p><ul><li><p><strong>头结点</strong>不持有任何数据, 且其level[]的长度为32</p></li><li><p>每个结点</p><ul><li><p><code>ele</code>字段，持有数据，是sds类型</p></li><li><p><code>score</code>字段, 其标示着结点的得分, 结点之间凭借得分来判断先后顺序, 跳跃表中的结点按结点的得分升序排列.</p></li><li><p><code>backward</code>指针, 这是原版跳跃表中所没有的. 该指针指向结点的前一个紧邻结点.</p></li><li><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>level
</span></span></code></pre></div><p>字段, 用以记录所有结点(除过头结点外)；每个结点中最多持有32个zskiplistLevel结构. 实际数量在结点创建时, 按幂次定律随机生成(不超过32). 每个zskiplistLevel中有两个字段</p><ul><li><code>forward</code>字段指向比自己得分高的某个结点(不一定是紧邻的), 并且, 若当前zskiplistLevel实例在level[]中的索引为X, 则其forward字段指向的结点, 其level[]字段的容量至少是X+1. 这也是上图中, 为什么forward指针总是画的水平的原因.</li><li><code>span</code>字段代表forward字段指向的结点, 距离当前结点的距离. 紧邻的两个结点之间的距离定义为1.</li></ul></li></ul></li></ul><h3 id=为什么不选择平衡树或哈希表>为什么不选择平衡树或哈希表</h3><p>作者：</p><blockquote><p>There are a few reasons:</p><p>They are not very memory intensive. It&rsquo;s up to you basically. Changing parameters about the probability of a node to have a given number of levels will make then less memory intensive than btrees.
A sorted set is often target of many ZRANGE or ZREVRANGE operations, that is, traversing the skip list as a linked list. With this operation the cache locality of skip lists is at least as good as with other kind of balanced trees.</p><p>They are simpler to implement, debug, and so forth. For instance thanks to the skip list simplicity I received a patch (already in Redis master) with augmented skip lists implementing ZRANK in O(log(N)). It required little changes to the code.</p><p>About the Append Only durability & speed, I don&rsquo;t think it is a good idea to optimize Redis at cost of more code and more complexity for a use case that IMHO should be rare for the Redis target (fsync() at every command). Almost no one is using this feature even with ACID SQL databases, as the performance hint is big anyway.
About threads: our experience shows that Redis is mostly I/O bound. I&rsquo;m using threads to serve things from Virtual Memory. The long term solution to exploit all the cores, assuming your link is so fast that you can saturate a single core, is running multiple instances of Redis (no locks, almost fully scalable linearly with number of cores), and using the &ldquo;Redis Cluster&rdquo; solution that I plan to develop in the future.</p></blockquote><p>简而言之就是实现简单且达到了类似效果。</p><p>skiplist和各种平衡树（如AVL、红黑树等）的元素是有序排列的，而哈希表不是有序的。因此，在哈希表上只能做单个key的查找，不适宜做范围查找。所谓范围查找，指的是查找那些大小在指定的两个值之间的所有节点。</p><p>在做范围查找的时候，平衡树比skiplist操作要复杂。在平衡树上，我们找到指定范围的小值之后，还需要以中序遍历的顺序继续寻找其它不超过大值的节点。如果不对平衡树进行一定的改造，这里的中序遍历并不容易实现。而在skiplist上进行范围查找就非常简单，只需要在找到小值之后，对第1层链表进行若干步的遍历就可以实现。</p><p>平衡树的插入和删除操作可能引发子树的调整，逻辑复杂，而skiplist的插入和删除只需要修改相邻节点的指针，操作简单又快速。</p><p>从内存占用上来说，skiplist比平衡树更灵活一些。一般来说，平衡树每个节点包含2个指针（分别指向左右子树），而skiplist每个节点包含的指针数目平均为1/(1-p)，具体取决于参数p的大小。如果像Redis里的实现一样，取p=1/4，那么平均每个节点包含1.33个指针，比平衡树更有优势。</p><p>查找单个key，skiplist和平衡树的时间复杂度都为O(log n)，大体相当；而哈希表在保持较低的哈希值冲突概率的前提下，查找时间复杂度接近O(1)，性能更高一些。所以我们平常使用的各种Map或dictionary结构，大都是基于哈希表实现的。</p><p>从算法实现难度上来比较，skiplist比平衡树要简单得多。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-e23ea9a97b8e45f6fe4f13ffc2073690>6 - CH06-缓存机制</h1><p>在实际的工作项目中， 缓存成为高并发、高性能架构的关键组件 ，那么Redis为什么可以作为缓存使用呢？首先可以作为缓存的两个主要特征：</p><ul><li>在分层系统中处于内存/CPU具有访问性能良好，</li><li>缓存数据饱和，有良好的数据淘汰机制</li></ul><p>由于 Redis 天然就具有这两个特征，Redis 基于内存操作的，且其具有完善的数据淘汰机制，十分适合作为缓存组件。</p><p>其中，基于内存操作，容量可以为 32-96GB，且操作时间平均为 100ns，操作效率高。而且数据淘汰机制众多，在Redis 4.0 后就有 8 种了促使 Redis 作为缓存可以适用很多场景。</p><h2 id=淘汰机制>淘汰机制</h2><p>Redis 对于缓存被写满的情况，就需要缓存数据淘汰机制，通过一定淘汰规则将一些数据刷选出来删除，让缓存服务可再使用。那么 Redis 使用哪些淘汰策略进行刷选删除数据？</p><p>在 Redis 4.0 之后，Redis 缓存淘汰策略 6+2 种，包括分成三大类：</p><ul><li>不淘汰数据<ul><li>noeviction ，不进行数据淘汰，当缓存被写满后，Redis不提供服务直接返回错误。</li></ul></li><li>在设置过期时间的键值对中，<ul><li>volatile-random ，在设置过期时间的键值对中随机删除</li><li>volatile-ttl ，在设置过期时间的键值对，基于过期时间的先后进行删除，越早过期的越先被删除。</li><li>volatile-lru ， 基于LRU(Least Recently Used) 算法筛选设置了过期时间的键值对， 最近最少使用的原则来筛选数据</li><li>volatile-lfu ，使用 LFU( Least Frequently Used ) 算法选择设置了过期时间的键值对, 使用频率最少的键值对,来筛选数据。</li></ul></li><li>在所有的键值对中<ul><li>allkeys-random， 从所有键值对中随机选择并删除数据</li><li>allkeys-lru， 使用 LRU 算法在所有数据中进行筛选</li><li>allkeys-lfu， 使用 LFU 算法在所有数据中进行筛选</li></ul></li></ul><blockquote><p><strong>Note</strong>: LRU( 最近最少使用，Least Recently Used)算法， LRU维护一个双向链表 ，链表的头和尾分别表示 MRU 端和 LRU 端，分别代表最近最常使用的数据和最近最不常用的数据。</p><p>LRU 算法在实际实现时，需要用链表管理所有的缓存数据，这会带来额外的空间开销。而且，当有数据被访问时，需要在链表上把该数据移动到 MRU 端，如果有大量数据被访问，就会带来很多链表移动操作，会很耗时，进而会降低 Redis 缓存性能。</p></blockquote><p>其中，LRU和LFU 基于Redis的对象结构<code>redisObject</code>的<code>lru</code>和<code>refcount</code>属性实现的:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#204a87;font-weight:700>typedef</span> <span style=color:#204a87;font-weight:700>struct</span> <span style=color:#000>redisObject</span> <span style=color:#000;font-weight:700>{</span>
</span></span><span style=display:flex><span>  <span style=color:#204a87;font-weight:700>unsigned</span> <span style=color:#f57900>type</span><span style=color:#000;font-weight:700>:</span><span style=color:#0000cf;font-weight:700>4</span><span style=color:#000;font-weight:700>;</span>
</span></span><span style=display:flex><span>  <span style=color:#204a87;font-weight:700>unsigned</span> <span style=color:#f57900>encoding</span><span style=color:#000;font-weight:700>:</span><span style=color:#0000cf;font-weight:700>4</span><span style=color:#000;font-weight:700>;</span>
</span></span><span style=display:flex><span>  <span style=color:#8f5902;font-style:italic>// 对象最后一次被访问的时间
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span>  <span style=color:#204a87;font-weight:700>unsigned</span> <span style=color:#f57900>lru</span><span style=color:#000;font-weight:700>:</span><span style=color:#000>LRU_BITS</span><span style=color:#000;font-weight:700>;</span> <span style=color:#8f5902;font-style:italic>/* LRU time (relative to global lru_clock) or
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>                            * LFU data (least significant 8 bits frequency
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>  // 引用计数               * and most significant 16 bits access time). */</span>
</span></span><span style=display:flex><span>  <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>refcount</span><span style=color:#000;font-weight:700>;</span>
</span></span><span style=display:flex><span>  <span style=color:#204a87;font-weight:700>void</span> <span style=color:#ce5c00;font-weight:700>*</span><span style=color:#000>ptr</span><span style=color:#000;font-weight:700>;</span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>}</span> <span style=color:#000>robj</span><span style=color:#000;font-weight:700>;</span>
</span></span></code></pre></div><p><code>Redis</code>的<code>LRU</code>会使用<code>redisObject</code>的<code>lru</code>记录最近一次被访问的时间，随机选取参数<code>maxmemory-samples</code> 配置的数量作为候选集合，在其中选择 <code>lru</code> 属性值最小的数据淘汰出去。</p><p>在实际项目中，那么该如何选择数据淘汰机制呢？</p><ul><li>优先选择 <code>allkeys-lru</code>算法，将最近最常访问的数据留在缓存中，提升应用的访问性能。</li><li>有顶置数据使用 <code>volatile-lru</code>算法 ,顶置数据不设置缓存过期时间，其他数据设置过期时间，基于LRU 规则进行筛选 。</li></ul><p>在理解了Redis缓存淘汰机制后，来看看Redis作为缓存共有多少种模式呢？</p><h2 id=缓存模式>缓存模式</h2><p>Redis 缓存模式基于是否接收写请求，可以分成只读缓存和读写缓存：</p><ul><li><p>只读缓存：只处理读操作，所有的更新操作都在数据库中，这样数据不会有丢失的风险。</p><ul><li>Cache Aside模式</li><li><div><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20220219174644.png style=display:block;margin-left:auto;margin-right:auto;width:80% alt=20220219174644></div></li></ul></li><li><p>读写缓存：读写操作都在缓存中执行，出现宕机故障，会导致数据丢失。缓存写回数据到数据库有分成两种同步和异步：</p><ul><li><p>同步：访问性能偏低，其更加侧重于保证数据可靠性</p><ul><li>Read-Throug模式</li><li>Write-Through模式</li></ul></li><li><p>异步：有数据丢失风险，其侧重于提供低延迟访问</p><ul><li>Write-Behind模式</li></ul></li><li><div><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20220219174748.png style=display:block;margin-left:auto;margin-right:auto;width:80% alt=20220219174748></div></li></ul></li></ul><h3 id=cache-aside-模式>Cache Aside 模式</h3><p>查询数据先从缓存读取数据，如果缓存中不存在，则再到数据库中读取数据，获取到数据之后更新到缓存Cache中，<strong>但更新数据操作，会先去更新数据库种的数据，然后将缓存种的数据失效。</strong></p><p>而且Cache Aside模式会存在并发风险：执行读操作未命中缓存，然后查询数据库中取数据，数据已经查询到还没放入缓存，同时一个更新写操作让缓存失效，然后读操作再把查询到数据加载缓存，导致缓存的脏数据。</p><h3 id=readwrite-throug-模式>Read/Write-Throug 模式</h3><p>查询数据和更新数据都直接访问缓存服务，<strong>缓存服务同步方式地将数据更新到数据库</strong>。出现脏数据的概率较低，但是就强依赖缓存，对缓存服务的稳定性有较大要求，但同步更新会导致其性能不好。</p><h3 id=write-behind-模式>Write Behind 模式</h3><p>查询数据和更新数据都直接访问缓存服务，<strong>但缓存服务使用异步方式地将数据更新到数据库（通过异步任务）</strong> 速度快，效率会非常高，但是数据的一致性比较差，还可能会有数据的丢失情况，实现逻辑也较为复杂。</p><h2 id=生产实践>生产实践</h2><p>在实际项目开发中根据实际的业务场景需求来进行选择缓存模式。那了解上述后，我们的应用中为什么需要使用到<code>redis</code>缓存呢？</p><p>在应用使用<code>Redis</code>缓存可以提高系统性能和并发，主要体现在</p><ul><li>高性能：基于内存查询，KV结构，简单逻辑运算</li><li>高并发：<code>Mysql</code> 每秒只能支持2000左右的请求，<code>Redis</code>轻松每秒1W以上。让80%以上查询走缓存，20%以下查询走数据库，能让系统吞吐量有很大的提高</li></ul><p>虽然使用Redis缓存可以大大提升系统的性能，但是使用了缓存，会出现一些问题，比如，缓存与数据库双向不一致、缓存雪崩等，对于出现的这些问题该怎么解决呢？</p><h2 id=常见问题>常见问题</h2><p>使用了缓存，会出现一些问题，主要体现在：</p><ul><li>缓存与数据库双写不一致</li><li>缓存雪崩: Redis 缓存无法处理大量的应用请求，转移到数据库层导致数据库层的压力激增;</li><li>缓存穿透：访问数据不存在在Redis缓存中和数据库中，导致大量访问穿透缓存直接转移到数据库导致数据库层的压力激增;</li><li>缓存击穿：缓存无法处理高频热点数据，导致直接高频访问数据库导致数据库层的压力激增;</li></ul><h3 id=数据一致性>数据一致性</h3><h4 id=只读缓存cache-aside模式><strong>只读缓存(Cache Aside模式)</strong></h4><p>对于<strong>只读缓存(<code>Cache Aside</code>模式)</strong>，读操作都发生在缓存中，数据不一致只会发生在删改操作上（新增操作不会，因为新增只会在数据库处理），当发生删改操作时，缓存将数据中标志为无效和更新数据库。因此在更新数据库和删除缓存值的过程中，无论这两个操作的执行顺序谁先谁后，只要有一个操作失败了就会出现数据不一致的情况。</p><p>总结出，<strong>当不存在并发的情况使用重试机制（消息队列使用），当存在高并发的情况，使用延迟双删除(在第一次删除后，睡眠一定时间后，再进行删除)</strong>，具体如下：</p><table><thead><tr><th>操作顺序</th><th>高并发</th><th>潜在问题</th><th>现象</th><th>应对方案</th></tr></thead><tbody><tr><td>先删除缓存，再更新数据库</td><td>否</td><td>缓存删除成功，数据库更新失败</td><td>读到数据库的旧值</td><td>重试机制（数据库更新）</td></tr><tr><td>先更新数据库，再删除缓存</td><td>否</td><td>数据库更新成功，缓存删除失败</td><td>读到缓存的旧值</td><td>重试机制（缓存删除）</td></tr><tr><td>先删除缓存，再更新数据库</td><td>是</td><td>缓存删除后，尚未更新数据库，有并发读请求</td><td>并发读请求读到数据库旧值，并更新到缓存，导致之后的读请求读到旧值</td><td>延迟双删</td></tr><tr><td>先更新数据库，再删除缓存</td><td>是</td><td>数据库更新成功，尚未删除缓存</td><td>读到缓存的旧值</td><td>不一致的情况短暂存在，对业务影响较小</td></tr></tbody></table><blockquote><p>延迟双删除伪代码：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>redis.delKey(X)
</span></span><span style=display:flex><span>db.update(X)
</span></span><span style=display:flex><span>Thread.sleep(N)
</span></span><span style=display:flex><span>redis.delKey(X)
</span></span></code></pre></div></blockquote><h4 id=读写缓存readwrite-througwrite-behind模式-><strong>读写缓存（Read/Write-Throug、Write Behind模式 ）</strong></h4><p>对于读写缓存，写操作都发生在缓存中，后再更新数据库，只要有一个操作失败了就会出现数据不一致的情况。</p><p>总结出，当不存在并发的情况使用重试机制（消息队列使用），当存在高并发的情况，使用分布锁。具体如下：</p><table><thead><tr><th>操作顺序</th><th>高 并发</th><th>潜在问题</th><th>现象</th><th>应对方案</th></tr></thead><tbody><tr><td>先更新缓存，再更新数据库</td><td>否</td><td>缓存更新成功，数据库更新失败</td><td>会从缓存中读到最新值，短期影响不大</td><td>重试机制（数据库更新）</td></tr><tr><td>先更新数据库，再更新缓存</td><td>否</td><td>数据库更新成功，缓存更新失败</td><td>会从缓存读到旧值</td><td>重试机制（缓存删除）</td></tr><tr><td>先更新数据库，再更新缓存</td><td>写+读并发</td><td>线程A先更新数据库，之后线程B读取数据，之后线程A更新缓存</td><td>B会命中缓存，读取到旧值</td><td>A更新缓存前，对业务有短暂影响</td></tr><tr><td>先更新缓存，再更新数据库</td><td>写+读并发</td><td>线程A先更新缓存成功，之后线程B读取数据，此时线程B命中缓存，读取到最新值后返回，之后线程A更新数据库成功</td><td>B会命中缓存，读取到最新值</td><td>业务没影响</td></tr><tr><td>先更新数据库，再更新缓存</td><td>写+写并发</td><td>线程A和线程B同时更新同一条数据，更新数据库的顺序是先A后B，但更新缓存时顺序是先B后A，这会导致数据库和缓存的不一致</td><td>数据库和缓存的不一致</td><td>写操作加分布式锁</td></tr><tr><td>先更新缓存，再更新数据库</td><td>写+写并发</td><td>线程A和线程B同时更新同一条数据，更新缓存的顺序是先A后B，但是更新数据库的顺序是先B后A，这也会导致数据库和缓存的不一致</td><td>数据库和缓存的不一致</td><td>写操作加分布式锁</td></tr></tbody></table><h3 id=缓存雪崩>缓存雪崩</h3><p>缓存雪崩，由于缓存中有大量数据同时过期失效或者缓存出现宕机，大量的应用请求无法在 Redis 缓存中进行处理，进而发送到数据库层导致数据库层的压力激增，严重的会造成数据库宕机。</p><p>对于缓存中有大量数据同时过期，导致大量请求无法得到处理， 解决方式：</p><ul><li><p><strong>数据预热</strong>，<strong>将发生大并发访问前手动触发加载缓存不同的key， 可以避免在用户请求的时候，先查询数据库</strong></p></li><li><p><strong>设置不同的过期时间，让缓存失效的时间点尽量均匀</strong></p></li><li><p><strong>双层缓存策略， 在原始缓存上加上拷贝缓存，原始缓存失效时可以访问拷贝缓存，且原始缓存失效时间设置为短期，拷贝缓存设置为长期</strong></p></li><li><p><strong>服务降级 ， 发生缓存雪崩时，针对不同的数据采取不同的降级方案</strong> ，比如，非核心数据直接返回预定义信息、空值或是错误信息</p></li></ul><p>对于缓存出现宕机，解决方式：</p><ul><li><strong>业务系统中实现服务熔断或请求限流机制，防止大量访问导致数据库出现宕机</strong></li></ul><h3 id=缓存穿透>缓存穿透</h3><p>缓存穿透，数据在数据库和缓存中都不存在，这样就导致查询数据，在缓存中找不到对应<code>key</code>的<code>value</code>，都要去数据库再查询一遍，然后返回空（相当于进行了两次无用的查询）。</p><p>当有大量访问请求，且其绕过缓存直接查数据库，导致数据库层的压力激增，严重的会造成数据库宕机。</p><p>对于缓存穿透，解决方式：</p><ul><li>缓存空值或缺省值，当一个查询返回的数据为空时， 空结果也将进行缓存，并将它的过期时间设置比较短，下次访问直接从缓存中取值，避免了把大量请求发送给数据库处理，造成数据库出问题。</li><li>布隆过滤器( <strong>BloomFilter</strong> )，将所有可能查询数据<code>key</code>哈希到一个足够大的<code>bitmap</code>中 , 在查询的时候先去<code>BloomFilter</code>去查询<code>key</code>是否存在，如果不存在就直接返回，存在再去查询缓存，缓存中没有再去查询数据库 ，从而避免了数据库层的压力激增出现宕机。</li></ul><h3 id=缓存击穿>缓存击穿</h3><p>缓存击穿，针对某个访问非常频繁的热点数据过期失效，导致访问无法在缓存中进行处理，进而会有导致大量的直接请求数据库，从而使得数据库层的压力激增，严重的会造成数据库宕机。</p><p>对于缓存击穿，解决方式：</p><ul><li>不设置过期时间，对于访问特别频繁的热点数据，不设置过期时间。</li></ul><h3 id=问题总结>问题总结</h3><p>在大多数业务场景下，Redis缓存作为只读缓存使用。针对只读缓存来说， 优先使用先更新数据库再删除缓存的方法保证数据一致性 。</p><p>其中，缓存雪崩，缓存穿透，缓存击穿三大问题的原因和解决方式</p><table><thead><tr><th>问题</th><th>原因</th><th>解决方式</th></tr></thead><tbody><tr><td>缓存雪崩</td><td>大量数据同时过期失效缓存出现宕机</td><td>数据预热设置不同的过期时间双层缓存策略服务降级服务熔断限流机制</td></tr><tr><td>缓存穿透</td><td>数据在数据库和缓存中都不存在</td><td>缓存空值或缺省值布隆过滤器( <strong>BloomFilter</strong> )</td></tr><tr><td>缓存击穿</td><td>访问非常频繁的热点数据过期失效</td><td>对于访问特别频繁的热点数据，不设置过期时间</td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-76cf898359b51ee9f123cd859135b47d>7 - CH07-高可用性</h1><h2 id=主从复制>主从复制</h2><p>Redis 主从复制模式可以将主节点的数据同步给从节点，从而保障当主节点不可达的情况下，从节点可以作为后备顶上来，并且可以保障数据尽量不丢失。主从复制可以保障最终一致性</p><p>从节点可以扩展主节点的读能力，一旦主节点不能支持大规模并发量的读操作，从节点可以在一定程度上分担主节点的压力。</p><div><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20220219220108.png style=display:block;margin-left:auto;margin-right:auto;width:80% alt=20220219220108></div><p>主从复制面临的问题：</p><ol><li>当主节点发生故障的时候，需要手动的将一个从节点晋升为主节点，同时通知应用方修改主节点地址并重启应用，同时需要命令其它从节点复制新的主节点，整个过程需要人工干预。</li><li>主节点的写能力受到单机的限制。</li><li>主节点的存储能力受到单机的限制。</li></ol><h3 id=复制过程>复制过程</h3><p>一般当<code>slave</code>第一次启动连接<code>master</code>，或者“被认为是第一次连接”，是主从采用全量复制。全量复制的执行流程如下：</p><ol><li><code>slave redis</code>启动. 会从<code>redis.conf</code>中读取<code>master ip</code>和<code>host</code>。</li><li>定时任务每秒检查是否有新的<code>mater</code>需要连接，如果发现就与<code>master</code>建立<code>socket</code>连接。</li><li><code>slave</code>发送<code>ping</code>指令到<code>mater</code>。</li><li>如果<code>mater</code>配置<code>require pass</code>，<code>slave</code>需要发送认证给<code>master</code>。</li><li><code>Salve</code>会发送<code>sync</code>命令到<code>Master</code>。</li><li><code>Master</code>启动一个后台进程，将<code>Redis</code>中的数据快照<code>rdb</code>保存到文件中。</li><li>启动后台进程的同时，<code>Master</code>会将保存数据快照期间接收到的写命令缓存起来。</li><li><code>Master</code>完成写文件操作后，将<code>rdb</code>发送给<code>Salve</code>。</li><li><code>Salve</code>将<code>rdb</code>保存到磁盘上，然后加载<code>rdb</code>到<code>redis</code>内存中。</li><li>当<code>Salve</code>完成数据快照的恢复后，<code>aster</code>将这期间收集的写命令发送给<code>Salve</code>端。</li><li>后续<code>Master</code>收集到的写命令都会通过之前建立的连接. 增量发送给<code>salve</code>端。</li></ol><div><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20220219220824.png style=display:block;margin-left:auto;margin-right:auto;width:80% alt=20220219220824></div><h3 id=增量复制>增量复制</h3><p>当<code>slave</code>节点与<code>master</code>全量同步后，<code>master</code>节点上数据再次发生更新，就会触发增量复制。</p><p>当我们在 <code>master</code> 服务器增减数据的时候，就会触发 <code>replicationFeedSalves()</code>函数，接下来在 <code>Master</code> 服务器上调用的每一个命令都会使用<code>replicationFeedSlaves()</code> 函数来同步到<code>Slave</code>服务器。当然，在执行此函数之前<code>master</code>服务器会判断用户执行的命令是否有数据更新，如果有数据更新并且<code>slave</code>服务器不为空，才会执行此函数，函数主要的工作就是把用户执行的命令发送到所有的 <code>slave</code>服务器，让<code>slave</code>服务器执行。
流程如下图：</p><div><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20220219220856.png style=display:block;margin-left:auto;margin-right:auto;width:30% alt=20220219220856></div><h3 id=断点续传>断点续传</h3><p>断点续传或者说是断点恢复复制，也就是说 slave 因为某种原因与<code>master</code>断开连接了一段时间，然后又与<code>master</code>发生重连。<code>redis2.8</code>以后对于这种场景进行了优化，开始加入了<code>PSYNC</code>同步策略。这种策略性能一定是大于全量复制的。</p><ol><li>从服务器向主服务器发送<code>PSYNC</code>命令，携带主服务器的<code>runid</code>和复制偏移量；</li><li>主服务器验证<code>runid</code>和自身<code>runid</code>是否一致，如不一致，则进行全量复制；</li><li>主服务器验证复制偏移量是否在积压缓冲区内，如不在，则进行全量复制；</li><li>如都验证通过，则主服务器将保持在积压区内的偏移量后的所有数据发送给从服务器，主从服务器再次回到一致状态。</li></ol><div><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20220219220940.png style=display:block;margin-left:auto;margin-right:auto;width:50% alt=20220219220940></div><h4 id=psync-核心参数>PSYNC 核心参数</h4><p>断点续传的几个核心参数，<code>offset</code>、<code>backlog</code>、<code>runid</code>。这三个参数在 PSYNC 中起到了至关重要的作用，下面我们来一一介绍一下。</p><ul><li><code>offet</code>复制偏移量 , <code>offset</code>是用来记录<code>master</code>和<code>lslave</code>某个时段的数据版本状态的，<code>slave</code>每秒会向<code>master</code>上报<code>offset</code>，<code>master</code>保存下来，当触发 PSYNC 时再拿来和<code>master</code>的<code>offset</code>数据作对比。说白了，它就是记录数据在某一时刻的快照，用来对比 master 和 slave 数据差异用的。</li><li><code>backlog</code>积压缓冲区<ol><li>这个也是一个非常核心的参数，它默认大小为<code>1mb</code>，复制积压缓冲区是由<code>Master</code>维护的一个固定长度的<code>FIFO</code>队列，它的作用是缓存已经传播出去的命令。当<code>Master</code>进行命令传播时，不仅将命令发送给所有<code>Slave</code>，还会将命令写入到复制积压缓冲区里面。</li><li>全量复制的时候，<code>master</code>的数据更新（读写操作，主动过期删除等）会临时存放在<code>backlog</code>中待全量复制完成后增量发到slave，必须为此保留足够的空间。</li><li>断点续传时，<code>backlog</code>会存下<code>slave</code>断开连接后，<code>master</code>变更的数据。当然由于它大小有限制，而且先进先出特性，所以达到缓冲大小后会弹出老数据。这样，就可以把它作为一个衡量执行<code>sync</code>还是<code>psync</code>的一个标准<code>（backlog = offset : 部分同步，backlog &lt; offset 执行全量同步）</code>。一般为了避免，大规模全量复制，我们都会给一个恰当的值，根据公式<code>second*write_size_per_second</code>来估算：其中<code>second</code>为从服务器断线后重新连接上主服务器所需的平均时间（以秒计算）；而<code>write_size_per_second</code>则是主服务器平均每秒产生的写命令数据量（协议格式的写命令的长度总和）；</li></ol></li><li>master run id, <code>master</code>唯一标示，<code>slave</code>连接<code>master</code>时会传<code>runid</code>，<code>master</code>每次重启<code>runid</code>都发生变化，当<code>slave</code>发现<code>master</code>的<code>runid</code>变化时都会触发全量复制流程。</li></ul><h3 id=优缺点>优缺点</h3><p><strong>优点：</strong></p><ol><li>高可靠性：一方面，采用双机主备架构，能够在主库出现故障时自动进行主备切换，从库提升为主库提供服务，保证服务平稳运行；另一方面，开启数据持久化功能和配置合理的备份策略，能有效的解决数据误操作和数据异常丢失的问题；</li><li>读写分离策略：从节点可以扩展主库节点的读能力，有效应对大并发量的读操作。</li></ol><p><strong>缺点：</strong></p><ol><li>故障恢复复杂，如果没有<code>RedisHA</code>系统（需要开发），当主库节点出现故障时，需要手动将一个从节点晋升为主节点，同时需要通知业务方变更配置，并且需要让其它从库节点去复制新主库节点，整个过程需要人为干预，比较繁琐；</li><li>主库的写能力受到单机的限制，可以考虑分片；</li><li>主库的存储能力受到单机的限制，可以考虑<code>Pika</code>；</li><li>原生复制的弊端在早期的版本中也会比较突出，如：<code>Redis</code>复制中断后，<code>Slave</code>会发起<code>psync</code>，此时如果同步不成功，则会进行全量同步，主库执行全量备份的同时可能会造成毫秒或秒级的卡顿；又由于<code>COW</code>机制，导致极端情况下的主库内存溢出，程序异常退出或宕机；主库节点生成备份文件导致服务器磁盘<code>IO</code>和<code>CPU</code>（压缩）资源消耗；发送数<code>GB</code>大小的备份文件导致服务器出口带宽暴增，阻塞请求，建议升级到最新版本。</li></ol><h2 id=redis-sentinel>Redis Sentinel</h2><div><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20220219220207.png style=display:block;margin-left:auto;margin-right:auto;width:80% alt=20220219220207></div><p>当主节点出现故障时，Redis Sentinel 能自动完成故障发现和故障转移，并通知应用方，从而实现真正的高可用。RedisSentinel 是一个分布式架构，其中包含若干个 Sentinel 节点和 Redis 数据节点，每个 Sentinel 节点会对数据节点和其余 Sentinel 节点进行监控，当它发现节点不可达时，会对节点做下线标识。如果被标识的是<strong>主节点</strong>，它还会和其他的 Sentinel 节点进行协商，当大多数 Sentinel 节点都认为主节点不可达时，它们会选举一个 Sentinel 节点来完成自动故障转移的工作，同时会将这个变化实时通知给 Redis 应用方。整个过程是自动的，不需要人工干预，解决了Redis 的高可用问题。</p><p>Redis Sentinel 包含了若干个 Sentinel 节点，这样做也带来了两个好处：</p><ol><li>对节点的故障判断是由多个 Sentinel 节点共同完成，这样可以有效的防止误判。</li><li>Sentinel 节点集合是由若干个 Sentinel 节点组成的，这样即使个别 Sentinel 节点不可用，整个Sentinel节点集合依然是健壮的。</li></ol><p>Redis Sentinel 具有以下几个功能：</p><ol><li>监控：Sentinel 会定期检测 Redis 数据节点、其余 Sentinel 节点是否可到达</li><li>通知：Sentinel 会将故障转移的结果通知给应用方。</li><li>主节点故障转移：实现从节点晋升为主节点并维护后续正确的主从关系。</li><li>配置提供者：在 RedisSentinel 结构中，客户端在初始化的时候连接的是 Sentinel 节点集合，从中获取主节点信息。</li></ol><p>RedisSentinel 处理流程：</p><ol><li>Sentinel 集群通过给定的配置文件发现 master，启动时会监控 master。通过向 master 发送 info 信息获得该服务器下面的所有从服务器。</li><li>Sentinel 集群通过命令连接向被监视的主从服务器发送 hello 信息（每秒一次），该信息包括 Sentinel 本身的 IP、端口、id 等内容，以此来向其他 Sentinel 宣告自己的存在。</li><li>Sentinel 集群通过订阅连接接收其他 Sentinel 发送的 hello 信息，以此来发现监视同一个主服务器的其他 Sentinel；集群之间会互相创建命令连接用于通信，因为已经有主从服务器作为发送和接收 hello 信息的中介，Sentinel 之间不会创建订阅连接。</li><li>Sentinel 集群使用 ping 命令来检测实例的状态，如果在指定的时间内（down-after-milliseconds）没有回复或则返回错误的回复，那么该实例被判为下线。</li><li>当 failover 主备切换被触发后，failover 并不会马上进行，Sentinel 中的大多数 Sentinel 授权后才可以进行 failover，即进行 failover 的 Sentinel 会去获得指定 quorum 个的 Sentinel 的授权，成功后进入 ODOWN 状态。如在 5 个 Sentinel 中配置了 2 个 quorum，等到 2 个 Sentinel 认为 master 死了就执行 failover。</li><li>Sentinel 向选为 master 的 slave 发送 SLAVEOF NO ONE 命令，选择 slave 的条件是 Sentinel 首先会根据 slaves 的优先级来进行排序，优先级越小排名越靠前。如果优先级相同，则查看复制的下标，哪个从 master 接收的复制数据多，哪个就靠前。如果优先级和下标都相同，就选择进程 ID 较小的。</li><li>Sentinel 被授权后，它将会获得宕掉的 master 的一份最新配置版本号 (config-epoch)，当 failover 执行结束以后，这个版本号将会被用于最新的配置，通过广播形式通知其它 Sentinel，其它的 Sentinel 则更新对应 master 的配置。</li></ol><p>1 到 3 是自动发现机制:</p><ul><li>以 10 秒一次的频率，向被监视的 master 发送 info 命令，根据回复获取 master 当前信息。</li><li>以 1 秒一次的频率，向所有 redis 服务器、包含 Sentinel 在内发送 PING 命令，通过回复判断服务器是否在线。与主节点，从节点，其余 Sentinel 都建立起连接，实现了对每个节点的监控。</li><li>以 2 秒一次的频率，通过向所有被监视的 master，slave 服务器发送当前 Sentinel master 信息的消息。这个定时任务可以完成以下两个工作：<ul><li>发现新的 Sentinel 节点：通过订阅主节点的 <em>Sentinel</em>:hello 了解其他 Sentinel 节点信息。如果是新加入的 Sentinel 节点，将该 Sentinel 节点信息保存起来，并与该 Sentinel 节点创建连接</li><li>Sentinel 节点之间交换主节点状态，作为后面客观下线以及领导者选举的依据</li></ul></li></ul><p>4 是检测机制，5 和 6 是 failover 机制，7 是更新配置机制</p><h3 id=leader-选举>Leader 选举</h3><p>其实在 sentinels 故障转移中，仍然需要一个 Leader 来调度整个过程：master 的选举以及 slave 的重配置和同步。当集群中有多个 sentinel 实例时，如何选举其中一个 sentinel 为 leader 呢？</p><p>在配置文件中 can-failover、quorum 参数，以及 is-master-down-by-addr 指令配合来完成整个过程。</p><ol><li>can-failover 用来表明当前 sentinel 是否可以参与 failover 过程，如果为 YES 则表明它将有能力参与 Leader 的选举，否则它将作为 Observer ，observer 参与 leader 选举投票但不能被选举；</li><li>quorum 不仅用来控制 master ODOWN 状态确认，同时还用来选举 leader 时最小「赞同票」数；</li><li>is-master-down-by-addr，在上文中以及提到，它可以用来检测 ip + port 的 master 是否已经处于 SDOWN 状态，不过此指令不仅能够获得 master 是否处于 SDOWN，同时它还额外的返回当前 sentinel 本地「投票选举」的 Leader 信息 (runid);</li></ol><p>每个 sentinel 实例都持有其他的 sentinels 信息，在 Leader 选举过程中（当为 leader 的 sentinel 实例失效时，有可能 master server 并没失效，注意分开理解），sentinel 实例将从所有的 sentinels 集合中去除 can-failover = no 和状态为 SDOWN 的 sentinels，在剩余的 sentinels 列表中按照 runid 按照「字典」顺序排序后，取出 runid 最小的 sentinel 实例，并将它「投票选举」为 Leader，并在其他 sentinel 发送的 is-master-down-by-addr 指令时将推选的 runid 追加到响应中。每个 sentinel 实例都会检测 is-master-down-by-addr 的响应结果，如果「投票选举」的 leader 为自己，且状态正常的 sentinels 实例中，赞同者的自己的 sentinel 个数不小于(>=) 50% + 1,且不小与 ，那么此 sentinel 就会认为选举成功且 leader 为自己。</p><p>在 sentinel.conf 文件中，我们期望有足够多的 sentinel 实例配置 can-failovers，这样能够确保当 leader 失效时，能够选举某个 sentinel 为 leader，以便进行 failover。如果 leader 无法产生，比如较少的 sentinels 实例有效，那么 failover 过程将续。</p><h3 id=failover-过程>failover 过程</h3><p>在 Leader 触发 failover 之前，首先 wait 数秒（随机 0~5），以便让其他 sentinel 实例准备和调整，如果一切正常，那么 leader 就需要开始将一个 salve 提升为 master，此 slave 必须为状态良好（不能处于 SDOWN/ODOWN 状态）且权重值最低（redis.conf中）的，当 master 身份被确认后，开始 failover：</p><ol><li>+failover-triggered: Leader 开始进行 failover，此后紧跟着 +failover-state-wait-start ，wait 数秒。</li><li>+failover-state-select-slave: Leader 开始查找合适的 slave</li><li>+selected-slave: 已经找到合适的 slave</li><li>+failover-state-sen-slaveof-noone: Leader 向 slave 发送 slaveof no one 指令，此时 slave 已经完成角色转换，此 slave 即为 master</li><li>+failover-state-wait-promotition: 等待其他 sentinel 确认 slave</li><li>+promoted-slave：确认成功</li><li>+failover-state-reconf-slaves: 开始对 slaves 进行 reconfig 操作。</li><li>+slave-reconf-sent: 向指定的 slave 发送 slaveof 指令，告知此 slave 跟随新的 master</li><li>+slave-reconf-inprog: 此 slave 正在执行 slaveof + SYNC 过程，如过 slave 收到 +slave-reconf-sent 之后将会执行 slaveof 操作。</li><li>+slave-reconf-done: 此 slave 同步完成，此后 leader 可以继续下一个 slave 的 reconfig 操作。循环步骤 10</li><li>+failover-end: 故障转移结束</li><li>+switch-master：故障转移成功后，各个 sentinel 实例开始监控新的 master。</li></ol><h3 id=总结>总结</h3><p>Redis-Sentinel 是 Redis 官方推荐的高可用性解决方案，Redis-sentinel 本身也是一个独立运行的进程，它能监控多个 master-slave 集群，发现 master 宕机后能进行自动切换。Sentinel 可以监视任意多个主服务器（复用），以及主服务器属下的从服务器，并在被监视的主服务器下线时，自动执行故障转移操作。</p><div><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20220219220545.png style=display:block;margin-left:auto;margin-right:auto;width:80% alt=20220219220545></div><p>为了防止 sentinel 的单点故障，可以对 sentinel 进行集群化，创建多个 sentinel。</p><div><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20220219220607.png style=display:block;margin-left:auto;margin-right:auto;width:40% alt=20220219220607></div><h2 id=redis-cluster>Redis Cluster</h2><p><code>Redis</code> 集群是一个分布式（<code>distributed</code>）、容错（<code>fault-tolerant</code>）的 <code>Redis</code> 实现， 集群可以使用的功能是普通单机 <code>Redis</code> 所能使用的功能的一个子集（<code>subset</code>）。</p><p><code>Redis</code> 集群中不存在中心（<code>central</code>）节点或者代理（<code>proxy</code>）节点， 集群的其中一个主要设计目标是达到线性可扩展性（<code>linear scalability</code>）。</p><p><code>Redis</code> 集群提供了一种运行 <code>Redis</code> 的方式，其中数据在多个 <code>Redis</code> 节点间自动分区。<code>Redis</code> 集群还在分区期间提供一定程度的可用性，即在实际情况下能够在某些节点发生故障或无法通信时继续运行。但是，如果发生较大故障（例如，大多数主站不可用时），集群会停止运行。</p><h3 id=集群模型>集群模型</h3><div><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20220219221214.png style=display:block;margin-left:auto;margin-right:auto;width:50% alt=20220219221214></div><p>所有的节点通过服务通道直接相连，各个节点之间通过二进制协议优化传输的速度和带宽。</p><p>客户端与节点之间通过 ascii 协议进行通信。</p><p>客户端与节点直连，不需要中间 Proxy 层。客户端不需要连接集群所有节点，连接集群中任何一个可用节点即可。</p><p>尽管这些节点彼此相连，功能相同，但是仍然分为两种节点：master 和 slave。</p><h3 id=节点间传递信息>节点间传递信息</h3><div><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20220219221317.png style=display:block;margin-left:auto;margin-right:auto;width:60% alt=20220219221317></div><p>各个节点之间通过 PING-PONG 机制通信，下面是一段关于 PING-PONG 机制的会话”内容”。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>节点M：PING，嘿，朋友你好吗？我是 XYZ 哈希槽的 master ，配置信息是 FF89X1JK。
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>节点N：PONG，我很好朋友，我也是 XYZ 哈希槽的 master ，配置信息是 FF89X1JK。
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>节点M：我这里有一些关于我最近收到的其他节点的信息 ，A 节点回复了我的 PING 消息，我认为 A 节点是正常的。B 没有回应我的消息，我猜它现在可能出问题了，但是我需要一些 ACK(Acknowledgement) 消息来确认。
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>节点N：我也想给你分享一些关于其它节点的信息，C 和 D 节点在指定的时间内回应了我， 我认为它们都是正常的，但是 B 也没有回应我，我觉得它现在可能已经挂掉了。
</span></span></code></pre></div><p>每个节点会向集群中的其他节点发送节点状态信息，如果某个节点挂掉停止了服务，那么会执行投票容错机制，关于这个机制，会在下面讲到。</p><h3 id=hash-槽slot>Hash 槽(slot)</h3><p>Redis 集群不使用一致的散列，而是一种不同的分片形式，其中每个键在概念上都是我们称之为散列槽的一部分，目的是使数据均匀的存储在诸多节点中。这点类似于 HashMap 中的桶(bucket)。</p><div><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20220219221405.png style=display:block;margin-left:auto;margin-right:auto;width:50% alt=20220219221405></div><p>Redis 集群中有 16384 个散列槽，为了计算给定密钥的散列槽，Redis 对 key 采用 CRC16 算法，以下是负责将键映射到槽的算法：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>slot = crc16(key) mod NUMER_SLOTS
</span></span></code></pre></div><p>例如，你可能有 3 个节点，其中一个集群：</p><ul><li>节点 A 包含从 0 到 5500 的散列槽。</li><li>节点 B 包含从 5501 到 11000 的散列槽。</li><li>节点 C 包含 从 11001 到 16383 的散列槽。</li></ul><p>Hash 槽可以轻松地添加和删除集群中的节点。例如，如果我想添加一个新节点 D，我需要将节点 A，B，C 中的一些散列槽移动到 D。同样，如果我想从节点 A 中删除节点 A，可以只移动由 A 服务的散列槽到 B 和 C。当节点 A 为空时，可以将它从群集中彻底删除。</p><div><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20220219221447.png style=display:block;margin-left:auto;margin-right:auto;width:60% alt=20220219221447></div><ol><li>对象保存到 Redis 之前先经过 CRC16 哈希到一个指定的 Node 上，例如 Object4 最终 Hash 到了 Node1 上。</li><li>每个 Node 被平均分配了一个 Slot 段，对应着 0-16384，Slot 不能重复也不能缺失，否则会导致对象重复存储或无法存储。</li><li>Node 之间也互相监听，一旦有 Node 退出或者加入，会按照 Slot 为单位做数据的迁移。例如 Node1 如果掉线了，0-5640 这些 Slot 将会平均分摊到 Node2 和 Node3 上,由于 Node2 和 Node3 本身维护的 Slot 还会在自己身上不会被重新分配，所以迁移过程中不会影响到 5641-16384Slot 段的使用。</li></ol><div><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20220219221600.png style=display:block;margin-left:auto;margin-right:auto;width:60% alt=20220219221600></div><p>想扩展并发读就添加 Slaver，想扩展并发写就添加 Master，想扩容也就是添加 Master，任何一个 Slaver 或者几个 Master 挂了都不会是灾难性的故障。</p><p>简单总结下哈希 Slot 的优缺点：</p><p>缺点：每个 Node 承担着互相监听、高并发数据写入、高并发数据读出，工作任务繁重</p><p>优点：将 Redis 的写操作分摊到了多个节点上，提高写的并发能力，扩容简单。</p><h3 id=容错>容错</h3><div><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20220219221622.png style=display:block;margin-left:auto;margin-right:auto;width:60% alt=20220219221622></div><ul><li>集群中的节点不断的 <code>PING</code> 其他的节点，当一个节点向另一个节点发送 <code>PING</code> 命令， 但是目标节点未能在给定的时限内回复， 那么发送命令的节点会将目标节点标记为 <code>PFAIL</code>(<code>possible failure</code>，可能已失效)。</li><li>当节点接收到其他节点发来的信息时， 它会记下那些被其他节点标记为失效的节点。 这被称为失效报告（<code>failure report</code>）。</li><li>如果节点已经将某个节点标记为 <code>PFAIL</code> ， 并且根据节点所收到的失效报告显式， 集群中的大部分其他主节点也认为那个节点进入了失效状态， 那么节点会将那个失效节点的状态标记为 <code>FAIL</code> 。</li><li>一旦某个节点被标记为 <code>FAIL</code> ， 关于这个节点已失效的信息就会被广播到整个集群， 所有接收到这条信息的节点都会将失效节点标记为 <code>FAIL</code> 。</li></ul><p>简单来说， 一个节点要将另一个节点标记为失效， 必须先询问其他节点的意见， 并且得到大部分主节点的同意才行。</p><p>如果被标记为 <code>FAIL</code> 的是从节点， 那么当这个节点重新上线时， <code>FAIL</code> 标记就会被移除。 一个从节点是否处于 <code>FAIL</code> 状态， 决定了这个从节点在有需要时能否被提升为主节点。</p><p>如果一个主节点被打上 <code>FAIL</code> 标记之后， 经过了节点超时时限的四倍时间， 再加上十秒钟之后， 针对这个主节点的槽的故障转移操作仍未完成， 并且这个主节点已经重新上线的话， 那么移除对这个节点的 <code>FAIL</code> 标记。在不符合上面的条件后，一旦某个主节点进入 <code>FAIL</code> 状态， 如果这个主节点有一个或多个从节点存在， 那么其中一个从节点会被升级为新的主节点， 而其他从节点则会开始对这个新的主节点进行复制。</p><h3 id=优缺点-1>优缺点</h3><p><strong>优点：</strong></p><ol><li>无中心架构；</li><li>数据按照<code>slot</code>存储分布在多个节点，节点间数据共享，可动态调整数据分布；</li><li>可扩展性：可线性扩展到 1000 多个节点，节点可动态添加或删除；</li><li>高可用性：部分节点不可用时，集群仍可用。通过增加<code>Slave</code>做<code>standby</code>数据副本，能够实现故障自动<code>failover</code>，节点之间通过<code>gossip</code>协议交换状态信息，用投票机制完成<code>Slave</code>到<code>Master</code>的角色提升；</li><li>降低运维成本，提高系统的扩展性和可用性。</li></ol><p><strong>缺点：</strong></p><ol><li><code>Client</code>实现复杂，驱动要求实现<code>Smart Client</code>，缓存<code>slots mapping</code>信息并及时更新，提高了开发难度，客户端的不成熟影响业务的稳定性。目前仅<code>JedisCluster</code>相对成熟，异常处理部分还不完善，比如常见的<code>“max redirect exception”</code>。</li><li>节点会因为某些原因发生阻塞（阻塞时间大于<code>clutser-node-timeout</code>），被判断下线，这种<code>failover</code>是没有必要的。</li><li>数据通过异步复制，不保证数据的强一致性。</li><li>多个业务使用同一套集群时，无法根据统计区分冷热数据，资源隔离性较差，容易出现相互影响的情况。</li><li><code>Slave</code>在集群中充当“冷备”，不能缓解读压力，当然可以通过<code>SDK</code>的合理设计来提高<code>Slave</code>资源的利用率。</li><li><code>Key</code>批量操作限制，如使用<code>mset</code>、<code>mget</code>目前只支持具有相同<code>slot</code>值的<code>Key</code>执行批量操作。对于映射为不同<code>slot</code>值的<code>Key</code>由于<code>Keys</code>不支持跨<code>slot</code>查询，所以执行<code>mset</code>、<code>mget</code>、<code>sunion</code>等操作支持不友好。</li><li><code>Key</code>事务操作支持有限，只支持多<code>key</code>在同一节点上的事务操作，当多个<code>Key</code>分布于不同的节点上时无法使用事务功能。</li><li><code>Key</code>作为数据分区的最小粒度，不能将一个很大的键值对象如<code>hash</code>、<code>list</code>等映射到不同的节点。</li><li>不支持多数据库空间，单机下的<code>redis</code>可以支持到 16 个数据库，集群模式下只能使用 1 个数据库空间，即 db 0。</li><li>复制结构只支持一层，从节点只能复制主节点，不支持嵌套树状复制结构。</li><li>避免产生<code>hot-key</code>，导致主库节点成为系统的短板。</li><li>避免产生<code>big-key</code>，导致网卡撑爆、慢查询等。</li><li>重试时间应该大于<code>cluster-node-time</code>时间。</li><li><code>Redis Cluster</code>不建议使用<code>pipeline</code>和<code>multi-keys</code>操作，减少<code>max redirect</code>产生的场景。</li></ol><h2 id=codis>Codis</h2><p><code>Codis</code> 是一个代理中间件，如下图，<code>Codis</code> 在系统的位置是这样的。</p><div><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20220219221752.png style=display:block;margin-left:auto;margin-right:auto;width:60% alt=20220219221752></div><p><code>Codis</code>分为四个部分，分别是<code>Codis Proxy</code> (<code>codis-proxy</code>)、<code>Codis Dashboard</code> (<code>codis-config</code>)、<code>Codis Redis</code>(<code>codis-server</code>)和<code>ZooKeeper/Etcd</code>.
<code>Codis</code>就是起着一个中间代理的作用，能够把所有的<code>Redis</code>实例当成一个来使用，在客户端操作着<code>SDK</code>的时候和操作<code>Redis</code>的时候是一样的，没有差别。
因为<code>Codis</code>是一个无状态的，所以可以增加多个<code>Codis</code>来提升<code>QPS</code>,同时也可以起着容灾的作用。</p><h3 id=分片原理>分片原理</h3><p>在<code>Codis</code>中，<code>Codis</code>会把所有的<code>key</code>分成 1024 个槽，这 1024 个槽对应着的就是<code>Redis</code>的集群，这个在<code>Codis</code>中是会在内存中维护着这 1024 个槽与<code>Redis</code>实例的映射关系。这个槽是可以配置，可以设置成 2048 或者是 4096 个。看你的<code>Redis</code>的节点数量有多少，偏多的话，可以设置槽多一些。
<code>Codis</code>中<code>key</code>的分配算法，先是把<code>key</code>进行<code>CRC32</code> 后，得到一个 32 位的数字，然后再<code>hash%1024</code>后得到一个余数，这个值就是这个<code>key</code>对应着的槽，这槽后面对应着的就是<code>redis</code>的实例。(可以思考一下，为什么 Codis 很多命令行不支持，例如 KEYS 操作)</p><blockquote><p><code>CRC32</code>:<code>CRC</code>本身是“冗余校验码”的意思，<code>CRC32</code>则表示会产生一个<code>32bit</code>（8 位十六进制数）的校验值。由于<code>CRC32</code>产生校验值时源数据块的每一个<code>bit</code>（位）都参与了计算，所以数据块中即使只有一位发生了变化，也会得到不同的<code>CRC32</code>值。</p></blockquote><p>Codis中Key的算法代码如下：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>hash = crc32(command.key)
</span></span><span style=display:flex><span>slot_index = hash % 1024
</span></span><span style=display:flex><span>redis = slots[slot_index].redis
</span></span><span style=display:flex><span>redis.do(command)
</span></span></code></pre></div><h3 id=槽位同步>槽位同步</h3><blockquote><p>思考一个问题：如果这个 Codis 节点只在自己的内存里面维护着槽位与实例的关系,那么它的槽位信息怎么在多个实例间同步呢？</p></blockquote><p>Codis 把这个工作交给了 ZooKeeper 来管理，当 Codis 的 Codis Dashbord 改变槽位的信息的时候，其他的 Codis 节点会监听到 ZooKeeper 的槽位变化，会及时同步过来。如图：</p><div><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20220219221951.png style=display:block;margin-left:auto;margin-right:auto;width:60% alt=20220219221951></div><h3 id=节点扩容>节点扩容</h3><blockquote><p>思考一个问题：在 Codis 中增加了 Redis 节点后,槽位的信息怎么变化，原来的 key 怎么迁移和分配？如果在扩容的时候，这个时候有新的 key 进来，Codis 的处理策略是怎么样的？</p></blockquote><p>因为<code>Codis</code>是一个代理中间件，所以这个当需要扩容<code>Redis</code>实例的时候，可以直接增加<code>redis</code>节点。在槽位分配的时候，可以手动指定<code>Codis Dashbord</code>来为新增的节点来分配特定的槽位。</p><p>在<code>Codis</code>中实现了自定义的扫描指令<code>SLOTSSCAN</code>，可以扫描指定的<code>slot</code>下的所有的<code>key</code>，将这些<code>key</code>迁移到新的<code>Redis</code>的节点中(话外语：这个是<code>Codis</code>定制化的其中一个好处)。</p><p>首先，在迁移的时候，会在原来的<code>Redis</code>节点和新的<code>Redis</code>里都保存着迁移的槽位信息，在迁移的过程中，如果有<code>key</code>打进将要迁移或者正在迁移的旧槽位的时候，这个时候<code>Codis</code>的处理机制是，先是将这个<code>key</code>强制迁移到新的<code>Redis</code>节点中，然后再告诉<code>Codis</code>,下次如果有新的<code>key</code>的打在这个槽位中的话，那么转发到新的节点。代码策略如下：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#000>slot_index</span> <span style=color:#ce5c00;font-weight:700>=</span> crc32<span style=color:#ce5c00;font-weight:700>(</span>command.key<span style=color:#ce5c00;font-weight:700>)</span> % <span style=color:#0000cf;font-weight:700>1024</span>
</span></span><span style=display:flex><span><span style=color:#204a87;font-weight:700>if</span> slot_index in migrating_slots:
</span></span><span style=display:flex><span>    do_migrate_key<span style=color:#ce5c00;font-weight:700>(</span>command.key<span style=color:#ce5c00;font-weight:700>)</span>  <span style=color:#8f5902;font-style:italic># 强制执行迁移</span>
</span></span><span style=display:flex><span>    <span style=color:#000>redis</span> <span style=color:#ce5c00;font-weight:700>=</span> slots<span style=color:#ce5c00;font-weight:700>[</span>slot_index<span style=color:#ce5c00;font-weight:700>]</span>.new_redis
</span></span><span style=display:flex><span><span style=color:#204a87;font-weight:700>else</span>:
</span></span><span style=display:flex><span>    <span style=color:#000>redis</span> <span style=color:#ce5c00;font-weight:700>=</span> slots<span style=color:#ce5c00;font-weight:700>[</span>slot_index<span style=color:#ce5c00;font-weight:700>]</span>.redis
</span></span><span style=display:flex><span>redis.do<span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87>command</span><span style=color:#ce5c00;font-weight:700>)</span>
</span></span></code></pre></div><h4 id=自动均衡策略>自动均衡策略</h4><p>面对着上面讲的迁移策略，如果有成千上万个节点新增进来，都需要我们手动去迁移吗？那岂不是得累死啊。当然，<code>Codis</code>也是考虑到了这一点，所以提供了自动均衡策略。自动均衡策略是这样的，<code>Codis</code> 会在机器空闲的时候，观察<code>Redis</code>中的实例对应着的<code>slot</code>数，如果不平衡的话就会自动进行迁移。</p><h4 id=codis-的牺牲>Codis 的牺牲</h4><p>因为<code>Codis</code>在<code>Redis</code>的基础上的改造，所以在<code>Codis</code>上是不支持事务的，同时也会有一些命令行不支持，在官方的文档上有(<code>Codis</code>不支持的命令)
官方的建议是单个集合的总容量不要超过 1M,否则在迁移的时候会有卡顿感。在<code>Codis</code>中，增加了<code>proxy</code>来当中转层，所以在网络开销上，是会比单个的<code>Redis</code>节点的性能有所下降的，所以这部分会有些的性能消耗。可以增加<code>proxy</code>的数量来避免掉这块的性能损耗。</p><h4 id=mget-的过程>MGET 的过程</h4><blockquote><p>思考一个问题：如果熟悉 Redis 中的 MGET、MSET 和 MSETNX 命令的话，就会知道这三个命令都是原子性的命令。但是，为什么 Codis 支持 MGET 和 MSET,却不支持 MSETNX 命令呢？</p></blockquote><div><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20220219222034.png style=display:block;margin-left:auto;margin-right:auto;width:60% alt=20220219222034></div><p>原因如下:</p><p>在<code>Codis</code>中的<code>MGET</code>命令的原理是这样的，先是在<code>Redis</code>中的各个实例里获取到符合的<code>key</code>，然后再汇总到<code>Codis</code>中，如果是<code>MSETNX</code>的话，因为<code>key</code>可能存在在多个<code>Redis</code>的实例中，如果某个实例的设值成功，而另一个实例的设值不成功，从本质上讲这是不成功的，但是分布在多个实例中的<code>Redis</code>是没有回滚机制的，所以会产生脏数据，所以 MSETNX 就是不能支持了。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-609363fe593c01d2ba6ab13171671b34>8 - CH08-百亿量级</h1><h2 id=需求背景>需求背景</h2><p>该应用场景为 DMP 缓存存储需求，DMP 需要管理非常多的第三方 id 数据，其中包括各媒体 cookie 与自身 cookie（以下统称 supperid）的 mapping 关系，还包括了 supperid 的人口标签、移动端id（主要是idfa和imei）的人口标签，以及一些黑名单id、ip等数据。</p><p>在 hdfs 的帮助下离线存储千亿记录并不困难，然而 DMP 还需要提供毫秒级的实时查询。由于 cookie 这种 id 本身具有不稳定性，所以很多的真实用户的浏览行为会导致大量的新 cookie 生成，只有及时同步 mapping 的数据才能命中 DMP 的人口标签，无法通过预热来获取较高的命中，这就跟缓存存储带来了极大的挑战。</p><p>经过实际测试，对于上述数据，常规存储超过五十亿的kv记录就需要1T多的内存，如果需要做高可用多副本那带来的消耗是巨大的，另外kv的长短不齐也会带来很多内存碎片，这就需要超大规模的存储方案来解决上述问题。</p><h2 id=缓存内容>缓存内容</h2><p>人⼝标签主要是 cookie、imei、idfa 以及其对应的 gender（性别）、age（年龄段）、geo（地域）等；mapping 关系主要是媒体 cookie 对 supperid 的映射。以下是数据存储⽰示例：</p><p><strong>1、PC端的ID：</strong></p><p>媒体编号-媒体 cookie=>supperid</p><ul><li><code>supperid => { age=>年龄段编码，gender=>性别编码，geo=>地理位置编码 }</code></li></ul><p><strong>2、Device 端的 ID：</strong></p><ul><li><code>imei or idfa => { age=>年龄段编码，gender=>性别编码，geo=>地理位置编码 }</code></li></ul><p>显然 PC 数据需要存储两种 key=>value 还有 key=>hashmap，⽽ Device 数据需要存储一种 key=>hashmap 即可。</p><h2 id=数据特点>数据特点</h2><p>短 key 短 value：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>其中superid为21位数字：比如1605242015141689522；
</span></span><span style=display:flex><span>imei为小写md5：比如2d131005dc0f37d362a5d97094103633；
</span></span><span style=display:flex><span>idfa为大写带”-”md5：比如：51DFFC83-9541-4411-FA4F-356927E39D04；
</span></span></code></pre></div><ul><li>媒体自身的 cookie 长短不一；</li><li>需要为全量数据提供服务，supperid 是百亿级、媒体映射是千亿级、移动 id 是几十亿级；</li><li>每天有十亿级别的 mapping 关系产生；</li><li>对于较大时间窗口内可以预判热数据（有一些存留的稳定 cookie）；</li><li>对于当前 mapping 数据无法预判热数据，有很多是新生成的 cookie；</li></ul><h2 id=技术挑战>技术挑战</h2><ol><li>长短不一容易造成内存碎片；</li><li>由于指针大量存在，内存膨胀率比较高，一般在7倍，纯内存存储通病；</li><li>虽然可以通过cookie的行为预判其热度，但每天新生成的id依然很多（百分比比较敏感，暂不透露）；</li><li>由于服务要求在公网环境（国内公网延迟60ms以下）下100ms以内，所以原则上当天新更新的 mapping 和人口标签需要全部 in memory，而不会让请求落到后端的冷数据；</li><li>业务方面，所有数据原则上至少保留35天甚至更久；</li><li>内存至今也比较昂贵，百亿级Key乃至千亿级存储方案势在必行！</li></ol><h2 id=解决方案>解决方案</h2><h3 id=淘汰策略>淘汰策略</h3><p>存储吃紧的一个重要原因在于每天会有很多新数据入库，所以及时清理数据尤为重要。主要方法就是发现和保留热数据淘汰冷数据。</p><p>网民的量级远远达不到几十亿的规模，id 有一定的生命周期，会不断的变化。所以很大程度上我们存储的id实际上是无效的。而查询其实前端的逻辑就是广告曝光，跟人的行为有关，所以一个 id 在某个时间窗口的（可能是一个campaign，半个月、几个月）访问行为上会有一定的重复性。</p><p>数据初始化之前，我们先利用 HBase 将日志的id聚合去重，划定TTL的范围，一般是35天，这样可以砍掉近35天未出现的id。另外在 Redis 中设置过期时间是35天，当有访问并命中时，对 key 进行续命，延长过期时间，未在 35 天出现的自然淘汰。这样可以针对稳定 cookie 或 id 有效，实际证明，续命的方法对 idfa 和 imei 比较实用，长期积累可达到非常理想的命中。</p><h3 id=减少膨胀>减少膨胀</h3><p>Hash 表空间大小和 Key 的个数决定了冲突率（或者用负载因子衡量），再合理的范围内，key 越多自然hash表空间越大，消耗的内存自然也会很大。再加上大量指针本身是长整型，所以内存存储的膨胀十分可观。先来谈谈如何把 key 的个数减少。</p><p>大家先来了解一种存储结构。我们期望将 key1=>value1 存储在 redis 中，那么可以按照如下过程去存储。先用固定长度的随机散列md5(key)值作为 redis 的 key，我们称之为 BucketId，而将key1=>value1存储在hashmap结构中，这样在查询的时候就可以让client按照上面的过程计算出散列，从而查询到 value1。</p><p>过程变化简单描述为：get(key1) -> hget(md5(key1), key1) 从而得到 value1。</p><p>如果我们通过预先计算，让很多key可以在BucketId空间里碰撞，那么可以认为一个BucketId下面挂了多个key。比如平均每个BucketId下面挂10个key，那么理论上我们将会减少超过90%的redis key的个数。</p><p>具体实现起来有一些麻烦，而且用这个方法之前你要想好容量规模。我们通常使用的 md5 是 32 位的 hexString（16进制字符），它的空间是 128bit，这个量级太大了，我们需要存储的是百亿级，大约是 33 bit（2的33次方），所以我们需要有一种机制计算出合适位数的散列，而且为了节约内存，我们需要利用全部字符类型（ASCII码在0~127之间）来填充，而不用 HexString，这样 Key 的长度可以缩短到一半。</p><p>下面是具体的实现方式：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#204a87;font-weight:700>public</span> <span style=color:#204a87;font-weight:700>static</span> <span style=color:#204a87;font-weight:700>byte</span> <span style=color:#ce5c00;font-weight:700>[]</span> <span style=color:#000>getBucketId</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>byte</span> <span style=color:#ce5c00;font-weight:700>[]</span> <span style=color:#000>key</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>Integer</span> <span style=color:#000>bit</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>
</span></span><span style=display:flex><span>    <span style=color:#000>MessageDigest</span> <span style=color:#000>mdInst</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>MessageDigest</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>getInstance</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#4e9a06>&#34;MD5&#34;</span><span style=color:#ce5c00;font-weight:700>);</span>
</span></span><span style=display:flex><span>    <span style=color:#000>mdInst</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>update</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>key</span><span style=color:#ce5c00;font-weight:700>);</span>
</span></span><span style=display:flex><span>    <span style=color:#204a87;font-weight:700>byte</span> <span style=color:#ce5c00;font-weight:700>[]</span> <span style=color:#000>md</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>mdInst</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>digest</span><span style=color:#ce5c00;font-weight:700>();</span>
</span></span><span style=display:flex><span>    <span style=color:#204a87;font-weight:700>byte</span> <span style=color:#ce5c00;font-weight:700>[]</span> <span style=color:#000>r</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>new</span> <span style=color:#204a87;font-weight:700>byte</span><span style=color:#ce5c00;font-weight:700>[(</span><span style=color:#000>bit</span><span style=color:#ce5c00;font-weight:700>-</span><span style=color:#000>1</span><span style=color:#ce5c00;font-weight:700>)/</span><span style=color:#000>7</span> <span style=color:#ce5c00;font-weight:700>+</span> <span style=color:#000>1</span><span style=color:#ce5c00;font-weight:700>];</span><span style=color:#8f5902;font-style:italic>// 因为一个字节中只有7位能够表示成单字符，ascii码是7位
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span>    <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>a</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>int</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#000>Math</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>pow</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>2</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>bit</span><span style=color:#ce5c00;font-weight:700>%</span><span style=color:#000>7</span><span style=color:#ce5c00;font-weight:700>)-</span><span style=color:#000>2</span><span style=color:#ce5c00;font-weight:700>;</span>
</span></span><span style=display:flex><span>    <span style=color:#000>md</span><span style=color:#ce5c00;font-weight:700>[</span><span style=color:#000>r</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>length</span><span style=color:#ce5c00;font-weight:700>-</span><span style=color:#000>1</span><span style=color:#ce5c00;font-weight:700>]</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>byte</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>md</span><span style=color:#ce5c00;font-weight:700>[</span><span style=color:#000>r</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>length</span><span style=color:#ce5c00;font-weight:700>-</span><span style=color:#000>1</span><span style=color:#ce5c00;font-weight:700>]</span> <span style=color:#ce5c00;font-weight:700>&amp;</span> <span style=color:#000>a</span><span style=color:#ce5c00;font-weight:700>);</span>
</span></span><span style=display:flex><span>    <span style=color:#000>System</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>arraycopy</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>md</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>0</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>r</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>0</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>r</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>length</span><span style=color:#ce5c00;font-weight:700>);</span>
</span></span><span style=display:flex><span>    <span style=color:#204a87;font-weight:700>for</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>i</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#000>0</span><span style=color:#ce5c00;font-weight:700>;</span><span style=color:#000>i</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>r</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#c4a000>length</span><span style=color:#ce5c00;font-weight:700>;</span><span style=color:#000>i</span><span style=color:#ce5c00;font-weight:700>++)</span> <span style=color:#ce5c00;font-weight:700>{</span>
</span></span><span style=display:flex><span>    	<span style=color:#204a87;font-weight:700>if</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>r</span><span style=color:#ce5c00;font-weight:700>[</span><span style=color:#000>i</span><span style=color:#ce5c00;font-weight:700>]&lt;</span><span style=color:#000>0</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#000>r</span><span style=color:#ce5c00;font-weight:700>[</span><span style=color:#000>i</span><span style=color:#ce5c00;font-weight:700>]</span> <span style=color:#ce5c00;font-weight:700>&amp;=</span> <span style=color:#000>127</span><span style=color:#ce5c00;font-weight:700>;</span>    
</span></span><span style=display:flex><span>    <span style=color:#ce5c00;font-weight:700>}</span>    
</span></span><span style=display:flex><span>    <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>r</span><span style=color:#ce5c00;font-weight:700>;</span>
</span></span><span style=display:flex><span><span style=color:#ce5c00;font-weight:700>}</span>
</span></span></code></pre></div><p>参数 bit 决定了最终 BucketId 空间的大小，空间大小集合是2的整数幂次的离散值。这里解释一下为何一个字节中只有7位可用，是因为 redis 存储 key 时需要是 ASCII（0~127），而不是 byte array。如果规划百亿级存储，计划每个桶分担10个kv，那么我们只需 2^30=1073741824 的桶个数即可，也就是最终 key 的个数。</p><h3 id=减少碎片>减少碎片</h3><p>碎片主要原因在于内存无法对齐、过期删除后，内存无法重新分配。通过上文描述的方式，我们可以将人口标签和mapping数据按照上面的方式去存储，这样的好处就是redis key是等长的。另外对于hashmap中的key我们也做了相关优化，截取cookie或者deviceid的后六位作为key，这样也可以保证内存对齐，理论上会有冲突的可能性，但在同一个桶内后缀相同的概率极低(试想id几乎是随机的字符串，随意10个由较长字符组成的id后缀相同的概率*桶样本数=发生冲突的期望值&#171;0.05,也就是说出现一个冲突样本则是极小概率事件，而且这个概率可以通过调整后缀保留长度控制期望值)。而 value 只存储 age、gender、geo 的编码，用三个字节去存储。</p><p>另外提一下，减少碎片还有个很 low 但是有效的方法，将 slave 重启，然后强制的 failover 切换主从，这样相当于给master整理的内存的碎片。</p><p>推荐 Google-tcmalloc， facebook-jemalloc 内存分配，可以在 value 不大时减少内存碎片和内存消耗。有人测过大 value 情况下反而libc更节约。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-52ebc52fef800cc7b90e32b1026ac24d>9 - CH09-实现搜索</h1><h2 id=场景>场景</h2><p>下面以一个例子开始，这是某购物网站的搜索条件，如果让你实现这样的一个搜索接口，你会如何实现？</p><div><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20220219223547.png style=display:block;margin-left:auto;margin-right:auto;width:80% alt=20220219223547></div><p>从上图中可以看出，搜索总共分为6大类，每大类中又分了各个子类。这中间，各大类条件之间是取的交集，各子类中有单选、多选、以及自定义的情况，最终输出符合条件的结果集。</p><p>好了，既然需求很明确了，我们就开始来实现。</p><h2 id=实现一>实现一</h2><p>以下面这段代码为例：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>select ... from table_1
</span></span><span style=display:flex><span>left join table_2
</span></span><span style=display:flex><span>left join table_3
</span></span><span style=display:flex><span>left join (select ... from table_x where ...) tmp_1
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span>where ...
</span></span><span style=display:flex><span>order by ...
</span></span><span style=display:flex><span>limit m,n
</span></span></code></pre></div><p>代码在测试环境跑了一把，结果好像都匹配上了，于是准备上预发。这一上预发，问题就开始暴露出来。预发为了尽可能的逼真线上环境，所以数据量自然而然要比测试大的多。所以这么一个复杂的 SQL，它的执行效率可想而知。</p><h2 id=实现二>实现二</h2><p>通过了<code>explain</code>关键字进行SQL性能分析，对该加索引的地方都加上了索引。同时将一条复杂SQL拆分成多条SQL，计算结果在程序内存中进行计算。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>
</span></span><span style=display:flex><span>$result_1 = query(&#39;select ... from table_1 where ...&#39;);
</span></span><span style=display:flex><span>$result_2 = query(&#39;select ... from table_2 where ...&#39;);
</span></span><span style=display:flex><span>$result_3 = query(&#39;select ... from table_3 where ...&#39;);
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span>$result = array_intersect($result_1, $result_2, $result_3, ...);
</span></span></code></pre></div><p>这种方案从性能上明显比第一种要好很多，但查询速度不够快。每次查询都会向数据库查询多次，而且有些历史原因，部分条件是做不到单表查询的，所以查询等待的时间是避免不了的。</p><h2 id=实现三>实现三</h2><p>从上面的方案中看到了优化的空间。方案二在思路上是没问题的，将复杂条件拆分，计算各个子维度的结果集，最后将所有的子结果集进行一个汇总合并，得到最终想要的结果。</p><p>如果事先将各个子维度的结果集给缓存起来，这要查询的时候直接去取想要的子集，而不用每次去查库计算。</p><p>这里采用 Redis 来存储缓存数据，用它的主要原因是，它提供了多种数据结构，并且在 Redis 中进行集合的交并集操作是一件很容易的事情。</p><p>具体方案，如图所示：</p><div><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20220219223927.png style=display:block;margin-left:auto;margin-right:auto;width:80% alt=20220219223927></div><p>这里每个条件都事先将计算好的结果集ID存入对应的key中，选用的数据结构是集合（Set）。查询操作包括：</p><ul><li>子类单选：直接根据条件 key，获取对应结果集；</li><li>子类多选：根据多个条件 Key，进行并集操作，获取对应结果集；</li><li>最终结果：将获取的所有子类结果集进行交集操作，得到最终结果；</li></ul><p><em>这其实就是所谓的反向索引。</em></p><p>这里会发现，漏了一个价格的条件。从需求中可知，价格条件是个区间，并且是无穷举的。所以上述的这种穷举条件的 Key-Value 方式是做不到的。这里我们采用 Redis 的另一种数据结构进行实现，有序集合（Sorted Set）：</p><div><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20220219224001.png style=display:block;margin-left:auto;margin-right:auto;width:80% alt=20220219224001></div><p>将所有商品加入 Key 为价格的有序集合中，值为商品ID，每个值对应的分数为商品价格的数值。这样在 Redis 的有序集合中就可以通过<code>ZRANGEBYSCORE</code>命令，根据分数（价格）区间，获取相应结果集。</p><p>至此，方案三的优化已全部结束，将数据的查询与计算通过缓存的手段，进行了分离。在每次查找时，只需要简单的查找 Redis 几次就能得出结果。查询速度上符合了验收的要求。</p><h2 id=扩展>扩展</h2><h3 id=分页>分页</h3><p>这里你或许发现了一个严重的功能缺陷，列表查询怎么能没有分页。是的，我们马上来看 Redis 是如何实现分页的。</p><p>分页主要涉及排序，这里简单起见，就以创建时间为例。</p><p>如图所示：</p><div><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20220219224033.png style=display:block;margin-left:auto;margin-right:auto;width:80% alt=20220219224033></div><p>图中蓝色部分是以创建时间为分值的商品有序集合，蓝色下方的结果集即为条件计算而得的结果，通过<code>ZINTERSTORE</code>命令，赋结果集权重为0，商品时间结果为1，取交集而得的结果集赋予创建时间分值的新有序集合。对新结果集的操作即能得到分页所需的各个数据：</p><ul><li>页面总数为：<code>ZCOUNT</code>命令</li><li>当前页内容：<code>ZRANGE</code>命令</li><li>若以倒序排列：<code>ZREVRANGE</code>命令</li></ul><h3 id=更新>更新</h3><p>关于索引数据更新的问题，有两种方式来进行。一种是通过商品数据的修改，来即时触发更新操作，一种是通过定时脚本来进行批量更新。这里要注意的是，关于索引内容的更新，如果暴力的删除 Key，再重新设置 Key。因为 Redis 中两个操作不会是原子性进行的，所以中间可能存在空白间隙，建议采用仅移除集合中失效元素，添加新元素的方式进行。</p><h2 id=性能优化>性能优化</h2><p>Redis 是内存级操作，所以单次的查询会很快。但是如果我们的实现中会进行多次的 Redis 操作，Redis 的多次连接时间可能是不必要时间消耗。通过使用<code>MULTI</code>命令，开启一个事务，将 Redis 的多次操作放在一个事务中，最后通过<code>EXEC</code>来进行原子性执行（<em>注意：这里所谓的事务，只是将多个操作在一次连接中执行，如果执行过程中遇到失败，是不会回滚的</em>）。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-0651586b1071ed29fcfe45d22825ffb0>10 - CH10-常见问题</h1><h2 id=操作问题>操作问题</h2><h3 id=过期时间意外丢失><strong>过期时间意外丢失？</strong></h3><p>SET 除了可以设置 key-value 之外，还可以设置 key 的过期时间，就像下面这样：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>127.0.0.1:6379&gt; SET testkey val1 EX 60
</span></span><span style=display:flex><span>OK
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; TTL testkey
</span></span><span style=display:flex><span>(integer) 59
</span></span></code></pre></div><p>此时如果你想修改 key 的值，但只是单纯地使用 SET 命令，而没有加上「过期时间」的参数，那这个 key 的过期时间将会被「擦除」。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>127.0.0.1:6379&gt; SET testkey val2
</span></span><span style=display:flex><span>OK
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; TTL testkey  // key永远不过期了！
</span></span><span style=display:flex><span>(integer) -1
</span></span></code></pre></div><p>看到了么？testkey 变成永远不过期了！</p><p><strong>SET 命令如果不设置过期时间，那么 Redis 会自动「擦除」这个 key 的过期时间。</strong></p><h3 id=del-竟然也会阻塞-redis><strong>DEL 竟然也会阻塞 Redis？</strong></h3><p>删除一个 key，你肯定会用 DEL 命令，不知道你没有思考过它的时间复杂度是多少？</p><p>O(1)？其实不一定。</p><p>如果你有认真阅读 Redis 的官方文档，就会发现：<strong>删除一个 key 的耗时，与这个 key 的类型有关。</strong></p><p>Redis 官方文档在介绍 DEL 命令时，是这样描述的：</p><ul><li>key 是 String 类型，DEL 时间复杂度是 O(1)</li><li>key 是 List/Hash/Set/ZSet 类型，DEL 时间复杂度是 O(M)，M 为元素数量</li></ul><p><strong>也就是说，如果你要删除的是一个非 String 类型的 key，这个 key 的元素越多，那么在执行 DEL 时耗时就越久！</strong></p><p>原因在于，删除这种 key 时，Redis 需要依次释放每个元素的内存，元素越多，这个过程就会越耗时。</p><p>而这么长的操作耗时，势必会阻塞整个 Redis 实例，影响 Redis 的性能。</p><p>所以，当你在删除 List/Hash/Set/ZSet 类型的 key 时，一定要格外注意，不能无脑执行 DEL，而是应该用以下方式删除：</p><ol><li>查询元素数量：执行 LLEN/HLEN/SCARD/ZCARD 命令</li><li>判断元素数量：如果元素数量较少，可直接执行 DEL 删除，否则分批删除</li><li>分批删除：执行 LRANGE/HSCAN/SSCAN/ZSCAN + LPOP/RPOP/HDEL/SREM/ZREM 删除</li></ol><p>我们再来分析下，删除一个 String 类型的 key 会不会有这种问题？其实这也不一定！如果一个 Key 存储了 500MB 的数据也会出现一样的问题。</p><p>这是因为，Redis 释放这么大的内存给操作系统，也是需要时间的，所以操作耗时也会变长。所以，对于 String 类型来说，你最好也不要存储过大的数据，否则在删除它时，也会有性能问题。</p><p>此时，你可能会想：<strong>Redis 4.0 不是推出了 lazy-free 机制么？打开这个机制，释放内存的操作会放到后台线程中执行，那是不是就不会阻塞主线程了？</strong></p><p>即使 Redis 打开了 lazy-free，在删除一个 String 类型的 bigkey 时，它仍旧是在主线程中处理，而不是放到后台线程中执行。所以，依旧有阻塞 Redis 的风险！</p><h3 id=randomkey-竟然也会阻塞-redis><strong>RANDOMKEY 竟然也会阻塞 Redis？</strong></h3><p>如果你想随机查看 Redis 中的一个 key，通常会使用 RANDOMKEY 这个命令。这个命令会从 Redis 中「随机」取出一个 key。</p><p>如果你对 Redis 的过期策略有所了解，应该知道 Redis 清理过期 key，是采用定时清理 + 懒惰清理 2 种方式结合来做的。整个流程就是这样的：</p><ol><li>master 随机取出一个 key，判断是否已过期</li><li>如果 key 已过期，删除它，继续随机取 key</li><li>以此循环往复，直到找到一个不过期的 key，返回</li></ol><p>但这里就有一个问题了：<strong>如果此时 Redis 中，有大量 key 已经过期，但还未来得及被清理掉，那这个循环就会持续很久才能结束，而且，这个耗时都花费在了清理过期 key + 寻找不过期 key 上。</strong></p><p>导致的结果就是，RANDOMKEY 执行耗时变长，影响 Redis 性能。</p><p>以上流程，其实是在 master 上执行的。如果在 slave 上执行 RANDOMEKY，那么问题会更严重！</p><p>主要原因就在于，slave 自己是不会清理过期 key。那 slave 什么时候删除过期 key 呢？</p><p>其实，当一个 key 要过期时，master 会先清理删除它，之后 master 向 slave 发送一个 DEL 命令，告知 slave 也删除这个 key，以此达到主从库的数据一致性。</p><p>还是同样的场景：Redis 中存在大量已过期，但还未被清理的 key，那在 slave 上执行 RANDOMKEY 时，就会发生以下问题：</p><ol><li>slave 随机取出一个 key，判断是否已过期</li><li>key 已过期，但 slave 不会删除它，而是继续随机寻找不过期的 key</li><li>由于大量 key 都已过期，那 slave 就会寻找不到符合条件的 key，此时就会陷入「<strong>死循环</strong>」！</li></ol><p><strong>也就是说，在 slave 上执行 RANDOMKEY，有可能会造成整个 Redis 实例卡死！</strong></p><p>修复的解决方案是，在 slave 上执行 RANDOMKEY 时，会先判断整个实例所有 key 是否都设置了过期时间，如果是，为了避免长时间找不到符合条件的 key，<strong>slave 最多只会在哈希表中寻找 100 次</strong>，无论是否能找到，都会退出循环。这个方案就是增加上了一个最大重试次数，这样一来，就避免了陷入死循环。</p><p>虽然这个方案可以避免了 slave 陷入死循环、卡死整个实例的问题，但是，在 master 上执行这个命令时，依旧有概率导致耗时变长。</p><p>所以，你在使用 RANDOMKEY 时，如果发现 Redis 发生了「抖动」，很有可能是因为这个原因导致的！</p><h3 id=o1-复杂度的-setbit竟然会导致-redis-oom><strong>O(1) 复杂度的 SETBIT，竟然会导致 Redis OOM？</strong></h3><p>在使用 Redis 的 String 类型时，除了直接写入一个字符串之外，还可以把它当做 bitmap 来用。</p><p>具体来讲就是，我们可以把一个 String 类型的 key，拆分成一个个 bit 来操作，就像下面这样：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>127.0.0.1:6379&gt; SETBIT testkey 10 1
</span></span><span style=display:flex><span>(integer) 1
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; GETBIT testkey 10
</span></span><span style=display:flex><span>(integer) 1
</span></span></code></pre></div><div><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20220219225235.png style=display:block;margin-left:auto;margin-right:auto;width:50% alt=20220219225235></div><p>其中，操作的每一个 bit 位叫做 offset。如果这个 key 不存在，或者 key 的内存使用很小，此时你要操作的 offset 非常大，那么 Redis 就需要分配「更大的内存空间」，这个操作耗时就会变长，影响性能。</p><div><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20220219225247.png style=display:block;margin-left:auto;margin-right:auto;width:60% alt=20220219225247></div><p>所以，当你在使用 SETBIT 时，也一定要注意 offset 的大小，操作过大的 offset 也会引发 Redis 卡顿。</p><p>这种类型的 key，也是典型的 bigkey，除了分配内存影响性能之外，在删除它时，耗时同样也会变长。</p><h3 id=执行-monitor-也会导致-redis-oom><strong>执行 MONITOR 也会导致 Redis OOM？</strong></h3><p>当你在执行 MONITOR 命令时，Redis 会把每一条命令写到客户端的「输出缓冲区」中，然后客户端从这个缓冲区读取服务端返回的结果。</p><div><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20220219225329.png style=display:block;margin-left:auto;margin-right:auto;width:80% alt=20220219225329></div><p>但是，如果你的 Redis QPS 很高，这将会导致这个输出缓冲区内存持续增长，占用 Redis 大量的内存资源，如果恰好你的机器的内存资源不足，那 Redis 实例就会面临被 OOM 的风险。</p><p>所以，你需要谨慎使用 MONITOR，尤其在 QPS 很高的情况下。</p><h2 id=持久化问题>持久化问题</h2><p>Redis 的数据持久化，分为 RDB 和 AOF 两种方式。其中，RDB 是数据快照，而 AOF 会记录每一个写命令到日志文件中。</p><h3 id=master-宕机slave-数据也丢失了><strong>master 宕机，slave 数据也丢失了？</strong></h3><p>如果你的 Redis 采用如下模式部署，就会发生数据丢失的问题：</p><ul><li>master-slave + 哨兵部署实例</li><li>master 没有开启数据持久化功能</li><li>Redis 进程使用 supervisor 管理，并配置为「进程宕机，自动重启」</li></ul><p>如果此时 master 宕机，就会导致下面的问题：</p><ul><li>master 宕机，哨兵还未发起切换，此时 master 进程立即被 supervisor 自动拉起</li><li>但 master 没有开启任何数据持久化，启动后是一个「空」实例</li><li>此时 slave 为了与 master 保持一致，它会自动「清空」实例中的所有数据，slave 也变成了一个「空」实例</li></ul><p>看到了么？在这个场景下，master / slave 的数据就全部丢失了。</p><p>这时，业务应用在访问 Redis 时，发现缓存中没有任何数据，就会把请求全部打到后端数据库上，这还会进一步引发「缓存雪崩」，对业务影响非常大。</p><p>所以，你一定要避免这种情况发生，我给你的建议是：</p><ol><li>Redis 实例不使用进程管理工具自动拉起</li><li>master 宕机后，让哨兵发起切换，把 slave 提升为 master</li><li>切换完成后，再重启 master，让其退化成 slave</li></ol><h3 id=aof-everysec-真的不会阻塞主线程吗><strong>AOF everysec 真的不会阻塞主线程吗？</strong></h3><p>当 Redis 开启 AOF 时，需要配置 AOF 的刷盘策略。基于性能和数据安全的平衡，你肯定会采用 appendfsync everysec 这种方案。</p><p>这种方案的工作模式为，Redis 的后台线程每间隔 1 秒，就把 AOF page cache 的数据，刷到磁盘（fsync）上。</p><p>其优势在于，把 AOF 刷盘的耗时操作，放到了后台线程中去执行，避免了对主线程的影响。</p><p>但真的不会影响主线程吗？答案是否定的。</p><p>其实存在这样一种场景：<strong>Redis 后台线程在执行 AOF page cache 刷盘（fysnc）时，如果此时磁盘 IO 负载过高，那么调用 fsync 就会被阻塞住。</strong></p><p>此时，主线程仍然接收写请求进来，那么此时的主线程会先判断，上一次后台线程是否已刷盘成功。</p><p>如何判断呢？</p><p>后台线程在刷盘成功后，都会记录刷盘的时间。</p><p>主线程会根据这个时间来判断，距离上一次刷盘已经过去多久了。整个流程是这样的：</p><ol><li>主线程在写 AOF page cache（write系统调用）前，先检查后台 fsync 是否已完成？</li><li>fsync 已完成，主线程直接写 AOF page cache</li><li>fsync 未完成，则检查距离上次 fsync 过去多久？</li><li>如果距离上次 fysnc 成功在 2 秒内，那么主线程会直接返回，不写 AOF page cache</li><li>如果距离上次 fysnc 成功超过了 2 秒，那主线程会强制写 AOF page cache（write系统调用）</li><li>由于磁盘 IO 负载过高，此时，后台线程 fynsc 会发生阻塞，那主线程在写 AOF page cache 时，也会发生阻塞等待（操作同一个 fd，fsync 和 write 是互斥的，一方必须等另一方成功才可以继续执行，否则阻塞等待）</li></ol><div><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20220219225617.png style=display:block;margin-left:auto;margin-right:auto;width:80% alt=20220219225617></div><p>通过分析我们可以发现，即使你配置的 AOF 刷盘策略是 appendfsync everysec，也依旧会有阻塞主线程的风险。</p><p>其实，产生这个问题的重点在于，磁盘 IO 负载过高导致 fynsc 阻塞，进而导致主线程写 AOF page cache 也发生阻塞。</p><p>所以，你一定要保证磁盘有充足的 IO 资源，避免这个问题。</p><h3 id=aof-everysec-真的只会丢失-1-秒数据><strong>AOF everysec 真的只会丢失 1 秒数据？</strong></h3><p>如上所述，这里我们需要重点关注上面的步骤 4。</p><p>也就是：主线程在写 AOF page cache 时，会先判断上一次 fsync 成功的时间，如果距离上次 fysnc 成功在 2 秒内，那么主线程会直接返回，不再写 AOF page cache。</p><p>这就意味着，<strong>后台线程在执行 fsync 刷盘时，主线程最多等待 2 秒不会写 AOF page cache。</strong></p><p>如果此时 Redis 发生了宕机，那么，AOF 文件中丢失是 2 秒的数据，而不是 1 秒！</p><p>我们继续分析，Redis 主线程为什么要等待 2 秒不写 AOF page cache 呢？</p><p>其实，Redis AOF 配置为 appendfsync everysec 时，正常来讲，后台线程每隔 1 秒执行一次 fsync 刷盘，如果磁盘资源充足，是不会被阻塞住的。</p><p>也就是说，Redis 主线程其实根本不用关心后台线程是否刷盘成功，只要无脑写 AOF page cache 即可。</p><p>但是，Redis 作者考虑到，如果此时的磁盘 IO 资源比较紧张，那么后台线程 fsync 就有概率发生阻塞风险。</p><p>所以，Redis 作者在主线程写 AOF page cache 之前，先检查一下距离上一次 fsync 成功的时间，如果大于 1 秒没有成功，那么主线程此时就能知道，fsync 可能阻塞了。</p><p>所以，主线程会等待 2 秒不写 AOF page cache，其目的在于：</p><ol><li>降低主线程阻塞的风险（如果无脑写 AOF page cache，主线程则会立即阻塞住）</li><li>如果 fsync 阻塞，主线程就会给后台线程留出 1 秒的时间，等待 fsync 成功</li></ol><p>但代价就是，如果此时发生宕机，AOF 丢失的就是 2 秒的数据，而不是 1 秒。</p><p>这个方案应该是 Redis 作者对性能和数据安全性的进一步权衡。</p><p>无论如何，这里你只需要知道的是，即使 AOF 配置为每秒刷盘，在发生上述极端情况时，AOF 丢失的数据其实是 2 秒。</p><h3 id=rdb-和-aof-rewrite-时redis-发生-oom><strong>RDB 和 AOF rewrite 时，Redis 发生 OOM？</strong></h3><p>最后，我们来看一下，当 Redis 在执行 RDB 快照和 AOF rewrite 时，会发生的问题。</p><p>Redis 在做 RDB 快照和 AOF rewrite 时，会采用创建子进程的方式，把实例中的数据持久化到磁盘上。</p><p>创建子进程，会调用操作系统的 fork 函数。</p><p>fork 执行完成后，父进程和子进程会同时共享同一份内存数据。</p><p>但此时的主进程依旧是可以接收写请求的，而进来的写请求，会采用 Copy On Write（写时复制）的方式操作内存数据。</p><p>也就是说，主进程一旦有数据需要修改，Redis 并不会直接修改现有内存中的数据，而是先将这块内存数据拷贝出来，再修改这块新内存的数据，这就是所谓的「写时复制」。</p><p>写时复制你也可以理解成，谁需要发生写操作，谁就先拷贝，再修改。</p><p>你应该发现了，如果父进程要修改一个 key，就需要拷贝原有的内存数据，到新内存中，这个过程涉及到了「新内存」的申请。</p><p>如果你的业务特点是「写多读少」，而且 OPS 非常高，那在 RDB 和 AOF rewrite 期间，就会产生大量的内存拷贝工作。</p><p>这会有什么问题呢？</p><p><strong>因为写请求很多，这会导致 Redis 父进程会申请非常多的内存。在这期间，修改 key 的范围越广，新内存的申请就越多。</strong></p><p>如果你的机器内存资源不足，这就会导致 Redis 面临被 OOM 的风险！</p><div><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20220219225805.png style=display:block;margin-left:auto;margin-right:auto;width:80% alt=20220219225805></div><p>这就是你会从 DBA 同学那里听到的，要给 Redis 机器预留内存的原因。</p><p>其目的就是避免在 RDB 和 AOF rewrite 期间，防止 Redis OOM。</p><p>以上这些，就是「数据持久化」会遇到的坑，你踩到过几个？</p><p>下面我们再来看「主从复制」会存在哪些问题。</p><h2 id=主从复制问题>主从复制问题</h2><p>Redis 为了保证高可用，提供了主从复制的方式，这样就可以保证 Redis 有多个「副本」，当主库宕机后，我们依旧有从库可以使用。</p><h3 id=主从复制会丢数据吗><strong>主从复制会丢数据吗？</strong></h3><p>首先，你需要知道，Redis 的主从复制是采用「异步」的方式进行的。</p><p>这就意味着，如果 master 突然宕机，可能存在有部分数据还未同步到 slave 的情况发生。</p><p>这会导致什么问题呢？</p><p>如果你把 Redis 当做纯缓存来使用，那对业务来说没有什么影响。</p><p>master 未同步到 slave 的数据，业务应用可以从后端数据库中重新查询到。</p><p>但是，对于把 Redis 当做数据库，或是当做分布式锁来使用的业务，有可能因为异步复制的问题，导致数据丢失 / 锁丢失。</p><blockquote><p>关于 Redis 分布式锁可靠性的更多细节，这里先不展开，后面会单独写一篇文章详细剖析这个知识点。这里你只需要先知道，Redis 主从复制是有概率发生数据丢失的。</p></blockquote><h3 id=同样命令查询一个-key主从库却返回不同的结果><strong>同样命令查询一个 key，主从库却返回不同的结果？</strong></h3><p>不知道你是否思考过这样一个问题：<strong>如果一个 key 已过期，但这个 key 还未被 master 清理，此时在 slave 上查询这个 key，会返回什么结果呢？</strong></p><ol><li>slave 正常返回 key 的值</li><li>slave 返回 NULL</li></ol><p>你认为是哪一种？可以思考一下。</p><p>答案是：<strong>不一定</strong>。</p><p>嗯？为什么会不一定？</p><p>其实，返回什么结果，这要取决于以下 3 个因素：</p><ol><li>Redis 的版本</li><li>具体执行的命令</li><li>机器时钟</li></ol><p>先来看 Redis 版本。</p><p>如果你使用的是 Redis 3.2 以下版本，只要这个 key 还未被 master 清理，那么，在 slave 上查询这个 key，它会永远返回 value 给你。</p><p><strong>也就是说，即使这个 key 已过期，在 slave 上依旧可以查询到这个 key。</strong></p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>// Redis 2.8 版本 在 slave 上执行
</span></span><span style=display:flex><span>127.0.0.1:6479&gt; TTL testkey
</span></span><span style=display:flex><span>(integer) -2    // 已过期
</span></span><span style=display:flex><span>127.0.0.1:6479&gt; GET testkey
</span></span><span style=display:flex><span>&#34;testval&#34;       // 还能查询到!
</span></span></code></pre></div><p>但如果此时在 master 上查询这个 key，发现已经过期，就会把它清理掉，然后返回 NULL。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>// Redis 2.8 版本 在 master 上执行
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; TTL testkey
</span></span><span style=display:flex><span>(integer) -2
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; GET testkey
</span></span><span style=display:flex><span>(nil)
</span></span></code></pre></div><p>发现了吗？在 master 和 slave 上查询同一个 key，结果竟然不一样？</p><p>其实，slave 应该要与 master 保持一致，key 已过期，就应该给客户端返回 NULL，而不是还正常返回 key 的值。</p><p>为什么会发生这种情况？</p><p>其实这是 Redis 的一个 Bug：<strong>3.2 以下版本的 Redis，在 slave 上查询一个 key 时，并不会判断这个 key 是否已过期，而是直接无脑返回给客户端结果。</strong></p><p>这个 Bug 在 3.2 版本进行了修复，但是，它修复得「不够彻底」。</p><p>什么叫修复得「不够彻底」？</p><p>这就要结合前面提到的，第 2 个影响因素「具体执行的命令」来解释了。</p><p>Redis 3.2 虽然修复了这个 Bug，但却遗漏了一个命令：<strong>EXISTS</strong>。</p><p>也就是说，一个 key 已过期，在 slave 直接查询它的数据，例如执行 GET/LRANGE/HGETALL/SMEMBERS/ZRANGE 这类命令时，slave 会返回 NULL。</p><p>但如果执行的是 EXISTS，slave 依旧会返回：<strong>key 还存在</strong>。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>// Redis 3.2 版本 在 slave 上执行
</span></span><span style=display:flex><span>127.0.0.1:6479&gt; GET testkey
</span></span><span style=display:flex><span>(nil)           // key 已逻辑过期
</span></span><span style=display:flex><span>127.0.0.1:6479&gt; EXISTS testkey
</span></span><span style=display:flex><span>(integer) 1     // 还存在！
</span></span></code></pre></div><p>原因在于，EXISTS 与查询数据的命令，使用的不是同一个方法。</p><p>Redis 作者只在查询数据时增加了过期时间的校验，但 EXISTS 命令依旧没有这么做。</p><p>直到 Redis 4.0.11 这个版本，Redis 才真正把这个遗漏的 Bug 完全修复。</p><p>如果你使用的是这个之上的版本，那在 slave 上执行数据查询或 EXISTS，对于已过期的 key，就都会返回「不存在」了。</p><p>这里我们先小结一下，slave 查询过期 key，经历了 3 个阶段：</p><ol><li>3.2 以下版本，key 过期未被清理，无论哪个命令，查询 slave，均正常返回 value</li><li>3.2 - 4.0.11 版本，查询数据返回 NULL，但 EXISTS 依旧返回 true</li><li>4.0.11 以上版本，所有命令均已修复，过期 key 在 slave 上查询，均返回「不存在」</li></ol><p>最后，我们来看影响查询结果的第 3 个因素：「机器时钟」。</p><p>假设我们已规避了上面提到的版本 Bug，例如，我们使用 Redis 5.0 版本，在 slave 查询一个 key，还会和 master 结果不同吗？</p><p>答案是，还是有可能会的。</p><p>这就与 master / slave 的机器时钟有关了。</p><p>无论是 master 还是 slave，在判断一个 key 是否过期时，都是基于「本机时钟」来判断的。</p><p>如果 slave 的机器时钟比 master 走得「快」，那就会导致，即使这个 key 还未过期，但以 slave 上视角来看，这个 key 其实已经过期了，那客户端在 slave 上查询时，就会返回 NULL。</p><p>是不是很有意思？一个小小的过期 key，竟然藏匿这么多猫腻。</p><p>如果你也遇到了类似的情况，就可以通过上述步骤进行排查，确认是否踩到了这个坑。</p><h3 id=主从切换会导致缓存雪崩><strong>主从切换会导致缓存雪崩？</strong></h3><p>这个问题是上一个问题的延伸。</p><p>我们假设，slave 的机器时钟比 master 走得「快」，而且是「快很多」。</p><p>此时，从 slave 角度来看，Redis 中的数据存在「大量过期」。</p><p>如果此时操作「主从切换」，把 slave 提升为新的 master。</p><p>它成为 master 后，就会开始大量清理过期 key，此时就会导致以下结果：</p><ol><li>master 大量清理过期 key，主线程发生阻塞，无法及时处理客户端请求</li><li>Redis 中数据大量过期，引发缓存雪崩</li></ol><p>你看，当 master / slave 机器时钟严重不一致时，对业务的影响非常大！</p><p>所以，如果你是 DBA 运维，一定要保证主从库的机器时钟一致性，避免发生这些问题。</p><h3 id=master--slave-大量数据不一致><strong>master / slave 大量数据不一致？</strong></h3><p>还有一种场景，会导致 master / slave 的数据存在大量不一致。</p><p>这就涉及到 Redis 的 maxmemory 配置了。</p><p>Redis 的 maxmemory 可以控制整个实例的内存使用上限，超过这个上限，并且配置了淘汰策略，那么实例就开始淘汰数据。</p><p>但这里有个问题：<strong>假设 master / slave 配置的 maxmemory 不一样，那此时就会发生数据不一致。</strong></p><p>例如，master 配置的 maxmemory 为 5G，而 slave 的 maxmemory 为 3G，当 Redis 中的数据超过 3G 时，slave 就会「提前」开始淘汰数据，此时主从库数据发生不一致。</p><div><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20220219230213.png style=display:block;margin-left:auto;margin-right:auto;width:80% alt=20220219230213></div><p>另外，尽管 master / slave 设置的 maxmemory 相同，如果你要调整它们的上限，也要格外注意，否则也会导致 slave 淘汰数据：</p><ul><li>调大 maxmemory 时，先调整 slave，再调整 master</li><li>调小 maxmemory 时，先调整 master，再调整 slave</li></ul><p>以此方式操作，就避免了 slave 提前超过 maxmemory 的问题。</p><p>其实，你可以思考一下，发生这些问题的关键在哪？</p><p>其根本原因在于，<strong>slave 超过 maxmemory 后，会「自行」淘汰数据</strong>。</p><p>如果不让 slave 自己淘汰数据，那这些问题是不是都可以规避了？</p><p>没错。</p><p>针对这个问题，Redis 官方应该也收到了很多用户的反馈。在 Redis 5.0 版本，官方终于把这个问题彻底解决了！</p><p>Redis 5.0 增加了一个配置项：replica-ignore-maxmemory，默认 yes。</p><p>这个参数表示，尽管 slave 内存超过了 maxmemory，也不会自行淘汰数据了！</p><p><strong>这样一来，slave 永远会向 master 看齐，只会老老实实地复制 master 发送过来的数据，不会自己再搞「小动作」。</strong></p><p>至此，master / slave 的数据就可以保证完全一致了！</p><blockquote><p>如果你使用的恰好是 5.0 版本，就不用担心这个问题了。</p></blockquote><h3 id=slave-竟然会有内存泄露问题><strong>slave 竟然会有内存泄露问题？</strong></h3><p>是的，你没看错。</p><p>这是怎么发生的？我们具体来看一下。</p><p>当你在使用 Redis 时，符合以下场景，就会触发 slave 内存泄露：</p><ul><li>Redis 使用的是 4.0 以下版本</li><li>slave 配置项为 read-only=no（从库可写）</li><li>向 slave 写入了有过期时间的 key</li></ul><p>这时的 slave 就会发生内存泄露：<strong>slave 中的 key，即使到了过期时间，也不会自动清理。</strong></p><p>如果你不主动删除它，那这些 key 就会一直残留在 slave 内存中，消耗 slave 的内存。</p><p>最麻烦的是，你使用命令查询这些 key，却还查不到任何结果！</p><p>这就 slave 「内存泄露」问题。</p><div><img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20220219230244.png style=display:block;margin-left:auto;margin-right:auto;width:80% alt=20220219230244></div><p>这其实也是 Redis 的一个 Bug，Redis 4.0 才修复了这个问题。</p><p>解决方案是，<strong>在可写的 slave 上，写入带有过期时间 key 时，slave 会「记录」下来这些 key。</strong></p><p>然后 slave 会定时扫描这些 key，如果到达过期时间，则清理之。</p><p>如果你的业务需要在 slave 上临时存储数据，而且这些 key 也都设置了过期时间，那么就要注意这个问题了。</p><p>你需要确认你的 Redis 版本，如果是 4.0 以下版本，一定要避免踩这个坑。</p><p>其实，最好的方案是，制定一个 Redis 使用规范，slave 必须强制设置为 read-only，不允许写，这样不仅可以保证 master / slave 的数据一致性，还避免了 slave 内存泄露问题。</p><h3 id=为什么主从全量同步一直失败><strong>为什么主从全量同步一直失败？</strong></h3><p>在主从全量同步时，你可能会遇到同步失败的问题，具体场景如下：</p><p>slave 向 master 发起全量同步请求，master 生成 RDB 后发给 slave，slave 加载 RDB。</p><p>由于 RDB 数据太大，slave 加载耗时也会变得很长。</p><p>此时你会发现，slave 加载 RDB 还未完成，master 和 slave 的连接却断开了，数据同步也失败了。</p><p>之后你又会发现，slave 又发起了全量同步，master 又生成 RDB 发送给 slave。</p><p>同样地，slave 在加载 RDB 时，master / slave 同步又失败了，以此往复。</p><p>这是怎么回事？</p><p>其实，这就是 Redis 的「复制风暴」问题。</p><p>什么是复制风暴？</p><p>就像刚才描述的：<strong>主从全量同步失败，又重新开始同步，之后又同步失败，以此往复，恶性循环，持续浪费机器资源。</strong></p><p>为什么会导致这种问题呢？</p><p>如果你的 Redis 有以下特点，就有可能发生这种问题：</p><ul><li>master 的实例数据过大，slave 在加载 RDB 时耗时太长</li><li>复制缓冲区（slave client-output-buffer-limit）配置过小</li><li>master 写请求量很大</li></ul><p>主从在全量同步数据时，master 接收到的写请求，会先写到主从「复制缓冲区」中，这个缓冲区的「上限」是配置决定的。</p><p>当 slave 加载 RDB 太慢时，就会导致 slave 无法及时读取「复制缓冲区」的数据，这就引发了复制缓冲区「溢出」。</p><p>为了避免内存持续增长，此时的 master 会「强制」断开 slave 的连接，这时全量同步就会失败。</p><p>之后，同步失败的 slave 又会「重新」发起全量同步，进而又陷入上面描述的问题中，以此往复，恶性循环，这就是所谓的「复制风暴」。</p><p>如何解决这个问题呢？我给你以下几点建议：</p><ol><li>Redis 实例不要太大，避免过大的 RDB</li><li>复制缓冲区配置的尽量大一些，给 slave 加载 RDB 留足时间，降低全量同步失败的概率</li></ol><p>如果你也踩到了这个坑，可以通过这个方案来解决。</p></div></main></div></div><footer class="bg-dark py-5 row d-print-none"><div class="container-fluid mx-sm-5"><div class=row><div class="col-6 col-sm-4 text-xs-center order-sm-2"></div><div class="col-6 col-sm-4 text-right text-xs-center order-sm-3"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=GitHub aria-label=GitHub><a class=text-white target=_blank rel="noopener noreferrer" href=https://github.com/infilos><i class="fab fa-github"></i></a></li></ul></div><div class="col-12 col-sm-4 text-center py-2 order-sm-2"><small class=text-white>&copy; 2022 infilos.com All Rights Reserved</small></div></div></div></footer></div><script src=/js/popper.min.js integrity=sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49 crossorigin=anonymous></script>
<script src=/js/bootstrap.min.js integrity=sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy crossorigin=anonymous></script>
<script src=/js/main.min.7d5b92c4889cf0554b0ea5e2309b0b81b196aa7c9a235632938a25d9fc4d8a7c.js integrity="sha256-fVuSxIic8FVLDqXiMJsLgbGWqnyaI1Yyk4ol2fxNinw=" crossorigin=anonymous></script></body></html>