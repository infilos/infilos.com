<!doctype html><html lang=zh class=no-js>
<head>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=generator content="Hugo 0.89.3">
<meta name=ROBOTS content="INDEX, FOLLOW">
<link rel=canonical type=text/html href=/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/redis/>
<link rel="shortcut icon" href=/favicons/favicon.ico>
<link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180>
<link rel=icon type=image/png href=/favicons/favicon-16x16.png sizes=16x16>
<link rel=icon type=image/png href=/favicons/favicon-32x32.png sizes=32x32>
<link rel=icon type=image/png href=/favicons/android-36x36.png sizes=36x36>
<link rel=icon type=image/png href=/favicons/android-48x48.png sizes=48x48>
<link rel=icon type=image/png href=/favicons/android-72x72.png sizes=72x72>
<link rel=icon type=image/png href=/favicons/android-96x96.png sizes=96x96>
<link rel=icon type=image/png href=/favicons/android-144x144.png sizes=144x144>
<link rel=icon type=image/png href=/favicons/android-192x192.png sizes=192x192>
<title>Redis | infilos.com</title><meta property="og:title" content="Redis">
<meta property="og:description" content="Infilos Wiki Website">
<meta property="og:type" content="website">
<meta property="og:url" content="/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/redis/"><meta property="og:site_name" content="infilos.com">
<meta itemprop=name content="Redis">
<meta itemprop=description content="Infilos Wiki Website"><meta name=twitter:card content="summary">
<meta name=twitter:title content="Redis">
<meta name=twitter:description content="Infilos Wiki Website">
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga('create','UA-123062585-1','auto'),ga('send','pageview'))</script>
<script async src=https://www.google-analytics.com/analytics.js></script>
<link rel=preload href=/scss/main.min.847464b684a6e89d7276700a5c500c17ab494dd1755b2654a7b27d8b59e3347e.css as=style>
<link href=/scss/main.min.847464b684a6e89d7276700a5c500c17ab494dd1755b2654a7b27d8b59e3347e.css rel=stylesheet integrity>
<script src=/js/jquery-3.5.1.min.js integrity="sha256-9/aliU8dGd2tb6OSsuzixeV4y/faTqgFtohetphbbj0=" crossorigin=anonymous></script>
</head>
<body class=td-section>
<header>
<nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-column flex-md-row td-navbar">
<a class=navbar-brand href=/>
<span class=navbar-logo><svg id="Capa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 512 512" style="enable-background:new 0 0 512 512"><path style="fill:#ffc107" d="M432.384 143.616c-4.165-4.164-10.917-4.164-15.083.0l-60.352 60.352c-4.164 4.165-4.164 10.917.0 15.083 21.187 20.463 54.951 19.876 75.413-1.311 19.962-20.668 19.962-53.435.0-74.102L432.384 143.616z"/><path style="fill:#607d8b" d="M42.667 277.334c-5.891.003-10.669-4.771-10.672-10.662-.002-4.338 2.623-8.245 6.64-9.882l234.667-96c5.455-2.233 11.687.38 13.92 5.835s-.38 11.687-5.835 13.92l-234.667 96C45.433 277.069 44.056 277.337 42.667 277.334z"/><path style="fill:#546e7a" d="M391.552 56.448l-32-32C343.938 8.745 322.689-.059 300.544.0h-3.755c-46.082.024-83.432 37.374-83.456 83.456v3.755c-.053 22.138 8.75 43.377 24.448 58.987l32 32c4.165 4.164 10.917 4.164 15.083.0L391.531 71.531C395.701 67.372 395.71 60.62 391.552 56.448z"/><path style="fill:#607d8b" d="M160 469.334c-3.279.006-6.379-1.497-8.405-4.075L34.261 315.926c-3.635-4.636-2.823-11.341 1.813-14.976s11.341-2.823 14.976 1.813l117.333 149.333c3.629 4.641 2.809 11.344-1.832 14.973C164.681 468.533 162.375 469.329 160 469.334z"/><path style="fill:#455a64" d="M487.467 86.848l-3.669-3.648c-37.687-36.557-97.71-36.197-134.955.811l-51.413 51.413c-36.996 37.25-37.357 97.263-.811 134.955l3.584 3.669c1.7 2.457 4.671 3.706 7.616 3.2 2.831.005 5.548-1.115 7.552-3.115l172.181-172.181c4.189-4.143 4.226-10.896.083-15.085-.028-.028-.055-.056-.083-.083L487.467 86.848z"/><g><path style="fill:#ffc107" d="M501.333 192H480c-5.891.0-10.667-4.776-10.667-10.667s4.776-10.667 10.667-10.667h21.333c5.891.0 10.667 4.776 10.667 10.667S507.225 192 501.333 192z"/><path style="fill:#ffc107" d="M394.667 298.667c-5.891.0-10.667-4.776-10.667-10.667v-21.333c0-5.891 4.776-10.667 10.667-10.667 5.891.0 10.667 4.776 10.667 10.667V288C405.333 293.891 400.558 298.667 394.667 298.667z"/><path style="fill:#ffc107" d="M480 277.334c-2.831.005-5.548-1.115-7.552-3.115l-21.333-21.333c-4.093-4.237-3.975-10.99.262-15.083 4.134-3.993 10.687-3.993 14.821.0l21.333 21.333c4.159 4.172 4.148 10.926-.024 15.085C485.514 276.209 482.815 277.327 480 277.334z"/></g><g><path style="fill:#455a64" d="M266.667 448H96c-29.455.0-53.333 23.878-53.333 53.333.0 5.891 4.776 10.667 10.667 10.667h256c5.891.0 10.667-4.776 10.667-10.667C320 471.878 296.122 448 266.667 448z"/><circle style="fill:#455a64" cx="32" cy="288" r="32"/></g><g/><g/><g/><g/><g/><g/><g/><g/><g/><g/><g/><g/><g/><g/><g/></svg></span><span class=font-weight-bold>infilos.com</span>
</a>
<div class="collapse navbar-collapse" id=navbarSupportedContent>
<ul class="navbar-nav mr-auto">
<li class=nav-item style=max-width:90px;min-width:10px>
<a class=nav-link href=/%e5%9f%ba%e7%a1%80%e7%9f%a5%e8%af%86>
<span>基础</span>
</a>
</li>
<li class=nav-item style=max-width:90px;min-width:10px>
<a class=nav-link href=/%e7%bc%96%e7%a8%8b%e8%af%ad%e8%a8%80>
<span>语言</span>
</a>
</li>
<li class=nav-item style=max-width:90px;min-width:10px>
<a class=nav-link href=/%e6%a1%86%e6%9e%b6%e4%b8%8e%e5%ba%93>
<span>框架库</span>
</a>
</li>
<li class="nav-item dropdown" style=max-width:90px;min-width:10px>
<a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>
分布式
<span>+</span>
</a>
<div class=dropdown-menu aria-labelledby=navbarDropdown>
<a class=dropdown-item href=/%e5%88%86%e5%b8%83%e5%bc%8f/base>基本构成</a>
</div>
</li>
<li class="nav-item dropdown" style=max-width:90px;min-width:10px>
<a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>
大数据
<span>+</span>
</a>
<div class=dropdown-menu aria-labelledby=navbarDropdown>
<a class=dropdown-item href=/%e5%ad%98%e5%82%a8%e7%b3%bb%e7%bb%9f>存储系统</a>
<a class=dropdown-item href=/%e6%9f%a5%e8%af%a2%e7%b3%bb%e7%bb%9f>查询系统</a>
<a class=dropdown-item href=/%e6%b6%88%e6%81%af%e7%b3%bb%e7%bb%9f>消息系统</a>
<a class=dropdown-item href=/%e5%a4%84%e7%90%86%e7%b3%bb%e7%bb%9f>处理系统</a>
<a class=dropdown-item href=/%e6%95%b0%e6%8d%ae%e6%b2%bb%e7%90%86>数据治理</a>
</div>
</li>
<li class="nav-item dropdown" style=max-width:90px;min-width:10px>
<a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>
中后台
<span>+</span>
</a>
<div class=dropdown-menu aria-labelledby=navbarDropdown>
<a class=dropdown-item href=/%e5%9f%ba%e7%a1%80%e8%ae%be%e6%96%bd>基础设施</a>
<a class=dropdown-item href=/%e7%94%a8%e6%88%b7%e7%b3%bb%e7%bb%9f>用户系统</a>
<a class=dropdown-item href=/%e4%ba%a4%e4%ba%92%e7%95%8c%e9%9d%a2>交互界面</a>
<a class=dropdown-item href=/%e4%b8%9a%e5%8a%a1%e7%b3%bb%e7%bb%9f>业务系统</a>
</div>
</li>
<li class=nav-item style=max-width:90px;min-width:10px>
<a class=nav-link href=/%e6%a8%a1%e5%bc%8f%e6%9e%b6%e6%9e%84>
<span>模式架构</span>
</a>
</li>
<li class=nav-item style=max-width:90px;min-width:10px>
<a class=nav-link href=/%e9%9d%a2%e8%af%95%e9%97%ae%e7%ad%94>
<span>面试</span>
</a>
</li>
<li class=nav-item style=max-width:90px;min-width:10px>
<a class=nav-link href=/%e7%ae%a1%e7%90%86%e8%b7%af%e5%be%84>
<span>管理</span>
</a>
</li>
<li class=nav-item style=max-width:90px;min-width:10px>
<a class=nav-link href=/%e5%bc%80%e6%ba%90%e9%a1%b9%e7%9b%ae>
<span>开源</span>
</a>
</li>
</ul>
<div class="form-inline my-2 my-lg-0">
<div class="nav-item nav-search-item my-2 my-md-0">
<input type=search class="form-control td-search-input" placeholder="&#xf002; 站内搜索…" aria-label=站内搜索… autocomplete=off>
</div>
</div>
</div>
</nav>
</header>
<div class="container-fluid td-outer">
<div class=td-main>
<div class="row flex-xl-nowrap">
<div class="col-12 col-md-3 col-xl-2 td-sidebar d-print-none">
</div>
<div class="d-none d-xl-block col-xl-2 td-toc d-print-none">
</div>
<main class="col-12 col-md-9 col-xl-8 pl-md-5" role=main>
<div class=td-content>
<div class="pageinfo pageinfo-primary d-print-none">
<p>
这是本节的多页打印视图。
<a href=# onclick="return print(),!1">点击此处打印</a>.
</p><p>
<a href=/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/redis/>返回本页常规视图</a>.
</p>
</div>
<h1 class=title>Redis</h1>
<ul>
<li>1: <a href=#pg-15dc494595c2bd4672f094c19c69802f>CH01-基本类型</a></li>
<li>2: <a href=#pg-74fbd382412792c903e2f596fdcce9b7>CH02-高级类型</a></li>
<li>3: <a href=#pg-fa602568c373b012706150061f875875>CH03-Stream</a></li>
<li>4: <a href=#pg-f39b5b7bdbb59acf255fb62ce2763d03>CH04-对象机制</a></li>
<li>5: <a href=#pg-d6ad1d4083c795b0ad006b6fb71ea3c7>CH05-底层结构</a></li>
</ul>
<div class=content>
</div>
</div>
<div class=td-content>
<h1 id=pg-15dc494595c2bd4672f094c19c69802f>1 - CH01-基本类型</h1>
<h2 id=概览>概览</h2>
<p>Redis 中所有的 Key 都是字符串。我们在谈基础数据结构时，讨论的是存储值的数据类型，主要包括常见的5种数据类型，分别是：String、List、Set、Zset、Hash。</p>
<div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210504125755.png style=display:block;width:50% alt=NAME align=center> </div>
<table>
<thead>
<tr>
<th>结构类型</th>
<th>值的形式</th>
<th>读写能力</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>String</strong></td>
<td>字符串、整数、浮点数</td>
<td>对整个字符串或字符串的一部分进行操作；对整数或浮点数进行自增或自减操作；</td>
</tr>
<tr>
<td><strong>List</strong></td>
<td>由字符串构造的链表</td>
<td>对链表的两端进行push和pop操作，读取单个或多个元素；根据值查找或删除元素；</td>
</tr>
<tr>
<td><strong>Set</strong></td>
<td>由无重复字符串构成的集合</td>
<td>字符串的集合，包含基础的方法有看是否存在添加、获取、删除；还包含计算交集、并集、差集等</td>
</tr>
<tr>
<td><strong>Hash</strong></td>
<td>由键值对构成的无序散列表</td>
<td>包含方法有添加、获取、删除单个元素</td>
</tr>
<tr>
<td><strong>Zset</strong></td>
<td>由键值对构成的有序集合</td>
<td>字符串成员与浮点数分数之间的有序映射；元素的排列顺序由分数的大小决定；包含方法有添加、获取、删除单个元素以及根据分值范围或成员来获取元素</td>
</tr>
</tbody>
</table>
<h2 id=string>String</h2>
<p>String是redis中最基本的数据类型，一个key对应一个value。</p>
<div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210504130432.png style=display:block;width:50% alt=NAME align=center> </div>
<h3 id=常用命令>常用命令</h3>
<table>
<thead>
<tr>
<th>命令</th>
<th>简述</th>
<th>使用</th>
</tr>
</thead>
<tbody>
<tr>
<td>GET</td>
<td>获取存储在给定键中的值</td>
<td>GET name</td>
</tr>
<tr>
<td>SET</td>
<td>设置存储在给定键中的值</td>
<td>SET name value</td>
</tr>
<tr>
<td>DEL</td>
<td>删除存储在给定键中的值</td>
<td>DEL name</td>
</tr>
<tr>
<td>INCR</td>
<td>将键存储的值加1</td>
<td>INCR key</td>
</tr>
<tr>
<td>DECR</td>
<td>将键存储的值减1</td>
<td>DECR key</td>
</tr>
<tr>
<td>INCRBY</td>
<td>将键存储的值加上整数</td>
<td>INCRBY key amount</td>
</tr>
<tr>
<td>DECRBY</td>
<td>将键存储的值减去整数</td>
<td>DECRBY key amount</td>
</tr>
</tbody>
</table>
<h3 id=应用场景>应用场景</h3>
<ul>
<li>
<p><strong>缓存</strong>： 经典使用场景，把常用信息，字符串，图片或者视频等信息放到redis中，redis作为缓存层，mysql做持久化层，降低mysql的读写压力。</p>
</li>
<li>
<p><strong>计数器</strong>：redis是单线程模型，一个命令执行完才会执行下一个，同时数据可以一步落地到其他的数据源。</p>
</li>
<li>
<p><strong>session</strong>：常见方案spring session + redis实现session共享</p>
</li>
</ul>
<h2 id=list>List</h2>
<p>Redis中的List其实就是链表（Redis用双端链表实现List）。</p>
<div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210504130444.png style=display:block;width:50% alt=NAME align=center> </div>
<h3 id=常用命令-1>常用命令</h3>
<table>
<thead>
<tr>
<th>命令</th>
<th>简述</th>
<th>使用</th>
</tr>
</thead>
<tbody>
<tr>
<td>RPUSH</td>
<td>将给定值推入到列表右端</td>
<td>RPUSH key value</td>
</tr>
<tr>
<td>LPUSH</td>
<td>将给定值推入到列表左端</td>
<td>LPUSH key value</td>
</tr>
<tr>
<td>RPOP</td>
<td>从列表的右端弹出一个值，并返回被弹出的值</td>
<td>RPOP key</td>
</tr>
<tr>
<td>LPOP</td>
<td>从列表的左端弹出一个值，并返回被弹出的值</td>
<td>LPOP key</td>
</tr>
<tr>
<td>LRANGE</td>
<td>获取列表在给定范围上的所有值</td>
<td>LRANGE key 0 -1</td>
</tr>
<tr>
<td>LINDEX</td>
<td>通过索引获取列表中的元素。你也可以使用负数下标，以 -1 表示列表的最后一个元素， -2 表示列表的倒数第二个元素，以此类推。</td>
<td>LINEX key index</td>
</tr>
</tbody>
</table>
<h3 id=应用场景-1>应用场景</h3>
<ul>
<li><strong>微博TimeLine</strong>: 有人发布微博，用lpush加入时间轴，展示新的列表信息。</li>
<li><strong>消息队列</strong></li>
</ul>
<h2 id=set>Set</h2>
<p>Redis 的 Set 是 String 类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据。</p>
<p>Redis 中集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。</p>
<div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210504130624.png style=display:block;width:50% alt=NAME align=center> </div>
<h3 id=常用命令-2>常用命令</h3>
<table>
<thead>
<tr>
<th>命令</th>
<th>简述</th>
<th>使用</th>
</tr>
</thead>
<tbody>
<tr>
<td>SADD</td>
<td>向集合添加一个或多个成员</td>
<td>SADD key value</td>
</tr>
<tr>
<td>SCARD</td>
<td>获取集合的成员数</td>
<td>SCARD key</td>
</tr>
<tr>
<td>SMEMBER</td>
<td>返回集合中的所有成员</td>
<td>SMEMBER key member</td>
</tr>
<tr>
<td>SISMEMBER</td>
<td>判断 member 元素是否是集合 key 的成员</td>
<td>SISMEMBER key member</td>
</tr>
</tbody>
</table>
<h3 id=应用场景-2>应用场景</h3>
<p><strong>实战场景</strong></p>
<ul>
<li><strong>标签</strong>（tag）,给用户添加标签，或者用户给消息添加标签，这样有同一标签或者类似标签的可以给推荐关注的事或者关注的人。</li>
<li><strong>点赞，或点踩，收藏等</strong>，可以放到set中实现</li>
</ul>
<h2 id=hash>Hash</h2>
<p>Redis hash 是一个 string 类型的 field（字段） 和 value（值） 的映射表，hash 特别适合用于存储对象。</p>
<div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210504130731.png style=display:block;width:50% alt=NAME align=center> </div>
<h3 id=常用命令-3>常用命令</h3>
<table>
<thead>
<tr>
<th>命令</th>
<th>简述</th>
<th>使用</th>
</tr>
</thead>
<tbody>
<tr>
<td>HSET</td>
<td>添加键值对</td>
<td>HSET hash-key sub-key1 value1</td>
</tr>
<tr>
<td>HGET</td>
<td>获取指定散列键的值</td>
<td>HGET hash-key key1</td>
</tr>
<tr>
<td>HGETALL</td>
<td>获取散列中包含的所有键值对</td>
<td>HGETALL hash-key</td>
</tr>
<tr>
<td>HDEL</td>
<td>如果给定键存在于散列中，那么就移除这个键</td>
<td>HDEL hash-key sub-key1</td>
</tr>
</tbody>
</table>
<h3 id=应用场景-3>应用场景</h3>
<ul>
<li><strong>缓存</strong>： 能直观，相比string更节省空间，的维护缓存信息，如用户信息，视频信息等。</li>
</ul>
<h2 id=zset>ZSet</h2>
<p>Redis 有序集合和集合一样也是 string 类型元素的集合,且不允许重复的成员。不同的是每个元素都会关联一个 double 类型的分数。redis 正是通过分数来为集合中的成员进行从小到大的排序。</p>
<p>有序集合的成员是唯一的,但分数(score)却可以重复。集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。</p>
<div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210504130854.png style=display:block;width:50% alt=NAME align=center> </div>
<h3 id=常用命令-4>常用命令</h3>
<table>
<thead>
<tr>
<th>命令</th>
<th>简述</th>
<th>使用</th>
</tr>
</thead>
<tbody>
<tr>
<td>ZADD</td>
<td>将一个带有给定分值的成员添加到哦有序集合里面</td>
<td>ZADD zset-key 178 member1</td>
</tr>
<tr>
<td>ZRANGE</td>
<td>根据元素在有序集合中所处的位置，从有序集合中获取多个元素</td>
<td>ZRANGE zset-key 0-1 withccores</td>
</tr>
<tr>
<td>ZREM</td>
<td>如果给定元素成员存在于有序集合中，那么就移除这个元素</td>
<td>ZREM zset-key member1</td>
</tr>
</tbody>
</table>
<h3 id=应用场景-4>应用场景</h3>
<ul>
<li><strong>排行榜</strong>：有序集合经典使用场景。例如小说视频等网站需要对用户上传的小说视频做排行榜，榜单可以按照用户关注数，更新时间，字数等打分，做排行。</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-74fbd382412792c903e2f596fdcce9b7>2 - CH02-高级类型</h1>
<h2 id=hyperloglogs基数>HyperLogLogs：基数</h2>
<h3 id=什么是基数>什么是基数</h3>
<p>举个例子，A = {1, 2, 3, 4, 5}， B = {3, 5, 6, 7, 9}；那么基数（不重复的元素）= 1, 2, 4, 6, 7, 9； （允许容错，即可以接受一定误差）</p>
<h3 id=基本用途>基本用途</h3>
<p>这个结构可以非常省内存的去统计各种计数，比如注册 IP 数、每日访问 IP 数、页面实时UV、在线用户数，共同好友数等。</p>
<h3 id=结构优点>结构优点</h3>
<p>一个大型的网站，每天 IP 比如有 100 万，粗算一个 IP 消耗 15 字节，那么 100 万个 IP 就是 15M。而 HyperLogLog 在 Redis 中每个键占用的内容都是 12K，理论存储近似接近 2^64 个值，不管存储的内容是什么，它一个基于基数估算的算法，只能比较准确的估算出基数，可以使用少量固定的内存去存储并识别集合中的唯一元素。而且这个估算的基数并不一定准确，是一个带有 0.81% 标准错误的近似值（对于可以接受一定容错的业务场景，比如IP数统计，UV等，是可以忽略不计的）。</p>
<h3 id=操作命令>操作命令</h3>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>127.0.0.1:6379&gt; pfadd key1 a b c d e f g h i	<span style=color:#8f5902;font-style:italic># 创建第一组元素</span>
<span style=color:#ce5c00;font-weight:700>(</span>integer<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#0000cf;font-weight:700>1</span>
127.0.0.1:6379&gt; pfcount key1					<span style=color:#8f5902;font-style:italic># 统计元素的基数数量</span>
<span style=color:#ce5c00;font-weight:700>(</span>integer<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#0000cf;font-weight:700>9</span>
127.0.0.1:6379&gt; pfadd key2 c j k l m e g a		<span style=color:#8f5902;font-style:italic># 创建第二组元素</span>
<span style=color:#ce5c00;font-weight:700>(</span>integer<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#0000cf;font-weight:700>1</span>
127.0.0.1:6379&gt; pfcount key2
<span style=color:#ce5c00;font-weight:700>(</span>integer<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#0000cf;font-weight:700>8</span>
127.0.0.1:6379&gt; pfmerge key3 key1 key2			<span style=color:#8f5902;font-style:italic># 合并两组：key1 key2 -&gt; key3 并集</span>
OK
127.0.0.1:6379&gt; pfcount key3
<span style=color:#ce5c00;font-weight:700>(</span>integer<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#0000cf;font-weight:700>13</span>
</code></pre></div><h2 id=bitmap位图>Bitmap：位图</h2>
<p>Bitmap 即位图数据结构，都是操作二进制位来进行记录，只有0 和 1 两个状态。</p>
<h3 id=基本用途-1>基本用途</h3>
<p>比如：统计用户信息，活跃，不活跃！ 登录，未登录！ 打卡，不打卡！ <strong>两个状态的，都可以使用 Bitmaps</strong>！</p>
<p>如果存储一年的打卡状态需要多少内存呢？ 365 天 = 365 bit 1字节 = 8bit 46 个字节左右！</p>
<h3 id=操作命令-1>操作命令</h3>
<p>使用bitmap 来记录 周一到周日的打卡！ 周一：1 周二：0 周三：0 周四：1 &mldr;&mldr;</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>127.0.0.1:6379&gt; setbit sign <span style=color:#0000cf;font-weight:700>0</span> <span style=color:#0000cf;font-weight:700>1</span>
<span style=color:#ce5c00;font-weight:700>(</span>integer<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#0000cf;font-weight:700>0</span>
127.0.0.1:6379&gt; setbit sign <span style=color:#0000cf;font-weight:700>1</span> <span style=color:#0000cf;font-weight:700>1</span>
<span style=color:#ce5c00;font-weight:700>(</span>integer<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#0000cf;font-weight:700>0</span>
127.0.0.1:6379&gt; setbit sign <span style=color:#0000cf;font-weight:700>2</span> <span style=color:#0000cf;font-weight:700>0</span>
<span style=color:#ce5c00;font-weight:700>(</span>integer<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#0000cf;font-weight:700>0</span>
127.0.0.1:6379&gt; setbit sign <span style=color:#0000cf;font-weight:700>3</span> <span style=color:#0000cf;font-weight:700>1</span>
<span style=color:#ce5c00;font-weight:700>(</span>integer<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#0000cf;font-weight:700>0</span>
127.0.0.1:6379&gt; setbit sign <span style=color:#0000cf;font-weight:700>4</span> <span style=color:#0000cf;font-weight:700>0</span>
<span style=color:#ce5c00;font-weight:700>(</span>integer<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#0000cf;font-weight:700>0</span>
127.0.0.1:6379&gt; setbit sign <span style=color:#0000cf;font-weight:700>5</span> <span style=color:#0000cf;font-weight:700>0</span>
<span style=color:#ce5c00;font-weight:700>(</span>integer<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#0000cf;font-weight:700>0</span>
127.0.0.1:6379&gt; setbit sign <span style=color:#0000cf;font-weight:700>6</span> <span style=color:#0000cf;font-weight:700>1</span>
<span style=color:#ce5c00;font-weight:700>(</span>integer<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#0000cf;font-weight:700>0</span>
</code></pre></div><p>查看某一天是否有打卡！</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>127.0.0.1:6379&gt; getbit sign <span style=color:#0000cf;font-weight:700>3</span>
<span style=color:#ce5c00;font-weight:700>(</span>integer<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#0000cf;font-weight:700>1</span>
127.0.0.1:6379&gt; getbit sign <span style=color:#0000cf;font-weight:700>5</span>
<span style=color:#ce5c00;font-weight:700>(</span>integer<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#0000cf;font-weight:700>0</span>
</code></pre></div><p>统计操作，统计 打卡的天数！</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>127.0.0.1:6379&gt; bitcount sign <span style=color:#8f5902;font-style:italic># 统计这周的打卡记录，就可以看到是否有全勤！</span>
<span style=color:#ce5c00;font-weight:700>(</span>integer<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#0000cf;font-weight:700>3</span>
</code></pre></div><h2 id=geospatial地理位置>Geospatial：地理位置</h2>
<p>用于地理位置坐标的存储与计算。</p>
<h3 id=添加地理位置>添加地理位置</h3>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>127.0.0.1:6379&gt; geoadd china:city 118.76 32.04 manjing 112.55 37.86 taiyuan 123.43 41.80 shenyang
<span style=color:#ce5c00;font-weight:700>(</span>integer<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#0000cf;font-weight:700>3</span>
127.0.0.1:6379&gt; geoadd china:city 144.05 22.52 shengzhen 120.16 30.24 hangzhou 108.96 34.26 xian
<span style=color:#ce5c00;font-weight:700>(</span>integer<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#0000cf;font-weight:700>3</span>
</code></pre></div><h3 id=获取地理位置>获取地理位置</h3>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>127.0.0.1:6379&gt; geopos china:city taiyuan manjing
1<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;112.54999905824661255&#34;</span>
   1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;37.86000073876942196&#34;</span>
2<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;118.75999957323074341&#34;</span>
   1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;32.03999960287850968&#34;</span>
</code></pre></div><h3 id=计算距离>计算距离</h3>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>127.0.0.1:6379&gt; geodist china:city taiyuan shenyang m
<span style=color:#4e9a06>&#34;1026439.1070&#34;</span>
127.0.0.1:6379&gt; geodist china:city taiyuan shenyang km
<span style=color:#4e9a06>&#34;1026.4391&#34;</span>
</code></pre></div><h3 id=范围查找>范围查找</h3>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=color:#8f5902;font-style:italic># 以 100,30 这个坐标为中心, 寻找半径为1000km的城市</span>
127.0.0.1:6379&gt; georadius china:city <span style=color:#0000cf;font-weight:700>110</span> <span style=color:#0000cf;font-weight:700>30</span> <span style=color:#0000cf;font-weight:700>1000</span> km
1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;xian&#34;</span>
2<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;hangzhou&#34;</span>
3<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;manjing&#34;</span>
4<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;taiyuan&#34;</span>
127.0.0.1:6379&gt; georadius china:city <span style=color:#0000cf;font-weight:700>110</span> <span style=color:#0000cf;font-weight:700>30</span> <span style=color:#0000cf;font-weight:700>500</span> km
1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;xian&#34;</span>
127.0.0.1:6379&gt; georadius china:city <span style=color:#0000cf;font-weight:700>110</span> <span style=color:#0000cf;font-weight:700>30</span> <span style=color:#0000cf;font-weight:700>500</span> km withdist
1<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;xian&#34;</span>
   2<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;483.8340&#34;</span>
127.0.0.1:6379&gt; georadius china:city <span style=color:#0000cf;font-weight:700>110</span> <span style=color:#0000cf;font-weight:700>30</span> <span style=color:#0000cf;font-weight:700>1000</span> km withcoord withdist count <span style=color:#0000cf;font-weight:700>2</span>
1<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;xian&#34;</span>
   2<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;483.8340&#34;</span>
   3<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;108.96000176668167114&#34;</span>
      2<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;34.25999964418929977&#34;</span>
2<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;manjing&#34;</span>
   2<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;864.9816&#34;</span>
   3<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;118.75999957323074341&#34;</span>
      2<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;32.03999960287850968&#34;</span>
</code></pre></div><p>参数：key 经度 纬度 半径 单位 显示结果的经度和纬度 显示结果的距离 显示的结果的数量</p>
<h3 id=范围相交>范围相交</h3>
<p>显示与指定成员一定半径范围内的其他成员：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>127.0.0.1:6379&gt; georadiusbymember china:city taiyuan <span style=color:#0000cf;font-weight:700>1000</span> km
1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;manjing&#34;</span>
2<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;taiyuan&#34;</span>
3<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;xian&#34;</span>
127.0.0.1:6379&gt; georadiusbymember china:city taiyuan <span style=color:#0000cf;font-weight:700>1000</span> km withcoord withdist count <span style=color:#0000cf;font-weight:700>2</span>
1<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;taiyuan&#34;</span>
   2<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;0.0000&#34;</span>
   3<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;112.54999905824661255&#34;</span>
      2<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;37.86000073876942196&#34;</span>
2<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;xian&#34;</span>
   2<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;514.2264&#34;</span>
   3<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;108.96000176668167114&#34;</span>
      2<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;34.25999964418929977&#34;</span>
</code></pre></div><h3 id=取-hash-值>取 Hash 值</h3>
<p>将二维的经纬度转换为一维的字符串, 如果两个字符串越接近, 则距离越近</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>127.0.0.1:6379&gt; geohash china:city taiyuan shenyang
1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;ww8p3hhqmp0&#34;</span>
2<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;wxrvb9qyxk0&#34;</span>
</code></pre></div><h3 id=底层实现>底层实现</h3>
<p>geo底层的实现原理实际上就是Zset, 我们可以通过Zset命令来操作geo：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>127.0.0.1:6379&gt; <span style=color:#204a87>type</span> china:city
zset
</code></pre></div><p>查看全部元素 删除指定的元素：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>127.0.0.1:6379&gt; zrange china:city <span style=color:#0000cf;font-weight:700>0</span> -1 withscores
 1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;xian&#34;</span>
 2<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;4040115445396757&#34;</span>
 3<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;hangzhou&#34;</span>
 4<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;4054133997236782&#34;</span>
 5<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;manjing&#34;</span>
 6<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;4066006694128997&#34;</span>
 7<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;taiyuan&#34;</span>
 8<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;4068216047500484&#34;</span>
 9<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;shenyang&#34;</span>
1<span style=color:#ce5c00;font-weight:700>)</span>  <span style=color:#4e9a06>&#34;4072519231994779&#34;</span>
2<span style=color:#ce5c00;font-weight:700>)</span>  <span style=color:#4e9a06>&#34;shengzhen&#34;</span>
3<span style=color:#ce5c00;font-weight:700>)</span>  <span style=color:#4e9a06>&#34;4154606886655324&#34;</span>
127.0.0.1:6379&gt; zrem china:city manjing
<span style=color:#ce5c00;font-weight:700>(</span>integer<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#0000cf;font-weight:700>1</span>
127.0.0.1:6379&gt; zrange china:city <span style=color:#0000cf;font-weight:700>0</span> -1
1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;xian&#34;</span>
2<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;hangzhou&#34;</span>
3<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;taiyuan&#34;</span>
4<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;shenyang&#34;</span>
5<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;shengzhen&#34;</span>
</code></pre></div>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-fa602568c373b012706150061f875875>3 - CH03-Stream</h1>
<h2 id=概览>概览</h2>
<p>Redis5.0 中还增加了一个数据结构Stream，从字面上看是流类型，但其实从功能上看，应该是Redis对消息队列（MQ，Message Queue）的完善实现。</p>
<p>用过Redis做消息队列的都了解，基于Reids的消息队列实现有很多种，例如：</p>
<ul>
<li>PUB/SUB，订阅/发布模式：
<ul>
<li>但是发布订阅模式是无法持久化的，如果出现网络断开、Redis 宕机等，消息就会被丢弃；</li>
</ul>
</li>
<li>基于 List LPUSH+BRPOP 或者基于Sorted-Set 的实现：
<ul>
<li>支持了持久化，但是不支持多播，分组消费等</li>
</ul>
</li>
</ul>
<p>为什么上面的结构无法满足广泛的MQ场景？ 这里便引出一个核心的问题：如果我们期望设计一种数据结构来实现消息队列，最重要的就是要理解<strong>设计一个消息队列需要考虑什么</strong>？初步的我们很容易想到</p>
<ul>
<li>消息的生产</li>
<li>消息的消费
<ul>
<li>单播和多播（多对多）</li>
<li>阻塞和非阻塞读取</li>
</ul>
</li>
<li>消息有序性</li>
<li>消息的持久化</li>
</ul>
<div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210504132556.png style=display:block;width:50% alt=NAME align=center> </div>
<h2 id=基本结构>基本结构</h2>
<p>每个 Stream 都有唯一的名称，它就是 Redis 的 key，在我们首次使用 xadd 指令追加消息时自动创建。</p>
<div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210504132658.png style=display:block;width:50% alt=NAME align=center> </div>
<p>上图解析：</p>
<ul>
<li><code>Consumer Group</code> ：消费组，使用 XGROUP CREATE 命令创建，一个消费组有多个消费者(Consumer), 这些消费者之间是竞争关系。</li>
<li><code>last_delivered_id</code> ：游标，每个消费组会有个游标 last_delivered_id，任意一个消费者读取了消息都会使游标 last_delivered_id 往前移动。</li>
<li><code>pending_ids</code> ：消费者(Consumer)的状态变量，作用是维护消费者的未确认的 id。 pending_ids 记录了当前已经被客户端读取的消息，但是还没有 <code>ack</code> (Acknowledge character：确认字符）。如果客户端没有ack，这个变量里面的消息ID会越来越多，一旦某个消息被ack，它就开始减少。这个pending_ids变量在Redis官方被称之为PEL，也就是Pending Entries List，这是一个很核心的数据结构，它用来确保客户端至少消费了消息一次，而不会在网络传输的中途丢失了没处理。</li>
</ul>
<p>此外我们还需要理解两点：</p>
<ul>
<li><code>消息ID</code>: 消息ID的形式是timestampInMillis-sequence，例如1527846880572-5，它表示当前的消息在毫米时间戳1527846880572时产生，并且是该毫秒内产生的第5条消息。消息ID可以由服务器自动生成，也可以由客户端自己指定，但是形式必须是整数-整数，而且必须是后面加入的消息的ID要大于前面的消息ID。</li>
<li><code>消息内容</code>: 消息内容就是键值对，形如hash结构的键值对，这没什么特别之处。</li>
</ul>
<h2 id=基本操作>基本操作</h2>
<p>消息队列相关命令：</p>
<ul>
<li>XADD - 添加消息到末尾</li>
<li>XTRIM - 对流进行修剪，限制长度</li>
<li>XDEL - 删除消息</li>
<li>XLEN - 获取流包含的元素数量，即消息长度</li>
<li>XRANGE - 获取消息列表，会自动过滤已经删除的消息</li>
<li>XREVRANGE - 反向获取消息列表，ID 从大到小</li>
<li>XREAD - 以阻塞或非阻塞方式获取消息列表</li>
</ul>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=color:#8f5902;font-style:italic># *号表示服务器自动生成ID，后面顺序跟着一堆key/value</span>
127.0.0.1:6379&gt; xadd codehole * name laoqian age <span style=color:#0000cf;font-weight:700>30</span>  <span style=color:#8f5902;font-style:italic>#  名字叫laoqian，年龄30岁</span>
1527849609889-0  <span style=color:#8f5902;font-style:italic># 生成的消息ID</span>
127.0.0.1:6379&gt; xadd codehole * name xiaoyu age <span style=color:#0000cf;font-weight:700>29</span>
1527849629172-0
127.0.0.1:6379&gt; xadd codehole * name xiaoqian age <span style=color:#0000cf;font-weight:700>1</span>
1527849637634-0
127.0.0.1:6379&gt; xlen codehole
<span style=color:#ce5c00;font-weight:700>(</span>integer<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#0000cf;font-weight:700>3</span>
127.0.0.1:6379&gt; xrange codehole - +  <span style=color:#8f5902;font-style:italic># -表示最小值, +表示最大值</span>
127.0.0.1:6379&gt; xrange codehole - +
1<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> 1527849609889-0
   1<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;name&#34;</span>
      1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;laoqian&#34;</span>
      2<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;age&#34;</span>
      3<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;30&#34;</span>
2<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> 1527849629172-0
   1<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;name&#34;</span>
      1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;xiaoyu&#34;</span>
      2<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;age&#34;</span>
      3<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;29&#34;</span>
3<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> 1527849637634-0
   1<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;name&#34;</span>
      1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;xiaoqian&#34;</span>
      2<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;age&#34;</span>
      3<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;1&#34;</span>
127.0.0.1:6379&gt; xrange codehole 1527849629172-0 +  <span style=color:#8f5902;font-style:italic># 指定最小消息ID的列表</span>
1<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> 1527849629172-0
   2<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;name&#34;</span>
      2<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;xiaoyu&#34;</span>
      3<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;age&#34;</span>
      4<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;29&#34;</span>
2<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> 1527849637634-0
   2<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;name&#34;</span>
      2<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;xiaoqian&#34;</span>
      3<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;age&#34;</span>
      4<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;1&#34;</span>
127.0.0.1:6379&gt; xrange codehole - 1527849629172-0  <span style=color:#8f5902;font-style:italic># 指定最大消息ID的列表</span>
1<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> 1527849609889-0
   2<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;name&#34;</span>
      2<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;laoqian&#34;</span>
      3<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;age&#34;</span>
      4<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;30&#34;</span>
2<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> 1527849629172-0
   2<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;name&#34;</span>
      2<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;xiaoyu&#34;</span>
      3<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;age&#34;</span>
      4<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;29&#34;</span>
127.0.0.1:6379&gt; xdel codehole 1527849609889-0
<span style=color:#ce5c00;font-weight:700>(</span>integer<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#0000cf;font-weight:700>1</span>
127.0.0.1:6379&gt; xlen codehole  <span style=color:#8f5902;font-style:italic># 长度不受影响</span>
<span style=color:#ce5c00;font-weight:700>(</span>integer<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#0000cf;font-weight:700>3</span>
127.0.0.1:6379&gt; xrange codehole - +  <span style=color:#8f5902;font-style:italic># 被删除的消息没了</span>
1<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> 1527849629172-0
   2<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;name&#34;</span>
      2<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;xiaoyu&#34;</span>
      3<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;age&#34;</span>
      4<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;29&#34;</span>
2<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> 1527849637634-0
   2<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;name&#34;</span>
      2<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;xiaoqian&#34;</span>
      3<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;age&#34;</span>
      4<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;1&#34;</span>
127.0.0.1:6379&gt; del codehole  <span style=color:#8f5902;font-style:italic># 删除整个Stream</span>
<span style=color:#ce5c00;font-weight:700>(</span>integer<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#0000cf;font-weight:700>1</span>
</code></pre></div><h2 id=独立消费>独立消费</h2>
<p>我们可以在不定义消费组的情况下进行Stream消息的独立消费，当Stream没有新消息时，甚至可以阻塞等待。Redis设计了一个单独的消费指令xread，可以将Stream当成普通的消息队列(list)来使用。使用xread时，我们可以完全忽略消费组(Consumer Group)的存在，就好比Stream就是一个普通的列表(list)。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#8f5902;font-style:italic># 从Stream头部读取两条消息</span>
127.0.0.1:6379&gt; xread count <span style=color:#0000cf;font-weight:700>2</span> streams codehole 0-0
1<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;codehole&#34;</span>
   2<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> 1527851486781-0
         2<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;name&#34;</span>
            2<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;laoqian&#34;</span>
            3<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;age&#34;</span>
            4<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;30&#34;</span>
      2<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> 1527851493405-0
         2<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;name&#34;</span>
            2<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;yurui&#34;</span>
            3<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;age&#34;</span>
            4<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;29&#34;</span>
<span style=color:#8f5902;font-style:italic># 从Stream尾部读取一条消息，毫无疑问，这里不会返回任何消息</span>
127.0.0.1:6379&gt; xread count <span style=color:#0000cf;font-weight:700>1</span> streams codehole $
<span style=color:#ce5c00;font-weight:700>(</span>nil<span style=color:#ce5c00;font-weight:700>)</span>
<span style=color:#8f5902;font-style:italic># 从尾部阻塞等待新消息到来，下面的指令会堵住，直到新消息到来</span>
127.0.0.1:6379&gt; xread block <span style=color:#0000cf;font-weight:700>0</span> count <span style=color:#0000cf;font-weight:700>1</span> streams codehole $
<span style=color:#8f5902;font-style:italic># 我们从新打开一个窗口，在这个窗口往Stream里塞消息</span>
127.0.0.1:6379&gt; xadd codehole * name youming age <span style=color:#0000cf;font-weight:700>60</span>
1527852774092-0
<span style=color:#8f5902;font-style:italic># 再切换到前面的窗口，我们可以看到阻塞解除了，返回了新的消息内容</span>
<span style=color:#8f5902;font-style:italic># 而且还显示了一个等待时间，这里我们等待了93s</span>
127.0.0.1:6379&gt; xread block <span style=color:#0000cf;font-weight:700>0</span> count <span style=color:#0000cf;font-weight:700>1</span> streams codehole $
1<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;codehole&#34;</span>
   2<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> 1527852774092-0
         2<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;name&#34;</span>
            2<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;youming&#34;</span>
            3<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;age&#34;</span>
            4<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;60&#34;</span>
<span style=color:#ce5c00;font-weight:700>(</span>93.11s<span style=color:#ce5c00;font-weight:700>)</span>
</code></pre></div><p>客户端如果想要使用xread进行顺序消费，一定要记住当前消费到哪里了，也就是返回的消息ID。下次继续调用xread时，将上次返回的最后一个消息ID作为参数传递进去，就可以继续消费后续的消息。</p>
<p>block 0表示永远阻塞，直到消息到来，block 1000表示阻塞1s，如果1s内没有任何消息到来，就返回nil</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>127.0.0.1:6379&gt; xread block <span style=color:#0000cf;font-weight:700>1000</span> count <span style=color:#0000cf;font-weight:700>1</span> streams codehole $
<span style=color:#ce5c00;font-weight:700>(</span>nil<span style=color:#ce5c00;font-weight:700>)</span>
<span style=color:#ce5c00;font-weight:700>(</span>1.07s<span style=color:#ce5c00;font-weight:700>)</span>
</code></pre></div><h2 id=按组消费>按组消费</h2>
<div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210504133052.png style=display:block;width:50% alt=NAME align=center> </div>
<h3 id=相关命令>相关命令</h3>
<ul>
<li>XGROUP CREATE - 创建消费者组</li>
<li>XREADGROUP GROUP - 读取消费者组中的消息</li>
<li>XACK - 将消息标记为"已处理"</li>
<li>XGROUP SETID - 为消费者组设置新的最后递送消息ID</li>
<li>XGROUP DELCONSUMER - 删除消费者</li>
<li>XGROUP DESTROY - 删除消费者组</li>
<li>XPENDING - 显示待处理消息的相关信息</li>
<li>XCLAIM - 转移消息的归属权</li>
<li>XINFO - 查看流和消费者组的相关信息；</li>
<li>XINFO GROUPS - 打印消费者组的信息；</li>
<li>XINFO STREAM - 打印流信息</li>
</ul>
<p>Stream通过xgroup create指令创建消费组(Consumer Group)，需要传递起始消息ID参数用来初始化last_delivered_id变量。</p>
<p>Stream提供了xreadgroup指令可以进行消费组的组内消费，需要提供消费组名称、消费者名称和起始消息ID。它同xread一样，也可以阻塞等待新消息。读到新消息后，对应的消息ID就会进入消费者的PEL(正在处理的消息)结构里，客户端处理完毕后使用xack指令通知服务器，本条消息已经处理完毕，该消息ID就会从PEL中移除。</p>
<h3 id=信息监控>信息监控</h3>
<p>Stream提供了XINFO来实现对服务器信息的监控，可以查询：</p>
<ul>
<li>查看队列信息</li>
<li>消费组信息</li>
<li>消费者组成员信息</li>
</ul>
<h3 id=应用场景>应用场景</h3>
<p>可用作时通信等，大数据分析，异地数据备份等</p>
<div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210504135014.png style=display:block;width:50% alt=NAME align=center> </div>
<p>客户端可以平滑扩展，提高处理能力</p>
<div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210504135029.png style=display:block;width:50% alt=NAME align=center> </div>
<h3 id=消息id的设计是否考虑了时间回拨的问题>消息ID的设计是否考虑了时间回拨的问题</h3>
<p>XADD生成的1553439850328-0，就是Redis生成的消息ID，由两部分组成:<strong>时间戳-序号</strong>。时间戳是毫秒级单位，是生成消息的Redis服务器时间，它是个64位整型（int64）。序号是在这个毫秒时间点内的消息序号，它也是个64位整型。</p>
<p>可以通过multi批处理，来验证序号的递增：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>127.0.0.1:6379&gt; MULTI
OK
127.0.0.1:6379&gt; XADD memberMessage * msg one
QUEUED
127.0.0.1:6379&gt; XADD memberMessage * msg two
QUEUED
127.0.0.1:6379&gt; XADD memberMessage * msg three
QUEUED
127.0.0.1:6379&gt; XADD memberMessage * msg four
QUEUED
127.0.0.1:6379&gt; XADD memberMessage * msg five
QUEUED
127.0.0.1:6379&gt; EXEC
1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;1553441006884-0&#34;</span>
2<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;1553441006884-1&#34;</span>
3<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;1553441006884-2&#34;</span>
4<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;1553441006884-3&#34;</span>
5<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;1553441006884-4&#34;</span>
</code></pre></div><p>由于一个redis命令的执行很快，所以可以看到在同一时间戳内，是通过序号递增来表示消息的。</p>
<p>为了保证消息是有序的，因此Redis生成的ID是单调递增有序的。由于ID中包含时间戳部分，为了避免服务器时间错误而带来的问题（例如服务器时间延后了），Redis的每个Stream类型数据都维护一个latest_generated_id属性，用于记录最后一个消息的ID。<strong>若发现当前时间戳退后（小于latest_generated_id所记录的），则采用时间戳不变而序号递增的方案来作为新消息ID</strong>（这也是序号为什么使用int64的原因，保证有足够多的的序号），从而保证ID的单调递增性质。</p>
<p>强烈建议使用Redis的方案生成消息ID，因为这种时间戳+序号的单调递增的ID方案，几乎可以满足你全部的需求。但同时，记住ID是支持自定义的，别忘了！</p>
<h3 id=消费者崩溃带来的会不会消息丢失问题>消费者崩溃带来的会不会消息丢失问题</h3>
<p>为了解决组内消息读取但处理期间消费者崩溃带来的消息丢失问题，STREAM 设计了 Pending 列表，用于记录读取但并未处理完毕的消息。命令XPENDIING 用来获消费组或消费内消费者的未处理完毕的消息。演示如下：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>127.0.0.1:6379&gt; XPENDING mq mqGroup <span style=color:#8f5902;font-style:italic># mpGroup的Pending情况</span>
1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>(</span>integer<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#0000cf;font-weight:700>5</span> <span style=color:#8f5902;font-style:italic># 5个已读取但未处理的消息</span>
2<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;1553585533795-0&#34;</span> <span style=color:#8f5902;font-style:italic># 起始ID</span>
3<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;1553585533795-4&#34;</span> <span style=color:#8f5902;font-style:italic># 结束ID</span>
4<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;consumerA&#34;</span> <span style=color:#8f5902;font-style:italic># 消费者A有3个</span>
      2<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;3&#34;</span>
   2<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;consumerB&#34;</span> <span style=color:#8f5902;font-style:italic># 消费者B有1个</span>
      2<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;1&#34;</span>
   3<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;consumerC&#34;</span> <span style=color:#8f5902;font-style:italic># 消费者C有1个</span>
      2<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;1&#34;</span>

127.0.0.1:6379&gt; XPENDING mq mqGroup - + <span style=color:#0000cf;font-weight:700>10</span> <span style=color:#8f5902;font-style:italic># 使用 start end count 选项可以获取详细信息</span>
1<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;1553585533795-0&#34;</span> <span style=color:#8f5902;font-style:italic># 消息ID</span>
   2<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;consumerA&#34;</span> <span style=color:#8f5902;font-style:italic># 消费者</span>
   3<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>(</span>integer<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#0000cf;font-weight:700>1654355</span> <span style=color:#8f5902;font-style:italic># 从读取到现在经历了1654355ms，IDLE</span>
   4<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>(</span>integer<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#0000cf;font-weight:700>5</span> <span style=color:#8f5902;font-style:italic># 消息被读取了5次，delivery counter</span>
2<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;1553585533795-1&#34;</span>
   2<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;consumerA&#34;</span>
   3<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>(</span>integer<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#0000cf;font-weight:700>1654355</span>
   4<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>(</span>integer<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#0000cf;font-weight:700>4</span>
<span style=color:#8f5902;font-style:italic># 共5个，余下3个省略 ...</span>

127.0.0.1:6379&gt; XPENDING mq mqGroup - + <span style=color:#0000cf;font-weight:700>10</span> consumerA <span style=color:#8f5902;font-style:italic># 在加上消费者参数，获取具体某个消费者的Pending列表</span>
1<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;1553585533795-0&#34;</span>
   2<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;consumerA&#34;</span>
   3<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>(</span>integer<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#0000cf;font-weight:700>1641083</span>
   4<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>(</span>integer<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#0000cf;font-weight:700>5</span>
<span style=color:#8f5902;font-style:italic># 共3个，余下2个省略 ...</span>
</code></pre></div><p>每个Pending的消息有4个属性：</p>
<ul>
<li>消息ID</li>
<li>所属消费者</li>
<li>IDLE，已读取时长</li>
<li>delivery counter，消息被读取次数</li>
</ul>
<p>上面的结果我们可以看到，我们之前读取的消息，都被记录在Pending列表中，说明全部读到的消息都没有处理，仅仅是读取了。那如何表示消费者处理完毕了消息呢？使用命令 XACK 完成告知消息处理完成，演示如下：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>127.0.0.1:6379&gt; XACK mq mqGroup 1553585533795-0 <span style=color:#8f5902;font-style:italic># 通知消息处理结束，用消息ID标识</span>
<span style=color:#ce5c00;font-weight:700>(</span>integer<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#0000cf;font-weight:700>1</span>

127.0.0.1:6379&gt; XPENDING mq mqGroup <span style=color:#8f5902;font-style:italic># 再次查看Pending列表</span>
1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>(</span>integer<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#0000cf;font-weight:700>4</span> <span style=color:#8f5902;font-style:italic># 已读取但未处理的消息已经变为4个</span>
2<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;1553585533795-1&#34;</span>
3<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;1553585533795-4&#34;</span>
4<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;consumerA&#34;</span> <span style=color:#8f5902;font-style:italic># 消费者A，还有2个消息处理</span>
      2<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;2&#34;</span>
   2<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;consumerB&#34;</span>
      2<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;1&#34;</span>
   3<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;consumerC&#34;</span>
      2<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;1&#34;</span>
127.0.0.1:6379&gt;
</code></pre></div><p>有了这样一个Pending机制，就意味着在某个消费者读取消息但未处理后，消息是不会丢失的。等待消费者再次上线后，可以读取该Pending列表，就可以继续处理该消息了，保证消息的有序和不丢失。</p>
<h3 id=消费者彻底宕机后如何转移给其它消费者处理>消费者彻底宕机后如何转移给其它消费者处理</h3>
<blockquote>
<p>还有一个问题，就是若某个消费者宕机之后，没有办法再上线了，那么就需要将该消费者Pending的消息，转移给其他的消费者处理，就是消息转移。</p>
</blockquote>
<p>消息转移的操作时将某个消息转移到自己的Pending列表中。使用语法XCLAIM来实现，需要设置组、转移的目标消费者和消息ID，同时需要提供IDLE（已被读取时长），只有超过这个时长，才能被转移。演示如下：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#8f5902;font-style:italic># 当前属于消费者A的消息1553585533795-1，已经15907,787ms未处理了</span>
127.0.0.1:6379&gt; XPENDING mq mqGroup - + <span style=color:#0000cf;font-weight:700>10</span>
1<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;1553585533795-1&#34;</span>
   2<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;consumerA&#34;</span>
   3<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>(</span>integer<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#0000cf;font-weight:700>15907787</span>
   4<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>(</span>integer<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#0000cf;font-weight:700>4</span>

<span style=color:#8f5902;font-style:italic># 转移超过3600s的消息1553585533795-1到消费者B的Pending列表</span>
127.0.0.1:6379&gt; XCLAIM mq mqGroup consumerB <span style=color:#0000cf;font-weight:700>3600000</span> 1553585533795-1
1<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;1553585533795-1&#34;</span>
   2<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;msg&#34;</span>
      2<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;2&#34;</span>

<span style=color:#8f5902;font-style:italic># 消息1553585533795-1已经转移到消费者B的Pending中。</span>
127.0.0.1:6379&gt; XPENDING mq mqGroup - + <span style=color:#0000cf;font-weight:700>10</span>
1<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;1553585533795-1&#34;</span>
   2<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;consumerB&#34;</span>
   3<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>(</span>integer<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#0000cf;font-weight:700>84404</span> <span style=color:#8f5902;font-style:italic># 注意IDLE，被重置了</span>
   4<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>(</span>integer<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#0000cf;font-weight:700>5</span> <span style=color:#8f5902;font-style:italic># 注意，读取次数也累加了1次</span>
</code></pre></div><p>以上代码，完成了一次消息转移。转移除了要指定ID外，还需要指定IDLE，保证是长时间未处理的才被转移。被转移的消息的IDLE会被重置，用以保证不会被重复转移，以为可能会出现将过期的消息同时转移给多个消费者的并发操作，设置了IDLE，则可以避免后面的转移不会成功，因为IDLE不满足条件。例如下面的连续两条转移，第二条不会成功。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>127.0.0.1:6379&gt; XCLAIM mq mqGroup consumerB <span style=color:#0000cf;font-weight:700>3600000</span> 1553585533795-1
127.0.0.1:6379&gt; XCLAIM mq mqGroup consumerC <span style=color:#0000cf;font-weight:700>3600000</span> 1553585533795-1
</code></pre></div><p>这就是消息转移。至此我们使用了一个Pending消息的ID，所属消费者和IDLE的属性，还有一个属性就是消息被读取次数，delivery counter，该属性的作用由于统计消息被读取的次数，包括被转移也算。这个属性主要用在判定是否为错误数据上。</p>
<h3 id=坏消息问题dead-letter死信问题>坏消息问题，Dead Letter，死信问题</h3>
<p>正如上面所说，如果某个消息，不能被消费者处理，也就是不能被XACK，这是要长时间处于Pending列表中，即使被反复的转移给各个消费者也是如此。此时该消息的delivery counter就会累加（上一节的例子可以看到），当累加到某个我们预设的临界值时，我们就认为是坏消息（也叫死信，DeadLetter，无法投递的消息），由于有了判定条件，我们将坏消息处理掉即可，删除即可。删除一个消息，使用XDEL语法，演示如下：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#8f5902;font-style:italic># 删除队列中的消息</span>
127.0.0.1:6379&gt; XDEL mq 1553585533795-1
<span style=color:#ce5c00;font-weight:700>(</span>integer<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#0000cf;font-weight:700>1</span>
<span style=color:#8f5902;font-style:italic># 查看队列中再无此消息</span>
127.0.0.1:6379&gt; XRANGE mq - +
1<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;1553585533795-0&#34;</span>
   2<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;msg&#34;</span>
      2<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;1&#34;</span>
2<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;1553585533795-2&#34;</span>
   2<span style=color:#ce5c00;font-weight:700>)</span> 1<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;msg&#34;</span>
      2<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#4e9a06>&#34;3&#34;</span>
</code></pre></div><p>注意本例中，并没有删除Pending中的消息因此你查看Pending，消息还会在。可以执行XACK标识其处理完毕！</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-f39b5b7bdbb59acf255fb62ce2763d03>4 - CH04-对象机制</h1>
<h2 id=结构概览>结构概览</h2>
<div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210504135719.png style=display:block;width:50% alt=NAME align=center> </div>
<p>上图反映了Redis的每种对象其实都由<strong>对象结构(redisObject)</strong> 与 <strong>对应编码的数据结构</strong>组合而成，而每种对象类型对应若干编码方式，不同的编码方式所对应的底层数据结构是不同的。</p>
<p>所以，我们需要从几个个角度来着手底层研究：</p>
<ul>
<li><strong>对象设计机制</strong>: 对象结构(redisObject)</li>
<li><strong>编码类型和底层数据结构</strong>: 对应编码的数据结构</li>
</ul>
<h2 id=redisobject>RedisObject</h2>
<p>在redis的命令中，用于对键进行处理的命令占了很大一部分，而对于键所保存的值的类型，键能执行的命令又各不相同。如： <code>LPUSH</code> 和 <code>LLEN</code> 只能用于列表键, 而 <code>SADD</code> 和 <code>SRANDMEMBER</code> 只能用于集合键; 另外一些命令, 比如 <code>DEL</code>、 <code>TTL</code> 和 <code>TYPE</code>, 可以用于任何类型的键；但是要正确实现这些命令, 必须为不同类型的键设置不同的处理方式: 比如说, 删除一个列表键和删除一个字符串键的操作过程就不太一样。</p>
<p>以上的描述说明, <strong>Redis 必须让每个键都带有类型信息, 使得程序可以检查键的类型, 并为它选择合适的处理方式</strong>.</p>
<p>比如说， 集合类型就可以由字典和整数集合两种不同的数据结构实现， 但是， 当用户执行 ZADD 命令时，应该不必关心集合使用的是什么编码， 只要 Redis 能按照 ZADD 命令的指示， 将新元素添加到集合就可以了。</p>
<p>这说明, <strong>操作数据类型的命令除了要对键的类型进行检查之外, 还需要根据数据类型的不同编码进行多态处理</strong>.</p>
<p>为了解决以上问题, <strong>Redis 构建了自己的类型系统</strong>, 这个系统的主要功能包括:</p>
<ul>
<li>redisObject 对象.</li>
<li>基于 redisObject 对象的类型检查.</li>
<li>基于 redisObject 对象的显式多态函数.</li>
<li>对 redisObject 进行分配、共享和销毁的机制.</li>
</ul>
<h3 id=数据结构>数据结构</h3>
<p>redisObject 是 Redis 类型系统的核心, 数据库中的每个键、值, 以及 Redis 本身处理的参数, 都表示为这种数据类型。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#8f5902;font-style:italic>/*
</span><span style=color:#8f5902;font-style:italic> * Redis 对象
</span><span style=color:#8f5902;font-style:italic> */</span>
<span style=color:#204a87;font-weight:700>typedef</span> <span style=color:#204a87;font-weight:700>struct</span> <span style=color:#000>redisObject</span> <span style=color:#000;font-weight:700>{</span>

    <span style=color:#8f5902;font-style:italic>// 类型
</span><span style=color:#8f5902;font-style:italic></span>    <span style=color:#204a87;font-weight:700>unsigned</span> <span style=color:#f57900>type</span><span style=color:#000;font-weight:700>:</span><span style=color:#0000cf;font-weight:700>4</span><span style=color:#000;font-weight:700>;</span>

    <span style=color:#8f5902;font-style:italic>// 编码方式
</span><span style=color:#8f5902;font-style:italic></span>    <span style=color:#204a87;font-weight:700>unsigned</span> <span style=color:#f57900>encoding</span><span style=color:#000;font-weight:700>:</span><span style=color:#0000cf;font-weight:700>4</span><span style=color:#000;font-weight:700>;</span>

    <span style=color:#8f5902;font-style:italic>// LRU - 24位, 记录最末一次访问时间（相对于lru_clock）; 或者 LFU（最少使用的数据：8位频率，16位访问时间）
</span><span style=color:#8f5902;font-style:italic></span>    <span style=color:#204a87;font-weight:700>unsigned</span> <span style=color:#f57900>lru</span><span style=color:#000;font-weight:700>:</span><span style=color:#000>LRU_BITS</span><span style=color:#000;font-weight:700>;</span> <span style=color:#8f5902;font-style:italic>// LRU_BITS: 24
</span><span style=color:#8f5902;font-style:italic></span>
    <span style=color:#8f5902;font-style:italic>// 引用计数
</span><span style=color:#8f5902;font-style:italic></span>    <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>refcount</span><span style=color:#000;font-weight:700>;</span>

    <span style=color:#8f5902;font-style:italic>// 指向底层数据结构实例
</span><span style=color:#8f5902;font-style:italic></span>    <span style=color:#204a87;font-weight:700>void</span> <span style=color:#ce5c00;font-weight:700>*</span><span style=color:#000>ptr</span><span style=color:#000;font-weight:700>;</span>

<span style=color:#000;font-weight:700>}</span> <span style=color:#000>robj</span><span style=color:#000;font-weight:700>;</span>
</code></pre></div><p>下图对应上面的结构：</p>
<div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210504140122.png style=display:block;width:50% alt=NAME align=center> </div>
<p><strong>其中type、encoding和ptr是最重要的三个属性</strong>。</p>
<ul>
<li><strong>type记录了对象所保存的值的类型</strong>，它的值可能是以下常量中的一个：</li>
</ul>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#8f5902;font-style:italic>/*
</span><span style=color:#8f5902;font-style:italic>* 对象类型
</span><span style=color:#8f5902;font-style:italic>*/</span>
<span style=color:#8f5902;font-style:italic>#define OBJ_STRING 0 </span><span style=color:#8f5902;font-style:italic>// 字符串
</span><span style=color:#8f5902;font-style:italic></span><span style=color:#8f5902;font-style:italic>#define OBJ_LIST 1 </span><span style=color:#8f5902;font-style:italic>// 列表
</span><span style=color:#8f5902;font-style:italic></span><span style=color:#8f5902;font-style:italic>#define OBJ_SET 2 </span><span style=color:#8f5902;font-style:italic>// 集合
</span><span style=color:#8f5902;font-style:italic></span><span style=color:#8f5902;font-style:italic>#define OBJ_ZSET 3 </span><span style=color:#8f5902;font-style:italic>// 有序集
</span><span style=color:#8f5902;font-style:italic></span><span style=color:#8f5902;font-style:italic>#define OBJ_HASH 4 </span><span style=color:#8f5902;font-style:italic>// 哈希表
</span></code></pre></div><ul>
<li><strong>encoding记录了对象所保存的值的编码</strong>，它的值可能是以下常量中的一个：</li>
</ul>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#8f5902;font-style:italic>/*
</span><span style=color:#8f5902;font-style:italic>* 对象编码
</span><span style=color:#8f5902;font-style:italic>*/</span>
<span style=color:#8f5902;font-style:italic>#define OBJ_ENCODING_RAW 0     </span><span style=color:#8f5902;font-style:italic>/* Raw representation */</span><span style=color:#8f5902;font-style:italic>
</span><span style=color:#8f5902;font-style:italic>#define OBJ_ENCODING_INT 1     </span><span style=color:#8f5902;font-style:italic>/* Encoded as integer */</span><span style=color:#8f5902;font-style:italic>
</span><span style=color:#8f5902;font-style:italic>#define OBJ_ENCODING_HT 2      </span><span style=color:#8f5902;font-style:italic>/* Encoded as hash table */</span><span style=color:#8f5902;font-style:italic>
</span><span style=color:#8f5902;font-style:italic>#define OBJ_ENCODING_ZIPMAP 3  </span><span style=color:#8f5902;font-style:italic>/* 注意：版本2.6后不再使用. */</span><span style=color:#8f5902;font-style:italic>
</span><span style=color:#8f5902;font-style:italic>#define OBJ_ENCODING_LINKEDLIST 4 </span><span style=color:#8f5902;font-style:italic>/* 注意：不再使用了，旧版本2.x中String的底层之一. */</span><span style=color:#8f5902;font-style:italic>
</span><span style=color:#8f5902;font-style:italic>#define OBJ_ENCODING_ZIPLIST 5 </span><span style=color:#8f5902;font-style:italic>/* Encoded as ziplist */</span><span style=color:#8f5902;font-style:italic>
</span><span style=color:#8f5902;font-style:italic>#define OBJ_ENCODING_INTSET 6  </span><span style=color:#8f5902;font-style:italic>/* Encoded as intset */</span><span style=color:#8f5902;font-style:italic>
</span><span style=color:#8f5902;font-style:italic>#define OBJ_ENCODING_SKIPLIST 7  </span><span style=color:#8f5902;font-style:italic>/* Encoded as skiplist */</span><span style=color:#8f5902;font-style:italic>
</span><span style=color:#8f5902;font-style:italic>#define OBJ_ENCODING_EMBSTR 8  </span><span style=color:#8f5902;font-style:italic>/* Embedded sds string encoding */</span><span style=color:#8f5902;font-style:italic>
</span><span style=color:#8f5902;font-style:italic>#define OBJ_ENCODING_QUICKLIST 9 </span><span style=color:#8f5902;font-style:italic>/* Encoded as linked list of ziplists */</span><span style=color:#8f5902;font-style:italic>
</span><span style=color:#8f5902;font-style:italic>#define OBJ_ENCODING_STREAM 10 </span><span style=color:#8f5902;font-style:italic>/* Encoded as a radix tree of listpacks */</span><span style=color:#8f5902;font-style:italic>
</span></code></pre></div><ul>
<li>
<p><strong>ptr是一个指针，指向实际保存值的数据结构</strong>，这个数据结构由type和encoding属性决定。举个例子， 如果一个redisObject 的type 属性为<code>OBJ_LIST</code> ， encoding 属性为<code>OBJ_ENCODING_QUICKLIST</code> ，那么这个对象就是一个Redis 列表（List)，它的值保存在一个QuickList的数据结构内，而ptr 指针就指向quicklist的对象；</p>
</li>
<li>
<p><strong>lru属性: 记录了对象最后一次被命令程序访问的时间</strong></p>
</li>
</ul>
<p><strong>空转时长</strong>：当前时间减去键的值对象的lru时间，就是该键的空转时长。Object idletime命令可以打印出给定键的空转时长</p>
<p>如果服务器打开了maxmemory选项，并且服务器用于回收内存的算法为volatile-lru或者allkeys-lru，那么当服务器占用的内存数超过了maxmemory选项所设置的上限值时，空转时长较高的那部分键会优先被服务器释放，从而回收内存。</p>
<h2 id=命令的类型检查与多态>命令的类型检查与多态</h2>
<p><strong>当执行一个处理数据类型命令的时候，redis执行以下步骤</strong></p>
<ul>
<li>根据给定的key，在数据库字典中查找和他相对应的redisObject，如果没找到，就返回NULL；</li>
<li>检查redisObject的type属性和执行命令所需的类型是否相符，如果不相符，返回类型错误；</li>
<li>根据redisObject的encoding属性所指定的编码，选择合适的操作函数来处理底层的数据结构；</li>
<li>返回数据结构的操作结果作为命令的返回值。</li>
</ul>
<p>比如现在执行LPOP命令：</p>
<div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210504140457.png style=display:block;width:50% alt=NAME align=center> </div>
<h2 id=对象共享>对象共享</h2>
<blockquote>
<p>redis一般会把一些常见的值放到一个共享对象中，这样可使程序避免了重复分配的麻烦，也节约了一些CPU时间。</p>
</blockquote>
<p><strong>redis预分配的值对象如下</strong>：</p>
<ul>
<li>各种命令的返回值，比如成功时返回的OK，错误时返回的ERROR，命令入队事务时返回的QUEUE，等等</li>
<li>包括0 在内，小于REDIS_SHARED_INTEGERS的所有整数（REDIS_SHARED_INTEGERS的默认值是10000）</li>
</ul>
<div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210504140534.png style=display:block;width:50% alt=NAME align=center> </div>
<blockquote>
<p>注意：共享对象只能被字典和双向链表这类能带有指针的数据结构使用。像整数集合和压缩列表这些只能保存字符串、整数等字面值的内存数据结构。</p>
</blockquote>
<p><strong>为什么redis不共享列表对象、哈希对象、集合对象、有序集合对象，只共享字符串对象</strong>？</p>
<ul>
<li>列表对象、哈希对象、集合对象、有序集合对象，本身可以包含字符串对象，复杂度较高。</li>
<li>如果共享对象是保存字符串对象，那么验证操作的复杂度为O(1)</li>
<li>如果共享对象是保存字符串值的字符串对象，那么验证操作的复杂度为O(N)</li>
<li>如果共享对象是包含多个值的对象，其中值本身又是字符串对象，即其它对象中嵌套了字符串对象，比如列表对象、哈希对象，那么验证操作的复杂度将会是O(N的平方)</li>
</ul>
<p>如果对复杂度较高的对象创建共享对象，需要消耗很大的CPU，用这种消耗去换取内存空间，是不合适的。</p>
<h2 id=引用计数以及对象的消毁>引用计数以及对象的消毁</h2>
<blockquote>
<p>redisObject中有refcount属性，是对象的引用计数，显然计数0那么就是可以回收。</p>
</blockquote>
<ul>
<li>每个redisObject结构都带有一个refcount属性，指示这个对象被引用了多少次；</li>
<li>当新创建一个对象时，它的refcount属性被设置为1；</li>
<li>当对一个对象进行共享时，redis将这个对象的refcount加一；</li>
<li>当使用完一个对象后，或者消除对一个对象的引用之后，程序将对象的refcount减一；</li>
<li>当对象的refcount降至0 时，这个RedisObject结构，以及它引用的数据结构的内存都会被释放。</li>
</ul>
<h2 id=总结>总结</h2>
<ul>
<li>
<p>redis使用自己实现的对象机制（redisObject)来实现类型判断、命令多态和基于引用次数的垃圾回收；</p>
</li>
<li>
<p>redis会预分配一些常用的数据对象，并通过共享这些对象来减少内存占用，和避免频繁的为小对象分配内存。</p>
</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-d6ad1d4083c795b0ad006b6fb71ea3c7>5 - CH05-底层结构</h1>
<div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210504140959.png style=display:block;width:50% alt=NAME align=center> </div>
<h2 id=简单动态字符串sds>简单动态字符串：SDS</h2>
<p>著作权归https://pdai.tech所有。 链接：https://www.pdai.tech/md/db/nosql-redis/db-redis-x-redis-ds.html</p>
<blockquote>
<p>Redis 是用 C 语言写的，但是对于Redis的字符串，却不是 C 语言中的字符串（即以空字符’\0’结尾的字符数组），它是自己构建了一种名为 <strong>简单动态字符串（simple dynamic string,SDS</strong>）的抽象类型，并将 SDS 作为 Redis的默认字符串表示。</p>
</blockquote>
<h3 id=定义>定义</h3>
<blockquote>
<p>这是一种用于存储二进制数据的一种结构, 具有动态扩容的特点. 其实现位于src/sds.h与src/sds.c中。</p>
</blockquote>
<div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210504141111.png style=display:block;width:50% alt=NAME align=center> </div>
<p>著作权归https://pdai.tech所有。 链接：https://www.pdai.tech/md/db/nosql-redis/db-redis-x-redis-ds.html</p>
<p>其中<code>sdshdr</code>是头部, <code>buf</code>是真实存储用户数据的地方. 另外注意, 从命名上能看出来, 这个数据结构除了能存储二进制数据, 显然是用于设计作为字符串使用的, 所以在buf中, 用户数据后总跟着一个\0. 即图中 <code>"数据" + "\0"</code>是为所谓的buf。</p>
<p>SDS有五种不同的头部. 其中sdshdr5实际并未使用到. 所以实际上有四种不同的头部, 分别如下:</p>
<div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210504145202.png style=display:block;width:50% alt=NAME align=center> </div>
<p>著作权归https://pdai.tech所有。 链接：https://www.pdai.tech/md/db/nosql-redis/db-redis-x-redis-ds.html</p>
<p>其中：</p>
<ul>
<li><code>len</code> 保存了SDS保存字符串的长度</li>
<li><code>buf[]</code> 数组用来保存字符串的每个元素</li>
<li><code>alloc</code>分别以uint8, uint16, uint32, uint64表示整个SDS, 除过头部与末尾的\0, 剩余的字节数.</li>
<li><code>flags</code> 始终为一字节, 以低三位标示着头部的类型, 高5位未使用.</li>
</ul>
<h3 id=为什么使用sds>为什么使用SDS</h3>
<blockquote>
<p><strong>为什么不使用C语言字符串实现，而是使用 SDS呢</strong>？这样实现有什么好处？</p>
</blockquote>
<ul>
<li>
<p><strong>常数复杂度获取字符串长度</strong></p>
<p>由于 len 属性的存在，我们获取 SDS 字符串的长度只需要读取 len 属性，时间复杂度为 O(1)。而对于 C 语言，获取字符串的长度通常是经过遍历计数来实现的，时间复杂度为 O(n)。通过 <code>strlen key</code> 命令可以获取 key 的字符串长度。</p>
</li>
<li>
<p><strong>杜绝缓冲区溢出</strong></p>
<p>我们知道在 C 语言中使用 <code>strcat</code> 函数来进行两个字符串的拼接，一旦没有分配足够长度的内存空间，就会造成缓冲区溢出。而对于 SDS 数据类型，在进行字符修改的时候，<strong>会首先根据记录的 len 属性检查内存空间是否满足需求</strong>，如果不满足，会进行相应的空间扩展，然后在进行修改操作，所以不会出现缓冲区溢出。</p>
</li>
<li>
<p><strong>减少修改字符串的内存重新分配次数</strong></p>
<p>C语言由于不记录字符串的长度，所以如果要修改字符串，必须要重新分配内存（先释放再申请），因为如果没有重新分配，字符串长度增大时会造成内存缓冲区溢出，字符串长度减小时会造成内存泄露。</p>
<p>而对于SDS，由于<code>len</code>属性和<code>alloc</code>属性的存在，对于修改字符串SDS实现了<strong>空间预分配</strong>和<strong>惰性空间释放</strong>两种策略：</p>
<ul>
<li>
<p><code>空间预分配</code>：对字符串进行空间扩展的时候，扩展的内存比实际需要的多，这样可以减少连续执行字符串增长操作所需的内存重分配次数。</p>
</li>
<li>
<p><code>惰性空间释放</code>：对字符串进行缩短操作时，程序不立即使用内存重新分配来回收缩短后多余的字节，而是使用 <code>alloc</code> 属性将这些字节的数量记录下来，等待后续使用。（当然SDS也提供了相应的API，当我们有需要时，也可以手动释放这些未使用的空间。）</p>
</li>
</ul>
</li>
<li>
<p><strong>二进制安全</strong></p>
<p>因为C字符串以空字符作为字符串结束的标识，而对于一些二进制文件（如图片等），内容可能包括空字符串，因此C字符串无法正确存取；而所有 SDS 的API 都是以处理二进制的方式来处理 <code>buf</code> 里面的元素，并且 SDS 不是以空字符串来判断是否结束，而是以 len 属性表示的长度来判断字符串是否结束。</p>
</li>
<li>
<p><strong>兼容部分 C 字符串函数</strong></p>
<p>虽然 SDS 是二进制安全的，但是一样遵从每个字符串都是以空字符串结尾的惯例，这样可以重用 C 语言库<code>&lt;string.h></code> 中的一部分函数。</p>
</li>
</ul>
<p>著作权归https://pdai.tech所有。 链接：https://www.pdai.tech/md/db/nosql-redis/db-redis-x-redis-ds.html</p>
<h3 id=空间预分配补进一步理解>空间预分配补进一步理解</h3>
<p>当执行追加操作时，比如现在给<code>key=‘Hello World’</code>的字符串后追加<code>‘ again!’</code>则这时的len=18，free由0变成了18，此时的<code>buf='Hello World again!\0....................'</code>(.表示空格)，也就是buf的内存空间是18+18+1=37个字节，其中‘\0’占1个字节redis给字符串多分配了18个字节的预分配空间，所以下次还有append追加的时候，如果预分配空间足够，就无须在进行空间分配了。在当前版本中，当新字符串的长度小于1M时，redis会分配他们所需大小一倍的空间，当大于1M的时候，就为他们额外多分配1M的空间。</p>
<p>思考：<strong>这种分配策略会浪费内存资源吗</strong>？</p>
<p>答：执行过APPEND 命令的字符串会带有额外的预分配空间，这些预分配空间不会被释放，除非该字符串所对应的键被删除，或者等到关闭Redis 之后，再次启动时重新载入的字符串对象将不会有预分配空间。因为执行APPEND 命令的字符串键数量通常并不多，占用内存的体积通常也不大，所以这一般并不算什么问题。另一方面，如果执行APPEND 操作的键很多，而字符串的体积又很大的话，那可能就需要修改Redis 服务器，让它定时释放一些字符串键的预分配空间，从而更有效地使用内存。</p>
<h3 id=小结>小结</h3>
<p>redis的字符串表示为sds，而不是C字符串（以\0结尾的char*）， 它是Redis 底层所使用的字符串表示，它被用在几乎所有的Redis 模块中。可以看如下对比：</p>
<div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210504145607.png style=display:block;width:50% alt=NAME align=center> </div>
<p>一般来说，SDS 除了保存数据库中的字符串值以外，SDS 还可以作为缓冲区（buffer）：包括 AOF 模块中的AOF缓冲区以及客户端状态中的输入缓冲区</p>
<h2 id=压缩列表ziplist>压缩列表：ZipList</h2>
<blockquote>
<p>ziplist是为了提高存储效率而设计的一种特殊编码的双向链表。它可以存储字符串或者整数，存储整数时是采用整数的二进制而不是字符串形式存储。他能在O(1)的时间复杂度下完成list两端的push和pop操作。但是因为每次操作都需要重新分配ziplist的内存，所以实际复杂度和ziplist的内存使用量相关。</p>
</blockquote>
<h3 id=ziplist-结构>ZipList 结构</h3>
<p>整个ziplist在内存中的存储格式如下：</p>
<div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210504145727.png style=display:block;width:50% alt=NAME align=center> </div>
<p>著作权归https://pdai.tech所有。 链接：https://www.pdai.tech/md/db/nosql-redis/db-redis-x-redis-ds.html</p>
<ul>
<li>
<p><code>zlbytes</code>字段的类型是uint32_t, 这个字段中存储的是整个ziplist所占用的内存的字节数</p>
</li>
<li>
<p><code>zltail</code>字段的类型是uint32_t, 它指的是ziplist中最后一个entry的偏移量. 用于快速定位最后一个entry, 以快速完成pop等操作</p>
</li>
<li>
<p><code>zllen</code>字段的类型是uint16_t, 它指的是整个ziplit中entry的数量. 这个值只占2bytes（16位）: 如果ziplist中entry的数目小于65535(2的16次方), 那么该字段中存储的就是实际entry的值. 若等于或超过65535, 那么该字段的值固定为65535, 但实际数量需要一个个entry的去遍历所有entry才能得到.</p>
</li>
<li>
<p><code>zlend</code>是一个终止字节, 其值为全F, 即0xff. ziplist保证任何情况下, 一个entry的首字节都不会是255</p>
</li>
</ul>
<h3 id=entry-结构>Entry 结构</h3>
<p>著作权归https://pdai.tech所有。 链接：https://www.pdai.tech/md/db/nosql-redis/db-redis-x-redis-ds.html</p>
<p><strong>第一种情况</strong>：一般结构 <code>&lt;prevlen> &lt;encoding> &lt;entry-data></code></p>
<p><code>prevlen</code>：前一个entry的大小，编码方式见下文；</p>
<p><code>encoding</code>：不同的情况下值不同，用于表示当前entry的类型和长度；</p>
<p><code>entry-data</code>：真是用于存储entry表示的数据；</p>
<p><strong>第二种情况</strong>：在entry中存储的是int类型时，encoding和entry-data会合并在encoding中表示，此时没有entry-data字段；</p>
<p>redis中，在存储数据时，会先尝试将string转换成int存储，节省空间；</p>
<p>此时entry结构：<code>&lt;prevlen> &lt;encoding></code></p>
<ul>
<li><strong>prevlen编码</strong></li>
</ul>
<p>当前一个元素长度小于254（255用于zlend）的时候，prevlen长度为1个字节，值即为前一个entry的长度，如果长度大于等于254的时候，prevlen用5个字节表示，第一字节设置为254，后面4个字节存储一个小端的无符号整型，表示前一个entry的长度；</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>&lt;prevlen from <span style=color:#0000cf;font-weight:700>0</span> to 253&gt; &lt;encoding&gt; &lt;entry&gt;      //长度小于254结构
0xFE &lt;<span style=color:#0000cf;font-weight:700>4</span> bytes unsigned little endian prevlen&gt; &lt;encoding&gt; &lt;entry&gt;   //长度大于等于254
</code></pre></div><ul>
<li><strong>encoding编码</strong></li>
</ul>
<p>encoding的长度和值根据保存的是int还是string，还有数据的长度而定；</p>
<p>前两位用来表示类型，当为“11”时，表示entry存储的是int类型，其他表示存储的是string；</p>
<p><strong>存储string时</strong>：</p>
<p><code>|00pppppp|</code> ：此时encoding长度为1个字节，该字节的后六位表示entry中存储的string长度，因为是6位，所以entry中存储的string长度不能超过63；</p>
<p><code>|01pppppp|qqqqqqqq|</code> 此时encoding长度为两个字节；此时encoding的后14位用来存储string长度，长度不能超过16383；</p>
<p><code>|10000000|qqqqqqqq|rrrrrrrr|ssssssss|ttttttt|</code> 此时encoding长度为5个字节，后面的4个字节用来表示encoding中存储的字符串长度，长度不能超过2^32 - 1;</p>
<p><strong>存储int时</strong>：</p>
<p><code>|11000000|</code> encoding为3个字节，后2个字节表示一个int16；</p>
<p><code>|11010000|</code> encoding为5个字节，后4个字节表示一个int32;</p>
<p><code>|11100000|</code> encoding 为9个字节，后8字节表示一个int64;</p>
<p><code>|11110000|</code> encoding为4个字节，后3个字节表示一个有符号整型；</p>
<p><code>|11111110|</code> encoding为2字节，后1个字节表示一个有符号整型；</p>
<p><code>|1111xxxx|</code> encoding长度就只有1个字节，xxxx表示一个0 - 12的整数值；</p>
<p><code>|11111111|</code> 还记得zlend么？</p>
<ul>
<li><strong>源码中数据结构支撑</strong></li>
</ul>
<p>你可以看到为了操作上的简易实际还增加了几个属性</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#8f5902;font-style:italic>/* We use this function to receive information about a ziplist entry.
</span><span style=color:#8f5902;font-style:italic> * Note that this is not how the data is actually encoded, is just what we
</span><span style=color:#8f5902;font-style:italic> * get filled by a function in order to operate more easily. */</span>
<span style=color:#204a87;font-weight:700>typedef</span> <span style=color:#204a87;font-weight:700>struct</span> <span style=color:#000>zlentry</span> <span style=color:#000;font-weight:700>{</span>
    <span style=color:#204a87;font-weight:700>unsigned</span> <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>prevrawlensize</span><span style=color:#000;font-weight:700>;</span> <span style=color:#8f5902;font-style:italic>/* Bytes used to encode the previous entry len*/</span>
    <span style=color:#204a87;font-weight:700>unsigned</span> <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>prevrawlen</span><span style=color:#000;font-weight:700>;</span>     <span style=color:#8f5902;font-style:italic>/* Previous entry len. */</span>
    <span style=color:#204a87;font-weight:700>unsigned</span> <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>lensize</span><span style=color:#000;font-weight:700>;</span>        <span style=color:#8f5902;font-style:italic>/* Bytes used to encode this entry type/len.
</span><span style=color:#8f5902;font-style:italic>                                    For example strings have a 1, 2 or 5 bytes
</span><span style=color:#8f5902;font-style:italic>                                    header. Integers always use a single byte.*/</span>
    <span style=color:#204a87;font-weight:700>unsigned</span> <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>len</span><span style=color:#000;font-weight:700>;</span>            <span style=color:#8f5902;font-style:italic>/* Bytes used to represent the actual entry.
</span><span style=color:#8f5902;font-style:italic>                                    For strings this is just the string length
</span><span style=color:#8f5902;font-style:italic>                                    while for integers it is 1, 2, 3, 4, 8 or
</span><span style=color:#8f5902;font-style:italic>                                    0 (for 4 bit immediate) depending on the
</span><span style=color:#8f5902;font-style:italic>                                    number range. */</span>
    <span style=color:#204a87;font-weight:700>unsigned</span> <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>headersize</span><span style=color:#000;font-weight:700>;</span>     <span style=color:#8f5902;font-style:italic>/* prevrawlensize + lensize. */</span>
    <span style=color:#204a87;font-weight:700>unsigned</span> <span style=color:#204a87;font-weight:700>char</span> <span style=color:#000>encoding</span><span style=color:#000;font-weight:700>;</span>      <span style=color:#8f5902;font-style:italic>/* Set to ZIP_STR_* or ZIP_INT_* depending on
</span><span style=color:#8f5902;font-style:italic>                                    the entry encoding. However for 4 bits
</span><span style=color:#8f5902;font-style:italic>                                    immediate integers this can assume a range
</span><span style=color:#8f5902;font-style:italic>                                    of values and must be range-checked. */</span>
    <span style=color:#204a87;font-weight:700>unsigned</span> <span style=color:#204a87;font-weight:700>char</span> <span style=color:#ce5c00;font-weight:700>*</span><span style=color:#000>p</span><span style=color:#000;font-weight:700>;</span>            <span style=color:#8f5902;font-style:italic>/* Pointer to the very start of the entry, that
</span><span style=color:#8f5902;font-style:italic>                                    is, this points to prev-entry-len field. */</span>
<span style=color:#000;font-weight:700>}</span> <span style=color:#000>zlentry</span><span style=color:#000;font-weight:700>;</span>
</code></pre></div><ul>
<li><code>prevrawlensize</code>表示 previous_entry_length字段的长度</li>
<li><code>prevrawlen</code>表示 previous_entry_length字段存储的内容</li>
<li><code>lensize</code>表示 encoding字段的长度</li>
<li><code>len</code>表示数据内容长度</li>
<li><code>headersize</code> 表示当前元素的首部长度，即previous_entry_length字段长度与encoding字段长度之和</li>
<li><code>encoding</code>表示数据类型</li>
<li><code>p</code>表示当前元素首地址</li>
</ul>
<h3 id=为什么ziplist特别省内存>为什么ZipList特别省内存</h3>
<ul>
<li>ziplist节省内存是相对于普通的list来说的，如果是普通的数组，那么它每个元素占用的内存是一样的且取决于最大的那个元素（很明显它是需要预留空间的）；</li>
<li>所以ziplist在设计时就很容易想到要尽量让每个元素按照实际的内容大小存储，<strong>所以增加encoding字段</strong>，针对不同的encoding来细化存储大小；</li>
<li>这时候还需要解决的一个问题是遍历元素时如何定位下一个元素呢？在普通数组中每个元素定长，所以不需要考虑这个问题；但是ziplist中每个data占据的内存不一样，所以为了解决遍历，需要增加记录上一个元素的length，<strong>所以增加了prelen字段</strong>。</li>
</ul>
<p><strong>为什么我们去研究ziplist特别节省内存的数据结构</strong>？ 在实际应用中，大量存储字符串的优化是需要你对底层的数据结构有一定的理解的，而ziplist在场景优化的时候也被考虑采用的首选。</p>
<h3 id=缺点>缺点</h3>
<ul>
<li>ziplist也不预留内存空间, 并且在移除结点后, 也是立即缩容, 这代表每次写操作都会进行内存分配操作.</li>
<li>结点如果扩容, 导致结点占用的内存增长, 并且超过254字节的话, 可能会导致链式反应: 其后一个结点的entry.prevlen需要从一字节扩容至五字节.
<ul>
<li><strong>最坏情况下, 第一个结点的扩容, 会导致整个ziplist表中的后续所有结点的entry.prevlen字段扩容</strong>.</li>
<li>虽然这个内存重分配的操作依然只会发生一次, 但代码中的时间复杂度是o(N)级别, 因为链式扩容只能一步一步的计算.</li>
<li>但这种情况的概率十分的小, 一般情况下链式扩容能连锁反映五六次就很不幸了.</li>
<li>这样的坏场景下, 其实时间复杂度并不高: 依次计算每个entry新的空间占用, 也就是o(N), 总体占用计算出来后, 只执行一次内存重分配, 与对应的memmove操作, 就可以了.</li>
</ul>
</li>
</ul>
<h2 id=快表quicklist>快表：QuickList</h2>
<p>著作权归https://pdai.tech所有。 链接：https://www.pdai.tech/md/db/nosql-redis/db-redis-x-redis-ds.html</p>
<blockquote>
<p>quicklist这个结构是Redis在3.2版本后新加的, 之前的版本是list(即linkedlist)， 用于String数据类型中。</p>
</blockquote>
<p>它是一种以ziplist为结点的双端链表结构. 宏观上, quicklist是一个链表, 微观上, 链表中的每个结点都是一个ziplist。</p>
<h3 id=quicklist-结构>QuickList 结构</h3>
<p>内部定义了6个结构体:</p>
<ul>
<li><code>quicklistNode</code>, 宏观上, quicklist是一个链表, 这个结构描述的就是链表中的结点. 它通过zl字段持有底层的ziplist. 简单来讲, 它描述了一个ziplist实例</li>
<li><code>quicklistLZF</code>, ziplist是一段连续的内存, 用LZ4算法压缩后, 就可以包装成一个quicklistLZF结构. 是否压缩quicklist中的每个ziplist实例是一个可配置项. 若这个配置项是开启的, 那么quicklistNode.zl字段指向的就不是一个ziplist实例, 而是一个压缩后的quicklistLZF实例</li>
<li><code>quicklistBookmark</code>, 在quicklist尾部增加的一个书签，它只有在大量节点的多余内存使用量可以忽略不计的情况且确实需要分批迭代它们，才会被使用。当不使用它们时，它们不会增加任何内存开销。</li>
<li><code>quicklist</code>. 这就是一个双链表的定义. head, tail分别指向头尾指针. len代表链表中的结点. count指的是整个quicklist中的所有ziplist中的entry的数目. fill字段影响着每个链表结点中ziplist的最大占用空间, compress影响着是否要对每个ziplist以LZ4算法进行进一步压缩以更节省内存空间.</li>
<li><code>quicklistIter</code>是一个迭代器</li>
<li><code>quicklistEntry</code>是对ziplist中的entry概念的封装. quicklist作为一个封装良好的数据结构, 不希望使用者感知到其内部的实现, 所以需要把ziplist.entry的概念重新包装一下.</li>
</ul>
<h3 id=内存布局图>内存布局图</h3>
<div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210504150301.png style=display:block;width:50% alt=NAME align=center> </div>
<h3 id=更多信息>更多信息</h3>
<p>著作权归https://pdai.tech所有。 链接：https://www.pdai.tech/md/db/nosql-redis/db-redis-x-redis-ds.html</p>
<p>下面是有关quicklist的更多额外信息:</p>
<ul>
<li>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback>quicklist.fill
</code></pre></div><p>的值影响着每个链表结点中, ziplist的长度.</p>
<ol>
<li>当数值为负数时, 代表以字节数限制单个ziplist的最大长度. 具体为:</li>
<li>-1 不超过4kb</li>
<li>-2 不超过 8kb</li>
<li>-3 不超过 16kb</li>
<li>-4 不超过 32kb</li>
<li>-5 不超过 64kb</li>
<li>当数值为正数时, 代表以entry数目限制单个ziplist的长度. 值即为数目. 由于该字段仅占16位, 所以以entry数目限制ziplist的容量时, 最大值为2^15个</li>
</ol>
</li>
<li>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback>quicklist.compress
</code></pre></div><p>的值影响着quicklistNode.zl字段指向的是原生的ziplist, 还是经过压缩包装后的quicklistLZF</p>
<ol>
<li>0 表示不压缩, zl字段直接指向ziplist</li>
<li>1 表示quicklist的链表头尾结点不压缩, 其余结点的zl字段指向的是经过压缩后的quicklistLZF</li>
<li>2 表示quicklist的链表头两个, 与末两个结点不压缩, 其余结点的zl字段指向的是经过压缩后的quicklistLZF</li>
<li>以此类推, 最大值为2^16</li>
</ol>
</li>
<li>
<p><code>quicklistNode.encoding</code>字段, 以指示本链表结点所持有的ziplist是否经过了压缩. 1代表未压缩, 持有的是原生的ziplist, 2代表压缩过</p>
</li>
<li>
<p><code>quicklistNode.container</code>字段指示的是每个链表结点所持有的数据类型是什么. 默认的实现是ziplist, 对应的该字段的值是2, 目前Redis没有提供其它实现. 所以实际上, 该字段的值恒为2</p>
</li>
<li>
<p><code>quicklistNode.recompress</code>字段指示的是当前结点所持有的ziplist是否经过了解压. 如果该字段为1即代表之前被解压过, 且需要在下一次操作时重新压缩.</p>
</li>
</ul>
<p>quicklist的具体实现代码篇幅很长, 这里就不贴代码片断了, 从内存布局上也能看出来, 由于每个结点持有的ziplist是有上限长度的, 所以在与操作时要考虑的分支情况比较多。</p>
<p>quicklist有自己的优点, 也有缺点, 对于使用者来说, 其使用体验类似于线性数据结构, list作为最传统的双链表, 结点通过指针持有数据, 指针字段会耗费大量内存. ziplist解决了耗费内存这个问题. 但引入了新的问题: 每次写操作整个ziplist的内存都需要重分配. quicklist在两者之间做了一个平衡. 并且使用者可以通过自定义<code>quicklist.fill</code>, 根据实际业务情况, 经验主义调参.</p>
<h2 id=字典dict>字典：Dict</h2>
<h3 id=数据结构>数据结构</h3>
<p>著作权归https://pdai.tech所有。 链接：https://www.pdai.tech/md/db/nosql-redis/db-redis-x-redis-ds.html</p>
<p><strong>哈希表结构定义</strong>：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#204a87;font-weight:700>typedef</span> <span style=color:#204a87;font-weight:700>struct</span> <span style=color:#000>dictht</span><span style=color:#000;font-weight:700>{</span>
    <span style=color:#8f5902;font-style:italic>//哈希表数组
</span><span style=color:#8f5902;font-style:italic></span>    <span style=color:#000>dictEntry</span> <span style=color:#ce5c00;font-weight:700>**</span><span style=color:#000>table</span><span style=color:#000;font-weight:700>;</span>
    <span style=color:#8f5902;font-style:italic>//哈希表大小
</span><span style=color:#8f5902;font-style:italic></span>    <span style=color:#204a87;font-weight:700>unsigned</span> <span style=color:#204a87;font-weight:700>long</span> <span style=color:#000>size</span><span style=color:#000;font-weight:700>;</span>
    <span style=color:#8f5902;font-style:italic>//哈希表大小掩码，用于计算索引值
</span><span style=color:#8f5902;font-style:italic></span>    <span style=color:#8f5902;font-style:italic>//总是等于 size-1
</span><span style=color:#8f5902;font-style:italic></span>    <span style=color:#204a87;font-weight:700>unsigned</span> <span style=color:#204a87;font-weight:700>long</span> <span style=color:#000>sizemask</span><span style=color:#000;font-weight:700>;</span>
    <span style=color:#8f5902;font-style:italic>//该哈希表已有节点的数量
</span><span style=color:#8f5902;font-style:italic></span>    <span style=color:#204a87;font-weight:700>unsigned</span> <span style=color:#204a87;font-weight:700>long</span> <span style=color:#000>used</span><span style=color:#000;font-weight:700>;</span>
 
<span style=color:#000;font-weight:700>}</span><span style=color:#000>dictht</span>
</code></pre></div><p>哈希表是由数组 table 组成，table 中每个元素都是指向 dict.h/dictEntry 结构，dictEntry 结构定义如下：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#204a87;font-weight:700>typedef</span> <span style=color:#204a87;font-weight:700>struct</span> <span style=color:#000>dictEntry</span><span style=color:#000;font-weight:700>{</span>
     <span style=color:#8f5902;font-style:italic>//键
</span><span style=color:#8f5902;font-style:italic></span>     <span style=color:#204a87;font-weight:700>void</span> <span style=color:#ce5c00;font-weight:700>*</span><span style=color:#000>key</span><span style=color:#000;font-weight:700>;</span>
     <span style=color:#8f5902;font-style:italic>//值
</span><span style=color:#8f5902;font-style:italic></span>     <span style=color:#204a87;font-weight:700>union</span><span style=color:#000;font-weight:700>{</span>
          <span style=color:#204a87;font-weight:700>void</span> <span style=color:#ce5c00;font-weight:700>*</span><span style=color:#000>val</span><span style=color:#000;font-weight:700>;</span>
          <span style=color:#000>uint64_tu64</span><span style=color:#000;font-weight:700>;</span>
          <span style=color:#000>int64_ts64</span><span style=color:#000;font-weight:700>;</span>
     <span style=color:#000;font-weight:700>}</span><span style=color:#000>v</span><span style=color:#000;font-weight:700>;</span>
 
     <span style=color:#8f5902;font-style:italic>//指向下一个哈希表节点，形成链表
</span><span style=color:#8f5902;font-style:italic></span>     <span style=color:#204a87;font-weight:700>struct</span> <span style=color:#000>dictEntry</span> <span style=color:#ce5c00;font-weight:700>*</span><span style=color:#000>next</span><span style=color:#000;font-weight:700>;</span>
<span style=color:#000;font-weight:700>}</span><span style=color:#000>dictEntry</span>
</code></pre></div><p>key 用来保存键，val 属性用来保存值，值可以是一个指针，也可以是uint64_t整数，也可以是int64_t整数。</p>
<p>注意这里还有一个指向下一个哈希表节点的指针，我们知道哈希表最大的问题是存在哈希冲突，如何解决哈希冲突，有开放地址法和链地址法。这里采用的便是链地址法，通过next这个指针可以将多个哈希值相同的键值对连接在一起，用来<strong>解决哈希冲突</strong>。</p>
<div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210504150508.png style=display:block;width:50% alt=NAME align=center> </div>
<h3 id=要点理解>要点理解</h3>
<p>著作权归https://pdai.tech所有。 链接：https://www.pdai.tech/md/db/nosql-redis/db-redis-x-redis-ds.html</p>
<ul>
<li><strong>哈希算法</strong>：Redis计算哈希值和索引值方法如下：</li>
</ul>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#8f5902;font-style:italic>#1、使用字典设置的哈希函数，计算键 key 的哈希值</span>
<span style=color:#204a87>hash</span> <span style=color:#ce5c00;font-weight:700>=</span> dict-&gt;type-&gt;hashFunction<span style=color:#ce5c00;font-weight:700>(</span>key<span style=color:#ce5c00;font-weight:700>)</span><span style=color:#000;font-weight:700>;</span>

<span style=color:#8f5902;font-style:italic>#2、使用哈希表的sizemask属性和第一步得到的哈希值，计算索引值</span>
<span style=color:#000>index</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87>hash</span> <span style=color:#000;font-weight:700>&amp;</span> dict-&gt;ht<span style=color:#ce5c00;font-weight:700>[</span>x<span style=color:#ce5c00;font-weight:700>]</span>.sizemask<span style=color:#000;font-weight:700>;</span>
</code></pre></div><ul>
<li>
<p><strong>解决哈希冲突</strong>：这个问题上面我们介绍了，方法是链地址法。通过字典里面的 *next 指针指向下一个具有相同索引值的哈希表节点。</p>
</li>
<li>
<p><strong>扩容和收缩</strong>：当哈希表保存的键值对太多或者太少时，就要通过 rerehash(重新散列）来对哈希表进行相应的扩展或者收缩。具体步骤：</p>
<ul>
<li>
<p>1、如果执行扩展操作，会基于原哈希表创建一个大小等于 <code>ht[0].used*2n</code> 的哈希表（也就是每次扩展都是根据原哈希表已使用的空间扩大一倍创建另一个哈希表）。相反如果执行的是收缩操作，每次收缩是根据已使用空间缩小一倍创建一个新的哈希表。</p>
</li>
<li>
<p>2、重新利用上面的哈希算法，计算索引值，然后将键值对放到新的哈希表位置上。</p>
</li>
<li>
<p>3、所有键值对都迁徙完毕后，释放原哈希表的内存空间。</p>
</li>
</ul>
</li>
<li>
<p><strong>触发扩容的条件</strong>：</p>
<ul>
<li>
<p>1、服务器目前没有执行 BGSAVE 命令或者 BGREWRITEAOF 命令，并且负载因子大于等于1。</p>
</li>
<li>
<p>2、服务器目前正在执行 BGSAVE 命令或者 BGREWRITEAOF 命令，并且负载因子大于等于5。</p>
</li>
<li>
<p>ps：负载因子 = 哈希表已保存节点数量 / 哈希表大小。</p>
</li>
</ul>
</li>
<li>
<p><strong>渐近式 rehash</strong></p>
<ul>
<li>什么叫渐进式 rehash？也就是说扩容和收缩操作不是一次性、集中式完成的，而是分多次、渐进式完成的。如果保存在Redis中的键值对只有几个几十个，那么 rehash 操作可以瞬间完成，但是如果键值对有几百万，几千万甚至几亿，那么要一次性的进行 rehash，势必会造成Redis一段时间内不能进行别的操作。所以Redis采用渐进式 rehash,这样在进行渐进式rehash期间，字典的删除查找更新等操作可能会在两个哈希表上进行，第一个哈希表没有找到，就会去第二个哈希表上进行查找。但是进行 增加操作，一定是在新的哈希表上进行的。</li>
</ul>
</li>
</ul>
<h2 id=整数集intset>整数集：IntSet</h2>
<blockquote>
<p>整数集合（intset）是集合类型的底层实现之一，当一个集合只包含整数值元素，并且这个集合的元素数量不多时，Redis 就会使用整数集合作为集合键的底层实现。</p>
</blockquote>
<h3 id=结构>结构</h3>
<p>著作权归https://pdai.tech所有。 链接：https://www.pdai.tech/md/db/nosql-redis/db-redis-x-redis-ds.html</p>
<p>首先看源码结构</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#204a87;font-weight:700>typedef</span> <span style=color:#204a87;font-weight:700>struct</span> <span style=color:#000>intset</span> <span style=color:#000;font-weight:700>{</span>
    <span style=color:#204a87;font-weight:700>uint32_t</span> <span style=color:#000>encoding</span><span style=color:#000;font-weight:700>;</span>
    <span style=color:#204a87;font-weight:700>uint32_t</span> <span style=color:#000>length</span><span style=color:#000;font-weight:700>;</span>
    <span style=color:#204a87;font-weight:700>int8_t</span> <span style=color:#000>contents</span><span style=color:#000;font-weight:700>[];</span>
<span style=color:#000;font-weight:700>}</span> <span style=color:#000>intset</span><span style=color:#000;font-weight:700>;</span>
</code></pre></div><ul>
<li>
<p><code>encoding</code> 表示编码方式，的取值有三个：INTSET_ENC_INT16, INTSET_ENC_INT32, INTSET_ENC_INT64</p>
</li>
<li>
<p><code>length</code> 代表其中存储的整数的个数</p>
</li>
<li>
<p><code>contents</code> 指向实际存储数值的连续内存区域, 就是一个数组；整数集合的每个元素都是 contents 数组的一个数组项（item），各个项在数组中按值得大小<strong>从小到大有序排序</strong>，且数组中不包含任何重复项。（虽然 intset 结构将 contents 属性声明为 int8_t 类型的数组，但实际上 contents 数组并不保存任何 int8_t 类型的值，contents 数组的真正类型取决于 encoding 属性的值）</p>
</li>
</ul>
<h3 id=内存布局>内存布局</h3>
<div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210504150750.png style=display:block;width:50% alt=NAME align=center> </div>
<p>content数组里面每个元素的数据类型是由encoding来决定的，那么如果原来的数据类型是int16, 当我们再插入一个int32类型的数据时怎么办呢？这就是下面要说的intset的升级。</p>
<h3 id=升级>升级</h3>
<p>著作权归https://pdai.tech所有。 链接：https://www.pdai.tech/md/db/nosql-redis/db-redis-x-redis-ds.html</p>
<p>当在一个int16类型的整数集合中插入一个int32类型的值，整个集合的所有元素都会转换成32类型。 整个过程有三步：</p>
<ul>
<li>根据新元素的类型（比如int32），扩展整数集合底层数组的空间大小，并为新元素分配空间。</li>
<li>将底层数组现有的所有元素都转换成与新元素相同的类型， 并将类型转换后的元素放置到正确的位上， 而且在放置元素的过程中， 需要继续维持底层数组的有序性质不变。</li>
<li>最后改变encoding的值，length+1。</li>
</ul>
<p><strong>那么如果我们删除掉刚加入的int32类型时，会不会做一个降级操作呢</strong>？</p>
<p>不会。主要还是减少开销的权衡。</p>
<h2 id=跳表zskiplist>跳表：ZSkipList</h2>
<p>著作权归https://pdai.tech所有。 链接：https://www.pdai.tech/md/db/nosql-redis/db-redis-x-redis-ds.html</p>
<blockquote>
<p>跳跃表结构在 Redis 中的运用场景只有一个，那就是作为有序列表 (Zset) 的使用。跳跃表的性能可以保证在查找，删除，添加等操作的时候在对数期望时间内完成，这个性能是可以和平衡树来相比较的，而且在实现方面比平衡树要优雅，这就是跳跃表的长处。</p>
<p>跳跃表的缺点就是需要的存储空间比较大，属于利用空间来换取时间的数据结构。</p>
</blockquote>
<h3 id=跳跃表>跳跃表</h3>
<p>对于于一个单链表来讲，即便链表中存储的数据是有序的，如果我们要想在其中查找某个数据，也只能从头到尾遍历链表。这样查找效率就会很低，时间复杂度会很高，是 O(n)。比如查找12，需要7次查找：</p>
<div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210504150943.png style=display:block;width:50% alt=NAME align=center> </div>
<p>如果我们增加如下两级索引，那么它搜索次数就变成了3次：</p>
<div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210504151003.png style=display:block;width:50% alt=NAME align=center> </div>
<h3 id=redis-跳跃表>Redis 跳跃表</h3>
<p>redis跳跃表并没有在单独的类（比如skplist.c)中定义，而是其定义在server.h中, 如下:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#8f5902;font-style:italic>/* ZSETs use a specialized version of Skiplists */</span>
<span style=color:#204a87;font-weight:700>typedef</span> <span style=color:#204a87;font-weight:700>struct</span> <span style=color:#000>zskiplistNode</span> <span style=color:#000;font-weight:700>{</span>
    <span style=color:#000>sds</span> <span style=color:#000>ele</span><span style=color:#000;font-weight:700>;</span>
    <span style=color:#204a87;font-weight:700>double</span> <span style=color:#000>score</span><span style=color:#000;font-weight:700>;</span>
    <span style=color:#204a87;font-weight:700>struct</span> <span style=color:#000>zskiplistNode</span> <span style=color:#ce5c00;font-weight:700>*</span><span style=color:#000>backward</span><span style=color:#000;font-weight:700>;</span>
    <span style=color:#204a87;font-weight:700>struct</span> <span style=color:#000>zskiplistLevel</span> <span style=color:#000;font-weight:700>{</span>
        <span style=color:#204a87;font-weight:700>struct</span> <span style=color:#000>zskiplistNode</span> <span style=color:#ce5c00;font-weight:700>*</span><span style=color:#000>forward</span><span style=color:#000;font-weight:700>;</span>
        <span style=color:#204a87;font-weight:700>unsigned</span> <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>span</span><span style=color:#000;font-weight:700>;</span>
    <span style=color:#000;font-weight:700>}</span> <span style=color:#000>level</span><span style=color:#000;font-weight:700>[];</span>
<span style=color:#000;font-weight:700>}</span> <span style=color:#000>zskiplistNode</span><span style=color:#000;font-weight:700>;</span>

<span style=color:#204a87;font-weight:700>typedef</span> <span style=color:#204a87;font-weight:700>struct</span> <span style=color:#000>zskiplist</span> <span style=color:#000;font-weight:700>{</span>
    <span style=color:#204a87;font-weight:700>struct</span> <span style=color:#000>zskiplistNode</span> <span style=color:#ce5c00;font-weight:700>*</span><span style=color:#000>header</span><span style=color:#000;font-weight:700>,</span> <span style=color:#ce5c00;font-weight:700>*</span><span style=color:#000>tail</span><span style=color:#000;font-weight:700>;</span>
    <span style=color:#204a87;font-weight:700>unsigned</span> <span style=color:#204a87;font-weight:700>long</span> <span style=color:#000>length</span><span style=color:#000;font-weight:700>;</span>
    <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>level</span><span style=color:#000;font-weight:700>;</span>
<span style=color:#000;font-weight:700>}</span> <span style=color:#000>zskiplist</span><span style=color:#000;font-weight:700>;</span>
</code></pre></div><p>内存布局：</p>
<div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210504151129.png style=display:block;width:50% alt=NAME align=center> </div>
<p>著作权归https://pdai.tech所有。 链接：https://www.pdai.tech/md/db/nosql-redis/db-redis-x-redis-ds.html</p>
<p><strong>zskiplist的核心设计要点</strong></p>
<ul>
<li>
<p><strong>头结点</strong>不持有任何数据, 且其level[]的长度为32</p>
</li>
<li>
<p>每个结点</p>
<ul>
<li>
<p><code>ele</code>字段，持有数据，是sds类型</p>
</li>
<li>
<p><code>score</code>字段, 其标示着结点的得分, 结点之间凭借得分来判断先后顺序, 跳跃表中的结点按结点的得分升序排列.</p>
</li>
<li>
<p><code>backward</code>指针, 这是原版跳跃表中所没有的. 该指针指向结点的前一个紧邻结点.</p>
</li>
<li>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback>level
</code></pre></div><p>字段, 用以记录所有结点(除过头结点外)；每个结点中最多持有32个zskiplistLevel结构. 实际数量在结点创建时, 按幂次定律随机生成(不超过32). 每个zskiplistLevel中有两个字段</p>
<ul>
<li><code>forward</code>字段指向比自己得分高的某个结点(不一定是紧邻的), 并且, 若当前zskiplistLevel实例在level[]中的索引为X, 则其forward字段指向的结点, 其level[]字段的容量至少是X+1. 这也是上图中, 为什么forward指针总是画的水平的原因.</li>
<li><code>span</code>字段代表forward字段指向的结点, 距离当前结点的距离. 紧邻的两个结点之间的距离定义为1.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id=为什么不选择平衡树或哈希表>为什么不选择平衡树或哈希表</h3>
<p>作者：</p>
<blockquote>
<p>There are a few reasons:</p>
<p>They are not very memory intensive. It&rsquo;s up to you basically. Changing parameters about the probability of a node to have a given number of levels will make then less memory intensive than btrees.
A sorted set is often target of many ZRANGE or ZREVRANGE operations, that is, traversing the skip list as a linked list. With this operation the cache locality of skip lists is at least as good as with other kind of balanced trees.</p>
<p>They are simpler to implement, debug, and so forth. For instance thanks to the skip list simplicity I received a patch (already in Redis master) with augmented skip lists implementing ZRANK in O(log(N)). It required little changes to the code.</p>
<p>About the Append Only durability & speed, I don&rsquo;t think it is a good idea to optimize Redis at cost of more code and more complexity for a use case that IMHO should be rare for the Redis target (fsync() at every command). Almost no one is using this feature even with ACID SQL databases, as the performance hint is big anyway.
About threads: our experience shows that Redis is mostly I/O bound. I&rsquo;m using threads to serve things from Virtual Memory. The long term solution to exploit all the cores, assuming your link is so fast that you can saturate a single core, is running multiple instances of Redis (no locks, almost fully scalable linearly with number of cores), and using the &ldquo;Redis Cluster&rdquo; solution that I plan to develop in the future.</p>
</blockquote>
<p>简而言之就是实现简单且达到了类似效果。</p>
<p>skiplist和各种平衡树（如AVL、红黑树等）的元素是有序排列的，而哈希表不是有序的。因此，在哈希表上只能做单个key的查找，不适宜做范围查找。所谓范围查找，指的是查找那些大小在指定的两个值之间的所有节点。</p>
<p>在做范围查找的时候，平衡树比skiplist操作要复杂。在平衡树上，我们找到指定范围的小值之后，还需要以中序遍历的顺序继续寻找其它不超过大值的节点。如果不对平衡树进行一定的改造，这里的中序遍历并不容易实现。而在skiplist上进行范围查找就非常简单，只需要在找到小值之后，对第1层链表进行若干步的遍历就可以实现。</p>
<p>平衡树的插入和删除操作可能引发子树的调整，逻辑复杂，而skiplist的插入和删除只需要修改相邻节点的指针，操作简单又快速。</p>
<p>从内存占用上来说，skiplist比平衡树更灵活一些。一般来说，平衡树每个节点包含2个指针（分别指向左右子树），而skiplist每个节点包含的指针数目平均为1/(1-p)，具体取决于参数p的大小。如果像Redis里的实现一样，取p=1/4，那么平均每个节点包含1.33个指针，比平衡树更有优势。</p>
<p>查找单个key，skiplist和平衡树的时间复杂度都为O(log n)，大体相当；而哈希表在保持较低的哈希值冲突概率的前提下，查找时间复杂度接近O(1)，性能更高一些。所以我们平常使用的各种Map或dictionary结构，大都是基于哈希表实现的。</p>
<p>从算法实现难度上来比较，skiplist比平衡树要简单得多。</p>
</div>
</main>
</div>
</div>
<footer class="bg-dark py-5 row d-print-none">
<div class="container-fluid mx-sm-5">
<div class=row>
<div class="col-6 col-sm-4 text-xs-center order-sm-2">
</div>
<div class="col-6 col-sm-4 text-right text-xs-center order-sm-3">
<ul class="list-inline mb-0">
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Weibo aria-label=Weibo>
<a class=text-white target=_blank rel="noopener noreferrer" href=https://weibo.com/u/3848950217>
<i class="fab fa-weibo"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Twitter aria-label=Twitter>
<a class=text-white target=_blank rel="noopener noreferrer" href=https://twitter.com/zhange_zzg>
<i class="fab fa-twitter"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="Stack Overflow" aria-label="Stack Overflow">
<a class=text-white target=_blank rel="noopener noreferrer" href=https://stackoverflow.com>
<i class="fab fa-stack-overflow"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=GitHub aria-label=GitHub>
<a class=text-white target=_blank rel="noopener noreferrer" href=https://github.com/infilos/infilos.com>
<i class="fab fa-github"></i>
</a>
</li>
</ul>
</div>
<div class="col-12 col-sm-4 text-center py-2 order-sm-2">
<small class=text-white>&copy; 2021 infilos.com All Rights Reserved</small>
</div>
</div>
</div>
</footer>
</div>
<script src=/js/popper.min.js integrity=sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49 crossorigin=anonymous></script>
<script src=/js/bootstrap.min.js integrity=sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy crossorigin=anonymous></script>
<script src=/js/main.min.5c74b870c6953931a705f390a49c7e4c0a842ec5c83b24354758dd674343ed0d.js integrity="sha256-XHS4cMaVOTGnBfOQpJx+TAqELsXIOyQ1R1jdZ0ND7Q0=" crossorigin=anonymous></script>
</body>
</html>