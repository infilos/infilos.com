<!doctype html><html lang=zh class=no-js>
<head>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=generator content="Hugo 0.89.3">
<meta name=ROBOTS content="INDEX, FOLLOW">
<link rel=canonical type=text/html href=/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/mysql/>
<link rel="shortcut icon" href=/favicons/favicon.ico>
<link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180>
<link rel=icon type=image/png href=/favicons/favicon-16x16.png sizes=16x16>
<link rel=icon type=image/png href=/favicons/favicon-32x32.png sizes=32x32>
<link rel=icon type=image/png href=/favicons/android-36x36.png sizes=36x36>
<link rel=icon type=image/png href=/favicons/android-48x48.png sizes=48x48>
<link rel=icon type=image/png href=/favicons/android-72x72.png sizes=72x72>
<link rel=icon type=image/png href=/favicons/android-96x96.png sizes=96x96>
<link rel=icon type=image/png href=/favicons/android-144x144.png sizes=144x144>
<link rel=icon type=image/png href=/favicons/android-192x192.png sizes=192x192>
<title>MySQL | infilos.com</title><meta property="og:title" content="MySQL">
<meta property="og:description" content="Infilos Wiki Website">
<meta property="og:type" content="website">
<meta property="og:url" content="/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/mysql/"><meta property="og:site_name" content="infilos.com">
<meta itemprop=name content="MySQL">
<meta itemprop=description content="Infilos Wiki Website"><meta name=twitter:card content="summary">
<meta name=twitter:title content="MySQL">
<meta name=twitter:description content="Infilos Wiki Website">
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga('create','UA-123062585-1','auto'),ga('send','pageview'))</script>
<script async src=https://www.google-analytics.com/analytics.js></script>
<link rel=preload href=/scss/main.min.847464b684a6e89d7276700a5c500c17ab494dd1755b2654a7b27d8b59e3347e.css as=style>
<link href=/scss/main.min.847464b684a6e89d7276700a5c500c17ab494dd1755b2654a7b27d8b59e3347e.css rel=stylesheet integrity>
<script src=/js/jquery-3.5.1.min.js integrity="sha256-9/aliU8dGd2tb6OSsuzixeV4y/faTqgFtohetphbbj0=" crossorigin=anonymous></script>
</head>
<body class=td-section>
<header>
<nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-column flex-md-row td-navbar">
<a class=navbar-brand href=/>
<span class=navbar-logo><svg id="Capa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 512 512" style="enable-background:new 0 0 512 512"><path style="fill:#ffc107" d="M432.384 143.616c-4.165-4.164-10.917-4.164-15.083.0l-60.352 60.352c-4.164 4.165-4.164 10.917.0 15.083 21.187 20.463 54.951 19.876 75.413-1.311 19.962-20.668 19.962-53.435.0-74.102L432.384 143.616z"/><path style="fill:#607d8b" d="M42.667 277.334c-5.891.003-10.669-4.771-10.672-10.662-.002-4.338 2.623-8.245 6.64-9.882l234.667-96c5.455-2.233 11.687.38 13.92 5.835s-.38 11.687-5.835 13.92l-234.667 96C45.433 277.069 44.056 277.337 42.667 277.334z"/><path style="fill:#546e7a" d="M391.552 56.448l-32-32C343.938 8.745 322.689-.059 300.544.0h-3.755c-46.082.024-83.432 37.374-83.456 83.456v3.755c-.053 22.138 8.75 43.377 24.448 58.987l32 32c4.165 4.164 10.917 4.164 15.083.0L391.531 71.531C395.701 67.372 395.71 60.62 391.552 56.448z"/><path style="fill:#607d8b" d="M160 469.334c-3.279.006-6.379-1.497-8.405-4.075L34.261 315.926c-3.635-4.636-2.823-11.341 1.813-14.976s11.341-2.823 14.976 1.813l117.333 149.333c3.629 4.641 2.809 11.344-1.832 14.973C164.681 468.533 162.375 469.329 160 469.334z"/><path style="fill:#455a64" d="M487.467 86.848l-3.669-3.648c-37.687-36.557-97.71-36.197-134.955.811l-51.413 51.413c-36.996 37.25-37.357 97.263-.811 134.955l3.584 3.669c1.7 2.457 4.671 3.706 7.616 3.2 2.831.005 5.548-1.115 7.552-3.115l172.181-172.181c4.189-4.143 4.226-10.896.083-15.085-.028-.028-.055-.056-.083-.083L487.467 86.848z"/><g><path style="fill:#ffc107" d="M501.333 192H480c-5.891.0-10.667-4.776-10.667-10.667s4.776-10.667 10.667-10.667h21.333c5.891.0 10.667 4.776 10.667 10.667S507.225 192 501.333 192z"/><path style="fill:#ffc107" d="M394.667 298.667c-5.891.0-10.667-4.776-10.667-10.667v-21.333c0-5.891 4.776-10.667 10.667-10.667 5.891.0 10.667 4.776 10.667 10.667V288C405.333 293.891 400.558 298.667 394.667 298.667z"/><path style="fill:#ffc107" d="M480 277.334c-2.831.005-5.548-1.115-7.552-3.115l-21.333-21.333c-4.093-4.237-3.975-10.99.262-15.083 4.134-3.993 10.687-3.993 14.821.0l21.333 21.333c4.159 4.172 4.148 10.926-.024 15.085C485.514 276.209 482.815 277.327 480 277.334z"/></g><g><path style="fill:#455a64" d="M266.667 448H96c-29.455.0-53.333 23.878-53.333 53.333.0 5.891 4.776 10.667 10.667 10.667h256c5.891.0 10.667-4.776 10.667-10.667C320 471.878 296.122 448 266.667 448z"/><circle style="fill:#455a64" cx="32" cy="288" r="32"/></g><g/><g/><g/><g/><g/><g/><g/><g/><g/><g/><g/><g/><g/><g/><g/></svg></span><span class=font-weight-bold>infilos.com</span>
</a>
<div class="collapse navbar-collapse" id=navbarSupportedContent>
<ul class="navbar-nav mr-auto">
<li class=nav-item style=max-width:90px;min-width:10px>
<a class=nav-link href=/%e5%9f%ba%e7%a1%80%e7%9f%a5%e8%af%86>
<span>基础</span>
</a>
</li>
<li class=nav-item style=max-width:90px;min-width:10px>
<a class=nav-link href=/%e7%bc%96%e7%a8%8b%e8%af%ad%e8%a8%80>
<span>语言</span>
</a>
</li>
<li class=nav-item style=max-width:90px;min-width:10px>
<a class=nav-link href=/%e6%a1%86%e6%9e%b6%e4%b8%8e%e5%ba%93>
<span>框架库</span>
</a>
</li>
<li class="nav-item dropdown" style=max-width:90px;min-width:10px>
<a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>
分布式
<span>+</span>
</a>
<div class=dropdown-menu aria-labelledby=navbarDropdown>
<a class=dropdown-item href=/%e5%88%86%e5%b8%83%e5%bc%8f/base>基本构成</a>
</div>
</li>
<li class="nav-item dropdown" style=max-width:90px;min-width:10px>
<a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>
大数据
<span>+</span>
</a>
<div class=dropdown-menu aria-labelledby=navbarDropdown>
<a class=dropdown-item href=/%e5%ad%98%e5%82%a8%e7%b3%bb%e7%bb%9f>存储系统</a>
<a class=dropdown-item href=/%e6%9f%a5%e8%af%a2%e7%b3%bb%e7%bb%9f>查询系统</a>
<a class=dropdown-item href=/%e6%b6%88%e6%81%af%e7%b3%bb%e7%bb%9f>消息系统</a>
<a class=dropdown-item href=/%e5%a4%84%e7%90%86%e7%b3%bb%e7%bb%9f>处理系统</a>
<a class=dropdown-item href=/%e6%95%b0%e6%8d%ae%e6%b2%bb%e7%90%86>数据治理</a>
</div>
</li>
<li class="nav-item dropdown" style=max-width:90px;min-width:10px>
<a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>
中后台
<span>+</span>
</a>
<div class=dropdown-menu aria-labelledby=navbarDropdown>
<a class=dropdown-item href=/%e5%9f%ba%e7%a1%80%e8%ae%be%e6%96%bd>基础设施</a>
<a class=dropdown-item href=/%e7%94%a8%e6%88%b7%e7%b3%bb%e7%bb%9f>用户系统</a>
<a class=dropdown-item href=/%e4%ba%a4%e4%ba%92%e7%95%8c%e9%9d%a2>交互界面</a>
<a class=dropdown-item href=/%e4%b8%9a%e5%8a%a1%e7%b3%bb%e7%bb%9f>业务系统</a>
</div>
</li>
<li class=nav-item style=max-width:90px;min-width:10px>
<a class=nav-link href=/%e6%a8%a1%e5%bc%8f%e6%9e%b6%e6%9e%84>
<span>模式架构</span>
</a>
</li>
<li class=nav-item style=max-width:90px;min-width:10px>
<a class=nav-link href=/%e9%9d%a2%e8%af%95%e9%97%ae%e7%ad%94>
<span>面试</span>
</a>
</li>
<li class=nav-item style=max-width:90px;min-width:10px>
<a class=nav-link href=/%e7%ae%a1%e7%90%86%e8%b7%af%e5%be%84>
<span>管理</span>
</a>
</li>
<li class=nav-item style=max-width:90px;min-width:10px>
<a class=nav-link href=/%e5%bc%80%e6%ba%90%e9%a1%b9%e7%9b%ae>
<span>开源</span>
</a>
</li>
</ul>
<div class="form-inline my-2 my-lg-0">
<div class="nav-item nav-search-item my-2 my-md-0">
<input type=search class="form-control td-search-input" placeholder="&#xf002; 站内搜索…" aria-label=站内搜索… autocomplete=off>
</div>
</div>
</div>
</nav>
</header>
<div class="container-fluid td-outer">
<div class=td-main>
<div class="row flex-xl-nowrap">
<div class="col-12 col-md-3 col-xl-2 td-sidebar d-print-none">
</div>
<div class="d-none d-xl-block col-xl-2 td-toc d-print-none">
</div>
<main class="col-12 col-md-9 col-xl-8 pl-md-5" role=main>
<div class=td-content>
<div class="pageinfo pageinfo-primary d-print-none">
<p>
这是本节的多页打印视图。
<a href=# onclick="return print(),!1">点击此处打印</a>.
</p><p>
<a href=/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/mysql/>返回本页常规视图</a>.
</p>
</div>
<h1 class=title>MySQL</h1>
<ul>
<li>1: <a href=#pg-90adba63667076abecda8b645b08e594>CH01-数据类型</a></li>
<li>2: <a href=#pg-87823f5c8c995312533c60e735d79427>CH02-存储引擎</a></li>
<li>3: <a href=#pg-e59a8b6bc16ee47aa4e9119f76c58aa2>CH03-索引B+树</a></li>
<li>4: <a href=#pg-e153ee081a2e00565371b72f637f2039>CH04-性能优化</a></li>
<li>5: <a href=#pg-29d040819faa80f395ba725e176690a3>CH05-分库分表</a></li>
<li>6: <a href=#pg-18dd619a88421627df2c9f215cacaecc>CH06-复制分离</a></li>
<li>7: <a href=#pg-280203572e4e446020b171753e2c2a12>CH07-执行过程</a></li>
<li>8: <a href=#pg-2f770b4ebcff7b1cb1f0b0c93c9c266f>CH08-参考规约</a></li>
</ul>
<div class=content>
</div>
</div>
<div class=td-content>
<h1 id=pg-90adba63667076abecda8b645b08e594>1 - CH01-数据类型</h1>
<h2 id=字段类型>字段类型</h2>
<h3 id=整型>整型</h3>
<p>TINYINT, SMALLINT, MEDIUMINT, INT, BIGINT 分别使用 8, 16, 24, 32, 64 位存储空间，一般情况下越小的列越好。</p>
<p>INT(11) 中的数字只是规定了交互工具显示字符的个数，对于存储和计算来说是没有意义的。</p>
<h3 id=浮点数>浮点数</h3>
<p>FLOAT 和 DOUBLE 为浮点类型，DECIMAL 为高精度小数类型。CPU 原生支持浮点运算，但是不支持 DECIMAl 类型的计算，因此 DECIMAL 的计算比浮点类型需要更高的代价。</p>
<p>FLOAT、DOUBLE 和 DECIMAL 都可以指定列宽，例如 DECIMAL(18, 9) 表示总共 18 位，取 9 位存储小数部分，剩下 9 位存储整数部分。</p>
<h3 id=字符串>字符串</h3>
<p>主要有 CHAR 和 VARCHAR 两种类型，一种是定长的，一种是变长的。</p>
<p>VARCHAR 这种变长类型能够节省空间，因为只需要存储必要的内容。但是在执行 UPDATE 时可能会使行变得比原来长，当超出一个页所能容纳的大小时，就要执行额外的操作。MyISAM 会将行拆成不同的片段存储，而 InnoDB 则需要分裂页来使行放进页内。</p>
<p>VARCHAR 会保留字符串末尾的空格，而 CHAR 会删除。</p>
<h3 id=时间和日期>时间和日期</h3>
<p>MySQL 提供了两种相似的日期时间类型: DATETIME 和 TIMESTAMP。</p>
<h4 id=1-datetime>1. DATETIME</h4>
<p>能够保存从 1001 年到 9999 年的日期和时间，精度为秒，使用 8 字节的存储空间。</p>
<p>它与时区无关。</p>
<p>默认情况下，MySQL 以一种可排序的、无歧义的格式显示 DATETIME 值，例如“2008-01-16 22:37:08”，这是 ANSI 标准定义的日期和时间表示方法。</p>
<h4 id=2-timestamp>2. TIMESTAMP</h4>
<p>和 UNIX 时间戳相同，保存从 1970 年 1 月 1 日午夜(格林威治时间)以来的秒数，使用 4 个字节，只能表示从 1970 年 到 2038 年。</p>
<p>它和时区有关，也就是说一个时间戳在不同的时区所代表的具体时间是不同的。</p>
<p>MySQL 提供了 FROM_UNIXTIME() 函数把 UNIX 时间戳转换为日期，并提供了 UNIX_TIMESTAMP() 函数把日期转换为 UNIX 时间戳。</p>
<p>默认情况下，如果插入时没有指定 TIMESTAMP 列的值，会将这个值设置为当前时间。</p>
<p>应该尽量使用 TIMESTAMP，因为它比 DATETIME 空间效率更高。</p>
<h2 id=选择优化的数据类型>选择优化的数据类型</h2>
<ul>
<li>更小的通常更好；更小的数据类型通常更快，因为它们占用更少的磁盘、内存和CPU缓存，并且处理时需要的CPU周期也更少；</li>
<li>简单就好；例如，整形比字符串操作代价更低；使用内建类型而不是字符串来存储日期和时间；用整形存储IP地址等；</li>
<li>尽量避免NULL；如果查询中包含可为NULL的列，对MySQL来说更难优化，因为可为NULL 的列使得索引、索引统计和值比较都更复杂。尽管把可为NULL的列改为NOT NULL带来的性能提升比较小，但如果计划在列上创建索引，就应该尽量避免设计成可为NULL的列；</li>
</ul>
<h3 id=字符串类型>字符串类型</h3>
<h4 id=varchar-和-char>VARCHAR 和 CHAR</h4>
<p>VARCHAR是最常见的字符串类型。VARCHAR节省了存储空间，所以对性能也有帮助。但是，由于行是可变的，在UPDATE时可能使行变得比原来更长，这就导致需要做额外的工作。如果一个行占用的空间增长，并且在页内没有更多的空间可以存储，MyISAM会将行拆成不同的片段存储；InnoDB则需要分裂页来使行可以放进页内。</p>
<p>下面这些情况使用VARCHAR是合适的：字符串的最大长度比平均长度大很多；列的更新很少，所以碎片不是问题；使用了像UTF-8这样复杂的字符集，每个字符都使用不同的字节数进行存储。</p>
<p>当存储CHAR值时，MySQL会删除所有的末尾空格。CHAR值会根据需要采用空格进行填充以方便比较。</p>
<p>CHAR适合存储很短的字符串，或者所有值都接近同一个长度，如密码的MD5值。对于经常变更的数据，CHAR也比VARCHAR更好，因为CHAR不容易产生碎片（行间碎片？）。</p>
<h4 id=varchar5和varchar200>VARCHAR(5)和VARCHAR(200)</h4>
<blockquote>
<p>使用VARCHAR(5)和VARCHAR(200)存储"hello"的空间开销是一样的。那么使用更短的列有什么优势吗？</p>
</blockquote>
<p>事实证明有很大的优势。更长的列会消耗更多的内存，因为MySQL通常会分配固定大小的内存块来保存内部值。尤其是使用内存临时表进行排序或其他操作时会特别糟糕。在利用磁盘临时表进行排序时也同样糟糕。</p>
<p>所以最好的策略是只分配真正需要的空间。</p>
<h4 id=blob-和-text>BLOB 和 TEXT</h4>
<p>BLOB和TEXT都是为存储很大的数据而设计的数据类型，分别采用二进制和字符方式存储。</p>
<p>与其他类型不同，MySQL把每个BLOB和TEXT值当做一个独立的对象去处理。当BLOB和TEXT值太大时，InnoDB会使用专门的“外部”存储区域来进行存储，此时每个值在行内需要1~4个字节存储一个指针，然后在外部存储区域存储实际的值。</p>
<p>MySQL对BLOB和TEXT列进行排序与其他类型是不同的：它只对每个列的最前max_sort_length个字节而不是整个字符串做排序。同样的，MySQL也不能将BLOB或TEXT列全部长度的字符串进行索引。</p>
<h3 id=选择标识符identifier>选择标识符（identifier）</h3>
<p>整数类型通常是标识列的最佳选择，因为它们很快并且可以使用AUTO_INCREMENT。 如果可能，应该避免使用字符串类型作为标识列，因为它们很耗空间，并且比数字类型慢。 对于完全随机的字符串也需要多加注意，例如MD5(),SHA1()或者UUID()产生的字符串。这些函数生成的新值会任意分布在很大的空间内，这会导致INSERT以及一些SELECT语句变得很慢：</p>
<ul>
<li>因为插入值会随机的写入到索引的不同位置，所以使得INSERT语句更慢。这会导致叶分裂、磁盘随机访问。</li>
<li>SELECT语句会变的更慢，因为逻辑上相邻的行会分布在磁盘和内存的不同地方。</li>
<li>随机值导致缓存对所有类型的查询语句效果都很差，因为会使得缓存赖以工作的局部性原理失效。</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-87823f5c8c995312533c60e735d79427>2 - CH02-存储引擎</h1>
<h2 id=innodb>InnoDB</h2>
<p>是 MySQL 默认的事务型存储引擎，<strong>只有在需要它不支持的特性时，才考虑使用其它存储引擎</strong>。</p>
<p>实现了四个标准的隔离级别，默认级别是可重复读(REPEATABLE READ)。在可重复读隔离级别下，通过多版本并发控制(MVCC)+ 间隙锁(Next-Key Locking)防止幻读。</p>
<p>主索引是聚簇索引，在索引中保存了数据，从而避免直接读取磁盘，因此对查询性能有很大的提升。</p>
<p>内部做了很多优化，包括从磁盘读取数据时采用的可预测性读、能够加快读操作并且自动创建的自适应哈希索引、能够加速插入操作的插入缓冲区等。</p>
<p>支持真正的在线热备份。其它存储引擎不支持在线热备份，要获取一致性视图需要停止对所有表的写入，而在读写混合场景中，停止写入可能也意味着停止读取。</p>
<h2 id=myisam>MyISAM</h2>
<p>设计简单，数据以紧密格式存储。对于只读数据，或者表比较小、可以容忍修复操作，则依然可以使用它。</p>
<p>提供了大量的特性，包括压缩表、空间数据索引等。</p>
<p><strong>不支持事务</strong>。</p>
<p>不支持行级锁，只能对整张表加锁，读取时会对需要读到的所有表加共享锁，写入时则对表加排它锁。但在表有读取操作的同时，也可以往表中插入新的记录，这被称为并发插入(CONCURRENT INSERT)。</p>
<p>可以手工或者自动执行检查和修复操作，但是和事务恢复以及崩溃恢复不同，可能导致一些数据丢失，而且修复操作是非常慢的。</p>
<p>如果指定了 DELAY_KEY_WRITE 选项，在每次修改执行完成时，不会立即将修改的索引数据写入磁盘，而是会写到内存中的键缓冲区，只有在清理键缓冲区或者关闭表的时候才会将对应的索引块写入磁盘。这种方式可以极大的提升写入性能，但是在数据库或者主机崩溃时会造成索引损坏，需要执行修复操作。</p>
<h2 id=对比>对比</h2>
<ul>
<li>事务: InnoDB 是事务型的，可以使用 Commit 和 Rollback 语句。</li>
<li>并发: MyISAM 只支持表级锁，而 InnoDB 还支持行级锁。</li>
<li>外键: InnoDB 支持外键。</li>
<li>备份: InnoDB 支持在线热备份。</li>
<li>崩溃恢复: MyISAM 崩溃后发生损坏的概率比 InnoDB 高很多，而且恢复的速度也更慢。</li>
<li>其它特性: MyISAM 支持压缩表和空间数据索引。</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-e59a8b6bc16ee47aa4e9119f76c58aa2>3 - CH03-索引B+树</h1>
<h2 id=b-tree-原理>B+ Tree 原理</h2>
<h3 id=1-数据结构>1. 数据结构</h3>
<p>B Tree 指的是 Balance Tree，也就是平衡树。平衡树是一颗查找树，并且所有叶子节点位于同一层。</p>
<p>B+ Tree 是基于 B Tree 和叶子节点顺序访问指针进行实现，它具有 B Tree 的平衡性，并且通过顺序访问指针来提高区间查询的性能。</p>
<p>在 B+ Tree 中，一个节点中的 key 从左到右非递减排列，如果某个指针的左右相邻 key 分别是 key i 和 key i+1，且不为 null，则该指针指向节点的所有 key 大于等于 key i 且小于等于 key i+1。</p>
<div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210503192121.png style=display:block;width:50% alt=NAME align=center> </div>
<h3 id=2-操作>2. 操作</h3>
<p>进行查找操作时，首先在根节点进行二分查找，找到一个 key 所在的指针，然后递归地在指针所指向的节点进行查找。直到查找到叶子节点，然后在叶子节点上进行二分查找，找出 key 所对应的 data。</p>
<p>插入删除操作记录会破坏平衡树的平衡性，因此在插入删除操作之后，需要对树进行一个分裂、合并、旋转等操作来维护平衡性。</p>
<h3 id=3-与红黑树的比较>3. 与红黑树的比较</h3>
<p>红黑树等平衡树也可以用来实现索引，但是文件系统及数据库系统普遍采用 B+ Tree 作为索引结构，主要有以下两个原因:</p>
<p>(一)更少的查找次数</p>
<p>平衡树查找操作的时间复杂度等于树高 h，而树高大致为 O(h)=O(logdN)，其中 d 为每个节点的出度。</p>
<p>红黑树的出度为 2，而 B+ Tree 的出度一般都非常大，所以红黑树的树高 h 很明显比 B+ Tree 大非常多，检索的次数也就更多。</p>
<p>(二)利用计算机预读特性</p>
<p>为了减少磁盘 I/O，磁盘往往不是严格按需读取，而是每次都会预读。预读过程中，磁盘进行顺序读取，顺序读取不需要进行磁盘寻道，并且只需要很短的旋转时间，因此速度会非常快。</p>
<p>操作系统一般将内存和磁盘分割成固态大小的块，每一块称为一页，内存与磁盘以页为单位交换数据。数据库系统将索引的一个节点的大小设置为页的大小，使得一次 I/O 就能完全载入一个节点，并且可以利用预读特性，相邻的节点也能够被预先载入。</p>
<h2 id=mysql-索引>MySQL 索引</h2>
<p>索引是在存储引擎层实现的，而不是在服务器层实现的，所以不同存储引擎具有不同的索引类型和实现。</p>
<h3 id=1-btree-索引>1. B+Tree 索引</h3>
<p>是大多数 MySQL 存储引擎的默认索引类型。</p>
<p>因为不再需要进行全表扫描，只需要对树进行搜索即可，因此查找速度快很多。除了用于查找，还可以用于排序和分组。</p>
<p>可以指定多个列作为索引列，多个索引列共同组成键。</p>
<p>适用于全键值、键值范围和键前缀查找，其中键前缀查找只适用于最左前缀查找。如果不是按照索引列的顺序进行查找，则无法使用索引。</p>
<p>InnoDB 的 B+Tree 索引分为主索引和辅助索引。</p>
<p>主索引的叶子节点 data 域记录着完整的数据记录，这种索引方式被称为聚簇索引。因为无法把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引。</p>
<div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210503192439.png style=display:block;width:50% alt=NAME align=center> </div>
<p>辅助索引的叶子节点的 data 域记录着主键的值，因此在使用辅助索引进行查找时，需要先查找到主键值，然后再到主索引中进行查找。</p>
<div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210503192458.png style=display:block;width:50% alt=NAME align=center> </div>
<h3 id=2-哈希索引>2. 哈希索引</h3>
<p>哈希索引能以 O(1) 时间进行查找，但是失去了有序性，它具有以下限制:</p>
<ul>
<li>无法用于排序与分组；</li>
<li>只支持精确查找，无法用于部分查找和范围查找。</li>
</ul>
<p>InnoDB 存储引擎有一个特殊的功能叫“自适应哈希索引”，当某个索引值被使用的非常频繁时，会在 B+Tree 索引之上再创建一个哈希索引，这样就让 B+Tree 索引具有哈希索引的一些优点，比如快速的哈希查找。</p>
<h3 id=3-全文索引>3. 全文索引</h3>
<p>MyISAM 存储引擎支持全文索引，用于查找文本中的关键词，而不是直接比较是否相等。查找条件使用 MATCH AGAINST，而不是普通的 WHERE。</p>
<p>全文索引一般使用倒排索引实现，它记录着关键词到其所在文档的映射。</p>
<p>InnoDB 存储引擎在 MySQL 5.6.4 版本中也开始支持全文索引。</p>
<h3 id=4-空间数据索引>4. 空间数据索引</h3>
<p>MyISAM 存储引擎支持空间数据索引(R-Tree)，可以用于地理数据存储。空间数据索引会从所有维度来索引数据，可以有效地使用任意维度来进行组合查询。</p>
<p>必须使用 GIS 相关的函数来维护数据。</p>
<h2 id=索引优化>索引优化</h2>
<h3 id=1-独立的列>1. 独立的列</h3>
<p>在进行查询时，索引列不能是表达式的一部分，也不能是函数的参数，否则无法使用索引。</p>
<p>例如下面的查询不能使用 actor_id 列的索引:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=color:#204a87;font-weight:700>SELECT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>actor_id</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>FROM</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>sakila</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>actor</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>WHERE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>actor_id</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>+</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#0000cf;font-weight:700>1</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#0000cf;font-weight:700>5</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></code></pre></div><h3 id=2-多列索引>2. 多列索引</h3>
<p>在需要使用多个列作为条件进行查询时，使用多列索引比使用多个单列索引性能更好。例如下面的语句中，最好把 actor_id 和 film_id 设置为多列索引。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=color:#204a87;font-weight:700>SELECT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>film_id</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>actor_</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>id</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>FROM</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>sakila</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>film_actor</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>WHERE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>actor_id</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#0000cf;font-weight:700>1</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>AND</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>film_id</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></code></pre></div><h3 id=3-索引列的顺序>3. 索引列的顺序</h3>
<p>让选择性最强的索引列放在前面，索引的选择性是指: 不重复的索引值和记录总数的比值。最大值为 1，此时每个记录都有唯一的索引与其对应。选择性越高，查询效率也越高。</p>
<h4 id=4-前缀索引>4. 前缀索引</h4>
<p>对于 BLOB、TEXT 和 VARCHAR 类型的列，必须使用前缀索引，只索引开始的部分字符。</p>
<p>对于前缀长度的选取需要根据索引选择性来确定。</p>
<h4 id=5-覆盖索引>5. 覆盖索引</h4>
<p>索引包含所有需要查询的字段的值。</p>
<p>具有以下优点:</p>
<ul>
<li>索引通常远小于数据行的大小，只读取索引能大大减少数据访问量。</li>
<li>一些存储引擎(例如 MyISAM)在内存中只缓存索引，而数据依赖于操作系统来缓存。因此，只访问索引可以不使用系统调用(通常比较费时)。</li>
<li>对于 InnoDB 引擎，若辅助索引能够覆盖查询，则无需访问主索引。</li>
</ul>
<h2 id=索引的有点>索引的有点</h2>
<p>大大减少了服务器需要扫描的数据行数。</p>
<p>帮助服务器避免进行排序和分组，也就不需要创建临时表(B+Tree 索引是有序的，可以用于 ORDER BY 和 GROUP BY 操作。临时表主要是在排序和分组过程中创建，因为不需要排序和分组，也就不需要创建临时表)。</p>
<p>将随机 I/O 变为顺序 I/O(B+Tree 索引是有序的，也就将相邻的数据都存储在一起)。</p>
<h3 id=索引的使用场景>索引的使用场景</h3>
<ul>
<li>对于非常小的表、大部分情况下简单的全表扫描比建立索引更高效。</li>
<li>对于中到大型的表，索引就非常有效。</li>
<li>但是对于特大型的表，建立和维护索引的代价将会随之增长。这种情况下，需要用到一种技术可以直接区分出需要查询的一组数据，而不是一条记录一条记录地匹配，例如可以使用分区技术。</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-e153ee081a2e00565371b72f637f2039>4 - CH04-性能优化</h1>
<h2 id=使用-explain-进行分析>使用 Explain 进行分析</h2>
<p>Explain 用来分析 SELECT 查询语句，开发人员可以通过分析 Explain 结果来优化查询语句。</p>
<p>Explain 结果中的字段含义:</p>
<ul>
<li><strong>select_type</strong> : 查询类型，有简单查询、联合查询、子查询等</li>
<li>table：当前数据表</li>
<li>partitions：</li>
<li>type：访问类型，表示MySQL在表中查找所需行的方式。
<ul>
<li>ALL：Full Table Scan， MySQL将遍历全表以找到匹配的行；</li>
<li>index：Full Index Scan，index与ALL区别为index类型只遍历索引树；</li>
<li>range：只检索给定范围的行，使用一个索引来选择行；</li>
<li>ref：表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值；</li>
<li>eq_ref：类似ref，区别就在使用的索引是唯一索引，对于每个索引键值，表中只有一条记录匹配，简单来说，就是多表连接中使用primary key或者 unique key作为关联条件；</li>
<li>const system：当MySQL对查询某部分进行优化，并转换为一个常量时，使用这些类型访问。如将主键置于where列表中，MySQL就能将该查询转换为一个常量,system是const类型的特例，当查询的表只有一行的情况下，使用system；</li>
<li>NULL：MySQL在优化过程中分解语句，执行时甚至不用访问表或索引，例如从一个索引列里选取最小值可以通过单独索引查找完成。</li>
</ul>
</li>
<li><strong>possible_keys</strong>：此次查询中可能会被选用的索引，不一定真正用到。</li>
<li><strong>key</strong>：此次查询中真正使用到的索引。当为复合索引时，不确定是否被充分使用。</li>
<li><strong>key_len</strong>：表示索引中使用的字节数，用来计算索引是否被充分使用，不损失精确性的情况下，长度越短越好。
<ul>
<li>key_len=字符长度*字节数+类型+是否允许为空</li>
<li>索引是否充分使用：复合索引每个列都需要计算，所有索引列都生效了才是充分利用。</li>
<li>计算规则：
<ul>
<li>字节数相关：长度、字符编码、类型（int+0，char+0，varchar+2）、是否允许为空（空+1，非空+0）；</li>
<li>int类型字节数为4；</li>
<li>char和varchar的长度是指字符数，一个字符在编码gbk为2个字节、utf-8为3个字节，需要：字符数*字节。</li>
</ul>
</li>
<li>name varchar(50)：表示是varchar类型，长度为50，允许为空，假设是utf8编码
<ul>
<li>key_len=50*3+2+1=153</li>
</ul>
</li>
<li>emp_no int(255)：表示int类型，字节数为4，允许为空，跟长度和编码无关
<ul>
<li>key_len=4+0=4</li>
</ul>
</li>
</ul>
</li>
<li><strong>ref</strong>：</li>
<li><strong>rows</strong> : 预估扫描的行数</li>
<li>filtered：</li>
<li><strong>Extra</strong>：
<ul>
<li><strong>Using where</strong>：意味着全表扫描或者在查找使用索引的情况下，但是还有查询条件不在索引字段当中。
<ul>
<li>查询条件中的相关列，不是索引字段， 全表扫描后，通过Using where过滤获取所需的数据**。**</li>
<li>由于索引未覆盖所有查询条件，在存储引擎返回记录后，仍然需要过滤数据。</li>
<li>WHERE筛选条件不是索引的前导列，导致不走索引，而走全表扫描。</li>
</ul>
</li>
<li><strong>Using index</strong>：表示直接访问索引就能够获取到所需要的数据（覆盖索引），不需要通过索引回表；</li>
<li><strong>Using index condition</strong>：会先条件过滤索引，过滤完索引后找到所有符合索引条件的数据行，随后用 WHERE 子句中的其他条件去过滤这些数据行；</li>
<li><strong>Using where; Using index</strong>：表示在索引的扫描过程中，也是需要过滤数据的（Index First Key 、Index Last Key），其实表扫描和索引扫描也是很类似的。只是发生的层面不一样。</li>
<li><strong>Using temporary</strong>：表示MySQL需要使用临时表来存储结果集，常见于排序和分组查询。</li>
<li><strong>Using filesort</strong>： MySQL中无法利用索引完成的排序操作称为“文件排序”。</li>
</ul>
</li>
</ul>
<blockquote>
<p>Extra 细节参考：https://www.cnblogs.com/kerrycode/p/9909093.html</p>
</blockquote>
<h2 id=优化数据访问>优化数据访问</h2>
<h3 id=0-引擎逻辑>0. 引擎逻辑</h3>
<ul>
<li>当全表扫描速度比索引速度快时，MySQL会使用全表扫描，此时索引失效。</li>
<li>表中存在多个索引时，即使where条件满足某个索引策略，MySQL查询优化器也不一定会使用该索引，可能使用其他索引，取决于性能。另外，当某个索引没有命中也不一定会走全表扫描，可能走其他索引。</li>
<li>理论上索引对顺序是敏感的，也就是说where子句的字段列表需要讲究顺序，但是由于MySQL的查询优化器会自动调整where子句的条件顺序以匹配适合的索引，因此，允许我们不去刻意关注where子句的条件顺序。</li>
</ul>
<h3 id=1-减少请求的数据量>1. 减少请求的数据量</h3>
<ul>
<li>只返回必要的列: 最好不要使用 SELECT * 语句。</li>
<li>只返回必要的行: 使用 LIMIT 语句来限制返回的数据。</li>
<li>缓存重复查询的数据: 使用缓存可以避免在数据库中进行查询，特别在要查询的数据经常被重复查询时，缓存带来的查询性能提升将会是非常明显的。</li>
</ul>
<h3 id=2-减少服务器端扫描的行数>2. 减少服务器端扫描的行数</h3>
<p>最有效的方式是使用索引来覆盖查询。</p>
<p>覆盖索引：SQL只需要通过遍历索引树就可以返回所需要查询的数据，而不必通过辅助索引查到主键值之后再去查询数据（回表操作）。</p>
<h3 id=3-遵循最左前缀匹配>3. 遵循最左前缀匹配</h3>
<p>联合索引命中必须遵循“最左前缀法则”。即SQL查询Where条件字段必须从索引的最左前列开始匹配，不能跳过索引中的列。联合索引又称复合索引，类似于书籍的目录，多级的目录结构中子目录依赖于父级目录存在，也是遵循“最左前缀法则”。</p>
<table>
<thead>
<tr>
<th>联合索引</th>
<th>INDEX idx_empno_birthdate_gender(emp_no,birth_date,gender)</th>
</tr>
</thead>
<tbody>
<tr>
<td>等价建立的索引</td>
<td>实际上联合索引idx_empno_birthdate_gender等价建立了三个索引：<br>- index_1(emp_no)<br>- index_2(emp_no,birth_date)<br>- index_3(emp_no,birth_date,gender)</td>
</tr>
<tr>
<td>联合索引命中的where条件字段列表</td>
<td>- index_1命中：emp_no 或 emp_no,gender<br>- index_2命中：emp_no,birth_date<br>- index_3命中：emp_no,birth_date,gender<br>以上where子句查询条件联合索引idx_empno_birthdate_gender都会命中，只是使用的程度不一样（走的子索引不一样），因此，联合索引有“是否充分使用”衡量指标（key_len），当然使用最充分的条件是：所有字段都命中，即使用了index_3。</td>
</tr>
</tbody>
</table>
<h3 id=4-范围查询字段放最后>4. 范围查询字段放最后</h3>
<p>联合索引定义时，尽量将范围查询字段放在最后（放在最后联合索引使用最充分，放在中间联合索引使用不充分）。使用联合索引时范围列（当前范围列索引生效）后面的索引列无法生效，同时索引最多用于一个范围列，如果查询条件中有多个范围列，也只能用到一个范围列索引。</p>
<h3 id=5-不对索引字段进行逻辑操作>5. 不对索引字段进行逻辑操作</h3>
<p>在索引字段上进行计算、函数、类型转换（自动\手动）都会导致索引失效。</p>
<h3 id=6-尽量全值匹配>6. 尽量全值匹配</h3>
<p>全值匹配也就是精确匹配不使用like查询（模糊匹配），使用like会使查询效率降低。</p>
<h3 id=7-like查询左侧尽量不要加>7. Like查询，左侧尽量不要加%</h3>
<p>like 以%开头，当前列索引无效(当为联合索引时，当前列和后续列索引不生效，可能导致索引使用不充分)；当like前缀没有%，后缀有%时，索引有效。</p>
<h3 id=8-注意nullnot-null-可能对索引有影响>8. 注意null/not null 可能对索引有影响</h3>
<p>在索引列上使用 IS NULL 或 IS NOT NULL条件，可能对索引有所影响。</p>
<ul>
<li>字段定义默认为NULL时，NULL索引生效，NOT NULL索引不生效；</li>
<li>字段定义明确为NOT NULL ，不允许为空时，NULL/NOT NULL索引列，索引均失效；</li>
</ul>
<p>列字段尽量设置为NOT NULL，MySQL难以对使用NULL的列进行查询优化，允许Null会使索引值以及索引统计更加复杂。允许NULL值的列需要更多的存储空间，还需要MySQL内部进行特殊处理。</p>
<h3 id=9-尽量减少使用不等于>9. 尽量减少使用不等于</h3>
<p>不等于操作符是不会使用索引的。不等于操作符包括：not，&lt;>，!=。</p>
<p>优化方法：数值型 key&lt;>0 改为 key>0 or key&lt;0。</p>
<h3 id=10-字符类型务必加上引号>10. 字符类型务必加上引号</h3>
<p>若varchar类型字段值不加单引号，可能会发生数据类型隐式转化，自动转换为int型，使索引无效。</p>
<h3 id=11-or关键字左右尽量都为索引列>11. OR关键字左右尽量都为索引列</h3>
<p>当OR左右查询字段只有一个是索引，会使该索引失效，只有当OR左右查询字段均为索引列时，这些索引才会生效。OR改UNION效率高。</p>
<h3 id=12-or关键字替换为-union>12. OR关键字替换为 UNION</h3>
<p>应尽量避免在 WHERE 子句中使用 OR 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，可以使用 UNION 合并查询：select id from t where num=10 union all select id from t where num=20。</p>
<p>他们的速度只同是否使用索引有关，如果查询需要用到联合索引，用 UNION all 执行的效率更高。多个 OR 的字句没有用到索引，改写成 UNION 的形式再试图与索引匹配。一个关键的问题是否用到索引。</p>
<h3 id=13-避免使用-in-或-not-in>13. 避免使用 IN 或 NOT IN</h3>
<p>IN 和 NOT IN 也要慎用，否则会导致全表扫描。对于连续的数值，能用 BETWEEN 就不要用 IN：select id from t where num between 1 and 3。</p>
<p>或者使用 JOIN 子查询或 EXISTS。</p>
<p>select num from a where num in(select num from b) 替换为 select num from a where exists(select 1 from b where num=a.num)。</p>
<h3 id=14-控制索引数量>14. 控制索引数量</h3>
<p>索引固然可以提高相应的 SELECT 的效率，但同时也降低了 INSERT 及 UPDATE 的效。因为 INSERT 或 UPDATE 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。一个表的索引数最好不要超过 6 个，若太多则应考虑一些不常使用到的列上建的索引是否有必要。</p>
<h3 id=15-避免更新-clustered-索引数据列>15. 避免更新 clustered 索引数据列</h3>
<p>因为 clustered 索引数据列的顺序就是表记录的物理存储顺序，一旦该列值改变将导致整个表记录的顺序的调整，会耗费相当大的资源。若应用系统需要频繁更新 clustered 索引数据列，那么需要考虑是否应将该索引建为 clustered 索引。</p>
<h3 id=16-尽量使用数字型字段>16. 尽量使用数字型字段</h3>
<p>若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。</p>
<h3 id=17-尽可能的使用-varchar-nvarchar>17. 尽可能的使用 varchar, nvarchar</h3>
<p>使用 varchar, nvarchar 代替 char, nchar。因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。</p>
<h3 id=18-仅返回需要的列>18. 仅返回需要的列</h3>
<p>最好不要使用返回所有：<code>select * from t</code> ，用具体的字段列表代替 “*”，不要返回用不到的任何字段。</p>
<h3 id=19-使用表别名-alias>19. 使用表别名 ALIAS</h3>
<p>当在 SQL 语句中连接多个表时，请使用表的别名并把别名前缀于每个 Column 上。这样一来，就可以减少解析的时间并减少那些由 Column 歧义引起的语法错误。</p>
<h3 id=20-使用临时表暂存中间结果>20. 使用“临时表”暂存中间结果</h3>
<p>简化 SQL 语句的重要方法就是采用临时表暂存中间结果。但是临时表的好处远远不止这些，将临时结果暂存在临时表，后面的查询就在 tempdb 中了，这可以避免程序中多次扫描主表，也大大减少了程序执行中“共享锁”阻塞“更新锁”，减少了阻塞，提高了并发性能。</p>
<h3 id=21-查询语句使用-nolock>21. 查询语句使用 nolock</h3>
<p>一些 SQL 查询语句应加上 nolock，读、写是会相互阻塞的，为了提高并发性能。对于一些查询，可以加上 nolock，这样读的时候可以允许写，但缺点是可能读到未提交的脏数据。</p>
<p>使用 nolock 有3条原则：</p>
<ul>
<li>查询的结果用于“插、删、改”的不能加 nolock；</li>
<li>查询的表属于频繁发生页分裂的，慎用 nolock ；</li>
<li>使用临时表一样可以保存“数据前影”，起到类似 Oracle 的 undo 表空间的功能，能采用临时表提高并发性能的，不要用 nolock。</li>
</ul>
<h3 id=22-控制查询涉及的表数量>22. 控制查询涉及的表数量</h3>
<p>不要有超过 5 个以上的表连接（JOIN），考虑使用临时表或表变量存放中间结果。少用子查询，视图嵌套不要过深，一般视图嵌套不要超过 2 个为宜。</p>
<h3 id=23-预计算>23. 预计算</h3>
<p>将需要查询的结果预先计算好放在表中，查询的时候再Select。这在SQL7.0以前是最重要的手段，例如医院的住院费计算。</p>
<h3 id=23-in-列表时值的顺序>23. IN 列表时值的顺序</h3>
<p>在IN后面值的列表中，将出现最频繁的值放在最前面，出现得最少的放在最后面，减少判断的次数。</p>
<h3 id=24-尽量将数据的处理工作放在服务器上减少网络的开销如使用存储过程>24. 尽量将数据的处理工作放在服务器上，减少网络的开销，如使用存储过程。</h3>
<p>存储过程是编译好、优化过、并且被组织到一个执行规划里、且存储在数据库中的 SQL 语句，是控制流语言的集合，速度当然快。反复执行的动态 SQL，可以使用临时存储过程，该过程（临时表）被放在 Tempdb 中。</p>
<h3 id=25-服务器线程数量>25. 服务器线程数量</h3>
<p>当服务器的内存够多时，配制<strong>线程数量 = 最大连接数+5</strong>，这样能发挥最大的效率；</p>
<p>否则使用<strong>配制线程数量&lt; 最大连接数</strong>，启用 SQL SERVER 的线程池来解决，如果还是<strong>数量 = 最大连接数+5</strong>，严重的损害服务器的性能。</p>
<h3 id=26-exists-判断是否存在>26. EXISTS 判断是否存在</h3>
<p>尽量使用 EXISTS 代替 select count(1) 来判断是否存在记录。count 函数只有在统计表中所有行数时使用，而且 count(1) 比 count(*) 更有效率。</p>
<h3 id=27-尽量使用-不要使用->27. 尽量使用 “>=”，不要使用 “>”</h3>
<h3 id=28-批量执行插入或更新不要逐条执行>28. 批量执行插入或更新，不要逐条执行</h3>
<p>JDBC 设置参数 <code>rewriteBatchedStatements=true</code>。</p>
<h3 id=29-存储过程避免循环>29. 存储过程避免循环</h3>
<p>例如：列出上个月的每一天，用 connect by 去递归查询一下，绝不会去用循环从上个月第一天到最后一天。</p>
<h3 id=30-选择最有效率的表名顺序>30. 选择最有效率的表名顺序</h3>
<p>只在基于规则的优化器中有效：</p>
<p>Oracle 的解析器按照从右到左的顺序处理 FROM 子句中的表名，FROM 子句中写在最后的表（基础表 driving table）将被最先处理，在 FROM 子句中包含多个表的情况下，你必须选择记录条数最少的表作为基础表。</p>
<p>如果有 3 个以上的表连接查询，那就需要选择交叉表（intersection table）作为基础表，交叉表是指那个被其他表所引用的表。</p>
<h3 id=31-过滤掉无需-group-by-的字段>31. 过滤掉无需 GROUP BY 的字段</h3>
<p>可以通过将不需要的记录在 GROUP BY 之前过滤掉。下面两个查询返回相同结果，但第二个明显就快了许多。</p>
<p>低效：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=color:#204a87;font-weight:700>SELECT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>JOB</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>AVG</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>SAL</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> 
</span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>FROM</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>EMP</span><span style=color:#f8f8f8;text-decoration:underline> 
</span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>GROUP</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>BY</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>JOB</span><span style=color:#f8f8f8;text-decoration:underline> 
</span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>HAVING</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>JOB</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#4e9a06>&#39;PRESIDENT&#39;</span><span style=color:#f8f8f8;text-decoration:underline> 
</span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>OR</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>JOB</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#4e9a06>&#39;MANAGER&#39;</span><span style=color:#f8f8f8;text-decoration:underline> 
</span></code></pre></div><p>高效：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=color:#204a87;font-weight:700>SELECT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>JOB</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>AVG</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>SAL</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline> 
</span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>FROM</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>EMP</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>WHERE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>JOB</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#4e9a06>&#39;PRESIDENT&#39;</span><span style=color:#f8f8f8;text-decoration:underline> 
</span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>OR</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>JOB</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#4e9a06>&#39;MANAGER&#39;</span><span style=color:#f8f8f8;text-decoration:underline> 
</span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>GROUP</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>BY</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>JOB</span><span style=color:#f8f8f8;text-decoration:underline>
</span></code></pre></div><h3 id=32-sql-语句用大写>32. SQL 语句用大写</h3>
<p>Oracle 中总是先解析 SQL 语句，把小写的字母转换成大写的再执行。</p>
<h3 id=36-避免存储过程死锁>36. 避免存储过程死锁</h3>
<ul>
<li>
<p>在你的存储过程和触发器中访问同一个表时总是以相同的顺序；</p>
</li>
<li>
<p>事务应经可能地缩短，在一个事务中应尽可能减少涉及到的数据量；</p>
</li>
<li>
<p>永远不要在事务中等待用户输入。</p>
</li>
</ul>
<h3 id=37-表变量优先于临时表>37. 表变量优先于临时表</h3>
<p>应尽量避免使用临时表，相反，可以使用表变量代替。大多数时候（99%），表变量驻扎在内存中，因此速度比临时表更快，临时表驻扎在 TempDb 数据库中，因此临时表上的操作需要跨数据库通信，速度自然慢。</p>
<h3 id=38-避免使用触发器>38. 避免使用触发器</h3>
<ul>
<li>触发一个触发器，执行一个触发器事件本身就是一个耗费资源的过程；</li>
<li>如果能够使用约束实现的，尽量不要使用触发器；</li>
<li>不要为不同的触发事件（Insert、Update 和 Delete）使用相同的触发器；</li>
<li>不要在触发器中使用事务型代码。</li>
</ul>
<h3 id=39-索引创建规则>39. 索引创建规则</h3>
<ul>
<li>表的主键、外键必须有索引；</li>
<li>数据量超过 300 的表应该有索引；</li>
<li>经常与其他表进行连接的表，在连接字段上应该建立索引；</li>
<li>经常出现在 WHERE 子句中的字段，特别是大表的字段，应该建立索引；</li>
<li>索引应该建在选择性高的字段上；</li>
<li>索引应该建在小字段上，对于大的文本字段甚至超长字段，不要建索引；</li>
<li>复合索引的建立需要进行仔细分析，尽量考虑用单字段索引代替；</li>
<li>正确选择复合索引中的主列字段，一般是选择性较好的字段；</li>
<li>复合索引的几个字段是否经常同时以 AND 方式出现在 WHERE 子句中？单字段查询是否极少甚至没有？如果是，则可以建立复合索引；否则考虑单字段索引；</li>
<li>如果复合索引中包含的字段经常单独出现在 WHERE 子句中，则分解为多个单字段索引；</li>
<li>如果复合索引所包含的字段超过 3 个，那么仔细考虑其必要性，考虑减少复合的字段；</li>
<li>如果既有单字段索引，又有这几个字段上的复合索引，一般可以删除复合索引；</li>
<li>频繁进行数据操作的表，不要建立太多的索引；</li>
<li>删除无用的索引，避免对执行计划造成负面影响；</li>
<li>表上建立的每个索引都会增加存储开销，索引对于插入、删除、更新操作也会增加处理上的开销。另外，过多的复合索引，在有单字段索引的情况下，一般都是没有存在价值的；相反，还会降低数据增加删除时的性能，特别是对频繁更新的表来说，负面影响更大。</li>
<li>尽量不要对数据库中某个含有大量重复的值的字段建立索引。</li>
</ul>
<h3 id=40-主键设置>40. 主键设置</h3>
<p>应该为数据库里的每张表都设置一个 ID 做为其主键，而且最好的是一个 INT 型的（推荐使用 UNSIGNED），并设置上自动增加的 AUTO_INCREMENT 标志。</p>
<h3 id=41-使用-innodb>41. 使用 InnoDB</h3>
<ul>
<li><strong>myisam：</strong>
<ul>
<li>应用时以读和插入操作为主，只有少量的更新和删除，并且对事务的完整性，并发性要求不是很高的。</li>
</ul>
</li>
<li>InnoDB：
<ul>
<li>事务处理，以及并发条件下要求数据的一致性。除了插入和查询外，包括很多的更新和删除。（InnoDB 有效地降低删除和更新导致的锁定）。</li>
<li>对于支持事务的 InnoDB类 型的表来说，影响速度的主要原因是 AUTOCOMMIT 默认设置是打开的，而且程序没有显式调用 BEGIN 开始事务，导致每插入一条都自动提交，严重影响了速度。可以在执行 SQL 前调用 begin，多条 SQL 形成一个事物（即使 autocommit 打开也可以），将大大提高性能。</li>
</ul>
</li>
</ul>
<h3 id=42-选择合适的字段类型>42. 选择合适的字段类型</h3>
<p>**原则：**更小通常更好，简单就好，所有字段都得有默认值，尽量避免 NULL。</p>
<p>例如：数据库表设计时候更小的占磁盘空间尽可能使用更小的整数类型。(mediumint 就比 int 更合适)</p>
<p>比如时间字段：datetime 和 timestamp。datetime 占用8个字节，timestamp 占用4个字节，只用了一半。而 timestamp 表示的范围是 1970—2037 适合做更新时间。</p>
<p>MySQL可以很好的支持大数据量的存取，但是一般说来，数据库中的表越小，在它上面执行的查询也就会越快。</p>
<p>因此，在创建表的时候，为了获得更好的性能，我们可以将表中字段的宽度设得尽可能小。</p>
<p>例如：在定义邮政编码这个字段时，如果将其设置为 CHAR(255)，显然给数据库增加了不必要的空间。甚至使用VARCHAR 这种类型也是多余的，因为 CHAR(6) 就可以很好的完成任务了。</p>
<p>同样的，如果可以的话，我们应该使用 MEDIUMINT 而不是 BIGIN 来定义整型字段，应该尽量把字段设置为 NOT NULL，这样在将来执行查询的时候，数据库不用去比较 NULL 值。</p>
<p>对于某些文本字段，例如“省份”或者“性别”，我们可以将它们定义为 ENUM 类型。因为在 MySQL 中，ENUM 类型被当作数值型数据来处理，而数值型数据被处理起来的速度要比文本类型快得多。这样，我们又可以提高数据库的性能。</p>
<h2 id=重构查询方式>重构查询方式</h2>
<h3 id=1-切分大查询>1. 切分大查询</h3>
<p>一个大查询如果一次性执行的话，可能一次锁住很多数据、占满整个事务日志、耗尽系统资源、阻塞很多小的但重要的查询。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=color:#000>DELEFT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>FROM</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>messages</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>WHERE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>create</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>DATE_SUB</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>NOW</span><span style=color:#000;font-weight:700>(),</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87>INTERVAL</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#0000cf;font-weight:700>3</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>MONTH</span><span style=color:#000;font-weight:700>);</span><span style=color:#f8f8f8;text-decoration:underline>
</span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=color:#000>rows_affected</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#0000cf;font-weight:700>0</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>do</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#a40000>{</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>    </span><span style=color:#000>rows_affected</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>do_query</span><span style=color:#000;font-weight:700>(</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>    </span><span style=color:#4e9a06>&#34;DELETE FROM messages WHERE create  &lt; DATE_SUB(NOW(), INTERVAL 3 MONTH) LIMIT 10000&#34;</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#a40000>}</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>while</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>rows_affected</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>&gt;</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#0000cf;font-weight:700>0</span><span style=color:#f8f8f8;text-decoration:underline>
</span></code></pre></div><h3 id=2-分解大连接查询>2. 分解大连接查询</h3>
<p>将一个大连接查询分解成对每一个表进行一次单表查询，然后将结果在应用程序中进行关联，这样做的好处有:</p>
<ul>
<li>让缓存更高效。对于连接查询，如果其中一个表发生变化，那么整个查询缓存就无法使用。而分解后的多个查询，即使其中一个表发生变化，对其它表的查询缓存依然可以使用。</li>
<li>分解成多个单表查询，这些单表查询的缓存结果更可能被其它查询使用到，从而减少冗余记录的查询。</li>
<li>减少锁竞争；</li>
<li>在应用层进行连接，可以更容易对数据库进行拆分，从而更容易做到高性能和可伸缩。</li>
<li>查询本身效率也可能会有所提升。例如下面的例子中，使用 IN() 代替连接查询，可以让 MySQL 按照 ID 顺序进行查询，这可能比随机的连接要更高效。</li>
</ul>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=color:#204a87;font-weight:700>SELECT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>*</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>FROM</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>tab</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>JOIN</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>tag_post</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>ON</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>tag_post</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>tag_id</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#000>tag</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>id</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>JOIN</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>post</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>ON</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>tag_post</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>post_id</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#000>post</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>id</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>WHERE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>tag</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>tag</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#4e9a06>&#39;mysql&#39;</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=color:#204a87;font-weight:700>SELECT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>*</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>FROM</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>tag</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>WHERE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>tag</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#4e9a06>&#39;mysql&#39;</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>SELECT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>*</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>FROM</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>tag_post</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>WHERE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>tag_id</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#0000cf;font-weight:700>1234</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>SELECT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>*</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>FROM</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>post</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>WHERE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>post</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>id</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>IN</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>123</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>456</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>567</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>9098</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>8904</span><span style=color:#000;font-weight:700>);</span><span style=color:#f8f8f8;text-decoration:underline>
</span></code></pre></div>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-29d040819faa80f395ba725e176690a3>5 - CH05-分库分表</h1>
<h2 id=水平切分>水平切分</h2>
<p>水平切分又称为 Sharding，它是将同一个表中的记录拆分到多个结构相同的表中。</p>
<p>当一个表的数据不断增多时，Sharding 是必然的选择，它可以将数据分布到集群的不同节点上，从而缓存单个数据库的压力。</p>
<div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210503194243.png style=display:block;width:50% alt=NAME align=center> </div>
<h2 id=垂直切分>垂直切分</h2>
<p>垂直切分是将一张表按列切分成多个表，通常是按照列的关系密集程度进行切分，也可以利用垂直切分将经常被使用的列和不经常被使用的列切分到不同的表中。</p>
<p>在数据库的层面使用垂直切分将按数据库中表的密集程度部署到不同的库中，例如将原来的电商数据库垂直切分成商品数据库、用户数据库等。</p>
<div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210503194255.png style=display:block;width:50% alt=NAME align=center> </div>
<h2 id=sharding-策略>Sharding 策略</h2>
<ul>
<li>哈希取模: hash(key) % NUM_DB</li>
<li>范围: 可以是 ID 范围也可以是时间范围</li>
<li>映射表: 使用单独的一个数据库来存储映射关系</li>
</ul>
<h2 id=sharding-存在的问题及解决方案>Sharding 存在的问题及解决方案</h2>
<h3 id=1-事务问题>1. 事务问题</h3>
<p>使用分布式事务来解决，比如 XA 接口。</p>
<h3 id=2-链接>2. 链接</h3>
<p>可以将原来的 JOIN 分解成多个单表查询，然后在用户程序中进行 JOIN。</p>
<h3 id=3-id-唯一性>3. ID 唯一性</h3>
<ul>
<li>使用全局唯一 ID: GUID</li>
<li>为每个分片指定一个 ID 范围</li>
<li>分布式 ID 生成器 (如 Twitter 的 Snowflake 算法)</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-18dd619a88421627df2c9f215cacaecc>6 - CH06-复制分离</h1>
<h2 id=主从复制>主从复制</h2>
<p>主要涉及三个线程: binlog 线程、I/O 线程和 SQL 线程。</p>
<ul>
<li><strong>binlog 线程</strong> : 负责将主服务器上的数据更改写入二进制日志中。</li>
<li><strong>I/O 线程</strong> : 负责从主服务器上读取二进制日志，并写入从服务器的中继日志中。</li>
<li><strong>SQL 线程</strong> : 负责读取中继日志并重放其中的 SQL 语句。</li>
</ul>
<div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210503194809.png style=display:block;width:50% alt=NAME align=center> </div>
<h2 id=读写分离>读写分离</h2>
<p>主服务器处理写操作以及实时性要求比较高的读操作，而从服务器处理读操作。</p>
<p>读写分离能提高性能的原因在于:</p>
<ul>
<li>主从服务器负责各自的读和写，极大程度缓解了锁的争用；</li>
<li>从服务器可以使用 MyISAM，提升查询性能以及节约系统开销；</li>
<li>增加冗余，提高可用性。</li>
</ul>
<p>读写分离常用代理方式来实现，代理服务器接收应用层传来的读写请求，然后决定转发到哪个服务器。</p>
<div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210503194848.png style=display:block;width:50% alt=NAME align=center> </div>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-280203572e4e446020b171753e2c2a12>7 - CH07-执行过程</h1>
<h2 id=前言>前言</h2>
<p>天天和数据库打交道，一天能写上几十条 SQL 语句，但你知道我们的系统是如何和数据库交互的吗？MySQL 如何帮我们存储数据、又是如何帮我们管理事务？&mldr;.是不是感觉真的除了写几个 「select * from dual」外基本脑子一片空白？这篇文章就将带你走进 MySQL 的世界，让你彻底了解系统到底是如何和 MySQL 交互的，MySQL 在接受到我们发送的 SQL 语句时又分别做了哪些事情。</p>
<h2 id=mysql-驱动>MySQL 驱动</h2>
<p>我们的系统在和 MySQL 数据库进行通信的时候，总不可能是平白无故的就能接收和发送请求，就算是你没有做什么操作，那总该是有其他的“人”帮我们做了一些事情，基本上使用过 MySQL 数据库的程序员多多少少都会知道 MySQL 驱动这个概念的。就是这个 MySQL 驱动在底层帮我们做了对数据库的连接，只有建立了连接了，才能够有后面的交互。看下图表示</p>
<div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210503195039.png style=display:block;width:50% alt=NAME align=center> </div>
<p>这样的话，在系统和 MySQL 进行交互之前，MySQL 驱动会帮我们建立好连接，然后我们只需要发送 SQL 语句就可以执行 CRUD 了。一次 SQL 请求就会建立一个连接，多个请求就会建立多个连接，那么问题来了，我们系统肯定不是一个人在使用的，换句话说肯定是存在多个请求同时去争抢连接的情况。我们的 web 系统一般都是部署在 tomcat 容器中的，而 tomcat 是可以并发处理多个请求的，这就会导致多个请求会去建立多个连接，然后使用完再都去关闭，这样会有什么问题呢？如下图</p>
<div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210503195111.png style=display:block;width:50% alt=NAME align=center> </div>
<p>java 系统在通过 MySQL 驱动和 MySQL 数据库连接的时候是基于 TCP/IP 协议的，所以如果每个请求都是新建连接和销毁连接，那这样势必会造成不必要的浪费和性能的下降，也就说上面的多线程请求的时候频繁的创建和销毁连接显然是不合理的。必然会大大降低我们系统的性能，但是如果给你提供一些固定的用来连接的线程，这样是不是不需要反复的创建和销毁连接了呢？相信懂行的朋友会会心一笑，没错，说的就是数据库连接池。</p>
<p><strong>数据库连接池</strong>：维护一定的连接数，方便系统获取连接，使用就去池子中获取，用完放回去就可以了，我们不需要关心连接的创建与销毁，也不需要关心线程池是怎么去维护这些连接的。</p>
<div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210503195148.png style=display:block;width:50% alt=NAME align=center> </div>
<p>常见的数据库连接池有 HakariCP、Druid、C3P0、DBCP，连接池实现原理在这里就不深入讨论了，采用连接池大大节省了不断创建与销毁线程的开销，这就是有名的「池化」思想，不管是线程池还是 HTTP 连接池，都能看到它的身影。</p>
<h2 id=数据库连接池>数据库连接池</h2>
<p>到这里，我们已经知道的是我们的系统在访问 MySQL 数据库的时候，建立的连接并不是每次请求都会去创建的，而是从数据库连接池中去获取，这样就解决了因为反复的创建和销毁连接而带来的性能损耗问题了。不过这里有个小问题，业务系统是并发的，而 MySQL 接受请求的线程呢，只有一个？</p>
<p>其实 MySQL 的架构体系中也已经提供了这样的一个池子，也是数据库连池。双方都是通过数据库连接池来管理各个连接的，这样一方面线程之前不需要是争抢连接，更重要的是不需要反复的创建的销毁连接。</p>
<div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210503195232.png style=display:block;width:50% alt=NAME align=center> </div>
<p>至此系统和 MySQL 数据库之间的连接问题已经说明清楚了。那么 MySQL 数据库中的这些连接是怎么来处理的，又是谁来处理呢？</p>
<h2 id=网络连接必须由线程来处理>网络连接必须由线程来处理</h2>
<p>对计算基础稍微有一点了解的的同学都是知道的，网络中的连接都是由线程来处理的，所谓网络连接说白了就是一次请求，每次请求都会有相应的线程去处理的。也就是说对于 SQL 语句的请求在 MySQL 中是由一个个的线程去处理的。</p>
<div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210503195303.png style=display:block;width:50% alt=NAME align=center> </div>
<p>那这些线程会怎么去处理这些请求？会做哪些事情？</p>
<h2 id=sql-接口>SQL 接口</h2>
<p>MySQL 中处理请求的线程在获取到请求以后获取 SQL 语句去交给 SQL 接口去处理。</p>
<h2 id=查询解析器>查询解析器</h2>
<p>假如现在有这样的一个 SQL</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=color:#204a87;font-weight:700>SELECT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>stuName</span><span style=color:#000;font-weight:700>,</span><span style=color:#000>age</span><span style=color:#000;font-weight:700>,</span><span style=color:#000>sex</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>FROM</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>students</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>WHERE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>id</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#0000cf;font-weight:700>1</span><span style=color:#f8f8f8;text-decoration:underline>
</span></code></pre></div><p>但是这个 SQL 是写给我们人看的，机器哪里知道你在说什么？这个时候解析器就上场了。他会将 SQL 接口传递过来的 SQL 语句进行解析，翻译成 MySQL 自己能认识的语言，至于怎么解析的就不需要在深究了，无非是自己一套相关的规则。</p>
<div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210503195353.png style=display:block;width:50% alt=NAME align=center> </div>
<p>现在 SQL 已经被解析成 MySQL 认识的样子的，那下一步是不是就是执行吗？理论上是这样子的，但是 MySQL 的强大远不止于此，他还会帮我们选择最优的查询路径。</p>
<p>什么叫最优查询路径？就是 MySQL 会按照自己认为的效率最高的方式去执行查询.</p>
<p>具体是怎么做到的呢？这就要说到 MySQL 的查询优化器了</p>
<h2 id=mysql-查询优化器>MySQL 查询优化器</h2>
<p>查询优化器内部具体怎么实现的我们不需要是关心，我需要知道的是 MySQL 会帮我去使用他自己认为的最好的方式去优化这条 SQL 语句，并生成一条条的执行计划，比如你创建了多个索引，MySQL 会依据成本最小原则来选择使用对应的索引，这里的成本主要包括两个方面, IO 成本和 CPU 成本</p>
<p><strong>IO 成本</strong>: 即从磁盘把数据加载到内存的成本，默认情况下，读取数据页的 IO 成本是 1，MySQL 是以页的形式读取数据的，即当用到某个数据时，并不会只读取这个数据，而会把这个数据相邻的数据也一起读到内存中，这就是有名的程序局部性原理，所以 MySQL 每次会读取一整页，一页的成本就是 1。所以 IO 的成本主要和页的大小有关</p>
<p><strong>CPU 成本</strong>：将数据读入内存后，还要检测数据是否满足条件和排序等 CPU 操作的成本，显然它与行数有关，默认情况下，检测记录的成本是 0.2。</p>
<p>MySQL 优化器 会计算 「IO 成本 + CPU」 成本最小的那个索引来执行</p>
<div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210503195422.png style=display:block;width:50% alt=NAME align=center> </div>
<p>优化器执行选出最优索引等步骤后，会去调用存储引擎接口，开始去执行被 MySQL 解析过和优化过的 SQL 语句</p>
<h2 id=存储引擎>存储引擎</h2>
<p>查询优化器会调用存储引擎的接口，去执行 SQL，也就是说真正执行 SQL 的动作是在存储引擎中完成的。数据是被存放在内存或者是磁盘中的（存储引擎是一个非常重要的组件，后面会详细介绍）</p>
<h2 id=执行器>执行器</h2>
<p>执行器是一个非常重要的组件，因为前面那些组件的操作最终必须通过执行器去调用存储引擎接口才能被执行。执行器最终最根据一系列的执行计划去调用存储引擎的接口去完成 SQL 的执行</p>
<div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210503195448.png style=display:block;width:50% alt=NAME align=center> </div>
<h2 id=初识存储引擎>初识存储引擎</h2>
<p>我们以一个更新的SQL语句来说明，SQL 如下</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=color:#204a87;font-weight:700>UPDATE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>students</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>SET</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>stuName</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#4e9a06>&#39;小强&#39;</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>WHERE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>id</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#0000cf;font-weight:700>1</span><span style=color:#f8f8f8;text-decoration:underline>
</span></code></pre></div><p>当我们系统发出这样的查询去交给 MySQL 的时候，MySQL 会按照我们上面介绍的一系列的流程最终通过执行器调用存储引擎去执行，流程图就是上面那个。在执行这个 SQL 的时候 SQL 语句对应的数据要么是在内存中，要么是在磁盘中，如果直接在磁盘中操作，那这样的随机IO读写的速度肯定让人无法接受的，所以每次在执行 SQL 的时候都会将其数据加载到内存中，这块内存就是 InnoDB 中一个非常重要的组件：<strong>缓冲池 Buffer Pool</strong></p>
<h2 id=buffer-pool>Buffer Pool</h2>
<p>Buffer Pool （缓冲池）是 InnoDB 存储引擎中非常重要的内存结构，顾名思义，缓冲池其实就是类似 Redis 一样的作用，起到一个缓存的作用，因为我们都知道 MySQL 的数据最终是存储在磁盘中的，如果没有这个 Buffer Pool 那么我们每次的数据库请求都会磁盘中查找，这样必然会存在 IO 操作，这肯定是无法接受的。但是有了 Buffer Pool 就是我们第一次在查询的时候会将查询的结果存到 Buffer Pool 中，这样后面再有请求的时候就会先从缓冲池中去查询，如果没有再去磁盘中查找，然后在放到 Buffer Pool 中，如下图</p>
<div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210503195538.png style=display:block;width:50% alt=NAME align=center> </div>
<p>按照上面的那幅图，这条 SQL 语句的执行步骤大致是这样子的</p>
<ul>
<li>innodb 存储引擎会在缓冲池中查找 id=1 的这条数据是否存在</li>
<li>发现不存在，那么就会去磁盘中加载，并将其存放在缓冲池中</li>
<li>该条记录会被加上一个独占锁（总不能你在修改的时候别人也在修改吧，这个机制本篇文章不重点介绍，以后会专门写文章来详细讲解）</li>
</ul>
<h2 id=undo-日志文件记录数据被修改前的样子>undo 日志文件：记录数据被修改前的样子</h2>
<p>undo 顾名思义，就是没有做，没发生的意思。undo log 就是没有发生事情（原本事情是什么）的一些日志</p>
<p>我们刚刚已经说了，在准备更新一条语句的时候，该条语句已经被加载到 Buffer pool 中了，实际上这里还有这样的操作，就是在将该条语句加载到 Buffer Pool 中的时候同时会往 undo 日志文件中插入一条日志，也就是将 id=1 的这条记录的原来的值记录下来。</p>
<p><strong>这样做的目的是什么</strong>？</p>
<p>Innodb 存储引擎的最大特点就是支持事务，如果本次更新失败，也就是事务提交失败，那么该事务中的所有的操作都必须回滚到执行前的样子，也就是说当事务失败的时候，也不会对原始数据有影响，看图说话</p>
<div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210503195600.png style=display:block;width:50% alt=NAME align=center> </div>
<p>这里说句额外话，其实 MySQL 也是一个系统，就好比我们平时开发的 java 的功能系统一样，MySQL 使用的是自己相应的语言开发出来的一套系统而已，它根据自己需要的功能去设计对应的功能，它即然能做到哪些事情，那么必然是设计者们当初这么定义或者是根据实际的场景变更演化而来的。所以大家放平心态，把 MySQL 当作一个系统去了解熟悉他。</p>
<p>到这一步，我们的执行的 SQL 语句已经被加载到 Buffer Pool 中了，然后开始更新这条语句，更新的操作实际是在Buffer Pool中执行的，那问题来了，按照我们平时开发的一套理论缓冲池中的数据和数据库中的数据不一致时候，我们就认为缓存中的数据是脏数据，那此时 Buffer Pool 中的数据岂不是成了脏数据？没错，目前这条数据就是脏数据，Buffer Pool 中的记录是小强 数据库中的记录是旺财 ，这种情况 MySQL是怎么处理的呢，继续往下看</p>
<h2 id=redo-日志文件记录数据被修改后的样子>redo 日志文件：记录数据被修改后的样子</h2>
<p>除了从磁盘中加载文件和将操作前的记录保存到 undo 日志文件中，其他的操作是在内存中完成的，内存中的数据的特点就是：断电丢失。如果此时 MySQL 所在的服务器宕机了，那么 Buffer Pool 中的数据会全部丢失的。这个时候 redo 日志文件就需要来大显神通了</p>
<p><strong>画外音：redo 日志文件是 InnoDB 特有的，他是存储引擎级别的，不是 MySQL 级别的</strong></p>
<p>redo 记录的是数据修改之后的值，不管事务是否提交都会记录下来，例如，此时将要做的是update students set stuName=&lsquo;小强&rsquo; where id=1; 那么这条操作就会被记录到 redo log buffer 中，啥？怎么又出来一个 redo log buffer ,很简单，MySQL 为了提高效率，所以将这些操作都先放在内存中去完成，然后会在某个时机将其持久化到磁盘中。</p>
<div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210503195621.png style=display:block;width:50% alt=NAME align=center> </div>
<p>截至目前，我们应该都熟悉了 MySQL 的执行器调用存储引擎是怎么将一条 SQL 加载到缓冲池和记录哪些日志的，流程如下：</p>
<ul>
<li>准备更新一条 SQL 语句</li>
<li>MySQL（innodb）会先去缓冲池（BufferPool）中去查找这条数据，没找到就会去磁盘中查找，如果查找到就会将这条数据加载到缓冲池（BufferPool）中</li>
<li>在加载到 Buffer Pool 的同时，会将这条数据的原始记录保存到 undo 日志文件中</li>
<li>innodb 会在 Buffer Pool 中执行更新操作</li>
<li>更新后的数据会记录在 redo log buffer 中</li>
</ul>
<p>上面说的步骤都是在正常情况下的操作，但是程序的设计和优化并不仅是为了这些正常情况而去做的，也是为了<strong>那些临界区和极端情况下出现的问题去优化</strong>设计的</p>
<p>这个时候如果服务器宕机了，那么缓存中的数据还是丢失了。真烦，竟然数据总是丢失，那能不能不要放在内存中，直接保存到磁盘呢？很显然不行，因为在上面也已经介绍了，在内存中的操作目的是为了提高效率。</p>
<p>此时，如果 MySQL 真的宕机了，那么没关系的，因为 MySQL 会认为本次事务是失败的，所以数据依旧是更新前的样子，并不会有任何的影响。</p>
<p>好了，语句也更新好了那么需要将更新的值提交啊，也就是需要提交本次的事务了，因为只要事务成功提交了，才会将最后的变更保存到数据库，在提交事务前仍然会具有相关的其他操作</p>
<p>将 redo Log Buffer 中的数据持久化到磁盘中，就是将 redo log buffer 中的数据写入到 redo log 磁盘文件中，一般情况下，redo log Buffer 数据写入磁盘的策略是立即刷入磁盘（具体策略情况在下面小总结出会详细介绍）,上图</p>
<div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210503195634.png style=display:block;width:50% alt=NAME align=center> </div>
<p>如果 redo log Buffer 刷入磁盘后，数据库服务器宕机了，那我们更新的数据怎么办？此时数据是在内存中，数据岂不是丢失了？不，这次数据就不会丢失了，因为 redo log buffer 中的数据已经被写入到磁盘了，已经被持久化了，就算数据库宕机了，在下次重启的时候 MySQL 也会将 redo 日志文件内容恢复到 Buffer Pool 中（这边我的理解是和 Redis 的持久化机制是差不多的，在 Redis 启动的时候会检查 rdb 或者是 aof 或者是两者都检查，根据持久化的文件来将数据恢复到内存中）</p>
<p>到此为止，<strong>从执行器开始调用存储引擎接口做了哪些事情呢</strong>？</p>
<ul>
<li>准备更新一条 SQL 语句</li>
<li>MySQL（innodb）会先去缓冲池（BufferPool）中去查找这条数据，没找到就会去磁盘中查找，如果查找到就会将这条数据加载</li>
<li>到缓冲池（BufferPool）中 3.在加载到 Buffer Pool 的同时，会将这条数据的原始记录保存到 undo 日志文件中</li>
<li>innodb 会在 Buffer Pool 中执行更新操作</li>
<li>更新后的数据会记录在 redo log buffer 中</li>
<li>MySQL 提交事务的时候，会将 redo log buffer 中的数据写入到 redo 日志文件中 刷磁盘可以通过 innodb_flush_log_at_trx_commit 参数来设置
<ul>
<li>值为 0 表示不刷入磁盘</li>
<li>值为 1 表示立即刷入磁盘</li>
<li>值为 2 表示先刷到 os cache</li>
</ul>
</li>
<li>myslq 重启的时候会将 redo 日志恢复到缓冲池中</li>
</ul>
<p>截止到目前位置，MySQL 的执行器调用存储引擎的接口去执行【执行计划】提供的 SQL 的时候 InnoDB 做了哪些事情也就基本差不多了，但是这还没完。下面还需要介绍下 MySQL 级别的日志文件 bin log</p>
<h2 id=bin-log-日志文件记录整个操作过程>bin log 日志文件：记录整个操作过程</h2>
<p>上面介绍到的redo log是 InnoDB 存储引擎特有的日志文件，而bin log属于是 MySQL 级别的日志。redo log记录的东西是偏向于物理性质的，如：“对什么数据，做了什么修改”。bin log是偏向于逻辑性质的，类似于：“对 students 表中的 id 为 1 的记录做了更新操作” 两者的主要特点总结如下:</p>
<table>
<thead>
<tr>
<th>性质</th>
<th>redo Log</th>
<th>bin Log</th>
</tr>
</thead>
<tbody>
<tr>
<td>文件大小</td>
<td>redo log 的大小是固定的（配置中也可以设置，一般默认的就足够了）</td>
<td>bin log 可通过配置参数max_bin log_size设置每个bin log文件的大小（但是一般不建议修改）。</td>
</tr>
<tr>
<td>实现方式</td>
<td>redo log是InnoDB引擎层实现的（也就是说是 Innodb 存储引起过独有的）</td>
<td>bin log是 MySQL 层实现的，所有引擎都可以使用 bin log日志</td>
</tr>
<tr>
<td>记录方式</td>
<td>redo log 采用循环写的方式记录，当写到结尾时，会回到开头循环写日志。</td>
<td>bin log 通过追加的方式记录，当文件大小大于给定值后，后续的日志会记录到新的文件上</td>
</tr>
<tr>
<td>使用场景</td>
<td>redo log适用于崩溃恢复(crash-safe)（这一点其实非常类似与 Redis 的持久化特征）</td>
<td>bin log 适用于主从复制和数据恢复</td>
</tr>
</tbody>
</table>
<p><strong>bin log文件是如何刷入磁盘的</strong>?</p>
<p>bin log 的刷盘是有相关的策略的，策略可以通过sync_bin log来修改，默认为 0，表示先写入 os cache，也就是说在提交事务的时候，数据不会直接到磁盘中，这样如果宕机bin log数据仍然会丢失。所以建议将sync_bin log设置为 1 表示直接将数据写入到磁盘文件中。</p>
<p>刷入 bin log 有以下几种模式</p>
<ul>
<li><strong>STATMENT</strong></li>
</ul>
<p>基于 SQL 语句的复制(statement-based replication, SBR)，每一条会修改数据的 SQL 语句会记录到 bin log 中</p>
<p>【优点】：不需要记录每一行的变化，减少了 bin log 日志量，节约了 IO , 从而提高了性能</p>
<p>【缺点】：在某些情况下会导致主从数据不一致，比如执行sysdate()、slepp()等</p>
<ul>
<li><strong>ROW</strong></li>
</ul>
<p>基于行的复制(row-based replication, RBR)，不记录每条SQL语句的上下文信息，仅需记录哪条数据被修改了</p>
<p>【优点】：不会出现某些特定情况下的存储过程、或 function、或 trigger 的调用和触发无法被正确复制的问题</p>
<p>【缺点】：会产生大量的日志，尤其是 alter table 的时候会让日志暴涨</p>
<ul>
<li><strong>MIXED</strong></li>
</ul>
<p>基于 STATMENT 和 ROW 两种模式的混合复制( mixed-based replication, MBR )，一般的复制使用 STATEMENT 模式保存 bin log ，对于 STATEMENT 模式无法复制的操作使用 ROW 模式保存 bin log</p>
<p>那既然bin log也是日志文件，那它是在什么记录数据的呢？</p>
<p>其实 MySQL 在提交事务的时候，不仅仅会将 redo log buffer 中的数据写入到redo log 文件中，同时也会将本次修改的数据记录到 bin log文件中，同时会将本次修改的bin log文件名和修改的内容在bin log中的位置记录到redo log中，最后还会在redo log最后写入 commit 标记，这样就表示本次事务被成功的提交了。</p>
<div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210503195659.png style=display:block;width:50% alt=NAME align=center> </div>
<p>如果在数据被写入到bin log文件的时候，刚写完，数据库宕机了，数据会丢失吗？</p>
<p>首先可以确定的是，只要redo log最后没有 commit 标记，说明本次的事务一定是失败的。但是数据是没有丢失了，因为已经被记录到redo log的磁盘文件中了。在 MySQL 重启的时候，就会将 redo log 中的数据恢复（加载）到Buffer Pool中。</p>
<p>好了，到目前为止，一个更新操作我们基本介绍得差不多，但是你有没有感觉少了哪件事情还没有做？是不是你也发现这个时候被更新记录仅仅是在内存中执行的，哪怕是宕机又恢复了也仅仅是将更新后的记录加载到Buffer Pool中，这个时候 MySQL 数据库中的这条记录依旧是旧值，也就是说内存中的数据在我们看来依旧是脏数据，那这个时候怎么办呢？</p>
<p>其实 MySQL 会有一个后台线程，它会在某个时机将我们Buffer Pool中的脏数据刷到 MySQL 数据库中，这样就将内存和数据库的数据保持统一了。</p>
<div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210503195713.png style=display:block;width:50% alt=NAME align=center> </div>
<h2 id=本文总结>本文总结</h2>
<p>到此，关于Buffer Pool、Redo Log Buffer 和undo log、redo log、bin log 概念以及关系就基本差不多了。</p>
<p>我们再回顾下</p>
<ul>
<li>Buffer Pool 是 MySQL 的一个非常重要的组件，因为针对数据库的增删改操作都是在 Buffer Pool 中完成的</li>
<li>Undo log 记录的是数据操作前的样子</li>
<li>redo log 记录的是数据被操作后的样子（redo log 是 Innodb 存储引擎特有）</li>
<li>bin log 记录的是整个操作记录（这个对于主从复制具有非常重要的意义）</li>
</ul>
<p>从准备更新一条数据到事务的提交的流程描述</p>
<ul>
<li>首先执行器根据 MySQL 的执行计划来查询数据，先是从缓存池中查询数据，如果没有就会去数据库中查询，如果查询到了就将其放到缓存池中</li>
<li>在数据被缓存到缓存池的同时，会写入 undo log 日志文件</li>
<li>更新的动作是在 BufferPool 中完成的，同时会将更新后的数据添加到 redo log buffer 中</li>
<li>完成以后就可以提交事务，在提交的同时会做以下三件事
<ul>
<li>将redo log buffer中的数据刷入到 redo log 文件中</li>
<li>将本次操作记录写入到 bin log文件中</li>
<li>将 bin log 文件名字和更新内容在 bin log 中的位置记录到redo log中，同时在 redo log 最后添加 commit 标记</li>
</ul>
</li>
</ul>
<p>至此表示整个更新事务已经完成</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-2f770b4ebcff7b1cb1f0b0c93c9c266f>8 - CH08-参考规约</h1>
<h2 id=建表>建表</h2>
<ol>
<li>
<p><font color=red>强制：</font>表达是与否概念的字段，必须使用 is_xxx 的方式命名，数据类型是 unsigned tinyint （1 表示是，0 表示否）。 说明：任何字段如果为非负数，必须是 unsigned。 注意：POJO 类中的任何布尔类型的变量，都不要加 is 前缀，所以，需要在<code>&lt;resultMap></code>设置 从 is_xxx 到 Xxx 的映射关系。数据库表示是与否的值，使用 tinyint 类型，坚持 is_xxx 的 命名方式是为了明确其取值含义与取值范围。 正例：表达逻辑删除的字段名 is_deleted，1 表示删除，0 表示未删除。</p>
</li>
<li>
<p><font color=red>强制：</font>表名、字段名必须使用小写字母或数字，禁止出现数字开头，禁止两个下划线中间只 出现数字。数据库字段名的修改代价很大，因为无法进行预发布，所以字段名称需要慎重考虑。 说明：MySQL 在 Windows 下不区分大小写，但在 Linux 下默认是区分大小写。因此，数据库名、 表名、字段名，都不允许出现任何大写字母，避免节外生枝。 正例：aliyun_admin，rdc_config，level3_name 反例：AliyunAdmin，rdcConfig，level_3_name</p>
</li>
<li>
<p><font color=red>强制：</font>表名不使用复数名词。 说明：表名应该仅仅表示表里面的实体内容，不应该表示实体数量，对应于 DO 类名也是单数 形式，符合表达习惯。</p>
</li>
<li>
<p><font color=red>强制：</font>禁用保留字，如 desc、range、match、delayed 等，请参考 MySQL 官方保留字。</p>
</li>
<li>
<p><font color=red>强制：</font>主键索引名为 pk_字段名；唯一索引名为 uk_字段名；普通索引名则为 idx_字段名。 说明：pk_ 即 primary key；uk_ 即 unique key；idx_ 即 index 的简称。</p>
</li>
<li>
<p><font color=red>强制：</font>小数类型为 decimal，禁止使用 float 和 double。</p>
<ul>
<li>说明：float 和 double 在存储的时候，存在精度损失的问题，很可能在值的比较时，得到不 正确的结果。如果存储的数据范围超过 decimal 的范围，建议将数据拆成整数和小数分开存储。</li>
</ul>
</li>
<li>
<p><font color=red>强制：</font>如果存储的字符串长度几乎相等，使用 char 定长字符串类型。</p>
</li>
<li>
<p><font color=red>强制：</font>varchar 是可变长字符串，不预先分配存储空间，长度不要超过 5000，如果存储长 度大于此值，定义字段类型为 text，独立出来一张表，用主键来对应，避免影响其它字段索 引效率。</p>
</li>
<li>
<p><font color=red>强制：</font>表必备三字段：id, gmt_create, gmt_modified。</p>
<ul>
<li>
<p>说明：其中 id 必为主键，类型为 bigint unsigned、单表时自增、步长为 1。gmt_create,</p>
</li>
<li>
<p>gmt_modified 的类型均为 datetime 类型，前者现在时表示主动创建，后者过去分词表示被动更新。</p>
</li>
</ul>
</li>
<li>
<p><font color=blue>推荐：</font>表的命名最好是加上“业务名称_表的作用”。 正例：alipay_task / force_project / trade_config</p>
</li>
<li>
<p><font color=blue>推荐：</font>库名与应用名称尽量一致。</p>
</li>
<li>
<p><font color=blue>推荐：</font>如果修改字段含义或对字段表示的状态追加时，需要及时更新字段注释。</p>
</li>
<li>
<p><font color=blue>推荐：</font>字段允许适当冗余，以提高查询性能，但必须考虑数据一致。冗余字段应遵循： 1）不是频繁修改的字段。 2）不是 varchar 超长字段，更不能是 text 字段。 正例：商品类目名称使用频率高，字段长度短，名称基本一成不变，可在相关联的表中冗余存 储类目名称，避免关联查询。</p>
</li>
<li>
<p><font color=blue>推荐：</font>单表行数超过 500 万行或者单表容量超过 2GB，才推荐进行分库分表。 说明：如果预计三年后的数据量根本达不到这个级别，请不要在创建表时就分库分表。</p>
</li>
<li>
<p><font color=#1A7605>参考：</font>合适的字符存储长度，不但节约数据库表空间、节约索引存储，更重要的是提升检 索速度。 正例：如下表，其中无符号值可以避免误存负数，且扩大了表示范围。</p>
</li>
</ol>
<div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20211028223753.png style=display:block;width:60% alt=NAME align=center> </div>
<h2 id=索引>索引</h2>
<ol>
<li>
<p><font color=red>强制：</font>业务上具有唯一特性的字段，即使是多个字段的组合，也必须建成唯一索引。 说明：不要以为唯一索引影响了 insert 速度，这个速度损耗可以忽略，但提高查找速度是明 显的；另外，即使在应用层做了非常完善的校验控制，只要没有唯一索引，根据墨菲定律，必 然有脏数据产生。</p>
</li>
<li>
<p><font color=red>强制：</font>超过三个表禁止 join。需要 join 的字段，数据类型必须绝对一致；多表关联查询时， 保证被关联的字段需要有索引。 说明：即使双表 join 也要注意表索引、SQL 性能。</p>
</li>
<li>
<p><font color=red>强制：</font>在 varchar 字段上建立索引时，必须指定索引长度，没必要对全字段建立索引，根据 实际文本区分度决定索引长度即可。</p>
<ul>
<li>说明：索引的长度与区分度是一对矛盾体，一般对字符串类型数据，长度为 20 的索引，区分 度会高达 90%以上，可以使用 <code>count(distinct left(列名, 索引长度))/count(*)</code> 的区分度 来确定。</li>
</ul>
</li>
<li>
<p><font color=red>强制：</font>页面搜索严禁左模糊或者全模糊，如果需要请走搜索引擎来解决。 说明：索引文件具有 B-Tree 的最左前缀匹配特性，如果左边的值未确定，那么无法使用此索 引。</p>
</li>
<li>
<p><font color=blue>推荐：</font>如果有 order by 的场景，请注意利用索引的有序性。order by 最后的字段是组合 索引的一部分，并且放在索引组合顺序的最后，避免出现 file_sort 的情况，影响查询性能。 正例：where a=? and b=? order by c; 索引：a_b_c</p>
<ul>
<li>反例：索引中有范围查找，那么索引有序性无法利用，如：WHERE a>10 ORDER BY b; 索引 a_b 无法排序。</li>
</ul>
</li>
<li>
<p><font color=blue>推荐：</font>利用覆盖索引来进行查询操作，避免回表。 说明：如果一本书需要知道第 11 章是什么标题，会翻开第 11 章对应的那一页吗？目录浏览 一下就好，这个目录就是起到覆盖索引的作用。 正例：能够建立索引的种类分为主键索引、唯一索引、普通索引三种，而覆盖索引只是一种查 询的一种效果，用 explain 的结果，extra 列会出现：using index。</p>
</li>
<li>
<p><font color=blue>推荐：</font>利用延迟关联或者子查询优化超多分页场景。 说明：MySQL 并不是跳过 offset 行，而是取 offset+N 行，然后返回放弃前 offset 行，返回 N 行，那当 offset 特别大的时候，效率就非常的低下，要么控制返回的总页数，要么对超过 特定阈值的页数进行 SQL 改写。 正例：先快速定位需要获取的 id 段，然后再关联：</p>
<ul>
<li><code>SELECT a.* FROM 表 1 a, (select id from 表 1 where 条件 LIMIT 100000,20 ) b where a.id=b.id</code></li>
</ul>
</li>
<li>
<p><font color=blue>推荐：</font> SQL 性能优化的目标：至少要达到 range 级别，要求是 ref 级别，如果可以是 consts 最好。 说明： 1）consts 单表中最多只有一个匹配行（主键或者唯一索引），在优化阶段即可读取到数据。 2）ref 指的是使用普通的索引（normal index）。 3）range 对索引进行范围检索。 反例：explain 表的结果，type=index，索引物理文件全扫描，速度非常慢，这个 index 级 别比较 range 还低，与全表扫描是小巫见大巫。</p>
</li>
<li>
<p><font color=blue>推荐：</font>建组合索引的时候，区分度最高的在最左边。 正例：如果 where a=? and b=? ，如果 a 列的几乎接近于唯一值，那么只需要单建 idx_a 索引即可。 说明：存在非等号和等号混合时，在建索引时，请把等号条件的列前置。如：where c>? and d=? 那么即使 c 的区分度更高，也必须把 d 放在索引的最前列，即索引 idx_d_c。</p>
</li>
<li>
<p><font color=blue>推荐：</font>防止因字段类型不同造成的隐式转换，导致索引失效。</p>
</li>
<li>
<p><font color=#1A7605>参考：</font>创建索引时避免有如下极端误解： 1）宁滥勿缺。认为一个查询就需要建一个索引。 2）宁缺勿滥。认为索引会消耗空间、严重拖慢更新和新增速度。 3）抵制惟一索引。认为业务的惟一性一律需要在应用层通过“先查后插”方式解决。</p>
</li>
</ol>
<h2 id=sql>SQL</h2>
<ol>
<li>
<p><font color=red>强制：</font>不要使用 count(列名)或 count(常量)来替代 count(<em>)，count(</em>)是 SQL92 定义的标准统计行数的语法，跟数据库无关，跟 NULL 和非 NULL 无关。 说明：count(*)会统计值为 NULL 的行，而 count(列名)不会统计此列为 NULL 值的行。</p>
</li>
<li>
<p><font color=red>强制：</font>count(distinct col) 计算该列除 NULL 之外的不重复行数，注意 count(distinct col1, col2) 如果其中一列全为 NULL，那么即使另一列有不同的值，也返回为 0。</p>
</li>
<li>
<p><font color=red>强制：</font>当某一列的值全是 NULL 时，count(col)的返回结果为 0，但 sum(col)的返回结果为NULL，因此使用 sum()时需注意 NPE 问题。</p>
<ul>
<li>正例：可以使用如下方式来避免 sum 的 NPE 问题：SELECT IF(ISNULL(SUM(g)),0,SUM(g)) FROM table;</li>
</ul>
</li>
<li>
<p><font color=red>强制：</font>使用 ISNULL()来判断是否为 NULL 值。</p>
<ul>
<li>说明：NULL 与任何值的直接比较都为 NULL。
<ul>
<li>1） NULL&lt;>NULL 的返回结果是 NULL，而不是 false。</li>
<li>2） NULL=NULL 的返回结果是 NULL，而不是 true。</li>
<li>3） NULL&lt;>1 的返回结果是 NULL，而不是 true。</li>
</ul>
</li>
</ul>
</li>
<li>
<p><font color=red>强制：</font> 在代码中写分页查询逻辑时，若 count 为 0 应直接返回，避免执行后面的分页语句。</p>
</li>
<li>
<p><font color=red>强制：</font>不得使用外键与级联，一切外键概念必须在应用层解决。 说明：以学生和成绩的关系为例，学生表中的 student_id 是主键，那么成绩表中的 student_id 则为外键。如果更新学生表中的 student_id，同时触发成绩表中的 student_id 更新，即为 级联更新。外键与级联更新适用于单机低并发，不适合分布式、高并发集群；级联更新是强阻 塞，存在数据库更新风暴的风险；外键影响数据库的插入速度。</p>
</li>
<li>
<p><font color=red>强制：</font>禁止使用存储过程，存储过程难以调试和扩展，更没有移植性。</p>
</li>
<li>
<p><font color=red>强制：</font>数据订正（特别是删除、修改记录操作）时，要先 select，避免出现误删除，确认 无误才能执行更新语句。</p>
</li>
<li>
<p><font color=blue>推荐：</font>in 操作能避免则避免，若实在避免不了，需要仔细评估 in 后边的集合元素数量，控 制在 1000 个之内。</p>
</li>
<li>
<p><font color=#1A7605>参考：</font>如果有国际化需要，所有的字符存储与表示，均以 utf-8 编码，注意字符统计函数 的区别。 说明： SELECT LENGTH(&ldquo;轻松工作&rdquo;)； 返回为 12 SELECT CHARACTER_LENGTH(&ldquo;轻松工作&rdquo;)； 返回为 4 如果需要存储表情，那么选择 utf8mb4 来进行存储，注意它与 utf-8 编码的区别。</p>
</li>
<li>
<p><font color=#1A7605>参考：</font>TRUNCATE TABLE 比 DELETE 速度快，且使用的系统和事务日志资源少，但 TRUNCATE 无事务且不触发 trigger，有可能造成事故，故不建议在开发代码中使用此语句。 说明：TRUNCATE TABLE 在功能上与不带 WHERE 子句的 DELETE 语句相同。</p>
</li>
</ol>
<h2 id=orm>ORM</h2>
<ol>
<li>
<p><font color=red>强制：</font>在表查询中，一律不要使用 * 作为查询的字段列表，需要哪些字段必须明确写明。 说明：1）增加查询分析器解析成本。2）增减字段容易与 resultMap 配置不一致。3）无用字 段增加网络消耗，尤其是 text 类型的字段。</p>
</li>
<li>
<p><font color=red>强制：</font>POJO 类的布尔属性不能加 is，而数据库字段必须加 is_，要求在 resultMap 中进行 字段与属性之间的映射。 说明：参见定义 POJO 类以及数据库字段定义规定，在<resultmap>中增加映射，是必须的。 在 MyBatis Generator 生成的代码中，需要进行对应的修改。</p>
</li>
<li>
<p><font color=red>强制：</font>不要用 resultClass 当返回参数，即使所有类属性名与数据库字段一一对应，也需 要定义；反过来，每一个表也必然有一个 POJO 类与之对应。 说明：配置映射关系，使字段与 DO 类解耦，方便维护。</p>
</li>
<li>
<p><font color=red>强制：</font>sql.xml 配置参数使用：#{}，#param# 不要使用${} 此种方式容易出现 SQL 注入。</p>
</li>
<li>
<p><font color=red>强制：</font>iBATIS 自带的 queryForList(String statementName,int start,int size)不推荐使用。</p>
<ul>
<li>
<p>说明：其实现方式是在数据库取到 statementName 对应的 SQL 语句的所有记录，再通过 subList 取 start,size 的子集合。</p>
</li>
<li>
<p>正例：<code>Map&lt;String, Object> map = new HashMap&lt;>(); map.put("start", start); map.put("size", size);</code></p>
</li>
</ul>
</li>
<li>
<p><font color=red>强制：</font>不允许直接拿 HashMap 与 Hashtable 作为查询结果集的输出。</p>
<ul>
<li>说明：resultClass=”Hashtable”，会置入字段名和属性值，但是值的类型不可控。</li>
</ul>
</li>
<li>
<p><font color=red>强制：</font>更新数据表记录时，必须同时更新记录对应的 gmt_modified 字段值为当前时间。</p>
</li>
<li>
<p><font color=blue>推荐：</font>不要写一个大而全的数据更新接口。传入为 POJO 类，不管是不是自己的目标更新字 段，都进行 update table set c1=value1,c2=value2,c3=value3; 这是不对的。执行 SQL 时，不要更新无改动的字段，一是易出错；二是效率低；三是增加 binlog 存储。</p>
</li>
<li>
<p><font color=#1A7605>参考：</font>@Transactional 事务不要滥用。事务会影响数据库的 QPS，另外使用事务的地方需 要考虑各方面的回滚方案，包括缓存回滚、搜索引擎回滚、消息补偿、统计修正等。</p>
</li>
<li>
<p><font color=#1A7605>参考：</font><isequal>中的 compareValue 是与属性值对比的常量，一般是数字，表示相等时带 上此条件；<isnotempty>表示不为空且不为 null 时执行；<isnotnull>表示不为 null 值时执行。</p>
</li>
</ol>
</div>
</main>
</div>
</div>
<footer class="bg-dark py-5 row d-print-none">
<div class="container-fluid mx-sm-5">
<div class=row>
<div class="col-6 col-sm-4 text-xs-center order-sm-2">
</div>
<div class="col-6 col-sm-4 text-right text-xs-center order-sm-3">
<ul class="list-inline mb-0">
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Weibo aria-label=Weibo>
<a class=text-white target=_blank rel="noopener noreferrer" href=https://weibo.com/u/3848950217>
<i class="fab fa-weibo"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Twitter aria-label=Twitter>
<a class=text-white target=_blank rel="noopener noreferrer" href=https://twitter.com/zhange_zzg>
<i class="fab fa-twitter"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="Stack Overflow" aria-label="Stack Overflow">
<a class=text-white target=_blank rel="noopener noreferrer" href=https://stackoverflow.com>
<i class="fab fa-stack-overflow"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=GitHub aria-label=GitHub>
<a class=text-white target=_blank rel="noopener noreferrer" href=https://github.com/infilos/infilos.com>
<i class="fab fa-github"></i>
</a>
</li>
</ul>
</div>
<div class="col-12 col-sm-4 text-center py-2 order-sm-2">
<small class=text-white>&copy; 2021 infilos.com All Rights Reserved</small>
</div>
</div>
</div>
</footer>
</div>
<script src=/js/popper.min.js integrity=sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49 crossorigin=anonymous></script>
<script src=/js/bootstrap.min.js integrity=sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy crossorigin=anonymous></script>
<script src=/js/main.min.5c74b870c6953931a705f390a49c7e4c0a842ec5c83b24354758dd674343ed0d.js integrity="sha256-XHS4cMaVOTGnBfOQpJx+TAqELsXIOyQ1R1jdZ0ND7Q0=" crossorigin=anonymous></script>
</body>
</html>