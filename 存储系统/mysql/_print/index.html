<!doctype html><html lang=zh class=no-js>
<head>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=generator content="Hugo 0.88.1">
<meta name=ROBOTS content="INDEX, FOLLOW">
<link rel=canonical type=text/html href=/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/mysql/>
<link rel="shortcut icon" href=/favicons/favicon.ico>
<link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180>
<link rel=icon type=image/png href=/favicons/favicon-16x16.png sizes=16x16>
<link rel=icon type=image/png href=/favicons/favicon-32x32.png sizes=32x32>
<link rel=icon type=image/png href=/favicons/android-36x36.png sizes=36x36>
<link rel=icon type=image/png href=/favicons/android-48x48.png sizes=48x48>
<link rel=icon type=image/png href=/favicons/android-72x72.png sizes=72x72>
<link rel=icon type=image/png href=/favicons/android-96x96.png sizes=96x96>
<link rel=icon type=image/png href=/favicons/android-144x144.png sizes=144x144>
<link rel=icon type=image/png href=/favicons/android-192x192.png sizes=192x192>
<title>MySQL | infilos.com</title><meta property="og:title" content="MySQL">
<meta property="og:description" content="Infilos Wiki Website">
<meta property="og:type" content="website">
<meta property="og:url" content="/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/mysql/"><meta property="og:site_name" content="infilos.com">
<meta itemprop=name content="MySQL">
<meta itemprop=description content="Infilos Wiki Website"><meta name=twitter:card content="summary">
<meta name=twitter:title content="MySQL">
<meta name=twitter:description content="Infilos Wiki Website">
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga('create','UA-123062585-1','auto'),ga('send','pageview'))</script>
<script async src=https://www.google-analytics.com/analytics.js></script>
<link rel=preload href=/scss/main.min.847464b684a6e89d7276700a5c500c17ab494dd1755b2654a7b27d8b59e3347e.css as=style>
<link href=/scss/main.min.847464b684a6e89d7276700a5c500c17ab494dd1755b2654a7b27d8b59e3347e.css rel=stylesheet integrity>
<script src=/js/jquery-3.5.1.min.js integrity="sha256-9/aliU8dGd2tb6OSsuzixeV4y/faTqgFtohetphbbj0=" crossorigin=anonymous></script>
</head>
<body class=td-section>
<header>
<nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-column flex-md-row td-navbar">
<a class=navbar-brand href=/>
<span class=navbar-logo><svg id="Capa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 512 512" style="enable-background:new 0 0 512 512"><path style="fill:#ffc107" d="M432.384 143.616c-4.165-4.164-10.917-4.164-15.083.0l-60.352 60.352c-4.164 4.165-4.164 10.917.0 15.083 21.187 20.463 54.951 19.876 75.413-1.311 19.962-20.668 19.962-53.435.0-74.102L432.384 143.616z"/><path style="fill:#607d8b" d="M42.667 277.334c-5.891.003-10.669-4.771-10.672-10.662-.002-4.338 2.623-8.245 6.64-9.882l234.667-96c5.455-2.233 11.687.38 13.92 5.835s-.38 11.687-5.835 13.92l-234.667 96C45.433 277.069 44.056 277.337 42.667 277.334z"/><path style="fill:#546e7a" d="M391.552 56.448l-32-32C343.938 8.745 322.689-.059 300.544.0h-3.755c-46.082.024-83.432 37.374-83.456 83.456v3.755c-.053 22.138 8.75 43.377 24.448 58.987l32 32c4.165 4.164 10.917 4.164 15.083.0L391.531 71.531C395.701 67.372 395.71 60.62 391.552 56.448z"/><path style="fill:#607d8b" d="M160 469.334c-3.279.006-6.379-1.497-8.405-4.075L34.261 315.926c-3.635-4.636-2.823-11.341 1.813-14.976s11.341-2.823 14.976 1.813l117.333 149.333c3.629 4.641 2.809 11.344-1.832 14.973C164.681 468.533 162.375 469.329 160 469.334z"/><path style="fill:#455a64" d="M487.467 86.848l-3.669-3.648c-37.687-36.557-97.71-36.197-134.955.811l-51.413 51.413c-36.996 37.25-37.357 97.263-.811 134.955l3.584 3.669c1.7 2.457 4.671 3.706 7.616 3.2 2.831.005 5.548-1.115 7.552-3.115l172.181-172.181c4.189-4.143 4.226-10.896.083-15.085-.028-.028-.055-.056-.083-.083L487.467 86.848z"/><g><path style="fill:#ffc107" d="M501.333 192H480c-5.891.0-10.667-4.776-10.667-10.667s4.776-10.667 10.667-10.667h21.333c5.891.0 10.667 4.776 10.667 10.667S507.225 192 501.333 192z"/><path style="fill:#ffc107" d="M394.667 298.667c-5.891.0-10.667-4.776-10.667-10.667v-21.333c0-5.891 4.776-10.667 10.667-10.667 5.891.0 10.667 4.776 10.667 10.667V288C405.333 293.891 400.558 298.667 394.667 298.667z"/><path style="fill:#ffc107" d="M480 277.334c-2.831.005-5.548-1.115-7.552-3.115l-21.333-21.333c-4.093-4.237-3.975-10.99.262-15.083 4.134-3.993 10.687-3.993 14.821.0l21.333 21.333c4.159 4.172 4.148 10.926-.024 15.085C485.514 276.209 482.815 277.327 480 277.334z"/></g><g><path style="fill:#455a64" d="M266.667 448H96c-29.455.0-53.333 23.878-53.333 53.333.0 5.891 4.776 10.667 10.667 10.667h256c5.891.0 10.667-4.776 10.667-10.667C320 471.878 296.122 448 266.667 448z"/><circle style="fill:#455a64" cx="32" cy="288" r="32"/></g><g/><g/><g/><g/><g/><g/><g/><g/><g/><g/><g/><g/><g/><g/><g/></svg></span><span class=font-weight-bold>infilos.com</span>
</a>
<div class="collapse navbar-collapse" id=navbarSupportedContent>
<ul class="navbar-nav mr-auto">
<li class="nav-item dropdown" style=max-width:90px;min-width:10px>
<a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>
基础
<span>+</span>
</a>
<div class=dropdown-menu aria-labelledby=navbarDropdown>
<a class=dropdown-item href=/%e5%9f%ba%e7%a1%80%e7%9f%a5%e8%af%86/%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f>操作系统</a>
<a class=dropdown-item href=/%e5%9f%ba%e7%a1%80%e7%9f%a5%e8%af%86/%e6%80%a7%e8%83%bd%e4%b9%8b%e6%ae%87>性能之殇</a>
<a class=dropdown-item href=/%e5%9f%ba%e7%a1%80%e7%9f%a5%e8%af%86/io%e6%a8%a1%e5%9e%8b>IO 模型</a>
<a class=dropdown-item href=/%e5%9f%ba%e7%a1%80%e7%9f%a5%e8%af%86/%e7%bd%91%e7%bb%9c%e5%9f%ba%e7%a1%80>网络基础</a>
<a class=dropdown-item href=/%e5%9f%ba%e7%a1%80%e7%9f%a5%e8%af%86/tcp-ip>TCP-IP</a>
<a class=dropdown-item href=/%e5%9f%ba%e7%a1%80%e7%9f%a5%e8%af%86/http>HTTP</a>
</div>
</li>
<li class="nav-item dropdown" style=max-width:90px;min-width:10px>
<a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>
语言
<span>+</span>
</a>
<div class=dropdown-menu aria-labelledby=navbarDropdown>
<a class=dropdown-item href=/%e7%bc%96%e7%a8%8b%e8%af%ad%e8%a8%80/java>Java 编程</a>
<a class=dropdown-item href=/%e7%bc%96%e7%a8%8b%e8%af%ad%e8%a8%80/jvm-core>JVM 核心</a>
<a class=dropdown-item href=/%e7%bc%96%e7%a8%8b%e8%af%ad%e8%a8%80/jvm-concurrent>JVM 并发</a>
<a class=dropdown-item href=/%e7%bc%96%e7%a8%8b%e8%af%ad%e8%a8%80/scala>Scala 编程</a>
</div>
</li>
<li class="nav-item dropdown" style=max-width:90px;min-width:10px>
<a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>
框架库
<span>+</span>
</a>
<div class=dropdown-menu aria-labelledby=navbarDropdown>
<a class=dropdown-item href=/%e6%a1%86%e6%9e%b6%e4%b8%8e%e5%ba%93/spring>Spring</a>
<a class=dropdown-item href=/%e6%a1%86%e6%9e%b6%e4%b8%8e%e5%ba%93/hikari>Hikari</a>
<a class=dropdown-item href=/%e6%a1%86%e6%9e%b6%e4%b8%8e%e5%ba%93/parboiled>Parboiled</a>
</div>
</li>
<li class="nav-item dropdown" style=max-width:90px;min-width:10px>
<a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>
分布式
<span>+</span>
</a>
<div class=dropdown-menu aria-labelledby=navbarDropdown>
<a class=dropdown-item href=/%e5%88%86%e5%b8%83%e5%bc%8f/base>基本构成</a>
</div>
</li>
<li class="nav-item dropdown" style=max-width:90px;min-width:10px>
<a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>
大数据
<span>+</span>
</a>
<div class=dropdown-menu aria-labelledby=navbarDropdown>
<a class=dropdown-item href=/%e5%ad%98%e5%82%a8%e7%b3%bb%e7%bb%9f>存储系统</a>
<a class=dropdown-item href=/%e6%9f%a5%e8%af%a2%e7%b3%bb%e7%bb%9f>查询系统</a>
<a class=dropdown-item href=/%e6%b6%88%e6%81%af%e7%b3%bb%e7%bb%9f>消息系统</a>
<a class=dropdown-item href=/%e5%a4%84%e7%90%86%e7%b3%bb%e7%bb%9f>处理系统</a>
<a class=dropdown-item href=/%e7%ae%a1%e7%90%86%e7%b3%bb%e7%bb%9f>管理系统</a>
</div>
</li>
<li class="nav-item dropdown" style=max-width:90px;min-width:10px>
<a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>
中后台
<span>+</span>
</a>
<div class=dropdown-menu aria-labelledby=navbarDropdown>
<a class=dropdown-item href=/%e5%9f%ba%e7%a1%80%e8%ae%be%e6%96%bd>基础设施</a>
<a class=dropdown-item href=/%e4%ba%a4%e4%ba%92%e7%95%8c%e9%9d%a2>交互界面</a>
<a class=dropdown-item href=/%e4%b8%9a%e5%8a%a1%e7%b3%bb%e7%bb%9f>业务系统</a>
</div>
</li>
<li class="nav-item dropdown" style=max-width:90px;min-width:10px>
<a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>
模式架构
<span>+</span>
</a>
<div class=dropdown-menu aria-labelledby=navbarDropdown>
<a class=dropdown-item href=/%e6%a8%a1%e5%bc%8f%e6%9e%b6%e6%9e%84/design-pattern>设计模式</a>
<a class=dropdown-item href=/%e6%a8%a1%e5%bc%8f%e6%9e%b6%e6%9e%84/micro-service>微服务架构</a>
</div>
</li>
<li class=nav-item style=max-width:90px;min-width:10px>
<a class=nav-link href=/%e9%9d%a2%e8%af%95%e9%97%ae%e7%ad%94>
<span>面试</span>
</a>
</li>
<li class=nav-item style=max-width:90px;min-width:10px>
<a class=nav-link href=/%e7%ae%a1%e7%90%86%e8%b7%af%e5%be%84>
<span>管理</span>
</a>
</li>
<li class=nav-item style=max-width:90px;min-width:10px>
<a class=nav-link href=/%e5%bc%80%e6%ba%90%e9%a1%b9%e7%9b%ae>
<span>开源</span>
</a>
</li>
</ul>
<div class="form-inline my-2 my-lg-0">
<div class="nav-item nav-search-item my-2 my-md-0">
<input type=search class="form-control td-search-input" placeholder="&#xf002; 站内搜索…" aria-label=站内搜索… autocomplete=off>
</div>
</div>
</div>
</nav>
</header>
<div class="container-fluid td-outer">
<div class=td-main>
<div class="row flex-xl-nowrap">
<div class="col-12 col-md-3 col-xl-2 td-sidebar d-print-none">
</div>
<div class="d-none d-xl-block col-xl-2 td-toc d-print-none">
</div>
<main class="col-12 col-md-9 col-xl-8 pl-md-5" role=main>
<div class=td-content>
<div class="pageinfo pageinfo-primary d-print-none">
<p>
这是本节的多页打印视图。
<a href=# onclick="return print(),!1">点击此处打印</a>.
</p><p>
<a href=/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/mysql/>返回本页常规视图</a>.
</p>
</div>
<h1 class=title>MySQL</h1>
<ul>
<li>1: <a href=#pg-90adba63667076abecda8b645b08e594>CH01-数据类型</a></li>
<li>2: <a href=#pg-87823f5c8c995312533c60e735d79427>CH02-存储引擎</a></li>
<li>3: <a href=#pg-e59a8b6bc16ee47aa4e9119f76c58aa2>CH03-索引B+树</a></li>
<li>4: <a href=#pg-e153ee081a2e00565371b72f637f2039>CH04-性能优化</a></li>
<li>5: <a href=#pg-29d040819faa80f395ba725e176690a3>CH05-分库分表</a></li>
<li>6: <a href=#pg-18dd619a88421627df2c9f215cacaecc>CH06-复制分离</a></li>
<li>7: <a href=#pg-280203572e4e446020b171753e2c2a12>CH07-执行过程</a></li>
</ul>
<div class=content>
</div>
</div>
<div class=td-content>
<h1 id=pg-90adba63667076abecda8b645b08e594>1 - CH01-数据类型</h1>
<h2 id=字段类型>字段类型</h2>
<h3 id=整型>整型</h3>
<p>TINYINT, SMALLINT, MEDIUMINT, INT, BIGINT 分别使用 8, 16, 24, 32, 64 位存储空间，一般情况下越小的列越好。</p>
<p>INT(11) 中的数字只是规定了交互工具显示字符的个数，对于存储和计算来说是没有意义的。</p>
<h3 id=浮点数>浮点数</h3>
<p>FLOAT 和 DOUBLE 为浮点类型，DECIMAL 为高精度小数类型。CPU 原生支持浮点运算，但是不支持 DECIMAl 类型的计算，因此 DECIMAL 的计算比浮点类型需要更高的代价。</p>
<p>FLOAT、DOUBLE 和 DECIMAL 都可以指定列宽，例如 DECIMAL(18, 9) 表示总共 18 位，取 9 位存储小数部分，剩下 9 位存储整数部分。</p>
<h3 id=字符串>字符串</h3>
<p>主要有 CHAR 和 VARCHAR 两种类型，一种是定长的，一种是变长的。</p>
<p>VARCHAR 这种变长类型能够节省空间，因为只需要存储必要的内容。但是在执行 UPDATE 时可能会使行变得比原来长，当超出一个页所能容纳的大小时，就要执行额外的操作。MyISAM 会将行拆成不同的片段存储，而 InnoDB 则需要分裂页来使行放进页内。</p>
<p>VARCHAR 会保留字符串末尾的空格，而 CHAR 会删除。</p>
<h3 id=时间和日期>时间和日期</h3>
<p>MySQL 提供了两种相似的日期时间类型: DATETIME 和 TIMESTAMP。</p>
<h4 id=1-datetime>1. DATETIME</h4>
<p>能够保存从 1001 年到 9999 年的日期和时间，精度为秒，使用 8 字节的存储空间。</p>
<p>它与时区无关。</p>
<p>默认情况下，MySQL 以一种可排序的、无歧义的格式显示 DATETIME 值，例如“2008-01-16 22:37:08”，这是 ANSI 标准定义的日期和时间表示方法。</p>
<h4 id=2-timestamp>2. TIMESTAMP</h4>
<p>和 UNIX 时间戳相同，保存从 1970 年 1 月 1 日午夜(格林威治时间)以来的秒数，使用 4 个字节，只能表示从 1970 年 到 2038 年。</p>
<p>它和时区有关，也就是说一个时间戳在不同的时区所代表的具体时间是不同的。</p>
<p>MySQL 提供了 FROM_UNIXTIME() 函数把 UNIX 时间戳转换为日期，并提供了 UNIX_TIMESTAMP() 函数把日期转换为 UNIX 时间戳。</p>
<p>默认情况下，如果插入时没有指定 TIMESTAMP 列的值，会将这个值设置为当前时间。</p>
<p>应该尽量使用 TIMESTAMP，因为它比 DATETIME 空间效率更高。</p>
<h2 id=选择优化的数据类型>选择优化的数据类型</h2>
<ul>
<li>更小的通常更好；更小的数据类型通常更快，因为它们占用更少的磁盘、内存和CPU缓存，并且处理时需要的CPU周期也更少；</li>
<li>简单就好；例如，整形比字符串操作代价更低；使用内建类型而不是字符串来存储日期和时间；用整形存储IP地址等；</li>
<li>尽量避免NULL；如果查询中包含可为NULL的列，对MySQL来说更难优化，因为可为NULL 的列使得索引、索引统计和值比较都更复杂。尽管把可为NULL的列改为NOT NULL带来的性能提升比较小，但如果计划在列上创建索引，就应该尽量避免设计成可为NULL的列；</li>
</ul>
<h3 id=字符串类型>字符串类型</h3>
<h4 id=varchar-和-char>VARCHAR 和 CHAR</h4>
<p>VARCHAR是最常见的字符串类型。VARCHAR节省了存储空间，所以对性能也有帮助。但是，由于行是可变的，在UPDATE时可能使行变得比原来更长，这就导致需要做额外的工作。如果一个行占用的空间增长，并且在页内没有更多的空间可以存储，MyISAM会将行拆成不同的片段存储；InnoDB则需要分裂页来使行可以放进页内。</p>
<p>下面这些情况使用VARCHAR是合适的：字符串的最大长度比平均长度大很多；列的更新很少，所以碎片不是问题；使用了像UTF-8这样复杂的字符集，每个字符都使用不同的字节数进行存储。</p>
<p>当存储CHAR值时，MySQL会删除所有的末尾空格。CHAR值会根据需要采用空格进行填充以方便比较。</p>
<p>CHAR适合存储很短的字符串，或者所有值都接近同一个长度，如密码的MD5值。对于经常变更的数据，CHAR也比VARCHAR更好，因为CHAR不容易产生碎片（行间碎片？）。</p>
<h4 id=varchar5和varchar200>VARCHAR(5)和VARCHAR(200)</h4>
<blockquote>
<p>使用VARCHAR(5)和VARCHAR(200)存储"hello"的空间开销是一样的。那么使用更短的列有什么优势吗？</p>
</blockquote>
<p>事实证明有很大的优势。更长的列会消耗更多的内存，因为MySQL通常会分配固定大小的内存块来保存内部值。尤其是使用内存临时表进行排序或其他操作时会特别糟糕。在利用磁盘临时表进行排序时也同样糟糕。</p>
<p>所以最好的策略是只分配真正需要的空间。</p>
<h4 id=blob-和-text>BLOB 和 TEXT</h4>
<p>BLOB和TEXT都是为存储很大的数据而设计的数据类型，分别采用二进制和字符方式存储。</p>
<p>与其他类型不同，MySQL把每个BLOB和TEXT值当做一个独立的对象去处理。当BLOB和TEXT值太大时，InnoDB会使用专门的“外部”存储区域来进行存储，此时每个值在行内需要1~4个字节存储一个指针，然后在外部存储区域存储实际的值。</p>
<p>MySQL对BLOB和TEXT列进行排序与其他类型是不同的：它只对每个列的最前max_sort_length个字节而不是整个字符串做排序。同样的，MySQL也不能将BLOB或TEXT列全部长度的字符串进行索引。</p>
<h3 id=选择标识符identifier>选择标识符（identifier）</h3>
<p>整数类型通常是标识列的最佳选择，因为它们很快并且可以使用AUTO_INCREMENT。 如果可能，应该避免使用字符串类型作为标识列，因为它们很耗空间，并且比数字类型慢。 对于完全随机的字符串也需要多加注意，例如MD5(),SHA1()或者UUID()产生的字符串。这些函数生成的新值会任意分布在很大的空间内，这会导致INSERT以及一些SELECT语句变得很慢：</p>
<ul>
<li>因为插入值会随机的写入到索引的不同位置，所以使得INSERT语句更慢。这会导致叶分裂、磁盘随机访问。</li>
<li>SELECT语句会变的更慢，因为逻辑上相邻的行会分布在磁盘和内存的不同地方。</li>
<li>随机值导致缓存对所有类型的查询语句效果都很差，因为会使得缓存赖以工作的局部性原理失效。</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-87823f5c8c995312533c60e735d79427>2 - CH02-存储引擎</h1>
<h2 id=innodb>InnoDB</h2>
<p>是 MySQL 默认的事务型存储引擎，<strong>只有在需要它不支持的特性时，才考虑使用其它存储引擎</strong>。</p>
<p>实现了四个标准的隔离级别，默认级别是可重复读(REPEATABLE READ)。在可重复读隔离级别下，通过多版本并发控制(MVCC)+ 间隙锁(Next-Key Locking)防止幻读。</p>
<p>主索引是聚簇索引，在索引中保存了数据，从而避免直接读取磁盘，因此对查询性能有很大的提升。</p>
<p>内部做了很多优化，包括从磁盘读取数据时采用的可预测性读、能够加快读操作并且自动创建的自适应哈希索引、能够加速插入操作的插入缓冲区等。</p>
<p>支持真正的在线热备份。其它存储引擎不支持在线热备份，要获取一致性视图需要停止对所有表的写入，而在读写混合场景中，停止写入可能也意味着停止读取。</p>
<h2 id=myisam>MyISAM</h2>
<p>设计简单，数据以紧密格式存储。对于只读数据，或者表比较小、可以容忍修复操作，则依然可以使用它。</p>
<p>提供了大量的特性，包括压缩表、空间数据索引等。</p>
<p><strong>不支持事务</strong>。</p>
<p>不支持行级锁，只能对整张表加锁，读取时会对需要读到的所有表加共享锁，写入时则对表加排它锁。但在表有读取操作的同时，也可以往表中插入新的记录，这被称为并发插入(CONCURRENT INSERT)。</p>
<p>可以手工或者自动执行检查和修复操作，但是和事务恢复以及崩溃恢复不同，可能导致一些数据丢失，而且修复操作是非常慢的。</p>
<p>如果指定了 DELAY_KEY_WRITE 选项，在每次修改执行完成时，不会立即将修改的索引数据写入磁盘，而是会写到内存中的键缓冲区，只有在清理键缓冲区或者关闭表的时候才会将对应的索引块写入磁盘。这种方式可以极大的提升写入性能，但是在数据库或者主机崩溃时会造成索引损坏，需要执行修复操作。</p>
<h2 id=对比>对比</h2>
<ul>
<li>事务: InnoDB 是事务型的，可以使用 Commit 和 Rollback 语句。</li>
<li>并发: MyISAM 只支持表级锁，而 InnoDB 还支持行级锁。</li>
<li>外键: InnoDB 支持外键。</li>
<li>备份: InnoDB 支持在线热备份。</li>
<li>崩溃恢复: MyISAM 崩溃后发生损坏的概率比 InnoDB 高很多，而且恢复的速度也更慢。</li>
<li>其它特性: MyISAM 支持压缩表和空间数据索引。</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-e59a8b6bc16ee47aa4e9119f76c58aa2>3 - CH03-索引B+树</h1>
<h2 id=b-tree-原理>B+ Tree 原理</h2>
<h3 id=1-数据结构>1. 数据结构</h3>
<p>B Tree 指的是 Balance Tree，也就是平衡树。平衡树是一颗查找树，并且所有叶子节点位于同一层。</p>
<p>B+ Tree 是基于 B Tree 和叶子节点顺序访问指针进行实现，它具有 B Tree 的平衡性，并且通过顺序访问指针来提高区间查询的性能。</p>
<p>在 B+ Tree 中，一个节点中的 key 从左到右非递减排列，如果某个指针的左右相邻 key 分别是 key i 和 key i+1，且不为 null，则该指针指向节点的所有 key 大于等于 key i 且小于等于 key i+1。</p>
<div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210503192121.png style=display:block;width:50% alt=NAME align=center> </div>
<h3 id=2-操作>2. 操作</h3>
<p>进行查找操作时，首先在根节点进行二分查找，找到一个 key 所在的指针，然后递归地在指针所指向的节点进行查找。直到查找到叶子节点，然后在叶子节点上进行二分查找，找出 key 所对应的 data。</p>
<p>插入删除操作记录会破坏平衡树的平衡性，因此在插入删除操作之后，需要对树进行一个分裂、合并、旋转等操作来维护平衡性。</p>
<h3 id=3-与红黑树的比较>3. 与红黑树的比较</h3>
<p>红黑树等平衡树也可以用来实现索引，但是文件系统及数据库系统普遍采用 B+ Tree 作为索引结构，主要有以下两个原因:</p>
<p>(一)更少的查找次数</p>
<p>平衡树查找操作的时间复杂度等于树高 h，而树高大致为 O(h)=O(logdN)，其中 d 为每个节点的出度。</p>
<p>红黑树的出度为 2，而 B+ Tree 的出度一般都非常大，所以红黑树的树高 h 很明显比 B+ Tree 大非常多，检索的次数也就更多。</p>
<p>(二)利用计算机预读特性</p>
<p>为了减少磁盘 I/O，磁盘往往不是严格按需读取，而是每次都会预读。预读过程中，磁盘进行顺序读取，顺序读取不需要进行磁盘寻道，并且只需要很短的旋转时间，因此速度会非常快。</p>
<p>操作系统一般将内存和磁盘分割成固态大小的块，每一块称为一页，内存与磁盘以页为单位交换数据。数据库系统将索引的一个节点的大小设置为页的大小，使得一次 I/O 就能完全载入一个节点，并且可以利用预读特性，相邻的节点也能够被预先载入。</p>
<h2 id=mysql-索引>MySQL 索引</h2>
<p>索引是在存储引擎层实现的，而不是在服务器层实现的，所以不同存储引擎具有不同的索引类型和实现。</p>
<h3 id=1-btree-索引>1. B+Tree 索引</h3>
<p>是大多数 MySQL 存储引擎的默认索引类型。</p>
<p>因为不再需要进行全表扫描，只需要对树进行搜索即可，因此查找速度快很多。除了用于查找，还可以用于排序和分组。</p>
<p>可以指定多个列作为索引列，多个索引列共同组成键。</p>
<p>适用于全键值、键值范围和键前缀查找，其中键前缀查找只适用于最左前缀查找。如果不是按照索引列的顺序进行查找，则无法使用索引。</p>
<p>InnoDB 的 B+Tree 索引分为主索引和辅助索引。</p>
<p>主索引的叶子节点 data 域记录着完整的数据记录，这种索引方式被称为聚簇索引。因为无法把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引。</p>
<div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210503192439.png style=display:block;width:50% alt=NAME align=center> </div>
<p>辅助索引的叶子节点的 data 域记录着主键的值，因此在使用辅助索引进行查找时，需要先查找到主键值，然后再到主索引中进行查找。</p>
<div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210503192458.png style=display:block;width:50% alt=NAME align=center> </div>
<h3 id=2-哈希索引>2. 哈希索引</h3>
<p>哈希索引能以 O(1) 时间进行查找，但是失去了有序性，它具有以下限制:</p>
<ul>
<li>无法用于排序与分组；</li>
<li>只支持精确查找，无法用于部分查找和范围查找。</li>
</ul>
<p>InnoDB 存储引擎有一个特殊的功能叫“自适应哈希索引”，当某个索引值被使用的非常频繁时，会在 B+Tree 索引之上再创建一个哈希索引，这样就让 B+Tree 索引具有哈希索引的一些优点，比如快速的哈希查找。</p>
<h3 id=3-全文索引>3. 全文索引</h3>
<p>MyISAM 存储引擎支持全文索引，用于查找文本中的关键词，而不是直接比较是否相等。查找条件使用 MATCH AGAINST，而不是普通的 WHERE。</p>
<p>全文索引一般使用倒排索引实现，它记录着关键词到其所在文档的映射。</p>
<p>InnoDB 存储引擎在 MySQL 5.6.4 版本中也开始支持全文索引。</p>
<h3 id=4-空间数据索引>4. 空间数据索引</h3>
<p>MyISAM 存储引擎支持空间数据索引(R-Tree)，可以用于地理数据存储。空间数据索引会从所有维度来索引数据，可以有效地使用任意维度来进行组合查询。</p>
<p>必须使用 GIS 相关的函数来维护数据。</p>
<h2 id=索引优化>索引优化</h2>
<h3 id=1-独立的列>1. 独立的列</h3>
<p>在进行查询时，索引列不能是表达式的一部分，也不能是函数的参数，否则无法使用索引。</p>
<p>例如下面的查询不能使用 actor_id 列的索引:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=color:#204a87;font-weight:700>SELECT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>actor_id</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>FROM</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>sakila</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>actor</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>WHERE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>actor_id</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>+</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#0000cf;font-weight:700>1</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#0000cf;font-weight:700>5</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></code></pre></div><h3 id=2-多列索引>2. 多列索引</h3>
<p>在需要使用多个列作为条件进行查询时，使用多列索引比使用多个单列索引性能更好。例如下面的语句中，最好把 actor_id 和 film_id 设置为多列索引。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=color:#204a87;font-weight:700>SELECT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>film_id</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>actor_</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>id</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>FROM</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>sakila</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>film_actor</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>WHERE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>actor_id</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#0000cf;font-weight:700>1</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>AND</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>film_id</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></code></pre></div><h3 id=3-索引列的顺序>3. 索引列的顺序</h3>
<p>让选择性最强的索引列放在前面，索引的选择性是指: 不重复的索引值和记录总数的比值。最大值为 1，此时每个记录都有唯一的索引与其对应。选择性越高，查询效率也越高。</p>
<h4 id=4-前缀索引>4. 前缀索引</h4>
<p>对于 BLOB、TEXT 和 VARCHAR 类型的列，必须使用前缀索引，只索引开始的部分字符。</p>
<p>对于前缀长度的选取需要根据索引选择性来确定。</p>
<h4 id=5-覆盖索引>5. 覆盖索引</h4>
<p>索引包含所有需要查询的字段的值。</p>
<p>具有以下优点:</p>
<ul>
<li>索引通常远小于数据行的大小，只读取索引能大大减少数据访问量。</li>
<li>一些存储引擎(例如 MyISAM)在内存中只缓存索引，而数据依赖于操作系统来缓存。因此，只访问索引可以不使用系统调用(通常比较费时)。</li>
<li>对于 InnoDB 引擎，若辅助索引能够覆盖查询，则无需访问主索引。</li>
</ul>
<h2 id=索引的有点>索引的有点</h2>
<p>大大减少了服务器需要扫描的数据行数。</p>
<p>帮助服务器避免进行排序和分组，也就不需要创建临时表(B+Tree 索引是有序的，可以用于 ORDER BY 和 GROUP BY 操作。临时表主要是在排序和分组过程中创建，因为不需要排序和分组，也就不需要创建临时表)。</p>
<p>将随机 I/O 变为顺序 I/O(B+Tree 索引是有序的，也就将相邻的数据都存储在一起)。</p>
<h3 id=索引的使用场景>索引的使用场景</h3>
<ul>
<li>对于非常小的表、大部分情况下简单的全表扫描比建立索引更高效。</li>
<li>对于中到大型的表，索引就非常有效。</li>
<li>但是对于特大型的表，建立和维护索引的代价将会随之增长。这种情况下，需要用到一种技术可以直接区分出需要查询的一组数据，而不是一条记录一条记录地匹配，例如可以使用分区技术。</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-e153ee081a2e00565371b72f637f2039>4 - CH04-性能优化</h1>
<h2 id=使用-explain-进行分析>使用 Explain 进行分析</h2>
<p>Explain 用来分析 SELECT 查询语句，开发人员可以通过分析 Explain 结果来优化查询语句。</p>
<p>比较重要的字段有:</p>
<ul>
<li>select_type : 查询类型，有简单查询、联合查询、子查询等</li>
<li>key : 使用的索引</li>
<li>rows : 扫描的行数</li>
</ul>
<h2 id=优化数据访问>优化数据访问</h2>
<h3 id=1-减少请求的数据量>1. 减少请求的数据量</h3>
<ul>
<li>只返回必要的列: 最好不要使用 SELECT * 语句。</li>
<li>只返回必要的行: 使用 LIMIT 语句来限制返回的数据。</li>
<li>缓存重复查询的数据: 使用缓存可以避免在数据库中进行查询，特别在要查询的数据经常被重复查询时，缓存带来的查询性能提升将会是非常明显的。</li>
</ul>
<h3 id=2-减少服务器端扫描的行数>2. 减少服务器端扫描的行数</h3>
<p>最有效的方式是使用索引来覆盖查询。</p>
<h2 id=重构查询方式>重构查询方式</h2>
<h3 id=1-切分大查询>1. 切分大查询</h3>
<p>一个大查询如果一次性执行的话，可能一次锁住很多数据、占满整个事务日志、耗尽系统资源、阻塞很多小的但重要的查询。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=color:#000>DELEFT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>FROM</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>messages</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>WHERE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>create</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>DATE_SUB</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>NOW</span><span style=color:#000;font-weight:700>(),</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87>INTERVAL</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#0000cf;font-weight:700>3</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>MONTH</span><span style=color:#000;font-weight:700>);</span><span style=color:#f8f8f8;text-decoration:underline>
</span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=color:#000>rows_affected</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#0000cf;font-weight:700>0</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>do</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#a40000>{</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>    </span><span style=color:#000>rows_affected</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>do_query</span><span style=color:#000;font-weight:700>(</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>    </span><span style=color:#4e9a06>&#34;DELETE FROM messages WHERE create  &lt; DATE_SUB(NOW(), INTERVAL 3 MONTH) LIMIT 10000&#34;</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#a40000>}</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>while</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>rows_affected</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>&gt;</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#0000cf;font-weight:700>0</span><span style=color:#f8f8f8;text-decoration:underline>
</span></code></pre></div><h3 id=2-分解大连接查询>2. 分解大连接查询</h3>
<p>将一个大连接查询分解成对每一个表进行一次单表查询，然后将结果在应用程序中进行关联，这样做的好处有:</p>
<ul>
<li>让缓存更高效。对于连接查询，如果其中一个表发生变化，那么整个查询缓存就无法使用。而分解后的多个查询，即使其中一个表发生变化，对其它表的查询缓存依然可以使用。</li>
<li>分解成多个单表查询，这些单表查询的缓存结果更可能被其它查询使用到，从而减少冗余记录的查询。</li>
<li>减少锁竞争；</li>
<li>在应用层进行连接，可以更容易对数据库进行拆分，从而更容易做到高性能和可伸缩。</li>
<li>查询本身效率也可能会有所提升。例如下面的例子中，使用 IN() 代替连接查询，可以让 MySQL 按照 ID 顺序进行查询，这可能比随机的连接要更高效。</li>
</ul>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=color:#204a87;font-weight:700>SELECT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>*</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>FROM</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>tab</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>JOIN</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>tag_post</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>ON</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>tag_post</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>tag_id</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#000>tag</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>id</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>JOIN</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>post</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>ON</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>tag_post</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>post_id</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#000>post</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>id</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>WHERE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>tag</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>tag</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#4e9a06>&#39;mysql&#39;</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=color:#204a87;font-weight:700>SELECT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>*</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>FROM</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>tag</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>WHERE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>tag</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#4e9a06>&#39;mysql&#39;</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>SELECT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>*</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>FROM</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>tag_post</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>WHERE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>tag_id</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#0000cf;font-weight:700>1234</span><span style=color:#000;font-weight:700>;</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>SELECT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>*</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>FROM</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>post</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>WHERE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>post</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>id</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>IN</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>123</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>456</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>567</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>9098</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>8904</span><span style=color:#000;font-weight:700>);</span><span style=color:#f8f8f8;text-decoration:underline>
</span></code></pre></div>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-29d040819faa80f395ba725e176690a3>5 - CH05-分库分表</h1>
<h2 id=水平切分>水平切分</h2>
<p>水平切分又称为 Sharding，它是将同一个表中的记录拆分到多个结构相同的表中。</p>
<p>当一个表的数据不断增多时，Sharding 是必然的选择，它可以将数据分布到集群的不同节点上，从而缓存单个数据库的压力。</p>
<div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210503194243.png style=display:block;width:50% alt=NAME align=center> </div>
<h2 id=垂直切分>垂直切分</h2>
<p>垂直切分是将一张表按列切分成多个表，通常是按照列的关系密集程度进行切分，也可以利用垂直切分将经常被使用的列和不经常被使用的列切分到不同的表中。</p>
<p>在数据库的层面使用垂直切分将按数据库中表的密集程度部署到不同的库中，例如将原来的电商数据库垂直切分成商品数据库、用户数据库等。</p>
<div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210503194255.png style=display:block;width:50% alt=NAME align=center> </div>
<h2 id=sharding-策略>Sharding 策略</h2>
<ul>
<li>哈希取模: hash(key) % NUM_DB</li>
<li>范围: 可以是 ID 范围也可以是时间范围</li>
<li>映射表: 使用单独的一个数据库来存储映射关系</li>
</ul>
<h2 id=sharding-存在的问题及解决方案>Sharding 存在的问题及解决方案</h2>
<h3 id=1-事务问题>1. 事务问题</h3>
<p>使用分布式事务来解决，比如 XA 接口。</p>
<h3 id=2-链接>2. 链接</h3>
<p>可以将原来的 JOIN 分解成多个单表查询，然后在用户程序中进行 JOIN。</p>
<h3 id=3-id-唯一性>3. ID 唯一性</h3>
<ul>
<li>使用全局唯一 ID: GUID</li>
<li>为每个分片指定一个 ID 范围</li>
<li>分布式 ID 生成器 (如 Twitter 的 Snowflake 算法)</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-18dd619a88421627df2c9f215cacaecc>6 - CH06-复制分离</h1>
<h2 id=主从复制>主从复制</h2>
<p>主要涉及三个线程: binlog 线程、I/O 线程和 SQL 线程。</p>
<ul>
<li><strong>binlog 线程</strong> : 负责将主服务器上的数据更改写入二进制日志中。</li>
<li><strong>I/O 线程</strong> : 负责从主服务器上读取二进制日志，并写入从服务器的中继日志中。</li>
<li><strong>SQL 线程</strong> : 负责读取中继日志并重放其中的 SQL 语句。</li>
</ul>
<div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210503194809.png style=display:block;width:50% alt=NAME align=center> </div>
<h2 id=读写分离>读写分离</h2>
<p>主服务器处理写操作以及实时性要求比较高的读操作，而从服务器处理读操作。</p>
<p>读写分离能提高性能的原因在于:</p>
<ul>
<li>主从服务器负责各自的读和写，极大程度缓解了锁的争用；</li>
<li>从服务器可以使用 MyISAM，提升查询性能以及节约系统开销；</li>
<li>增加冗余，提高可用性。</li>
</ul>
<p>读写分离常用代理方式来实现，代理服务器接收应用层传来的读写请求，然后决定转发到哪个服务器。</p>
<div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210503194848.png style=display:block;width:50% alt=NAME align=center> </div>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-280203572e4e446020b171753e2c2a12>7 - CH07-执行过程</h1>
<h2 id=前言>前言</h2>
<p>天天和数据库打交道，一天能写上几十条 SQL 语句，但你知道我们的系统是如何和数据库交互的吗？MySQL 如何帮我们存储数据、又是如何帮我们管理事务？&mldr;.是不是感觉真的除了写几个 「select * from dual」外基本脑子一片空白？这篇文章就将带你走进 MySQL 的世界，让你彻底了解系统到底是如何和 MySQL 交互的，MySQL 在接受到我们发送的 SQL 语句时又分别做了哪些事情。</p>
<h2 id=mysql-驱动>MySQL 驱动</h2>
<p>我们的系统在和 MySQL 数据库进行通信的时候，总不可能是平白无故的就能接收和发送请求，就算是你没有做什么操作，那总该是有其他的“人”帮我们做了一些事情，基本上使用过 MySQL 数据库的程序员多多少少都会知道 MySQL 驱动这个概念的。就是这个 MySQL 驱动在底层帮我们做了对数据库的连接，只有建立了连接了，才能够有后面的交互。看下图表示</p>
<div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210503195039.png style=display:block;width:50% alt=NAME align=center> </div>
<p>这样的话，在系统和 MySQL 进行交互之前，MySQL 驱动会帮我们建立好连接，然后我们只需要发送 SQL 语句就可以执行 CRUD 了。一次 SQL 请求就会建立一个连接，多个请求就会建立多个连接，那么问题来了，我们系统肯定不是一个人在使用的，换句话说肯定是存在多个请求同时去争抢连接的情况。我们的 web 系统一般都是部署在 tomcat 容器中的，而 tomcat 是可以并发处理多个请求的，这就会导致多个请求会去建立多个连接，然后使用完再都去关闭，这样会有什么问题呢？如下图</p>
<div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210503195111.png style=display:block;width:50% alt=NAME align=center> </div>
<p>java 系统在通过 MySQL 驱动和 MySQL 数据库连接的时候是基于 TCP/IP 协议的，所以如果每个请求都是新建连接和销毁连接，那这样势必会造成不必要的浪费和性能的下降，也就说上面的多线程请求的时候频繁的创建和销毁连接显然是不合理的。必然会大大降低我们系统的性能，但是如果给你提供一些固定的用来连接的线程，这样是不是不需要反复的创建和销毁连接了呢？相信懂行的朋友会会心一笑，没错，说的就是数据库连接池。</p>
<p><strong>数据库连接池</strong>：维护一定的连接数，方便系统获取连接，使用就去池子中获取，用完放回去就可以了，我们不需要关心连接的创建与销毁，也不需要关心线程池是怎么去维护这些连接的。</p>
<div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210503195148.png style=display:block;width:50% alt=NAME align=center> </div>
<p>常见的数据库连接池有 HakariCP、Druid、C3P0、DBCP，连接池实现原理在这里就不深入讨论了，采用连接池大大节省了不断创建与销毁线程的开销，这就是有名的「池化」思想，不管是线程池还是 HTTP 连接池，都能看到它的身影。</p>
<h2 id=数据库连接池>数据库连接池</h2>
<p>到这里，我们已经知道的是我们的系统在访问 MySQL 数据库的时候，建立的连接并不是每次请求都会去创建的，而是从数据库连接池中去获取，这样就解决了因为反复的创建和销毁连接而带来的性能损耗问题了。不过这里有个小问题，业务系统是并发的，而 MySQL 接受请求的线程呢，只有一个？</p>
<p>其实 MySQL 的架构体系中也已经提供了这样的一个池子，也是数据库连池。双方都是通过数据库连接池来管理各个连接的，这样一方面线程之前不需要是争抢连接，更重要的是不需要反复的创建的销毁连接。</p>
<div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210503195232.png style=display:block;width:50% alt=NAME align=center> </div>
<p>至此系统和 MySQL 数据库之间的连接问题已经说明清楚了。那么 MySQL 数据库中的这些连接是怎么来处理的，又是谁来处理呢？</p>
<h2 id=网络连接必须由线程来处理>网络连接必须由线程来处理</h2>
<p>对计算基础稍微有一点了解的的同学都是知道的，网络中的连接都是由线程来处理的，所谓网络连接说白了就是一次请求，每次请求都会有相应的线程去处理的。也就是说对于 SQL 语句的请求在 MySQL 中是由一个个的线程去处理的。</p>
<div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210503195303.png style=display:block;width:50% alt=NAME align=center> </div>
<p>那这些线程会怎么去处理这些请求？会做哪些事情？</p>
<h2 id=sql-接口>SQL 接口</h2>
<p>MySQL 中处理请求的线程在获取到请求以后获取 SQL 语句去交给 SQL 接口去处理。</p>
<h2 id=查询解析器>查询解析器</h2>
<p>假如现在有这样的一个 SQL</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=color:#204a87;font-weight:700>SELECT</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>stuName</span><span style=color:#000;font-weight:700>,</span><span style=color:#000>age</span><span style=color:#000;font-weight:700>,</span><span style=color:#000>sex</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>FROM</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>students</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>WHERE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>id</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#0000cf;font-weight:700>1</span><span style=color:#f8f8f8;text-decoration:underline>
</span></code></pre></div><p>但是这个 SQL 是写给我们人看的，机器哪里知道你在说什么？这个时候解析器就上场了。他会将 SQL 接口传递过来的 SQL 语句进行解析，翻译成 MySQL 自己能认识的语言，至于怎么解析的就不需要在深究了，无非是自己一套相关的规则。</p>
<div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210503195353.png style=display:block;width:50% alt=NAME align=center> </div>
<p>现在 SQL 已经被解析成 MySQL 认识的样子的，那下一步是不是就是执行吗？理论上是这样子的，但是 MySQL 的强大远不止于此，他还会帮我们选择最优的查询路径。</p>
<p>什么叫最优查询路径？就是 MySQL 会按照自己认为的效率最高的方式去执行查询.</p>
<p>具体是怎么做到的呢？这就要说到 MySQL 的查询优化器了</p>
<h2 id=mysql-查询优化器>MySQL 查询优化器</h2>
<p>查询优化器内部具体怎么实现的我们不需要是关心，我需要知道的是 MySQL 会帮我去使用他自己认为的最好的方式去优化这条 SQL 语句，并生成一条条的执行计划，比如你创建了多个索引，MySQL 会依据成本最小原则来选择使用对应的索引，这里的成本主要包括两个方面, IO 成本和 CPU 成本</p>
<p><strong>IO 成本</strong>: 即从磁盘把数据加载到内存的成本，默认情况下，读取数据页的 IO 成本是 1，MySQL 是以页的形式读取数据的，即当用到某个数据时，并不会只读取这个数据，而会把这个数据相邻的数据也一起读到内存中，这就是有名的程序局部性原理，所以 MySQL 每次会读取一整页，一页的成本就是 1。所以 IO 的成本主要和页的大小有关</p>
<p><strong>CPU 成本</strong>：将数据读入内存后，还要检测数据是否满足条件和排序等 CPU 操作的成本，显然它与行数有关，默认情况下，检测记录的成本是 0.2。</p>
<p>MySQL 优化器 会计算 「IO 成本 + CPU」 成本最小的那个索引来执行</p>
<div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210503195422.png style=display:block;width:50% alt=NAME align=center> </div>
<p>优化器执行选出最优索引等步骤后，会去调用存储引擎接口，开始去执行被 MySQL 解析过和优化过的 SQL 语句</p>
<h2 id=存储引擎>存储引擎</h2>
<p>查询优化器会调用存储引擎的接口，去执行 SQL，也就是说真正执行 SQL 的动作是在存储引擎中完成的。数据是被存放在内存或者是磁盘中的（存储引擎是一个非常重要的组件，后面会详细介绍）</p>
<h2 id=执行器>执行器</h2>
<p>执行器是一个非常重要的组件，因为前面那些组件的操作最终必须通过执行器去调用存储引擎接口才能被执行。执行器最终最根据一系列的执行计划去调用存储引擎的接口去完成 SQL 的执行</p>
<div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210503195448.png style=display:block;width:50% alt=NAME align=center> </div>
<h2 id=初识存储引擎>初识存储引擎</h2>
<p>我们以一个更新的SQL语句来说明，SQL 如下</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=color:#204a87;font-weight:700>UPDATE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>students</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>SET</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>stuName</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#4e9a06>&#39;小强&#39;</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>WHERE</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>id</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#0000cf;font-weight:700>1</span><span style=color:#f8f8f8;text-decoration:underline>
</span></code></pre></div><p>当我们系统发出这样的查询去交给 MySQL 的时候，MySQL 会按照我们上面介绍的一系列的流程最终通过执行器调用存储引擎去执行，流程图就是上面那个。在执行这个 SQL 的时候 SQL 语句对应的数据要么是在内存中，要么是在磁盘中，如果直接在磁盘中操作，那这样的随机IO读写的速度肯定让人无法接受的，所以每次在执行 SQL 的时候都会将其数据加载到内存中，这块内存就是 InnoDB 中一个非常重要的组件：<strong>缓冲池 Buffer Pool</strong></p>
<h2 id=buffer-pool>Buffer Pool</h2>
<p>Buffer Pool （缓冲池）是 InnoDB 存储引擎中非常重要的内存结构，顾名思义，缓冲池其实就是类似 Redis 一样的作用，起到一个缓存的作用，因为我们都知道 MySQL 的数据最终是存储在磁盘中的，如果没有这个 Buffer Pool 那么我们每次的数据库请求都会磁盘中查找，这样必然会存在 IO 操作，这肯定是无法接受的。但是有了 Buffer Pool 就是我们第一次在查询的时候会将查询的结果存到 Buffer Pool 中，这样后面再有请求的时候就会先从缓冲池中去查询，如果没有再去磁盘中查找，然后在放到 Buffer Pool 中，如下图</p>
<div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210503195538.png style=display:block;width:50% alt=NAME align=center> </div>
<p>按照上面的那幅图，这条 SQL 语句的执行步骤大致是这样子的</p>
<ul>
<li>innodb 存储引擎会在缓冲池中查找 id=1 的这条数据是否存在</li>
<li>发现不存在，那么就会去磁盘中加载，并将其存放在缓冲池中</li>
<li>该条记录会被加上一个独占锁（总不能你在修改的时候别人也在修改吧，这个机制本篇文章不重点介绍，以后会专门写文章来详细讲解）</li>
</ul>
<h2 id=undo-日志文件记录数据被修改前的样子>undo 日志文件：记录数据被修改前的样子</h2>
<p>undo 顾名思义，就是没有做，没发生的意思。undo log 就是没有发生事情（原本事情是什么）的一些日志</p>
<p>我们刚刚已经说了，在准备更新一条语句的时候，该条语句已经被加载到 Buffer pool 中了，实际上这里还有这样的操作，就是在将该条语句加载到 Buffer Pool 中的时候同时会往 undo 日志文件中插入一条日志，也就是将 id=1 的这条记录的原来的值记录下来。</p>
<p><strong>这样做的目的是什么</strong>？</p>
<p>Innodb 存储引擎的最大特点就是支持事务，如果本次更新失败，也就是事务提交失败，那么该事务中的所有的操作都必须回滚到执行前的样子，也就是说当事务失败的时候，也不会对原始数据有影响，看图说话</p>
<div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210503195600.png style=display:block;width:50% alt=NAME align=center> </div>
<p>这里说句额外话，其实 MySQL 也是一个系统，就好比我们平时开发的 java 的功能系统一样，MySQL 使用的是自己相应的语言开发出来的一套系统而已，它根据自己需要的功能去设计对应的功能，它即然能做到哪些事情，那么必然是设计者们当初这么定义或者是根据实际的场景变更演化而来的。所以大家放平心态，把 MySQL 当作一个系统去了解熟悉他。</p>
<p>到这一步，我们的执行的 SQL 语句已经被加载到 Buffer Pool 中了，然后开始更新这条语句，更新的操作实际是在Buffer Pool中执行的，那问题来了，按照我们平时开发的一套理论缓冲池中的数据和数据库中的数据不一致时候，我们就认为缓存中的数据是脏数据，那此时 Buffer Pool 中的数据岂不是成了脏数据？没错，目前这条数据就是脏数据，Buffer Pool 中的记录是小强 数据库中的记录是旺财 ，这种情况 MySQL是怎么处理的呢，继续往下看</p>
<h2 id=redo-日志文件记录数据被修改后的样子>redo 日志文件：记录数据被修改后的样子</h2>
<p>除了从磁盘中加载文件和将操作前的记录保存到 undo 日志文件中，其他的操作是在内存中完成的，内存中的数据的特点就是：断电丢失。如果此时 MySQL 所在的服务器宕机了，那么 Buffer Pool 中的数据会全部丢失的。这个时候 redo 日志文件就需要来大显神通了</p>
<p><strong>画外音：redo 日志文件是 InnoDB 特有的，他是存储引擎级别的，不是 MySQL 级别的</strong></p>
<p>redo 记录的是数据修改之后的值，不管事务是否提交都会记录下来，例如，此时将要做的是update students set stuName=&lsquo;小强&rsquo; where id=1; 那么这条操作就会被记录到 redo log buffer 中，啥？怎么又出来一个 redo log buffer ,很简单，MySQL 为了提高效率，所以将这些操作都先放在内存中去完成，然后会在某个时机将其持久化到磁盘中。</p>
<div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210503195621.png style=display:block;width:50% alt=NAME align=center> </div>
<p>截至目前，我们应该都熟悉了 MySQL 的执行器调用存储引擎是怎么将一条 SQL 加载到缓冲池和记录哪些日志的，流程如下：</p>
<ul>
<li>准备更新一条 SQL 语句</li>
<li>MySQL（innodb）会先去缓冲池（BufferPool）中去查找这条数据，没找到就会去磁盘中查找，如果查找到就会将这条数据加载到缓冲池（BufferPool）中</li>
<li>在加载到 Buffer Pool 的同时，会将这条数据的原始记录保存到 undo 日志文件中</li>
<li>innodb 会在 Buffer Pool 中执行更新操作</li>
<li>更新后的数据会记录在 redo log buffer 中</li>
</ul>
<p>上面说的步骤都是在正常情况下的操作，但是程序的设计和优化并不仅是为了这些正常情况而去做的，也是为了<strong>那些临界区和极端情况下出现的问题去优化</strong>设计的</p>
<p>这个时候如果服务器宕机了，那么缓存中的数据还是丢失了。真烦，竟然数据总是丢失，那能不能不要放在内存中，直接保存到磁盘呢？很显然不行，因为在上面也已经介绍了，在内存中的操作目的是为了提高效率。</p>
<p>此时，如果 MySQL 真的宕机了，那么没关系的，因为 MySQL 会认为本次事务是失败的，所以数据依旧是更新前的样子，并不会有任何的影响。</p>
<p>好了，语句也更新好了那么需要将更新的值提交啊，也就是需要提交本次的事务了，因为只要事务成功提交了，才会将最后的变更保存到数据库，在提交事务前仍然会具有相关的其他操作</p>
<p>将 redo Log Buffer 中的数据持久化到磁盘中，就是将 redo log buffer 中的数据写入到 redo log 磁盘文件中，一般情况下，redo log Buffer 数据写入磁盘的策略是立即刷入磁盘（具体策略情况在下面小总结出会详细介绍）,上图</p>
<div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210503195634.png style=display:block;width:50% alt=NAME align=center> </div>
<p>如果 redo log Buffer 刷入磁盘后，数据库服务器宕机了，那我们更新的数据怎么办？此时数据是在内存中，数据岂不是丢失了？不，这次数据就不会丢失了，因为 redo log buffer 中的数据已经被写入到磁盘了，已经被持久化了，就算数据库宕机了，在下次重启的时候 MySQL 也会将 redo 日志文件内容恢复到 Buffer Pool 中（这边我的理解是和 Redis 的持久化机制是差不多的，在 Redis 启动的时候会检查 rdb 或者是 aof 或者是两者都检查，根据持久化的文件来将数据恢复到内存中）</p>
<p>到此为止，<strong>从执行器开始调用存储引擎接口做了哪些事情呢</strong>？</p>
<ul>
<li>准备更新一条 SQL 语句</li>
<li>MySQL（innodb）会先去缓冲池（BufferPool）中去查找这条数据，没找到就会去磁盘中查找，如果查找到就会将这条数据加载</li>
<li>到缓冲池（BufferPool）中 3.在加载到 Buffer Pool 的同时，会将这条数据的原始记录保存到 undo 日志文件中</li>
<li>innodb 会在 Buffer Pool 中执行更新操作</li>
<li>更新后的数据会记录在 redo log buffer 中</li>
<li>MySQL 提交事务的时候，会将 redo log buffer 中的数据写入到 redo 日志文件中 刷磁盘可以通过 innodb_flush_log_at_trx_commit 参数来设置
<ul>
<li>值为 0 表示不刷入磁盘</li>
<li>值为 1 表示立即刷入磁盘</li>
<li>值为 2 表示先刷到 os cache</li>
</ul>
</li>
<li>myslq 重启的时候会将 redo 日志恢复到缓冲池中</li>
</ul>
<p>截止到目前位置，MySQL 的执行器调用存储引擎的接口去执行【执行计划】提供的 SQL 的时候 InnoDB 做了哪些事情也就基本差不多了，但是这还没完。下面还需要介绍下 MySQL 级别的日志文件 bin log</p>
<h2 id=bin-log-日志文件记录整个操作过程>bin log 日志文件：记录整个操作过程</h2>
<p>上面介绍到的redo log是 InnoDB 存储引擎特有的日志文件，而bin log属于是 MySQL 级别的日志。redo log记录的东西是偏向于物理性质的，如：“对什么数据，做了什么修改”。bin log是偏向于逻辑性质的，类似于：“对 students 表中的 id 为 1 的记录做了更新操作” 两者的主要特点总结如下:</p>
<table>
<thead>
<tr>
<th>性质</th>
<th>redo Log</th>
<th>bin Log</th>
</tr>
</thead>
<tbody>
<tr>
<td>文件大小</td>
<td>redo log 的大小是固定的（配置中也可以设置，一般默认的就足够了）</td>
<td>bin log 可通过配置参数max_bin log_size设置每个bin log文件的大小（但是一般不建议修改）。</td>
</tr>
<tr>
<td>实现方式</td>
<td>redo log是InnoDB引擎层实现的（也就是说是 Innodb 存储引起过独有的）</td>
<td>bin log是 MySQL 层实现的，所有引擎都可以使用 bin log日志</td>
</tr>
<tr>
<td>记录方式</td>
<td>redo log 采用循环写的方式记录，当写到结尾时，会回到开头循环写日志。</td>
<td>bin log 通过追加的方式记录，当文件大小大于给定值后，后续的日志会记录到新的文件上</td>
</tr>
<tr>
<td>使用场景</td>
<td>redo log适用于崩溃恢复(crash-safe)（这一点其实非常类似与 Redis 的持久化特征）</td>
<td>bin log 适用于主从复制和数据恢复</td>
</tr>
</tbody>
</table>
<p><strong>bin log文件是如何刷入磁盘的</strong>?</p>
<p>bin log 的刷盘是有相关的策略的，策略可以通过sync_bin log来修改，默认为 0，表示先写入 os cache，也就是说在提交事务的时候，数据不会直接到磁盘中，这样如果宕机bin log数据仍然会丢失。所以建议将sync_bin log设置为 1 表示直接将数据写入到磁盘文件中。</p>
<p>刷入 bin log 有以下几种模式</p>
<ul>
<li><strong>STATMENT</strong></li>
</ul>
<p>基于 SQL 语句的复制(statement-based replication, SBR)，每一条会修改数据的 SQL 语句会记录到 bin log 中</p>
<p>【优点】：不需要记录每一行的变化，减少了 bin log 日志量，节约了 IO , 从而提高了性能</p>
<p>【缺点】：在某些情况下会导致主从数据不一致，比如执行sysdate()、slepp()等</p>
<ul>
<li><strong>ROW</strong></li>
</ul>
<p>基于行的复制(row-based replication, RBR)，不记录每条SQL语句的上下文信息，仅需记录哪条数据被修改了</p>
<p>【优点】：不会出现某些特定情况下的存储过程、或 function、或 trigger 的调用和触发无法被正确复制的问题</p>
<p>【缺点】：会产生大量的日志，尤其是 alter table 的时候会让日志暴涨</p>
<ul>
<li><strong>MIXED</strong></li>
</ul>
<p>基于 STATMENT 和 ROW 两种模式的混合复制( mixed-based replication, MBR )，一般的复制使用 STATEMENT 模式保存 bin log ，对于 STATEMENT 模式无法复制的操作使用 ROW 模式保存 bin log</p>
<p>那既然bin log也是日志文件，那它是在什么记录数据的呢？</p>
<p>其实 MySQL 在提交事务的时候，不仅仅会将 redo log buffer 中的数据写入到redo log 文件中，同时也会将本次修改的数据记录到 bin log文件中，同时会将本次修改的bin log文件名和修改的内容在bin log中的位置记录到redo log中，最后还会在redo log最后写入 commit 标记，这样就表示本次事务被成功的提交了。</p>
<div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210503195659.png style=display:block;width:50% alt=NAME align=center> </div>
<p>如果在数据被写入到bin log文件的时候，刚写完，数据库宕机了，数据会丢失吗？</p>
<p>首先可以确定的是，只要redo log最后没有 commit 标记，说明本次的事务一定是失败的。但是数据是没有丢失了，因为已经被记录到redo log的磁盘文件中了。在 MySQL 重启的时候，就会将 redo log 中的数据恢复（加载）到Buffer Pool中。</p>
<p>好了，到目前为止，一个更新操作我们基本介绍得差不多，但是你有没有感觉少了哪件事情还没有做？是不是你也发现这个时候被更新记录仅仅是在内存中执行的，哪怕是宕机又恢复了也仅仅是将更新后的记录加载到Buffer Pool中，这个时候 MySQL 数据库中的这条记录依旧是旧值，也就是说内存中的数据在我们看来依旧是脏数据，那这个时候怎么办呢？</p>
<p>其实 MySQL 会有一个后台线程，它会在某个时机将我们Buffer Pool中的脏数据刷到 MySQL 数据库中，这样就将内存和数据库的数据保持统一了。</p>
<div align=center> <img src=https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20210503195713.png style=display:block;width:50% alt=NAME align=center> </div>
<h2 id=本文总结>本文总结</h2>
<p>到此，关于Buffer Pool、Redo Log Buffer 和undo log、redo log、bin log 概念以及关系就基本差不多了。</p>
<p>我们再回顾下</p>
<ul>
<li>Buffer Pool 是 MySQL 的一个非常重要的组件，因为针对数据库的增删改操作都是在 Buffer Pool 中完成的</li>
<li>Undo log 记录的是数据操作前的样子</li>
<li>redo log 记录的是数据被操作后的样子（redo log 是 Innodb 存储引擎特有）</li>
<li>bin log 记录的是整个操作记录（这个对于主从复制具有非常重要的意义）</li>
</ul>
<p>从准备更新一条数据到事务的提交的流程描述</p>
<ul>
<li>首先执行器根据 MySQL 的执行计划来查询数据，先是从缓存池中查询数据，如果没有就会去数据库中查询，如果查询到了就将其放到缓存池中</li>
<li>在数据被缓存到缓存池的同时，会写入 undo log 日志文件</li>
<li>更新的动作是在 BufferPool 中完成的，同时会将更新后的数据添加到 redo log buffer 中</li>
<li>完成以后就可以提交事务，在提交的同时会做以下三件事
<ul>
<li>将redo log buffer中的数据刷入到 redo log 文件中</li>
<li>将本次操作记录写入到 bin log文件中</li>
<li>将 bin log 文件名字和更新内容在 bin log 中的位置记录到redo log中，同时在 redo log 最后添加 commit 标记</li>
</ul>
</li>
</ul>
<p>至此表示整个更新事务已经完成</p>
</div>
</main>
</div>
</div>
<footer class="bg-dark py-5 row d-print-none">
<div class="container-fluid mx-sm-5">
<div class=row>
<div class="col-6 col-sm-4 text-xs-center order-sm-2">
</div>
<div class="col-6 col-sm-4 text-right text-xs-center order-sm-3">
<ul class="list-inline mb-0">
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Weibo aria-label=Weibo>
<a class=text-white target=_blank rel="noopener noreferrer" href=https://weibo.com/u/3848950217>
<i class="fab fa-weibo"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Twitter aria-label=Twitter>
<a class=text-white target=_blank rel="noopener noreferrer" href=https://twitter.com/zhange_zzg>
<i class="fab fa-twitter"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="Stack Overflow" aria-label="Stack Overflow">
<a class=text-white target=_blank rel="noopener noreferrer" href=https://stackoverflow.com>
<i class="fab fa-stack-overflow"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=GitHub aria-label=GitHub>
<a class=text-white target=_blank rel="noopener noreferrer" href=https://github.com/infilos/infilos.com>
<i class="fab fa-github"></i>
</a>
</li>
</ul>
</div>
<div class="col-12 col-sm-4 text-center py-2 order-sm-2">
<small class=text-white>&copy; 2021 infilos.com All Rights Reserved</small>
</div>
</div>
</div>
</footer>
</div>
<script src=/js/popper.min.js integrity=sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49 crossorigin=anonymous></script>
<script src=/js/bootstrap.min.js integrity=sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy crossorigin=anonymous></script>
<script src=/js/main.min.5c74b870c6953931a705f390a49c7e4c0a842ec5c83b24354758dd674343ed0d.js integrity="sha256-XHS4cMaVOTGnBfOQpJx+TAqELsXIOyQ1R1jdZ0ND7Q0=" crossorigin=anonymous></script>
</body>
</html>